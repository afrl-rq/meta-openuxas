From 0a25e2fe7e5f8aaf660eddca897b986056a21978 Mon Sep 17 00:00:00 2001
From: "Adam C. Foltzer" <acfoltzer@galois.com>
Date: Fri, 2 Jun 2017 16:05:34 -0700
Subject: [PATCH] add generated LMCP sources

---
 src/LMCP/CMASI.xml                                 | 1582 +++++++++
 src/LMCP/IMPACT.xml                                |  599 ++++
 src/LMCP/LMCP.vcproj                               |  560 ++++
 src/LMCP/LMCP.vcxproj                              |  448 +++
 src/LMCP/LMCP.vcxproj.filters                      | 1209 +++++++
 src/LMCP/Makefile                                  |  211 ++
 src/LMCP/PERCEIVE.xml                              |  111 +
 src/LMCP/ROUTE.xml                                 |  166 +
 src/LMCP/UXNATIVE.xml                              |  129 +
 src/LMCP/UXTASK.xml                                |  421 +++
 src/LMCP/afrl/cmasi/AbstractGeometry.h             |  100 +
 src/LMCP/afrl/cmasi/AbstractGeometryDescendants.h  |   15 +
 src/LMCP/afrl/cmasi/AbstractZone.h                 |  169 +
 src/LMCP/afrl/cmasi/AbstractZoneDescendants.h      |   15 +
 src/LMCP/afrl/cmasi/AirVehicleConfiguration.h      |  164 +
 .../cmasi/AirVehicleConfigurationDescendants.h     |   12 +
 src/LMCP/afrl/cmasi/AirVehicleState.h              |  124 +
 src/LMCP/afrl/cmasi/AirVehicleStateDescendants.h   |   12 +
 src/LMCP/afrl/cmasi/AltitudeType.h                 |   56 +
 src/LMCP/afrl/cmasi/AreaSearchTask.h               |  114 +
 src/LMCP/afrl/cmasi/AreaSearchTaskDescendants.h    |   12 +
 src/LMCP/afrl/cmasi/AutomationRequest.h            |  129 +
 src/LMCP/afrl/cmasi/AutomationRequestDescendants.h |   12 +
 src/LMCP/afrl/cmasi/AutomationResponse.h           |  119 +
 .../afrl/cmasi/AutomationResponseDescendants.h     |   12 +
 src/LMCP/afrl/cmasi/CMASI.h                        |   93 +
 src/LMCP/afrl/cmasi/CMASIEnum.h                    |   91 +
 src/LMCP/afrl/cmasi/CMASIXMLReader.cpp             | 3340 ++++++++++++++++++++
 src/LMCP/afrl/cmasi/CMASIXMLReader.h               |   45 +
 src/LMCP/afrl/cmasi/CameraAction.h                 |  113 +
 src/LMCP/afrl/cmasi/CameraActionDescendants.h      |   12 +
 src/LMCP/afrl/cmasi/CameraConfiguration.h          |  144 +
 .../afrl/cmasi/CameraConfigurationDescendants.h    |   12 +
 src/LMCP/afrl/cmasi/CameraState.h                  |  126 +
 src/LMCP/afrl/cmasi/CameraStateDescendants.h       |   12 +
 src/LMCP/afrl/cmasi/Circle.h                       |  113 +
 src/LMCP/afrl/cmasi/CircleDescendants.h            |   12 +
 src/LMCP/afrl/cmasi/CommandStatusType.h            |   68 +
 src/LMCP/afrl/cmasi/EntityConfiguration.h          |  156 +
 .../afrl/cmasi/EntityConfigurationDescendants.h    |   16 +
 src/LMCP/afrl/cmasi/EntityState.h                  |  252 ++
 src/LMCP/afrl/cmasi/EntityStateDescendants.h       |   16 +
 src/LMCP/afrl/cmasi/FOVOperationMode.h             |   56 +
 src/LMCP/afrl/cmasi/FlightDirectorAction.h         |  138 +
 .../afrl/cmasi/FlightDirectorActionDescendants.h   |   12 +
 src/LMCP/afrl/cmasi/FlightProfile.h                |  136 +
 src/LMCP/afrl/cmasi/FlightProfileDescendants.h     |   12 +
 src/LMCP/afrl/cmasi/FollowPathCommand.h            |  132 +
 src/LMCP/afrl/cmasi/FollowPathCommandDescendants.h |   12 +
 src/LMCP/afrl/cmasi/GimbalAngleAction.h            |  118 +
 src/LMCP/afrl/cmasi/GimbalAngleActionDescendants.h |   12 +
 src/LMCP/afrl/cmasi/GimbalConfiguration.h          |  184 ++
 .../afrl/cmasi/GimbalConfigurationDescendants.h    |   12 +
 src/LMCP/afrl/cmasi/GimbalPointingMode.h           |   76 +
 src/LMCP/afrl/cmasi/GimbalScanAction.h             |  142 +
 src/LMCP/afrl/cmasi/GimbalScanActionDescendants.h  |   12 +
 src/LMCP/afrl/cmasi/GimbalStareAction.h            |  113 +
 src/LMCP/afrl/cmasi/GimbalStareActionDescendants.h |   12 +
 src/LMCP/afrl/cmasi/GimbalState.h                  |  125 +
 src/LMCP/afrl/cmasi/GimbalStateDescendants.h       |   12 +
 src/LMCP/afrl/cmasi/GimballedPayloadState.h        |  125 +
 .../afrl/cmasi/GimballedPayloadStateDescendants.h  |   13 +
 src/LMCP/afrl/cmasi/GoToWaypointAction.h           |  106 +
 .../afrl/cmasi/GoToWaypointActionDescendants.h     |   12 +
 src/LMCP/afrl/cmasi/KeepInZone.h                   |  100 +
 src/LMCP/afrl/cmasi/KeepInZoneDescendants.h        |   12 +
 src/LMCP/afrl/cmasi/KeepOutZone.h                  |  115 +
 src/LMCP/afrl/cmasi/KeepOutZoneDescendants.h       |   12 +
 src/LMCP/afrl/cmasi/KeyValuePair.h                 |  112 +
 src/LMCP/afrl/cmasi/KeyValuePairDescendants.h      |   12 +
 src/LMCP/afrl/cmasi/LineSearchTask.h               |  119 +
 src/LMCP/afrl/cmasi/LineSearchTaskDescendants.h    |   12 +
 src/LMCP/afrl/cmasi/Location3D.h                   |  125 +
 src/LMCP/afrl/cmasi/Location3DDescendants.h        |   14 +
 src/LMCP/afrl/cmasi/LoiterAction.h                 |  151 +
 src/LMCP/afrl/cmasi/LoiterActionDescendants.h      |   12 +
 src/LMCP/afrl/cmasi/LoiterDirection.h              |   60 +
 src/LMCP/afrl/cmasi/LoiterTask.h                   |  107 +
 src/LMCP/afrl/cmasi/LoiterTaskDescendants.h        |   12 +
 src/LMCP/afrl/cmasi/LoiterType.h                   |   68 +
 src/LMCP/afrl/cmasi/MissionCommand.h               |  113 +
 src/LMCP/afrl/cmasi/MissionCommandDescendants.h    |   12 +
 src/LMCP/afrl/cmasi/MustFlyTask.h                  |  113 +
 src/LMCP/afrl/cmasi/MustFlyTaskDescendants.h       |   12 +
 src/LMCP/afrl/cmasi/NavigationAction.h             |  100 +
 src/LMCP/afrl/cmasi/NavigationActionDescendants.h  |   15 +
 src/LMCP/afrl/cmasi/NavigationMode.h               |   72 +
 src/LMCP/afrl/cmasi/OperatingRegion.h              |  117 +
 src/LMCP/afrl/cmasi/OperatingRegionDescendants.h   |   12 +
 src/LMCP/afrl/cmasi/OperatorSignal.h               |  107 +
 src/LMCP/afrl/cmasi/OperatorSignalDescendants.h    |   12 +
 src/LMCP/afrl/cmasi/PathWaypoint.h                 |  106 +
 src/LMCP/afrl/cmasi/PathWaypointDescendants.h      |   12 +
 src/LMCP/afrl/cmasi/PayloadAction.h                |  106 +
 src/LMCP/afrl/cmasi/PayloadActionDescendants.h     |   16 +
 src/LMCP/afrl/cmasi/PayloadConfiguration.h         |  119 +
 .../afrl/cmasi/PayloadConfigurationDescendants.h   |   18 +
 src/LMCP/afrl/cmasi/PayloadState.h                 |  113 +
 src/LMCP/afrl/cmasi/PayloadStateDescendants.h      |   18 +
 src/LMCP/afrl/cmasi/PayloadStowAction.h            |  106 +
 src/LMCP/afrl/cmasi/PayloadStowActionDescendants.h |   12 +
 src/LMCP/afrl/cmasi/PointSearchTask.h              |  120 +
 src/LMCP/afrl/cmasi/PointSearchTaskDescendants.h   |   12 +
 src/LMCP/afrl/cmasi/Polygon.h                      |  107 +
 src/LMCP/afrl/cmasi/PolygonDescendants.h           |   12 +
 src/LMCP/afrl/cmasi/Rectangle.h                    |  125 +
 src/LMCP/afrl/cmasi/RectangleDescendants.h         |   12 +
 src/LMCP/afrl/cmasi/RemoveEntities.h               |  106 +
 src/LMCP/afrl/cmasi/RemoveEntitiesDescendants.h    |   12 +
 src/LMCP/afrl/cmasi/RemoveTasks.h                  |  106 +
 src/LMCP/afrl/cmasi/RemoveTasksDescendants.h       |   12 +
 src/LMCP/afrl/cmasi/RemoveZones.h                  |  106 +
 src/LMCP/afrl/cmasi/RemoveZonesDescendants.h       |   12 +
 src/LMCP/afrl/cmasi/SearchTask.h                   |  119 +
 src/LMCP/afrl/cmasi/SearchTaskDescendants.h        |   22 +
 src/LMCP/afrl/cmasi/ServiceStatus.h                |  128 +
 src/LMCP/afrl/cmasi/ServiceStatusDescendants.h     |   12 +
 src/LMCP/afrl/cmasi/ServiceStatusType.h            |   60 +
 src/LMCP/afrl/cmasi/SessionStatus.h                |  132 +
 src/LMCP/afrl/cmasi/SessionStatusDescendants.h     |   12 +
 src/LMCP/afrl/cmasi/SimulationStatusType.h         |   64 +
 src/LMCP/afrl/cmasi/SpeedType.h                    |   56 +
 src/LMCP/afrl/cmasi/StopMovementAction.h           |  107 +
 .../afrl/cmasi/StopMovementActionDescendants.h     |   12 +
 src/LMCP/afrl/cmasi/Task.h                         |  142 +
 src/LMCP/afrl/cmasi/TaskDescendants.h              |   30 +
 src/LMCP/afrl/cmasi/TravelMode.h                   |   60 +
 src/LMCP/afrl/cmasi/TurnType.h                     |   56 +
 src/LMCP/afrl/cmasi/VehicleAction.h                |  108 +
 src/LMCP/afrl/cmasi/VehicleActionCommand.h         |  126 +
 .../afrl/cmasi/VehicleActionCommandDescendants.h   |   14 +
 src/LMCP/afrl/cmasi/VehicleActionDescendants.h     |   25 +
 src/LMCP/afrl/cmasi/VideoStreamAction.h            |  112 +
 src/LMCP/afrl/cmasi/VideoStreamActionDescendants.h |   12 +
 src/LMCP/afrl/cmasi/VideoStreamConfiguration.h     |  106 +
 .../cmasi/VideoStreamConfigurationDescendants.h    |   12 +
 src/LMCP/afrl/cmasi/VideoStreamState.h             |  106 +
 src/LMCP/afrl/cmasi/VideoStreamStateDescendants.h  |   12 +
 src/LMCP/afrl/cmasi/WavelengthBand.h               |   72 +
 src/LMCP/afrl/cmasi/Waypoint.h                     |  162 +
 src/LMCP/afrl/cmasi/WaypointDescendants.h          |   13 +
 src/LMCP/afrl/cmasi/WaypointTransfer.h             |  120 +
 src/LMCP/afrl/cmasi/WaypointTransferDescendants.h  |   12 +
 src/LMCP/afrl/cmasi/WaypointTransferMode.h         |   64 +
 src/LMCP/afrl/cmasi/WeatherReport.h                |  137 +
 src/LMCP/afrl/cmasi/WeatherReportDescendants.h     |   12 +
 src/LMCP/afrl/cmasi/Wedge.h                        |  124 +
 src/LMCP/afrl/cmasi/WedgeDescendants.h             |   12 +
 src/LMCP/afrl/cmasi/ZoneAvoidanceType.h            |   68 +
 src/LMCP/afrl/cmasi/afrlcmasiAbstractGeometry.cpp  |  151 +
 src/LMCP/afrl/cmasi/afrlcmasiAbstractZone.cpp      |  368 +++
 .../cmasi/afrlcmasiAirVehicleConfiguration.cpp     |  452 +++
 src/LMCP/afrl/cmasi/afrlcmasiAirVehicleState.cpp   |  282 ++
 src/LMCP/afrl/cmasi/afrlcmasiAreaSearchTask.cpp    |  303 ++
 src/LMCP/afrl/cmasi/afrlcmasiAutomationRequest.cpp |  263 ++
 .../afrl/cmasi/afrlcmasiAutomationResponse.cpp     |  363 +++
 src/LMCP/afrl/cmasi/afrlcmasiCameraAction.cpp      |  249 ++
 .../afrl/cmasi/afrlcmasiCameraConfiguration.cpp    |  285 ++
 src/LMCP/afrl/cmasi/afrlcmasiCameraState.cpp       |  316 ++
 src/LMCP/afrl/cmasi/afrlcmasiCircle.cpp            |  210 ++
 .../afrl/cmasi/afrlcmasiEntityConfiguration.cpp    |  402 +++
 src/LMCP/afrl/cmasi/afrlcmasiEntityState.cpp       |  694 ++++
 .../afrl/cmasi/afrlcmasiFlightDirectorAction.cpp   |  247 ++
 src/LMCP/afrl/cmasi/afrlcmasiFlightProfile.cpp     |  238 ++
 src/LMCP/afrl/cmasi/afrlcmasiFollowPathCommand.cpp |  293 ++
 src/LMCP/afrl/cmasi/afrlcmasiGimbalAngleAction.cpp |  204 ++
 .../afrl/cmasi/afrlcmasiGimbalConfiguration.cpp    |  410 +++
 src/LMCP/afrl/cmasi/afrlcmasiGimbalScanAction.cpp  |  264 ++
 src/LMCP/afrl/cmasi/afrlcmasiGimbalStareAction.cpp |  220 ++
 src/LMCP/afrl/cmasi/afrlcmasiGimbalState.cpp       |  218 ++
 .../afrl/cmasi/afrlcmasiGimballedPayloadState.cpp  |  219 ++
 .../afrl/cmasi/afrlcmasiGoToWaypointAction.cpp     |  172 +
 src/LMCP/afrl/cmasi/afrlcmasiKeepInZone.cpp        |  184 ++
 src/LMCP/afrl/cmasi/afrlcmasiKeepOutZone.cpp       |  199 ++
 src/LMCP/afrl/cmasi/afrlcmasiKeyValuePair.cpp      |  178 ++
 src/LMCP/afrl/cmasi/afrlcmasiLineSearchTask.cpp    |  344 ++
 src/LMCP/afrl/cmasi/afrlcmasiLocation3D.cpp        |  210 ++
 src/LMCP/afrl/cmasi/afrlcmasiLoiterAction.cpp      |  308 ++
 src/LMCP/afrl/cmasi/afrlcmasiLoiterTask.cpp        |  217 ++
 src/LMCP/afrl/cmasi/afrlcmasiMissionCommand.cpp    |  249 ++
 src/LMCP/afrl/cmasi/afrlcmasiMustFlyTask.cpp       |  234 ++
 src/LMCP/afrl/cmasi/afrlcmasiNavigationAction.cpp  |  159 +
 src/LMCP/afrl/cmasi/afrlcmasiOperatingRegion.cpp   |  233 ++
 src/LMCP/afrl/cmasi/afrlcmasiOperatorSignal.cpp    |  219 ++
 src/LMCP/afrl/cmasi/afrlcmasiPathWaypoint.cpp      |  203 ++
 src/LMCP/afrl/cmasi/afrlcmasiPayloadAction.cpp     |  175 +
 .../afrl/cmasi/afrlcmasiPayloadConfiguration.cpp   |  255 ++
 src/LMCP/afrl/cmasi/afrlcmasiPayloadState.cpp      |  240 ++
 src/LMCP/afrl/cmasi/afrlcmasiPayloadStowAction.cpp |  163 +
 src/LMCP/afrl/cmasi/afrlcmasiPointSearchTask.cpp   |  317 ++
 src/LMCP/afrl/cmasi/afrlcmasiPolygon.cpp           |  222 ++
 src/LMCP/afrl/cmasi/afrlcmasiRectangle.cpp         |  240 ++
 src/LMCP/afrl/cmasi/afrlcmasiRemoveEntities.cpp    |  183 ++
 src/LMCP/afrl/cmasi/afrlcmasiRemoveTasks.cpp       |  183 ++
 src/LMCP/afrl/cmasi/afrlcmasiRemoveZones.cpp       |  183 ++
 src/LMCP/afrl/cmasi/afrlcmasiSearchTask.cpp        |  248 ++
 src/LMCP/afrl/cmasi/afrlcmasiServiceStatus.cpp     |  249 ++
 src/LMCP/afrl/cmasi/afrlcmasiSessionStatus.cpp     |  279 ++
 .../afrl/cmasi/afrlcmasiStopMovementAction.cpp     |  202 ++
 src/LMCP/afrl/cmasi/afrlcmasiTask.cpp              |  347 ++
 src/LMCP/afrl/cmasi/afrlcmasiVehicleAction.cpp     |  196 ++
 .../afrl/cmasi/afrlcmasiVehicleActionCommand.cpp   |  277 ++
 src/LMCP/afrl/cmasi/afrlcmasiVideoStreamAction.cpp |  186 ++
 .../cmasi/afrlcmasiVideoStreamConfiguration.cpp    |  195 ++
 src/LMCP/afrl/cmasi/afrlcmasiVideoStreamState.cpp  |  173 +
 src/LMCP/afrl/cmasi/afrlcmasiWaypoint.cpp          |  395 +++
 src/LMCP/afrl/cmasi/afrlcmasiWaypointTransfer.cpp  |  250 ++
 src/LMCP/afrl/cmasi/afrlcmasiWeatherReport.cpp     |  269 ++
 src/LMCP/afrl/cmasi/afrlcmasiWedge.cpp             |  208 ++
 src/LMCP/afrl/cmasi/perceive/EntityPerception.h    |  170 +
 .../cmasi/perceive/EntityPerceptionDescendants.h   |   12 +
 src/LMCP/afrl/cmasi/perceive/PERCEIVE.h            |   21 +
 src/LMCP/afrl/cmasi/perceive/PERCEIVEEnum.h        |   36 +
 src/LMCP/afrl/cmasi/perceive/PERCEIVEXMLReader.cpp |  257 ++
 src/LMCP/afrl/cmasi/perceive/PERCEIVEXMLReader.h   |   47 +
 src/LMCP/afrl/cmasi/perceive/TrackEntityAction.h   |  120 +
 .../cmasi/perceive/TrackEntityActionDescendants.h  |   12 +
 src/LMCP/afrl/cmasi/perceive/TrackEntityTask.h     |  121 +
 .../cmasi/perceive/TrackEntityTaskDescendants.h    |   12 +
 .../perceive/afrlcmasiperceiveEntityPerception.cpp |  471 +++
 .../afrlcmasiperceiveTrackEntityAction.cpp         |  203 ++
 .../perceive/afrlcmasiperceiveTrackEntityTask.cpp  |  220 ++
 src/LMCP/afrl/impact/AngledAreaSearchTask.h        |  119 +
 .../afrl/impact/AngledAreaSearchTaskDescendants.h  |   12 +
 src/LMCP/afrl/impact/AreaOfInterest.h              |  113 +
 src/LMCP/afrl/impact/AreaOfInterestDescendants.h   |   12 +
 src/LMCP/afrl/impact/AreaSearchPattern.h           |   60 +
 src/LMCP/afrl/impact/BatchRoutePlanRequest.h       |  140 +
 .../afrl/impact/BatchRoutePlanRequestDescendants.h |   12 +
 src/LMCP/afrl/impact/BatchRoutePlanResponse.h      |  113 +
 .../impact/BatchRoutePlanResponseDescendants.h     |   12 +
 src/LMCP/afrl/impact/BatchSummaryRequest.h         |  128 +
 .../afrl/impact/BatchSummaryRequestDescendants.h   |   12 +
 src/LMCP/afrl/impact/BatchSummaryResponse.h        |  113 +
 .../afrl/impact/BatchSummaryResponseDescendants.h  |   12 +
 src/LMCP/afrl/impact/BlockadeTask.h                |  125 +
 src/LMCP/afrl/impact/BlockadeTaskDescendants.h     |   12 +
 src/LMCP/afrl/impact/CommRelayTask.h               |  119 +
 src/LMCP/afrl/impact/CommRelayTaskDescendants.h    |   12 +
 src/LMCP/afrl/impact/ConfigurationRequest.h        |  106 +
 .../afrl/impact/ConfigurationRequestDescendants.h  |   12 +
 src/LMCP/afrl/impact/CordonTask.h                  |  113 +
 src/LMCP/afrl/impact/CordonTaskDescendants.h       |   12 +
 src/LMCP/afrl/impact/DeployImpactPayload.h         |  119 +
 .../afrl/impact/DeployImpactPayloadDescendants.h   |   12 +
 src/LMCP/afrl/impact/EscortTask.h                  |  125 +
 src/LMCP/afrl/impact/EscortTaskDescendants.h       |   12 +
 src/LMCP/afrl/impact/GroundVehicleConfiguration.h  |  124 +
 .../impact/GroundVehicleConfigurationDescendants.h |   12 +
 src/LMCP/afrl/impact/GroundVehicleState.h          |  100 +
 .../afrl/impact/GroundVehicleStateDescendants.h    |   12 +
 src/LMCP/afrl/impact/IMPACT.h                      |   62 +
 src/LMCP/afrl/impact/IMPACTEnum.h                  |   72 +
 src/LMCP/afrl/impact/IMPACTXMLReader.cpp           | 2713 ++++++++++++++++
 src/LMCP/afrl/impact/IMPACTXMLReader.h             |   45 +
 src/LMCP/afrl/impact/ImpactAutomationRequest.h     |  138 +
 .../impact/ImpactAutomationRequestDescendants.h    |   12 +
 src/LMCP/afrl/impact/ImpactAutomationResponse.h    |  138 +
 .../impact/ImpactAutomationResponseDescendants.h   |   12 +
 src/LMCP/afrl/impact/ImpactComponentJoin.h         |  106 +
 .../afrl/impact/ImpactComponentJoinDescendants.h   |   12 +
 src/LMCP/afrl/impact/ImpactComponentLeave.h        |  106 +
 .../afrl/impact/ImpactComponentLeaveDescendants.h  |   12 +
 src/LMCP/afrl/impact/ImpactHeartbeat.h             |  112 +
 src/LMCP/afrl/impact/ImpactHeartbeatDescendants.h  |   12 +
 src/LMCP/afrl/impact/ImpactLineSearchTask.h        |  119 +
 .../afrl/impact/ImpactLineSearchTaskDescendants.h  |   12 +
 src/LMCP/afrl/impact/ImpactPayloadConfiguration.h  |  107 +
 .../impact/ImpactPayloadConfigurationDescendants.h |   12 +
 src/LMCP/afrl/impact/ImpactPayloadType.h           |  128 +
 src/LMCP/afrl/impact/ImpactPointSearchTask.h       |  133 +
 .../afrl/impact/ImpactPointSearchTaskDescendants.h |   12 +
 src/LMCP/afrl/impact/LineOfInterest.h              |  113 +
 src/LMCP/afrl/impact/LineOfInterestDescendants.h   |   12 +
 src/LMCP/afrl/impact/MultiVehicleWatchTask.h       |  112 +
 .../afrl/impact/MultiVehicleWatchTaskDescendants.h |   12 +
 src/LMCP/afrl/impact/PatternSearchTask.h           |  126 +
 .../afrl/impact/PatternSearchTaskDescendants.h     |   12 +
 src/LMCP/afrl/impact/PointOfInterest.h             |  113 +
 src/LMCP/afrl/impact/PointOfInterestDescendants.h  |   12 +
 src/LMCP/afrl/impact/PowerConfiguration.h          |  107 +
 .../afrl/impact/PowerConfigurationDescendants.h    |   12 +
 src/LMCP/afrl/impact/PowerPlant.h                  |   68 +
 src/LMCP/afrl/impact/PowerPlantState.h             |  107 +
 src/LMCP/afrl/impact/PowerPlantStateDescendants.h  |   12 +
 src/LMCP/afrl/impact/RadioConfiguration.h          |  119 +
 .../afrl/impact/RadioConfigurationDescendants.h    |   12 +
 src/LMCP/afrl/impact/RadioState.h                  |  112 +
 src/LMCP/afrl/impact/RadioStateDescendants.h       |   12 +
 src/LMCP/afrl/impact/RadioTowerConfiguration.h     |  119 +
 .../impact/RadioTowerConfigurationDescendants.h    |   12 +
 src/LMCP/afrl/impact/RadioTowerState.h             |  106 +
 src/LMCP/afrl/impact/RadioTowerStateDescendants.h  |   12 +
 src/LMCP/afrl/impact/SpeedAltPair.h                |  125 +
 src/LMCP/afrl/impact/SpeedAltPairDescendants.h     |   12 +
 src/LMCP/afrl/impact/SurfaceVehicleConfiguration.h |  136 +
 .../SurfaceVehicleConfigurationDescendants.h       |   12 +
 src/LMCP/afrl/impact/SurfaceVehicleState.h         |  112 +
 .../afrl/impact/SurfaceVehicleStateDescendants.h   |   12 +
 src/LMCP/afrl/impact/TaskSummary.h                 |  119 +
 src/LMCP/afrl/impact/TaskSummaryDescendants.h      |   12 +
 src/LMCP/afrl/impact/TaskTimingPair.h              |  130 +
 src/LMCP/afrl/impact/TaskTimingPairDescendants.h   |   12 +
 src/LMCP/afrl/impact/VehicleSummary.h              |  154 +
 src/LMCP/afrl/impact/VehicleSummaryDescendants.h   |   12 +
 src/LMCP/afrl/impact/WatchTask.h                   |  106 +
 src/LMCP/afrl/impact/WatchTaskDescendants.h        |   12 +
 src/LMCP/afrl/impact/WaterReport.h                 |  131 +
 src/LMCP/afrl/impact/WaterReportDescendants.h      |   12 +
 src/LMCP/afrl/impact/WaterZone.h                   |  100 +
 src/LMCP/afrl/impact/WaterZoneDescendants.h        |   12 +
 .../afrl/impact/afrlimpactAngledAreaSearchTask.cpp |  261 ++
 src/LMCP/afrl/impact/afrlimpactAreaOfInterest.cpp  |  210 ++
 .../impact/afrlimpactBatchRoutePlanRequest.cpp     |  313 ++
 .../impact/afrlimpactBatchRoutePlanResponse.cpp    |  234 ++
 .../afrl/impact/afrlimpactBatchSummaryRequest.cpp  |  283 ++
 .../afrl/impact/afrlimpactBatchSummaryResponse.cpp |  234 ++
 src/LMCP/afrl/impact/afrlimpactBlockadeTask.cpp    |  264 ++
 src/LMCP/afrl/impact/afrlimpactCommRelayTask.cpp   |  249 ++
 .../afrl/impact/afrlimpactConfigurationRequest.cpp |  183 ++
 src/LMCP/afrl/impact/afrlimpactCordonTask.cpp      |  234 ++
 .../afrl/impact/afrlimpactDeployImpactPayload.cpp  |  201 ++
 src/LMCP/afrl/impact/afrlimpactEscortTask.cpp      |  302 ++
 .../afrlimpactGroundVehicleConfiguration.cpp       |  237 ++
 .../afrl/impact/afrlimpactGroundVehicleState.cpp   |  222 ++
 .../impact/afrlimpactImpactAutomationRequest.cpp   |  323 ++
 .../impact/afrlimpactImpactAutomationResponse.cpp  |  323 ++
 .../afrl/impact/afrlimpactImpactComponentJoin.cpp  |  163 +
 .../afrl/impact/afrlimpactImpactComponentLeave.cpp |  163 +
 src/LMCP/afrl/impact/afrlimpactImpactHeartbeat.cpp |  178 ++
 .../afrl/impact/afrlimpactImpactLineSearchTask.cpp |  286 ++
 .../afrlimpactImpactPayloadConfiguration.cpp       |  195 ++
 .../impact/afrlimpactImpactPointSearchTask.cpp     |  376 +++
 src/LMCP/afrl/impact/afrlimpactLineOfInterest.cpp  |  236 ++
 .../impact/afrlimpactMultiVehicleWatchTask.cpp     |  215 ++
 .../afrl/impact/afrlimpactPatternSearchTask.cpp    |  276 ++
 src/LMCP/afrl/impact/afrlimpactPointOfInterest.cpp |  209 ++
 .../afrl/impact/afrlimpactPowerConfiguration.cpp   |  175 +
 src/LMCP/afrl/impact/afrlimpactPowerPlantState.cpp |  173 +
 .../afrl/impact/afrlimpactRadioConfiguration.cpp   |  236 ++
 src/LMCP/afrl/impact/afrlimpactRadioState.cpp      |  188 ++
 .../impact/afrlimpactRadioTowerConfiguration.cpp   |  253 ++
 src/LMCP/afrl/impact/afrlimpactRadioTowerState.cpp |  237 ++
 src/LMCP/afrl/impact/afrlimpactSpeedAltPair.cpp    |  208 ++
 .../afrlimpactSurfaceVehicleConfiguration.cpp      |  267 ++
 .../afrl/impact/afrlimpactSurfaceVehicleState.cpp  |  252 ++
 src/LMCP/afrl/impact/afrlimpactTaskSummary.cpp     |  249 ++
 src/LMCP/afrl/impact/afrlimpactTaskTimingPair.cpp  |  223 ++
 src/LMCP/afrl/impact/afrlimpactVehicleSummary.cpp  |  283 ++
 src/LMCP/afrl/impact/afrlimpactWatchTask.cpp       |  200 ++
 src/LMCP/afrl/impact/afrlimpactWaterReport.cpp     |  255 ++
 src/LMCP/afrl/impact/afrlimpactWaterZone.cpp       |  184 ++
 src/LMCP/avtas/lmcp/ByteBuffer.cpp                 |  538 ++++
 src/LMCP/avtas/lmcp/ByteBuffer.h                   |  148 +
 src/LMCP/avtas/lmcp/Factory.cpp                    |  536 ++++
 src/LMCP/avtas/lmcp/Factory.h                      |   85 +
 src/LMCP/avtas/lmcp/LmcpXMLReader.h                |  104 +
 src/LMCP/avtas/lmcp/Node.cpp                       |  301 ++
 src/LMCP/avtas/lmcp/Node.h                         |  113 +
 src/LMCP/avtas/lmcp/NodeUtil.cpp                   |  142 +
 src/LMCP/avtas/lmcp/NodeUtil.h                     |   45 +
 src/LMCP/avtas/lmcp/Object.h                       |   98 +
 src/LMCP/avtas/lmcp/XMLParser.cpp                  |  284 ++
 src/LMCP/avtas/lmcp/XMLParser.h                    |   54 +
 src/LMCP/meson.build                               |  180 ++
 src/LMCP/test/client/Makefile                      |   39 +
 src/LMCP/test/client/TestClient.vcproj             |  185 ++
 src/LMCP/test/client/TestClient.vcxproj            |   93 +
 src/LMCP/test/client/main.cpp                      | 1556 +++++++++
 src/LMCP/test/server/Makefile                      |   39 +
 src/LMCP/test/server/TestServer.vcproj             |  185 ++
 src/LMCP/test/server/TestServer.vcxproj            |   93 +
 src/LMCP/test/server/main.cpp                      |  136 +
 src/LMCP/uxas/messages/route/EgressRouteRequest.h  |  121 +
 .../messages/route/EgressRouteRequestDescendants.h |   12 +
 src/LMCP/uxas/messages/route/EgressRouteResponse.h |  120 +
 .../route/EgressRouteResponseDescendants.h         |   12 +
 src/LMCP/uxas/messages/route/GraphEdge.h           |  127 +
 .../uxas/messages/route/GraphEdgeDescendants.h     |   12 +
 src/LMCP/uxas/messages/route/GraphNode.h           |  121 +
 .../uxas/messages/route/GraphNodeDescendants.h     |   12 +
 src/LMCP/uxas/messages/route/GraphRegion.h         |  121 +
 .../uxas/messages/route/GraphRegionDescendants.h   |   12 +
 src/LMCP/uxas/messages/route/ROUTE.h               |   29 +
 src/LMCP/uxas/messages/route/ROUTEEnum.h           |   44 +
 src/LMCP/uxas/messages/route/ROUTEXMLReader.cpp    |  473 +++
 src/LMCP/uxas/messages/route/ROUTEXMLReader.h      |   47 +
 src/LMCP/uxas/messages/route/RouteConstraints.h    |  146 +
 .../messages/route/RouteConstraintsDescendants.h   |   12 +
 src/LMCP/uxas/messages/route/RoutePlan.h           |  127 +
 .../uxas/messages/route/RoutePlanDescendants.h     |   12 +
 src/LMCP/uxas/messages/route/RoutePlanRequest.h    |  139 +
 .../messages/route/RoutePlanRequestDescendants.h   |   12 +
 src/LMCP/uxas/messages/route/RoutePlanResponse.h   |  133 +
 .../messages/route/RoutePlanResponseDescendants.h  |   12 +
 src/LMCP/uxas/messages/route/RouteRequest.h        |  138 +
 .../uxas/messages/route/RouteRequestDescendants.h  |   12 +
 src/LMCP/uxas/messages/route/RouteResponse.h       |  115 +
 .../uxas/messages/route/RouteResponseDescendants.h |   12 +
 .../route/uxasmessagesrouteEgressRouteRequest.cpp  |  226 ++
 .../route/uxasmessagesrouteEgressRouteResponse.cpp |  273 ++
 .../messages/route/uxasmessagesrouteGraphEdge.cpp  |  268 ++
 .../messages/route/uxasmessagesrouteGraphNode.cpp  |  246 ++
 .../route/uxasmessagesrouteGraphRegion.cpp         |  307 ++
 .../route/uxasmessagesrouteRouteConstraints.cpp    |  317 ++
 .../messages/route/uxasmessagesrouteRoutePlan.cpp  |  323 ++
 .../route/uxasmessagesrouteRoutePlanRequest.cpp    |  296 ++
 .../route/uxasmessagesrouteRoutePlanResponse.cpp   |  281 ++
 .../route/uxasmessagesrouteRouteRequest.cpp        |  316 ++
 .../route/uxasmessagesrouteRouteResponse.cpp       |  236 ++
 .../uxas/messages/task/AssignmentCoordination.h    |  115 +
 .../task/AssignmentCoordinationDescendants.h       |   12 +
 .../uxas/messages/task/AssignmentCoordinatorTask.h |  102 +
 .../task/AssignmentCoordinatorTaskDescendants.h    |   12 +
 src/LMCP/uxas/messages/task/AssignmentCostMatrix.h |  132 +
 .../task/AssignmentCostMatrixDescendants.h         |   12 +
 src/LMCP/uxas/messages/task/CancelTask.h           |  113 +
 .../uxas/messages/task/CancelTaskDescendants.h     |   12 +
 .../messages/task/CoordinatedAutomationRequest.h   |  128 +
 .../task/CoordinatedAutomationRequestDescendants.h |   12 +
 src/LMCP/uxas/messages/task/FootprintRequest.h     |  136 +
 .../messages/task/FootprintRequestDescendants.h    |   12 +
 src/LMCP/uxas/messages/task/PlanningState.h        |  121 +
 .../uxas/messages/task/PlanningStateDescendants.h  |   12 +
 src/LMCP/uxas/messages/task/SensorFootprint.h      |  193 ++
 .../messages/task/SensorFootprintDescendants.h     |   12 +
 .../uxas/messages/task/SensorFootprintRequests.h   |  115 +
 .../task/SensorFootprintRequestsDescendants.h      |   12 +
 .../uxas/messages/task/SensorFootprintResponse.h   |  115 +
 .../task/SensorFootprintResponseDescendants.h      |   12 +
 src/LMCP/uxas/messages/task/TaskActive.h           |  120 +
 .../uxas/messages/task/TaskActiveDescendants.h     |   12 +
 src/LMCP/uxas/messages/task/TaskAssignment.h       |  132 +
 .../uxas/messages/task/TaskAssignmentDescendants.h |   12 +
 .../uxas/messages/task/TaskAssignmentSummary.h     |  121 +
 .../task/TaskAssignmentSummaryDescendants.h        |   12 +
 .../uxas/messages/task/TaskAutomationRequest.h     |  128 +
 .../task/TaskAutomationRequestDescendants.h        |   12 +
 .../uxas/messages/task/TaskAutomationResponse.h    |  115 +
 .../task/TaskAutomationResponseDescendants.h       |   12 +
 src/LMCP/uxas/messages/task/TaskComplete.h         |  120 +
 .../uxas/messages/task/TaskCompleteDescendants.h   |   12 +
 .../uxas/messages/task/TaskImplementationRequest.h |  163 +
 .../task/TaskImplementationRequestDescendants.h    |   12 +
 .../messages/task/TaskImplementationResponse.h     |  152 +
 .../task/TaskImplementationResponseDescendants.h   |   12 +
 src/LMCP/uxas/messages/task/TaskInitialized.h      |  108 +
 .../messages/task/TaskInitializedDescendants.h     |   12 +
 src/LMCP/uxas/messages/task/TaskOption.h           |  152 +
 src/LMCP/uxas/messages/task/TaskOptionCost.h       |  138 +
 .../uxas/messages/task/TaskOptionCostDescendants.h |   12 +
 .../uxas/messages/task/TaskOptionDescendants.h     |   12 +
 src/LMCP/uxas/messages/task/TaskPause.h            |  108 +
 src/LMCP/uxas/messages/task/TaskPauseDescendants.h |   12 +
 src/LMCP/uxas/messages/task/TaskPlanOptions.h      |  127 +
 .../messages/task/TaskPlanOptionsDescendants.h     |   12 +
 src/LMCP/uxas/messages/task/TaskProgress.h         |  126 +
 .../uxas/messages/task/TaskProgressDescendants.h   |   12 +
 src/LMCP/uxas/messages/task/TaskProgressRequest.h  |  114 +
 .../messages/task/TaskProgressRequestDescendants.h |   12 +
 src/LMCP/uxas/messages/task/TaskResume.h           |  121 +
 .../uxas/messages/task/TaskResumeDescendants.h     |   12 +
 src/LMCP/uxas/messages/task/UXTASK.h               |   46 +
 src/LMCP/uxas/messages/task/UXTASKEnum.h           |   61 +
 src/LMCP/uxas/messages/task/UXTASKXMLReader.cpp    | 1108 +++++++
 src/LMCP/uxas/messages/task/UXTASKXMLReader.h      |   47 +
 .../uxas/messages/task/UniqueAutomationRequest.h   |  128 +
 .../task/UniqueAutomationRequestDescendants.h      |   12 +
 .../uxas/messages/task/UniqueAutomationResponse.h  |  115 +
 .../task/UniqueAutomationResponseDescendants.h     |   12 +
 .../uxasmessagestaskAssignmentCoordination.cpp     |  209 ++
 .../uxasmessagestaskAssignmentCoordinatorTask.cpp  |  175 +
 .../task/uxasmessagestaskAssignmentCostMatrix.cpp  |  301 ++
 .../messages/task/uxasmessagestaskCancelTask.cpp   |  220 ++
 ...xasmessagestaskCoordinatedAutomationRequest.cpp |  295 ++
 .../task/uxasmessagestaskFootprintRequest.cpp      |  320 ++
 .../task/uxasmessagestaskPlanningState.cpp         |  226 ++
 .../task/uxasmessagestaskSensorFootprint.cpp       |  375 +++
 .../uxasmessagestaskSensorFootprintRequests.cpp    |  236 ++
 .../uxasmessagestaskSensorFootprintResponse.cpp    |  236 ++
 .../messages/task/uxasmessagestaskTaskActive.cpp   |  195 ++
 .../task/uxasmessagestaskTaskAssignment.cpp        |  225 ++
 .../task/uxasmessagestaskTaskAssignmentSummary.cpp |  251 ++
 .../task/uxasmessagestaskTaskAutomationRequest.cpp |  295 ++
 .../uxasmessagestaskTaskAutomationResponse.cpp     |  209 ++
 .../messages/task/uxasmessagestaskTaskComplete.cpp |  215 ++
 .../uxasmessagestaskTaskImplementationRequest.cpp  |  331 ++
 .../uxasmessagestaskTaskImplementationResponse.cpp |  358 +++
 .../task/uxasmessagestaskTaskInitialized.cpp       |  165 +
 .../messages/task/uxasmessagestaskTaskOption.cpp   |  352 +++
 .../task/uxasmessagestaskTaskOptionCost.cpp        |  240 ++
 .../messages/task/uxasmessagestaskTaskPause.cpp    |  165 +
 .../task/uxasmessagestaskTaskPlanOptions.cpp       |  266 ++
 .../messages/task/uxasmessagestaskTaskProgress.cpp |  230 ++
 .../task/uxasmessagestaskTaskProgressRequest.cpp   |  180 ++
 .../messages/task/uxasmessagestaskTaskResume.cpp   |  224 ++
 .../uxasmessagestaskUniqueAutomationRequest.cpp    |  295 ++
 .../uxasmessagestaskUniqueAutomationResponse.cpp   |  209 ++
 .../uxas/messages/uxnative/AutopilotKeepAlive.h    |  120 +
 .../uxnative/AutopilotKeepAliveDescendants.h       |   12 +
 .../messages/uxnative/BandwidthReceiveReport.h     |  122 +
 .../uxnative/BandwidthReceiveReportDescendants.h   |   12 +
 src/LMCP/uxas/messages/uxnative/BandwidthTest.h    |  114 +
 .../messages/uxnative/BandwidthTestDescendants.h   |   12 +
 src/LMCP/uxas/messages/uxnative/CreateNewService.h |  114 +
 .../uxnative/CreateNewServiceDescendants.h         |   12 +
 src/LMCP/uxas/messages/uxnative/EntityExit.h       |  114 +
 .../uxas/messages/uxnative/EntityExitDescendants.h |   12 +
 src/LMCP/uxas/messages/uxnative/EntityJoin.h       |  114 +
 .../uxas/messages/uxnative/EntityJoinDescendants.h |   12 +
 src/LMCP/uxas/messages/uxnative/EntityLocation.h   |  121 +
 .../messages/uxnative/EntityLocationDescendants.h  |   13 +
 .../uxas/messages/uxnative/IncrementWaypoint.h     |  108 +
 .../uxnative/IncrementWaypointDescendants.h        |   12 +
 src/LMCP/uxas/messages/uxnative/KillService.h      |  108 +
 .../messages/uxnative/KillServiceDescendants.h     |   12 +
 .../messages/uxnative/OnboardProcessorIsAlive.h    |  114 +
 .../uxnative/OnboardProcessorIsAliveDescendants.h  |   12 +
 src/LMCP/uxas/messages/uxnative/StartupComplete.h  |  102 +
 .../messages/uxnative/StartupCompleteDescendants.h |   12 +
 .../uxas/messages/uxnative/SubTaskAssignment.h     |  115 +
 .../uxnative/SubTaskAssignmentDescendants.h        |   12 +
 src/LMCP/uxas/messages/uxnative/SubTaskExecution.h |  115 +
 .../uxnative/SubTaskExecutionDescendants.h         |   12 +
 src/LMCP/uxas/messages/uxnative/UXNATIVE.h         |   32 +
 src/LMCP/uxas/messages/uxnative/UXNATIVEEnum.h     |   47 +
 .../uxas/messages/uxnative/UXNATIVEXMLReader.cpp   |  364 +++
 .../uxas/messages/uxnative/UXNATIVEXMLReader.h     |   47 +
 src/LMCP/uxas/messages/uxnative/VideoRecord.h      |  108 +
 .../messages/uxnative/VideoRecordDescendants.h     |   12 +
 .../uxasmessagesuxnativeAutopilotKeepAlive.cpp     |  195 ++
 .../uxasmessagesuxnativeBandwidthReceiveReport.cpp |  255 ++
 .../uxnative/uxasmessagesuxnativeBandwidthTest.cpp |  195 ++
 .../uxasmessagesuxnativeCreateNewService.cpp       |  204 ++
 .../uxnative/uxasmessagesuxnativeEntityExit.cpp    |  180 ++
 .../uxnative/uxasmessagesuxnativeEntityJoin.cpp    |  180 ++
 .../uxasmessagesuxnativeEntityLocation.cpp         |  227 ++
 .../uxasmessagesuxnativeIncrementWaypoint.cpp      |  165 +
 .../uxnative/uxasmessagesuxnativeKillService.cpp   |  165 +
 ...uxasmessagesuxnativeOnboardProcessorIsAlive.cpp |  180 ++
 .../uxasmessagesuxnativeStartupComplete.cpp        |  150 +
 .../uxasmessagesuxnativeSubTaskAssignment.cpp      |  299 ++
 .../uxasmessagesuxnativeSubTaskExecution.cpp       |  242 ++
 .../uxnative/uxasmessagesuxnativeVideoRecord.cpp   |  165 +
 544 files changed, 80964 insertions(+)
 create mode 100644 src/LMCP/CMASI.xml
 create mode 100644 src/LMCP/IMPACT.xml
 create mode 100644 src/LMCP/LMCP.vcproj
 create mode 100644 src/LMCP/LMCP.vcxproj
 create mode 100644 src/LMCP/LMCP.vcxproj.filters
 create mode 100644 src/LMCP/Makefile
 create mode 100644 src/LMCP/PERCEIVE.xml
 create mode 100644 src/LMCP/ROUTE.xml
 create mode 100644 src/LMCP/UXNATIVE.xml
 create mode 100644 src/LMCP/UXTASK.xml
 create mode 100644 src/LMCP/afrl/cmasi/AbstractGeometry.h
 create mode 100644 src/LMCP/afrl/cmasi/AbstractGeometryDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/AbstractZone.h
 create mode 100644 src/LMCP/afrl/cmasi/AbstractZoneDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/AirVehicleConfiguration.h
 create mode 100644 src/LMCP/afrl/cmasi/AirVehicleConfigurationDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/AirVehicleState.h
 create mode 100644 src/LMCP/afrl/cmasi/AirVehicleStateDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/AltitudeType.h
 create mode 100644 src/LMCP/afrl/cmasi/AreaSearchTask.h
 create mode 100644 src/LMCP/afrl/cmasi/AreaSearchTaskDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/AutomationRequest.h
 create mode 100644 src/LMCP/afrl/cmasi/AutomationRequestDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/AutomationResponse.h
 create mode 100644 src/LMCP/afrl/cmasi/AutomationResponseDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/CMASI.h
 create mode 100644 src/LMCP/afrl/cmasi/CMASIEnum.h
 create mode 100644 src/LMCP/afrl/cmasi/CMASIXMLReader.cpp
 create mode 100644 src/LMCP/afrl/cmasi/CMASIXMLReader.h
 create mode 100644 src/LMCP/afrl/cmasi/CameraAction.h
 create mode 100644 src/LMCP/afrl/cmasi/CameraActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/CameraConfiguration.h
 create mode 100644 src/LMCP/afrl/cmasi/CameraConfigurationDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/CameraState.h
 create mode 100644 src/LMCP/afrl/cmasi/CameraStateDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/Circle.h
 create mode 100644 src/LMCP/afrl/cmasi/CircleDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/CommandStatusType.h
 create mode 100644 src/LMCP/afrl/cmasi/EntityConfiguration.h
 create mode 100644 src/LMCP/afrl/cmasi/EntityConfigurationDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/EntityState.h
 create mode 100644 src/LMCP/afrl/cmasi/EntityStateDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/FOVOperationMode.h
 create mode 100644 src/LMCP/afrl/cmasi/FlightDirectorAction.h
 create mode 100644 src/LMCP/afrl/cmasi/FlightDirectorActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/FlightProfile.h
 create mode 100644 src/LMCP/afrl/cmasi/FlightProfileDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/FollowPathCommand.h
 create mode 100644 src/LMCP/afrl/cmasi/FollowPathCommandDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/GimbalAngleAction.h
 create mode 100644 src/LMCP/afrl/cmasi/GimbalAngleActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/GimbalConfiguration.h
 create mode 100644 src/LMCP/afrl/cmasi/GimbalConfigurationDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/GimbalPointingMode.h
 create mode 100644 src/LMCP/afrl/cmasi/GimbalScanAction.h
 create mode 100644 src/LMCP/afrl/cmasi/GimbalScanActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/GimbalStareAction.h
 create mode 100644 src/LMCP/afrl/cmasi/GimbalStareActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/GimbalState.h
 create mode 100644 src/LMCP/afrl/cmasi/GimbalStateDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/GimballedPayloadState.h
 create mode 100644 src/LMCP/afrl/cmasi/GimballedPayloadStateDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/GoToWaypointAction.h
 create mode 100644 src/LMCP/afrl/cmasi/GoToWaypointActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/KeepInZone.h
 create mode 100644 src/LMCP/afrl/cmasi/KeepInZoneDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/KeepOutZone.h
 create mode 100644 src/LMCP/afrl/cmasi/KeepOutZoneDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/KeyValuePair.h
 create mode 100644 src/LMCP/afrl/cmasi/KeyValuePairDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/LineSearchTask.h
 create mode 100644 src/LMCP/afrl/cmasi/LineSearchTaskDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/Location3D.h
 create mode 100644 src/LMCP/afrl/cmasi/Location3DDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/LoiterAction.h
 create mode 100644 src/LMCP/afrl/cmasi/LoiterActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/LoiterDirection.h
 create mode 100644 src/LMCP/afrl/cmasi/LoiterTask.h
 create mode 100644 src/LMCP/afrl/cmasi/LoiterTaskDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/LoiterType.h
 create mode 100644 src/LMCP/afrl/cmasi/MissionCommand.h
 create mode 100644 src/LMCP/afrl/cmasi/MissionCommandDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/MustFlyTask.h
 create mode 100644 src/LMCP/afrl/cmasi/MustFlyTaskDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/NavigationAction.h
 create mode 100644 src/LMCP/afrl/cmasi/NavigationActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/NavigationMode.h
 create mode 100644 src/LMCP/afrl/cmasi/OperatingRegion.h
 create mode 100644 src/LMCP/afrl/cmasi/OperatingRegionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/OperatorSignal.h
 create mode 100644 src/LMCP/afrl/cmasi/OperatorSignalDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/PathWaypoint.h
 create mode 100644 src/LMCP/afrl/cmasi/PathWaypointDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/PayloadAction.h
 create mode 100644 src/LMCP/afrl/cmasi/PayloadActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/PayloadConfiguration.h
 create mode 100644 src/LMCP/afrl/cmasi/PayloadConfigurationDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/PayloadState.h
 create mode 100644 src/LMCP/afrl/cmasi/PayloadStateDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/PayloadStowAction.h
 create mode 100644 src/LMCP/afrl/cmasi/PayloadStowActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/PointSearchTask.h
 create mode 100644 src/LMCP/afrl/cmasi/PointSearchTaskDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/Polygon.h
 create mode 100644 src/LMCP/afrl/cmasi/PolygonDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/Rectangle.h
 create mode 100644 src/LMCP/afrl/cmasi/RectangleDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/RemoveEntities.h
 create mode 100644 src/LMCP/afrl/cmasi/RemoveEntitiesDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/RemoveTasks.h
 create mode 100644 src/LMCP/afrl/cmasi/RemoveTasksDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/RemoveZones.h
 create mode 100644 src/LMCP/afrl/cmasi/RemoveZonesDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/SearchTask.h
 create mode 100644 src/LMCP/afrl/cmasi/SearchTaskDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/ServiceStatus.h
 create mode 100644 src/LMCP/afrl/cmasi/ServiceStatusDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/ServiceStatusType.h
 create mode 100644 src/LMCP/afrl/cmasi/SessionStatus.h
 create mode 100644 src/LMCP/afrl/cmasi/SessionStatusDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/SimulationStatusType.h
 create mode 100644 src/LMCP/afrl/cmasi/SpeedType.h
 create mode 100644 src/LMCP/afrl/cmasi/StopMovementAction.h
 create mode 100644 src/LMCP/afrl/cmasi/StopMovementActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/Task.h
 create mode 100644 src/LMCP/afrl/cmasi/TaskDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/TravelMode.h
 create mode 100644 src/LMCP/afrl/cmasi/TurnType.h
 create mode 100644 src/LMCP/afrl/cmasi/VehicleAction.h
 create mode 100644 src/LMCP/afrl/cmasi/VehicleActionCommand.h
 create mode 100644 src/LMCP/afrl/cmasi/VehicleActionCommandDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/VehicleActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/VideoStreamAction.h
 create mode 100644 src/LMCP/afrl/cmasi/VideoStreamActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/VideoStreamConfiguration.h
 create mode 100644 src/LMCP/afrl/cmasi/VideoStreamConfigurationDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/VideoStreamState.h
 create mode 100644 src/LMCP/afrl/cmasi/VideoStreamStateDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/WavelengthBand.h
 create mode 100644 src/LMCP/afrl/cmasi/Waypoint.h
 create mode 100644 src/LMCP/afrl/cmasi/WaypointDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/WaypointTransfer.h
 create mode 100644 src/LMCP/afrl/cmasi/WaypointTransferDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/WaypointTransferMode.h
 create mode 100644 src/LMCP/afrl/cmasi/WeatherReport.h
 create mode 100644 src/LMCP/afrl/cmasi/WeatherReportDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/Wedge.h
 create mode 100644 src/LMCP/afrl/cmasi/WedgeDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/ZoneAvoidanceType.h
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiAbstractGeometry.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiAbstractZone.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiAirVehicleConfiguration.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiAirVehicleState.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiAreaSearchTask.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiAutomationRequest.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiAutomationResponse.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiCameraAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiCameraConfiguration.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiCameraState.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiCircle.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiEntityConfiguration.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiEntityState.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiFlightDirectorAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiFlightProfile.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiFollowPathCommand.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiGimbalAngleAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiGimbalConfiguration.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiGimbalScanAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiGimbalStareAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiGimbalState.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiGimballedPayloadState.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiGoToWaypointAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiKeepInZone.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiKeepOutZone.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiKeyValuePair.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiLineSearchTask.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiLocation3D.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiLoiterAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiLoiterTask.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiMissionCommand.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiMustFlyTask.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiNavigationAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiOperatingRegion.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiOperatorSignal.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiPathWaypoint.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiPayloadAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiPayloadConfiguration.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiPayloadState.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiPayloadStowAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiPointSearchTask.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiPolygon.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiRectangle.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiRemoveEntities.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiRemoveTasks.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiRemoveZones.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiSearchTask.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiServiceStatus.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiSessionStatus.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiStopMovementAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiTask.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiVehicleAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiVehicleActionCommand.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiVideoStreamAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiVideoStreamConfiguration.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiVideoStreamState.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiWaypoint.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiWaypointTransfer.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiWeatherReport.cpp
 create mode 100644 src/LMCP/afrl/cmasi/afrlcmasiWedge.cpp
 create mode 100644 src/LMCP/afrl/cmasi/perceive/EntityPerception.h
 create mode 100644 src/LMCP/afrl/cmasi/perceive/EntityPerceptionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/perceive/PERCEIVE.h
 create mode 100644 src/LMCP/afrl/cmasi/perceive/PERCEIVEEnum.h
 create mode 100644 src/LMCP/afrl/cmasi/perceive/PERCEIVEXMLReader.cpp
 create mode 100644 src/LMCP/afrl/cmasi/perceive/PERCEIVEXMLReader.h
 create mode 100644 src/LMCP/afrl/cmasi/perceive/TrackEntityAction.h
 create mode 100644 src/LMCP/afrl/cmasi/perceive/TrackEntityActionDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/perceive/TrackEntityTask.h
 create mode 100644 src/LMCP/afrl/cmasi/perceive/TrackEntityTaskDescendants.h
 create mode 100644 src/LMCP/afrl/cmasi/perceive/afrlcmasiperceiveEntityPerception.cpp
 create mode 100644 src/LMCP/afrl/cmasi/perceive/afrlcmasiperceiveTrackEntityAction.cpp
 create mode 100644 src/LMCP/afrl/cmasi/perceive/afrlcmasiperceiveTrackEntityTask.cpp
 create mode 100644 src/LMCP/afrl/impact/AngledAreaSearchTask.h
 create mode 100644 src/LMCP/afrl/impact/AngledAreaSearchTaskDescendants.h
 create mode 100644 src/LMCP/afrl/impact/AreaOfInterest.h
 create mode 100644 src/LMCP/afrl/impact/AreaOfInterestDescendants.h
 create mode 100644 src/LMCP/afrl/impact/AreaSearchPattern.h
 create mode 100644 src/LMCP/afrl/impact/BatchRoutePlanRequest.h
 create mode 100644 src/LMCP/afrl/impact/BatchRoutePlanRequestDescendants.h
 create mode 100644 src/LMCP/afrl/impact/BatchRoutePlanResponse.h
 create mode 100644 src/LMCP/afrl/impact/BatchRoutePlanResponseDescendants.h
 create mode 100644 src/LMCP/afrl/impact/BatchSummaryRequest.h
 create mode 100644 src/LMCP/afrl/impact/BatchSummaryRequestDescendants.h
 create mode 100644 src/LMCP/afrl/impact/BatchSummaryResponse.h
 create mode 100644 src/LMCP/afrl/impact/BatchSummaryResponseDescendants.h
 create mode 100644 src/LMCP/afrl/impact/BlockadeTask.h
 create mode 100644 src/LMCP/afrl/impact/BlockadeTaskDescendants.h
 create mode 100644 src/LMCP/afrl/impact/CommRelayTask.h
 create mode 100644 src/LMCP/afrl/impact/CommRelayTaskDescendants.h
 create mode 100644 src/LMCP/afrl/impact/ConfigurationRequest.h
 create mode 100644 src/LMCP/afrl/impact/ConfigurationRequestDescendants.h
 create mode 100644 src/LMCP/afrl/impact/CordonTask.h
 create mode 100644 src/LMCP/afrl/impact/CordonTaskDescendants.h
 create mode 100644 src/LMCP/afrl/impact/DeployImpactPayload.h
 create mode 100644 src/LMCP/afrl/impact/DeployImpactPayloadDescendants.h
 create mode 100644 src/LMCP/afrl/impact/EscortTask.h
 create mode 100644 src/LMCP/afrl/impact/EscortTaskDescendants.h
 create mode 100644 src/LMCP/afrl/impact/GroundVehicleConfiguration.h
 create mode 100644 src/LMCP/afrl/impact/GroundVehicleConfigurationDescendants.h
 create mode 100644 src/LMCP/afrl/impact/GroundVehicleState.h
 create mode 100644 src/LMCP/afrl/impact/GroundVehicleStateDescendants.h
 create mode 100644 src/LMCP/afrl/impact/IMPACT.h
 create mode 100644 src/LMCP/afrl/impact/IMPACTEnum.h
 create mode 100644 src/LMCP/afrl/impact/IMPACTXMLReader.cpp
 create mode 100644 src/LMCP/afrl/impact/IMPACTXMLReader.h
 create mode 100644 src/LMCP/afrl/impact/ImpactAutomationRequest.h
 create mode 100644 src/LMCP/afrl/impact/ImpactAutomationRequestDescendants.h
 create mode 100644 src/LMCP/afrl/impact/ImpactAutomationResponse.h
 create mode 100644 src/LMCP/afrl/impact/ImpactAutomationResponseDescendants.h
 create mode 100644 src/LMCP/afrl/impact/ImpactComponentJoin.h
 create mode 100644 src/LMCP/afrl/impact/ImpactComponentJoinDescendants.h
 create mode 100644 src/LMCP/afrl/impact/ImpactComponentLeave.h
 create mode 100644 src/LMCP/afrl/impact/ImpactComponentLeaveDescendants.h
 create mode 100644 src/LMCP/afrl/impact/ImpactHeartbeat.h
 create mode 100644 src/LMCP/afrl/impact/ImpactHeartbeatDescendants.h
 create mode 100644 src/LMCP/afrl/impact/ImpactLineSearchTask.h
 create mode 100644 src/LMCP/afrl/impact/ImpactLineSearchTaskDescendants.h
 create mode 100644 src/LMCP/afrl/impact/ImpactPayloadConfiguration.h
 create mode 100644 src/LMCP/afrl/impact/ImpactPayloadConfigurationDescendants.h
 create mode 100644 src/LMCP/afrl/impact/ImpactPayloadType.h
 create mode 100644 src/LMCP/afrl/impact/ImpactPointSearchTask.h
 create mode 100644 src/LMCP/afrl/impact/ImpactPointSearchTaskDescendants.h
 create mode 100644 src/LMCP/afrl/impact/LineOfInterest.h
 create mode 100644 src/LMCP/afrl/impact/LineOfInterestDescendants.h
 create mode 100644 src/LMCP/afrl/impact/MultiVehicleWatchTask.h
 create mode 100644 src/LMCP/afrl/impact/MultiVehicleWatchTaskDescendants.h
 create mode 100644 src/LMCP/afrl/impact/PatternSearchTask.h
 create mode 100644 src/LMCP/afrl/impact/PatternSearchTaskDescendants.h
 create mode 100644 src/LMCP/afrl/impact/PointOfInterest.h
 create mode 100644 src/LMCP/afrl/impact/PointOfInterestDescendants.h
 create mode 100644 src/LMCP/afrl/impact/PowerConfiguration.h
 create mode 100644 src/LMCP/afrl/impact/PowerConfigurationDescendants.h
 create mode 100644 src/LMCP/afrl/impact/PowerPlant.h
 create mode 100644 src/LMCP/afrl/impact/PowerPlantState.h
 create mode 100644 src/LMCP/afrl/impact/PowerPlantStateDescendants.h
 create mode 100644 src/LMCP/afrl/impact/RadioConfiguration.h
 create mode 100644 src/LMCP/afrl/impact/RadioConfigurationDescendants.h
 create mode 100644 src/LMCP/afrl/impact/RadioState.h
 create mode 100644 src/LMCP/afrl/impact/RadioStateDescendants.h
 create mode 100644 src/LMCP/afrl/impact/RadioTowerConfiguration.h
 create mode 100644 src/LMCP/afrl/impact/RadioTowerConfigurationDescendants.h
 create mode 100644 src/LMCP/afrl/impact/RadioTowerState.h
 create mode 100644 src/LMCP/afrl/impact/RadioTowerStateDescendants.h
 create mode 100644 src/LMCP/afrl/impact/SpeedAltPair.h
 create mode 100644 src/LMCP/afrl/impact/SpeedAltPairDescendants.h
 create mode 100644 src/LMCP/afrl/impact/SurfaceVehicleConfiguration.h
 create mode 100644 src/LMCP/afrl/impact/SurfaceVehicleConfigurationDescendants.h
 create mode 100644 src/LMCP/afrl/impact/SurfaceVehicleState.h
 create mode 100644 src/LMCP/afrl/impact/SurfaceVehicleStateDescendants.h
 create mode 100644 src/LMCP/afrl/impact/TaskSummary.h
 create mode 100644 src/LMCP/afrl/impact/TaskSummaryDescendants.h
 create mode 100644 src/LMCP/afrl/impact/TaskTimingPair.h
 create mode 100644 src/LMCP/afrl/impact/TaskTimingPairDescendants.h
 create mode 100644 src/LMCP/afrl/impact/VehicleSummary.h
 create mode 100644 src/LMCP/afrl/impact/VehicleSummaryDescendants.h
 create mode 100644 src/LMCP/afrl/impact/WatchTask.h
 create mode 100644 src/LMCP/afrl/impact/WatchTaskDescendants.h
 create mode 100644 src/LMCP/afrl/impact/WaterReport.h
 create mode 100644 src/LMCP/afrl/impact/WaterReportDescendants.h
 create mode 100644 src/LMCP/afrl/impact/WaterZone.h
 create mode 100644 src/LMCP/afrl/impact/WaterZoneDescendants.h
 create mode 100644 src/LMCP/afrl/impact/afrlimpactAngledAreaSearchTask.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactAreaOfInterest.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactBatchRoutePlanRequest.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactBatchRoutePlanResponse.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactBatchSummaryRequest.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactBatchSummaryResponse.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactBlockadeTask.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactCommRelayTask.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactConfigurationRequest.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactCordonTask.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactDeployImpactPayload.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactEscortTask.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactGroundVehicleConfiguration.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactGroundVehicleState.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactImpactAutomationRequest.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactImpactAutomationResponse.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactImpactComponentJoin.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactImpactComponentLeave.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactImpactHeartbeat.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactImpactLineSearchTask.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactImpactPayloadConfiguration.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactImpactPointSearchTask.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactLineOfInterest.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactMultiVehicleWatchTask.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactPatternSearchTask.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactPointOfInterest.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactPowerConfiguration.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactPowerPlantState.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactRadioConfiguration.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactRadioState.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactRadioTowerConfiguration.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactRadioTowerState.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactSpeedAltPair.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactSurfaceVehicleConfiguration.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactSurfaceVehicleState.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactTaskSummary.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactTaskTimingPair.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactVehicleSummary.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactWatchTask.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactWaterReport.cpp
 create mode 100644 src/LMCP/afrl/impact/afrlimpactWaterZone.cpp
 create mode 100644 src/LMCP/avtas/lmcp/ByteBuffer.cpp
 create mode 100644 src/LMCP/avtas/lmcp/ByteBuffer.h
 create mode 100644 src/LMCP/avtas/lmcp/Factory.cpp
 create mode 100644 src/LMCP/avtas/lmcp/Factory.h
 create mode 100644 src/LMCP/avtas/lmcp/LmcpXMLReader.h
 create mode 100644 src/LMCP/avtas/lmcp/Node.cpp
 create mode 100644 src/LMCP/avtas/lmcp/Node.h
 create mode 100644 src/LMCP/avtas/lmcp/NodeUtil.cpp
 create mode 100644 src/LMCP/avtas/lmcp/NodeUtil.h
 create mode 100644 src/LMCP/avtas/lmcp/Object.h
 create mode 100644 src/LMCP/avtas/lmcp/XMLParser.cpp
 create mode 100644 src/LMCP/avtas/lmcp/XMLParser.h
 create mode 100644 src/LMCP/meson.build
 create mode 100644 src/LMCP/test/client/Makefile
 create mode 100644 src/LMCP/test/client/TestClient.vcproj
 create mode 100644 src/LMCP/test/client/TestClient.vcxproj
 create mode 100644 src/LMCP/test/client/main.cpp
 create mode 100644 src/LMCP/test/server/Makefile
 create mode 100644 src/LMCP/test/server/TestServer.vcproj
 create mode 100644 src/LMCP/test/server/TestServer.vcxproj
 create mode 100644 src/LMCP/test/server/main.cpp
 create mode 100644 src/LMCP/uxas/messages/route/EgressRouteRequest.h
 create mode 100644 src/LMCP/uxas/messages/route/EgressRouteRequestDescendants.h
 create mode 100644 src/LMCP/uxas/messages/route/EgressRouteResponse.h
 create mode 100644 src/LMCP/uxas/messages/route/EgressRouteResponseDescendants.h
 create mode 100644 src/LMCP/uxas/messages/route/GraphEdge.h
 create mode 100644 src/LMCP/uxas/messages/route/GraphEdgeDescendants.h
 create mode 100644 src/LMCP/uxas/messages/route/GraphNode.h
 create mode 100644 src/LMCP/uxas/messages/route/GraphNodeDescendants.h
 create mode 100644 src/LMCP/uxas/messages/route/GraphRegion.h
 create mode 100644 src/LMCP/uxas/messages/route/GraphRegionDescendants.h
 create mode 100644 src/LMCP/uxas/messages/route/ROUTE.h
 create mode 100644 src/LMCP/uxas/messages/route/ROUTEEnum.h
 create mode 100644 src/LMCP/uxas/messages/route/ROUTEXMLReader.cpp
 create mode 100644 src/LMCP/uxas/messages/route/ROUTEXMLReader.h
 create mode 100644 src/LMCP/uxas/messages/route/RouteConstraints.h
 create mode 100644 src/LMCP/uxas/messages/route/RouteConstraintsDescendants.h
 create mode 100644 src/LMCP/uxas/messages/route/RoutePlan.h
 create mode 100644 src/LMCP/uxas/messages/route/RoutePlanDescendants.h
 create mode 100644 src/LMCP/uxas/messages/route/RoutePlanRequest.h
 create mode 100644 src/LMCP/uxas/messages/route/RoutePlanRequestDescendants.h
 create mode 100644 src/LMCP/uxas/messages/route/RoutePlanResponse.h
 create mode 100644 src/LMCP/uxas/messages/route/RoutePlanResponseDescendants.h
 create mode 100644 src/LMCP/uxas/messages/route/RouteRequest.h
 create mode 100644 src/LMCP/uxas/messages/route/RouteRequestDescendants.h
 create mode 100644 src/LMCP/uxas/messages/route/RouteResponse.h
 create mode 100644 src/LMCP/uxas/messages/route/RouteResponseDescendants.h
 create mode 100644 src/LMCP/uxas/messages/route/uxasmessagesrouteEgressRouteRequest.cpp
 create mode 100644 src/LMCP/uxas/messages/route/uxasmessagesrouteEgressRouteResponse.cpp
 create mode 100644 src/LMCP/uxas/messages/route/uxasmessagesrouteGraphEdge.cpp
 create mode 100644 src/LMCP/uxas/messages/route/uxasmessagesrouteGraphNode.cpp
 create mode 100644 src/LMCP/uxas/messages/route/uxasmessagesrouteGraphRegion.cpp
 create mode 100644 src/LMCP/uxas/messages/route/uxasmessagesrouteRouteConstraints.cpp
 create mode 100644 src/LMCP/uxas/messages/route/uxasmessagesrouteRoutePlan.cpp
 create mode 100644 src/LMCP/uxas/messages/route/uxasmessagesrouteRoutePlanRequest.cpp
 create mode 100644 src/LMCP/uxas/messages/route/uxasmessagesrouteRoutePlanResponse.cpp
 create mode 100644 src/LMCP/uxas/messages/route/uxasmessagesrouteRouteRequest.cpp
 create mode 100644 src/LMCP/uxas/messages/route/uxasmessagesrouteRouteResponse.cpp
 create mode 100644 src/LMCP/uxas/messages/task/AssignmentCoordination.h
 create mode 100644 src/LMCP/uxas/messages/task/AssignmentCoordinationDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/AssignmentCoordinatorTask.h
 create mode 100644 src/LMCP/uxas/messages/task/AssignmentCoordinatorTaskDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/AssignmentCostMatrix.h
 create mode 100644 src/LMCP/uxas/messages/task/AssignmentCostMatrixDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/CancelTask.h
 create mode 100644 src/LMCP/uxas/messages/task/CancelTaskDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/CoordinatedAutomationRequest.h
 create mode 100644 src/LMCP/uxas/messages/task/CoordinatedAutomationRequestDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/FootprintRequest.h
 create mode 100644 src/LMCP/uxas/messages/task/FootprintRequestDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/PlanningState.h
 create mode 100644 src/LMCP/uxas/messages/task/PlanningStateDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/SensorFootprint.h
 create mode 100644 src/LMCP/uxas/messages/task/SensorFootprintDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/SensorFootprintRequests.h
 create mode 100644 src/LMCP/uxas/messages/task/SensorFootprintRequestsDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/SensorFootprintResponse.h
 create mode 100644 src/LMCP/uxas/messages/task/SensorFootprintResponseDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskActive.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskActiveDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskAssignment.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskAssignmentDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskAssignmentSummary.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskAssignmentSummaryDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskAutomationRequest.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskAutomationRequestDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskAutomationResponse.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskAutomationResponseDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskComplete.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskCompleteDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskImplementationRequest.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskImplementationRequestDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskImplementationResponse.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskImplementationResponseDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskInitialized.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskInitializedDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskOption.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskOptionCost.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskOptionCostDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskOptionDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskPause.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskPauseDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskPlanOptions.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskPlanOptionsDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskProgress.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskProgressDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskProgressRequest.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskProgressRequestDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskResume.h
 create mode 100644 src/LMCP/uxas/messages/task/TaskResumeDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/UXTASK.h
 create mode 100644 src/LMCP/uxas/messages/task/UXTASKEnum.h
 create mode 100644 src/LMCP/uxas/messages/task/UXTASKXMLReader.cpp
 create mode 100644 src/LMCP/uxas/messages/task/UXTASKXMLReader.h
 create mode 100644 src/LMCP/uxas/messages/task/UniqueAutomationRequest.h
 create mode 100644 src/LMCP/uxas/messages/task/UniqueAutomationRequestDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/UniqueAutomationResponse.h
 create mode 100644 src/LMCP/uxas/messages/task/UniqueAutomationResponseDescendants.h
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskAssignmentCoordination.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskAssignmentCoordinatorTask.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskAssignmentCostMatrix.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskCancelTask.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskCoordinatedAutomationRequest.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskFootprintRequest.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskPlanningState.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskSensorFootprint.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskSensorFootprintRequests.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskSensorFootprintResponse.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskActive.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskAssignment.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskAssignmentSummary.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskAutomationRequest.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskAutomationResponse.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskComplete.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskImplementationRequest.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskImplementationResponse.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskInitialized.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskOption.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskOptionCost.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskPause.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskPlanOptions.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskProgress.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskProgressRequest.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskTaskResume.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskUniqueAutomationRequest.cpp
 create mode 100644 src/LMCP/uxas/messages/task/uxasmessagestaskUniqueAutomationResponse.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/AutopilotKeepAlive.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/AutopilotKeepAliveDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/BandwidthReceiveReport.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/BandwidthReceiveReportDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/BandwidthTest.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/BandwidthTestDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/CreateNewService.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/CreateNewServiceDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/EntityExit.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/EntityExitDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/EntityJoin.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/EntityJoinDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/EntityLocation.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/EntityLocationDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/IncrementWaypoint.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/IncrementWaypointDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/KillService.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/KillServiceDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/OnboardProcessorIsAlive.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/OnboardProcessorIsAliveDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/StartupComplete.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/StartupCompleteDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/SubTaskAssignment.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/SubTaskAssignmentDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/SubTaskExecution.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/SubTaskExecutionDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/UXNATIVE.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/UXNATIVEEnum.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/UXNATIVEXMLReader.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/UXNATIVEXMLReader.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/VideoRecord.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/VideoRecordDescendants.h
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeAutopilotKeepAlive.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeBandwidthReceiveReport.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeBandwidthTest.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeCreateNewService.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeEntityExit.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeEntityJoin.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeEntityLocation.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeIncrementWaypoint.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeKillService.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeOnboardProcessorIsAlive.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeStartupComplete.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeSubTaskAssignment.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeSubTaskExecution.cpp
 create mode 100644 src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeVideoRecord.cpp

diff --git a/src/LMCP/CMASI.xml b/src/LMCP/CMASI.xml
new file mode 100644
index 0000000..db4596b
--- /dev/null
+++ b/src/LMCP/CMASI.xml
@@ -0,0 +1,1582 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE MDM SYSTEM 'MDM.DTD'>
+
+<!--
+        <h2>Introduction</h2>
+        CMASI message definitions. The Common Mission Automation Services Interface (CMASI) defines data relevant to mission planning and
+        UAV autonomy. Direct any questions to Matt Duquette (matthew.duquette@wright.edu).
+        <br/>
+        <p>CMASI is designed for machine-to-machine communication of information related to UAV mission planning.  It is designed
+        to provide a minimum set of data for that purpose.  It is envisioned that end-users would expand on the base data set
+        by making custom messages that extend from existing data types.</p>
+
+        <p><i>Note on units:</i> Unless otherwise specified, the units of measure [meters, kilograms, milliSeconds, degrees] are used.  Since this is a system
+        for machine-to-machine communication, end applications are expected to do appropriate conversions to and from the MKSD unit types.</p>
+
+        <p><i>Note on Earth coordinates:</i>Unless otherwise specified, latitudes and longitudes are assumed to be based on the
+        WGS84 ellipsoid/datum and EGM96 gravitational model.  Altitude is the height above mean sea level for a given point.
+        (See <a href="http://en.wikipedia.org/wiki/World_Geodetic_System">WGS-84</a> and <a href="http://en.wikipedia.org/wiki/EGM96">EGM96</a>
+        for more info)</p>
+        <p>Note on directions:  Unless otherwise noted, all directional angles are relative to true North.</p>
+        <p>Note on IDs:  Many types have scenario-wide unique ids associated with them (VehicleID, TaskID, etc.)  These IDs should not be zero.</p>
+
+
+        <h2>Changes</h2>
+		
+        <h3>7 May 2015</h3>
+		<ul>
+			<li>Added nominal altitde in {@link EntityConfiguration}</li>
+		</ul>
+ 
+		<h3>23 April 2015</h3>
+		<ul>
+			<li>Changed default AltitudeType in {@link Location3D} from "AGL" to "MSL"</li>
+			<li>Changed time field in {@link FollowPathCommand} from real32 seconds to int64 milliseconds</li>
+			<li>Changed DwellTime field in {@link SearchTask} from real32 seconds to int64 milliseconds</li>
+			<li>Changed Duration field in {@link LoiterAction} from real32 seconds to int64 milliseconds</li>
+		</ul>
+		
+		<h3>16 April 2015</h3>
+		<ul>
+			<li>Moved "ActualEnergyRate", "CurrentCommand", "CurrentWaypoint", "Mode", and "AssociatedTasks" 
+				from {@link AirVehicleState} to {@link EntityState} </li>
+		</ul>
+ 
+		<h3>18 March 2015</h3>
+		<ul>
+            <li>All ID fields updated from uint32 to int64</li>
+            <li>PauseTime in {@link PathWaypoint} and Duration in {@link GimbalStareAction} changed to millisecond units</li>
+        </ul>
+		
+		<h3>11 March 2015</h3>
+		<ul>
+			<li>Moved EntityDetection, TrackEntityTask, and TrackEntityAction to PERCEIVE MDM</li>
+			<li>Added "Unknown" gimbal pointing type to {@link GimbalPointingMode}</li>
+			<li>Added reported boresight angles and vertical field of view to {@link GimballedPayloadState}</li>
+			<li>{@link CameraState} now derives from {@link GimballedPayloadState} for direct reporting of angles during state messages</li>
+			<li><Added associated payload actions to {@link CameraAction} to streamline gimbal pointing simultaneously with camera zoom</li>
+                        <li>Added {@link WaypointTransfer} message and {@link WaypointTransferMode} enumeration</li>
+                        <li>Added additional contingency point in {@link Waypoint}</li>
+                        <li>Added {@link PayloadStowAction} and added "stowed" to {@link GimbalPointingMode} </li>
+                </ul>
+		
+		<h3>5 March 2015</h3>
+		<ul>
+			<li>Moved body axis speeds, accelerations, and angles from {@link AirVehicleState} to {@link EntityState}.</li>
+			<li>Added {@link KeyValuePair} lists to {@link EntityConfiguration} and {@link EntityState} to support easy inclusion of custom data</li>
+			<li>Added {@link EntityDetection}</li>
+			<li>Added {@link TrackEntityTask}, {@link TrackEntityAction}</li>
+			<li>Added {@link FollowPathCommand} and {@link PathWaypoint}</li>
+		</ul>
+        
+        <h3>25 Feb 2015</h3>
+        <ul>
+            <li>Created {@link EntityConfiguration} and {@link EntityState} with {@link AirVehicleConfiguration} and {@link AirVehicleState} deriving from them
+            <li>Created {@link OperatingRegion} to collect all zones during {@link AutomationRequest}
+            <li>Moved vehicle eligibility constraints to {@link Task}
+            <li>Removed VehicleInfo structure for {@link AutomationRequest} constraints - all constraints via task or zone eligibility
+            <li>Removed Location2D. When only two dimensions are needed, the third is ignored as specified in message documentation
+            <li>Added altitude type. {@link Location3D} and {@link AbstractZone} now both utilize
+            <li>All time fields now use int64 type and are considered in units of milliseconds
+        </ul>
+ 
+        <h3>8 October 2010</h3>
+        <ul>
+            <li>Changed EndPoint in {@link VehicleInfo} to be {@link Location2D} based on group discussion
+            <li>Added Centerpoint field in {@link CameraState}
+            <li>Changed "ClimbRate" to "VerticalSpeed" in {@link FlightProfile}
+        </ul>
+
+        <h3>7 October 2010</h3>
+        <ul>
+            <li>Changed StartPoint in {@link VehicleInfo} to be {@link Location3D} so that altitude is always well defined
+            <li>Fixed documentation in {@link AirVehicleConfiguration} regarding MinAltAboveGround
+            <li>Fixed documentation in {@link AirVehicleState} regarding VerticalSpeed
+        </ul>
+
+        <h3>4 October 2010</h3>
+        <ul>
+            <li>Made {@link VideoStreamState} extend {@link PayloadState}
+            <li>Fixed documentation in {@link WeatherReport}
+        </ul>
+
+        <h3>21 September 2010</h3>
+        <ul>
+            <li>Set default WavelengthBand to "EO" in {@link CameraConfiguration}.
+            <li>Added aspect ratio comment in {@link CameraConfiguration}.
+            <li>Changed documentation in {@link VehicleInfo} to denote use of {@link Location2D} or
+            {@link Location3D} objects for "StartPoint" and "EndPoint".
+            <li>Added note regarding end-of-route behavior in {@link MissionCommand}.
+            <li>Changed {@link VideoStreamConfiguration} to extend {@link PayloadConfiguration} and removed.
+            "VideoStreamConfigurationList" from {@link AirVehicleConfiguration}.
+            <li>Added "Priority" and "Required" fields to {@link Task}.
+            <li>Created {@link WeatherReport}.
+            <li>Changed comment regarding WGS-84 and EGM-96.
+        </ul>
+        
+        <h3>31 August 2010</h3>
+        <ul>
+        <li>Fixed missing type in "UseInertialViewAngles" in {@link LineSearchTask}
+        </ul>
+
+        <h3>20 August 2010</h3>
+        <ul>
+        <li>Changed default altitude to Mean-sea-level from Height-above-ellipsoid</li>
+        <li>Added note in main documentation regarding "zero" in ids
+        <li>Changed documentation for "ContingencyPoint" in {@link Waypoint}
+        <li>Removed WavelengthBand from {@link CameraAction} and changed WavelengthBands to WavelengthBand (array to scalar) in {@link CameraConfiguration}
+        <li>Removed framerate information from {@link CameraConfiguration} and {@link SearchTask}
+        <li>Renamed "FlightMode" to {@link NavigationMode}
+        <li>Added "Hover" to {@link LoiterType} and updated {@link LoiterAction} to reflect the use of Axis in hover-mode.
+        <li>Added Min, Max, and Min AGL altitudes to {@link AirVehicleConfiguration}
+        <li>Updated documentation for Min/Max altitudes in {@link VehicleInfo}.
+        <li>Added start and end points in {@link VehicleInfo}.
+        <li>Improved (hopefully) the view angle documentation in {@link LineSearchTask}.
+        <li>Updated documentation in {@link Wedge}.
+        </ul>
+
+        <h3>10 August 2010</h3>
+        <ul>
+        <li>Changed "ContingencyWaypoint" type from {@link Waypoint} to uint32 in {@link Waypoint}.
+        <li>Renamed "LostCommPoint" to "ContingencyPoint" in {@link VehicleInfo} and updated the documentation.
+        <li>Added "RequiredFramerate" to {@link SearchTask}.
+        <li>Addded "AvailableFramerates" to {@link CameraConfiguration}.
+        <li>Changed "WaypointMode" enum to {@link FlightMode}.  WaypointMode was a misnomer, since the enum describes many flight states, "WaypointFollow" being
+        only one of the available states.
+        <li>Added "AvailableLoiterTypes" and "AvailableTurnTypes" to {@link AirVehicleConfiguration} to denote vehicle capabilities.
+        <li>Removed "AssignedAltitude" from {@link AirVehicleConfiguration} since altitude can be assigned using {@link VehicleInfo} object in {@link AutomationRequest}
+        The presence of "AssignedAltitude" caused ambiguity in planning situations.  (which takes precedence?)
+        <li>Added "CurrentCommand" to {@link AirVehicleState} to denote the VehicleActionCommand or MissionCommand currently being executed.
+        <li>Improved documentation in {@link Wedge}.
+        </ul>
+
+        <h3>28 July 2010</h3>
+        <ul>
+        <li>Removed "WedgeList" from {@link Task} and put "ViewAngleList" fields in {@link PointSearchTask} {@link LineSearchTask}, and {@link AreaSearchTask}
+        The definition of ViewAngle is based on the type of task.</li>
+        <li>Removed "Azimuth" and "Elevation" from {@link LineSearchTask}. Replaced with "ViewAngleList"</li>
+        <li>Added {@link KeyValuePair} to replace many existing string fields with a more structured set of data</li>
+        <li>Replaced string fields with {@link KeyValuePair} type to enable structured maps of data in {@link Task}, {@link OperatorSignal}, {@link AutomationResponse},
+        {@link ServiceStatus}, {@link SessionStatus}.</li>
+        <li>Added "CommandID" in {@link VehicleActionCommand} and {@link MissionCommand}</li>
+        <li>Added {@link CommandStatusType} enum
+        <li>Added "Status" fields in {@link VehicleActionCommand} and {@link MissionCommand}.
+        <li>Updated documentation to {@link VehicleInfo} to clarify the meaning of min/max altitudes.
+        </ul>
+
+        <h3>26 July 2010</h3>
+        <ul>
+        <li>Changed version tag to "2".
+        <li>Replaced references to "No Fly" to "Keep Out".
+        <li>Added "Length" parameter in {@link LoiterAction}.
+        <li>Fixed azimuth and elevation fields in {@link LineSearchTask} to reflect inertial coordinates.
+        <li>Updated comments in {@link AirVehicleState} regarding body angles.
+        <li>Added "Visual" to {@link ZoneAvoidanceType} enum.
+        <li>Added vertical component to {@link Wedge}.
+        <li>Added "ContingencyWaypoint" field in {@link Waypoint}.
+        <li>Added {@link AutomationResponse} type.
+        <li>Changed "PlanRequest" to {@link AutomationRequest}.
+        <li>Added "UseAltitude" field in {@link MustFlyTask}.
+        <li>Moved "Boundary" from {@link KeepInZone} and {@link KeepOutZone} into {@link AbstractZone}.
+        <li>Added {@link RemoveZones} and {@link RemoveAirVehicles} types.
+        <li>Added {@link FlightDirectorAction} type.
+        </ul>
+
+        ( Previous changes are reflected in CMASI version 1 MDM )
+        
+-->
+<MDM>
+    <SeriesName>CMASI</SeriesName>
+    <Namespace>afrl/cmasi</Namespace>
+    <Version>3</Version>
+
+    <EnumList>
+        <!-- Describes wavelength bands -->
+        <Enum Name="WavelengthBand">
+            <!-- used in cases when wavelength is not applicable -->
+            <Entry Name="AllAny" Value="0"/>
+            <!-- Electro-optical.  Visible spectrum -->
+            <Entry Name="EO" Value="1"/>
+            <!-- Long-wave Infrared -->
+            <Entry Name="LWIR" Value="2"/>
+            <!-- Short-wave infrared -->
+            <Entry Name="SWIR" Value="3"/>
+            <!-- mid-wave infrared -->
+            <Entry Name="MWIR" Value="4"/>
+            <!-- Other or undefined wavelength band -->
+            <Entry Name="Other" Value="5"/>
+        </Enum>
+        <!-- Describes waypoint modes -->
+        <Enum Name="NavigationMode">
+            <!-- standard waypoint following mode -->
+            <Entry Name="Waypoint" Value="0"/>
+            <!-- loiter mode, vehicle in constant orbit -->
+            <Entry Name="Loiter" Value="1"/>
+            <!-- flight director, vehicle following specific heading and spedd commands without regard to waypoints -->
+            <Entry Name="FlightDirector" Value="2"/>
+            <!-- track target, vehicle adjusts path to maintain current target track -->
+            <Entry Name="TargetTrack" Value="3"/>
+            <!-- follow leader, vehicle path is maintained to remain in formation with a leader -->
+            <Entry Name="FollowLeader" Value="4"/>
+            <!-- lost comm, vehicle is out of comm range and should be executing lost-comm behavior -->
+            <Entry Name="LostComm" Value="5"/>
+        </Enum>
+        <!-- Describes how the field-of-view for a camera can be changed, i.e. in a continuous or discrete manner -->
+        <Enum Name="FOVOperationMode">
+            <!-- field of view can be continuously changed -->
+            <Entry Name="Continuous" Value="0"/>
+            <!-- field of view can only be set to certian, discrete values -->
+            <Entry Name="Discrete" Value="1"/>
+        </Enum>
+        <!-- Describes available pointing modes for a gimbal -->
+        <Enum Name="GimbalPointingMode">
+            <!-- Unknown pointing mode or unavailable -->
+            <Entry Name="Unknown" Value="0"/>
+          <!-- angles are commanded relative to the vehicle -->
+            <Entry Name="AirVehicleRelativeAngle" Value="1"/>
+            <!-- angle rates are commanded relative to the vehicle -->
+            <Entry Name="AirVehicleRelativeSlewRate" Value="2"/>
+            <!-- gimbal aimed at an inertial location -->
+            <Entry Name="LatLonSlaved" Value="3"/>
+            <!-- gimbal rates are calculated relative to the inertial coordinate system -->
+            <Entry Name="InertialRelativeSlewRate" Value="4"/>
+            <!-- gimbal continuously scans in a pre-determined pattern -->
+            <Entry Name="Scan" Value="5"/>
+            <!-- indicates that the gimbal is stowed -->
+            <Entry Name="Stowed" Value="6"/>
+        </Enum>
+        <!-- Describes types of keep-out zones -->
+        <Enum Name="ZoneAvoidanceType">
+            <!-- zone corresponds to a physical boundary (e.g. terrain, buildings) -->
+            <Entry Name="Physical" Value="1"/>
+            <!-- zone corresponds to a regulatory boundary (e.g. flight control corridor) -->
+            <Entry Name="Regulatory" Value="2"/>
+            <!-- zone corresponds to an area that is sensitive to acoustic intrusion -->
+            <Entry Name="Acoustic" Value="3"/>
+            <!-- zone contains a threat-->
+            <Entry Name="Threat" Value="4"/>
+            <!-- zone defines an area that is sensitive to visual detection.  The threshold of visual detection
+                is not defined by this standard.-->
+            <Entry Name="Visual" Value="5"/>
+        </Enum>
+        <!-- Describes loiter types -->
+        <Enum Name="LoiterType">
+            <!-- vehicle default -->
+            <Entry Name="VehicleDefault" Value="0"/>
+            <!-- circular -->
+            <Entry Name="Circular" Value="1"/>
+            <!-- racetrack -->
+            <Entry Name="Racetrack" Value="2"/>
+            <!-- figure eight-->
+            <Entry Name="FigureEight" Value="3"/>
+            <!-- Hovering.-->
+            <Entry Name="Hover" Value="4"/>
+        </Enum>
+        <!-- Describes loiter direction -->
+        <Enum Name="LoiterDirection">
+            <!-- vehicle default -->
+            <Entry Name="VehicleDefault" Value="0"/>
+            <!-- counter-clockwise -->
+            <Entry Name="CounterClockwise" Value="1"/>
+            <!-- clockwise -->
+            <Entry Name="Clockwise" Value="2"/>
+        </Enum>
+        <!-- Describes automation service status types -->
+        <Enum Name="ServiceStatusType">
+            <!-- informational note from automation service -->
+            <Entry Name="Information" Value="0"/>
+            <!-- warning from automation service -->
+            <Entry Name="Warning" Value="1"/>
+            <!-- error from automation service -->
+            <Entry Name="Error" Value="2"/>
+        </Enum>
+        <!-- Describes simulation status types -->
+        <Enum Name="SimulationStatusType">
+            <!-- simulation is stopped -->
+            <Entry Name="Stopped" Value="0"/>
+            <!-- simulation is running -->
+            <Entry Name="Running" Value="1"/>
+            <!-- simulation paused -->
+            <Entry Name="Paused" Value="2"/>
+            <!-- simulation is reset -->
+            <Entry Name="Reset" Value="3"/>
+        </Enum>
+        <!-- Describes vehicle speed type -->
+        <Enum Name="SpeedType">
+            <!-- airspeed -->
+            <Entry Name="Airspeed" Value="0"/>
+            <!-- groundspeed -->
+            <Entry Name="Groundspeed" Value="1"/>
+        </Enum>
+        <!-- Describes vehicle turn type -->
+        <Enum Name="TurnType">
+            <!-- turn short, return to track -->
+            <Entry Name="TurnShort" Value="0"/>
+            <!-- fly over, return to track -->
+            <Entry Name="FlyOver" Value="1"/>
+        </Enum>
+        <Enum Name="CommandStatusType">
+            <!-- Pending authorization prior to execution -->
+            <Entry Name="Pending"/>
+            <!-- Approved for execution by the aircraft -->
+            <Entry Name="Approved"/>
+            <!-- Currently executing by an aircraft -->
+            <Entry Name="InProcess"/>
+            <!-- Completed execution by an aircraft -->
+            <Entry Name="Executed"/>
+            <!-- Cancelled by an operator, aircraft, or other entity -->
+            <Entry Name="Cancelled"/>
+        </Enum>
+        <Enum Name="AltitudeType">
+            <!-- Height above ground/survace level -->
+            <Entry Name="AGL"/>
+            <!-- Height above WGS84 ellipsoid, mean sea level -->
+            <Entry Name="MSL"/>
+        </Enum>
+		
+	<!-- Designates how an entity should treat a path following command.  -->
+        <Enum Name="TravelMode">
+            <!-- A path is traversed from beginning to end, then the entity stops -->
+            <Entry Name="SinglePass"/>
+            <!-- Upon reaching the end of a route, the entity travels the waypoint list in reverse-direction. -->
+            <Entry Name="ReverseCourse"/>
+            <!-- Upon reaching the end of a route, the entity travels to the first point and repeats the route. -->
+            <Entry Name="Loop"/>
+        </Enum>
+        
+        <!-- Used in {@link WaypointTransfer} to indicate the type of waypoint exchange -->
+        <Enum Name="WaypointTransferMode">
+            <!-- Requests download of waypoints from the aircraft -->
+            <Entry Name="RequestWaypoints"/>
+            <!-- Adds waypoints to the aircraft.  Waypoints with the same number are overwritten -->
+            <Entry Name="AddWaypoints"/>
+            <!-- Commands the aircraft to clear its waypoints -->
+            <Entry Name="ClearWaypoints"/>
+            <!-- Reports waypoints that are curretly in the aircraft computer -->
+            <Entry Name="ReportWaypoints"/>
+        </Enum>
+
+    </EnumList>
+
+    <StructList>
+
+        <!-- Base class for geometry types -->
+        <Struct Name="AbstractGeometry">
+        </Struct>
+        
+        <!-- A container for key/value pairs.  Keys and values can be any valid string. -->
+        <Struct Name="KeyValuePair">
+            <!-- A key (name) for the property -->
+            <Field Name="Key" Type="string"/>
+            <!-- A value for the property -->
+            <Field Name="Value" Type="string"/>
+        </Struct>
+        
+        <!--
+         Location is defined as a point in the world using the WGS84 specification for latitude
+         and longitude.
+         -->
+        <Struct Name="Location3D">
+            <!-- Latitude -->
+            <Field Name="Latitude" Type="real64" Units="degree" />
+            
+            <!-- Longitude -->
+            <Field Name="Longitude" Type="real64" Units="degree" />
+            
+            <!-- Altitude for this waypoint -->
+            <Field Name="Altitude" Type="real32" Units="meter"/>
+            
+            <!-- Altitude type for specified altitude -->
+            <Field Name="AltitudeType" Type="AltitudeType" Default="MSL" />
+        </Struct>
+        
+        <!-- An action for controlling a payload item (abstract). -->
+        <Struct Name="PayloadAction" Extends="VehicleAction">
+            <!-- A unique id for this payload item. -->
+            <Field Name="PayloadID" Type="int64" Units="None" />
+        </Struct>
+        
+        <!-- Base type for payloads -->
+        <Struct Name="PayloadConfiguration">
+            <!-- The unique id for this payload item. -->
+            <Field Name="PayloadID" Type="int64" Units="None" />
+            
+            <!-- A string uniquely identifying the kind of payload item (primarily to be used
+             for debugging purposes). -->
+            <Field Name="PayloadKind" Type="string" Units="None" />
+            
+            <!-- Optional parameters associated with payload configuration -->
+            <Field Name="Parameters" Type="KeyValuePair[]" />
+        </Struct>
+        
+        <!-- Describes the current state of a payload item (abstract). -->
+        <Struct Name="PayloadState">
+            <!-- The unique id for this payload item. -->
+            <Field Name="PayloadID" Type="int64" Units="None" />
+            
+            <!-- Optional parameters associated with payload state -->
+            <Field Name="Parameters" Type="KeyValuePair[]" />
+        </Struct>
+        
+        <!--
+         Base class for an action to be taken by a vehicle.  This is usually used as an object inside of
+         {@link Waypoint} to describe the action that a vehicle is to take upon reaching a waypoint.  This is
+         used by child types to perform something meaningful.<br/>
+         -->
+        <Struct Name="VehicleAction">
+            <!--
+             A list of tasks that are associated with this action.  A length of zero denotes no associated tasks.
+             This field is for analysis purposes.  The automation service should associate a list of tasks with each action to enable
+             analysis of the allocation of tasks to vehicles.<br/>
+             -->
+            <Field Name="AssociatedTaskList" Type="int64[]"/>
+        </Struct>
+        
+        <!--
+         The base class for all task requests passed to the automation service.  Task requests are not assigned to a specific vehicle, but
+         allow the automation service to determine the best vehicle to complete the task.
+         -->
+        <Struct Name="Task">
+            <!-- A unique identifier for this task. -->
+            <Field Name="TaskID" Type="int64" Units="None" />
+            
+            <!-- An optional text string for the task. This is not necesarily unique,
+             and is included for information only. TaskID should be used to uniquely
+             identify tasks. -->
+            <Field Name="Label" Type="string" />
+            
+            <!-- A list of entity IDs that are eligible to accomplish this task.  If the list is empty, then it is
+             assumed all entities are eligible. -->
+            <Field Name="EligibleEntities" Type="int64[]" Units="None" />
+            
+            <!--
+             If a task is to be repeatedly done, this field indicates how often.
+             A value of zero means the task is complete on the first pass.
+             -->
+            <Field Name="RevisitRate" Type="real32" Units="sec" Default="0"/>
+            
+            <!-- An optional text string for automation service task parameters. -->
+            <Field Name="Parameters" Type="KeyValuePair[]" />
+            
+            <!-- The priority value for this task.  Priority is a relative value of this task compared to other tasks in the scenario.  This
+             field should be limited to the range[0..100], 100 being the highest level of priority.  The exact interpretation
+             priority may vary depending on algorithm implementation. -->
+            <Field Name="Priority" Type="byte" Default="0"/>
+            
+            <!-- Indicates whether this task <i><b>must</b></i> be executed as part of a mission plan.  -->
+            <Field Name="Required" Type="bool" Default="true"/>
+            
+        </Struct>
+        
+        <!-- Used to request a search task allocation from the automation service. -->
+        <Struct Name="SearchTask" Extends="Task">
+            
+            <!-- The wavelength bands that should be used to complete the task.   -->
+            <Field Name="DesiredWavelengthBands" Type="WavelengthBand[]" Default="AllAny" />
+            
+            <!-- Minimum time that a sensor must look at any given point in this search task. -->
+            <Field Name="DwellTime" Type="int64" Units="milliseconds" />
+            
+            <!-- Average ground sample distance for locations in search area -->
+            <Field Name="GroundSampleDistance" Type="real32" Units="meters/pixel" />
+            
+        </Struct>
+
+        <!-- Base Type for all zones (keep-in and keep-out zones) -->
+        <Struct Name="AbstractZone">
+            <!-- A globally unique reference number for this zone -->
+            <Field Name="ZoneID" Type="int64" Units="None" />
+
+            <!-- Lower altitude bound for the zone -->
+            <Field Name="MinAltitude" Type="real32" Units="meter" />
+            
+            <!-- Altitude type for min altitude -->
+            <Field Name="MinAltitudeType" Type="AltitudeType" Default="AGL" />
+
+            <!-- Maximum altitude for operations -->
+            <Field Name="MaxAltitude" Type="real32" Units="meter" />
+            
+            <!-- Altitude type for max altitude -->
+            <Field Name="MaxAltitudeType" Type="AltitudeType" Default="MSL" />
+
+            <!-- A list of aircraft IDs that this zone applies to.  If the list is empty, then it is
+                 assumed that the boundary applies to all aircraft. -->
+            <Field Name="AffectedAircraft" Type="int64[]" Units="None" />
+
+            <!-- Time at which this zone becomes active. Time datum is defined by the application, but unless otherwise specified is milliseconds since 1 Jan 1970 -->
+            <Field Name="StartTime" Type="int64" Units="milliseconds"/>
+
+            <!-- Time at which this zone becomes inactive. Time datum is defined by the application, but unless otherwise specified is milliseconds since 1 Jan 1970 -->
+            <Field Name="EndTime" Type="int64" Units="milliseconds"/>
+
+            <!-- Buffer to add/subtract around the border of the zone -->
+            <Field Name="Padding" Type="real32" Units="meters" Default="0" />
+
+            <!-- Optional label for this zone -->
+            <Field Name="Label" Type="string"/>
+
+            <!--
+                Geometry object describing the boundary.  This boundary is 2-dimensional.  The zone boundary is defined as
+                an extrusion of this boundary from MinAltitude to MaxAltitude.
+            -->
+            <Field Name="Boundary" Type="AbstractGeometry" Units="None" />
+        </Struct>
+
+        <!--
+            Provides information regarding a base entitie's configuration items.
+        -->
+        <Struct Name="EntityConfiguration">
+            <!-- A unique id for this entity -->
+            <Field Name="ID" Type="int64" Units="None" />
+            
+            <!-- the team or "side" that an entity belongs to.  This can be a name of a country, a "friend" or
+             "foe" designation, or a team name (e.g. "red team"). -->
+            <Field Name="Affiliation" Type="string" Default="Unknown"/>
+            
+            <!-- The type of this entity.  The content of this field is dependent on the session. The value
+             of this field is not specifically defined, so it is up to the simulation/session components
+             to define a type system. For a common entity definition, see MIL STD 2525 or use DIS enumerations.
+             -->
+            <Field Name="EntityType" Type="string"/>
+
+            <!--
+                An optional text string for the vehicle.  This is not necessarily unique, and is included
+                for information only.  ID should be used to uniquely identify entities.
+            -->
+            <Field Name="Label" Type="string"/>
+            
+            <!-- The speed that is typically commanded for this entity -->
+            <Field Name="NominalSpeed" Type="real32" Units="meter/sec" />
+            
+            <!-- The altitude that is typically commanded for this entity -->
+            <Field Name="NominalAltitude" Type="real32" Units="meter" Default="0.0" />
+            
+            <!-- Altitude type for nominal altitude -->
+            <Field Name="NominalAltitudeType" Type="AltitudeType" Default="AGL" />
+
+            <!-- A list of all payload configurations for this vehicle. Examples of payloads include: gimbaled sensors,
+                 SAR radars (not yet supported), air-launched UAVs (not yet supported), and weapons (not yet supported). -->
+            <Field Name="PayloadConfigurationList" Type="PayloadConfiguration[]" Units="None" />
+			
+			<!-- A list that maps keys to values for the inclusion of extra, custom information about this entity -->
+            <Field Name="Info" Type="KeyValuePair[]" />
+
+        </Struct>
+        
+        <!--
+         A set of parameter describing the operations of a vehicle.  This can be used to set routing preferences
+         for a particular vehicle.  The "Name" field can be used to describe a given condition, such as "cruise" or "climb".
+         -->
+        <Struct Name="FlightProfile">
+            <!-- The unique name for this configuration -->
+            <Field Name="Name" Type="string" Units="None" />
+            
+            <!-- True Airspeed -->
+            <Field Name="Airspeed" Type="real32" Units="meter/sec" />
+            
+            <!-- The pitch angle of the aircraft in this flight condition(assuming zero bank) -->
+            <Field Name="PitchAngle" Type="real32" Units="degree" />
+            
+            <!-- Vertical speed (positive upwards) of the vehicle -->
+            <Field Name="VerticalSpeed" Type="real32" Units="meter/sec" />
+            
+            <!-- The maximum angle that this vehicle will bank -->
+            <Field Name="MaxBankAngle" Type="real32" Units="degree" />
+            
+            <!--
+             The consumption rate of available energy, expressed in terms of the percentage of maximum capacity
+             used per second.
+             -->
+            <Field Name="EnergyRate" Type="real32" Units="%/sec" />
+            
+        </Struct>
+
+        <!--
+            Provides information regarding a vehicle's configuration items.
+        -->
+        <Struct Name="AirVehicleConfiguration" Extends="EntityConfiguration">
+
+            <!-- The minimum true airspeed that should be commanded for this aircraft -->
+            <Field Name="MinimumSpeed" Type="real32" Units="meter/sec" />
+
+            <!-- The maximum true airspeed that should be commanded for this aircraft -->
+            <Field Name="MaximumSpeed" Type="real32" Units="meter/sec" />
+
+            <!-- Describes the preferred operating mode for most planning purposes.  This can be a max range
+            or endurance speed profile, or any other operating point chosen by a user.  This field may not
+            be null.
+            -->
+            <Field Name="NominalFlightProfile" Type="FlightProfile"/>
+
+            <!-- A list of all flight configurations described for this vehicle.
+                Each flight configuration specifies a different mode of flight, for instance: climb, cruise,
+                dash, loiter.  This list may be empty, and does not necessarily contain the nominal flight
+                configuration.
+            -->
+            <Field Name="AlternateFlightProfiles" Type="FlightProfile[]" Units="None" />
+
+            <!-- A list of available loiter types for this aircraft -->
+            <Field Name="AvailableLoiterTypes" Type="LoiterType[]"/>
+
+            <!-- A list of available turning modes for this aircraft -->
+            <Field Name="AvailableTurnTypes" Type="TurnType[]"/>
+
+            <!-- Minimum MSL altitude that this aircraft is allowed to fly.  This value should be treated as
+            a regulatory or safety-of-flight parameter and therefore takes precedence over other requests. -->
+            <Field Name="MinimumAltitude" Type="real32" Default="0" Units="meter"/>
+            
+            <!-- Altitude type for min altitude -->
+            <Field Name="MinAltitudeType" Type="AltitudeType" Default="AGL" />
+
+            <!-- Maximum MSL altitude that this aircraft is allowed to fly.  This value should be treated as
+            a regulatory or safety-of-flight parameter and therefore takes precedence over other requests.
+            -->
+            <Field Name="MaximumAltitude" Type="real32" Default="1000000" Units="meter"/>
+            
+            <!-- Altitude type for max altitude -->
+            <Field Name="MaxAltitudeType" Type="AltitudeType" Default="MSL" />
+
+        </Struct>
+
+        <!-- Reported state for an entity in the system  -->
+        <Struct Name="EntityState">
+            <!-- A unique ID for this entity. IDs should be greater than zero -->
+            <Field Name="ID" Type="int64" />
+			
+			<!-- Velocity in the body x-direction (postive out nose) -->
+            <Field Name="u" Type="real32" Units="meter/sec" />
+
+            <!-- Velocity in the body y-direction (positive out right wing) -->
+            <Field Name="v" Type="real32" Units="meter/sec" />
+
+            <!-- Velocity in the body z-direction (positve downward) -->
+            <Field Name="w" Type="real32" Units="meter/sec" />
+
+            <!-- Acceleration in the body x-direction (postive out nose) -->
+            <Field Name="udot" Type="real32" Units="meter/sec/sec" />
+
+            <!-- Acceleration in the body y-direction (positive out right wing) -->
+            <Field Name="vdot" Type="real32" Units="meter/sec/sec" />
+
+            <!-- Acceleration in the body z-direction (positve downward) -->
+            <Field Name="wdot" Type="real32" Units="meter/sec/sec" />
+
+            <!-- Angle between true North and the projection of the body x-axis in the North-East plane. -->
+            <Field Name="Heading" Type="real32" Units="degree" />
+
+            <!-- Pitch of vehicle around body y-axis (positive upwards) -->
+            <Field Name="Pitch" Type="real32" Units="degree" />
+
+            <!-- Roll angle of the vehicle around body x-axis (positive right wing down) -->
+            <Field Name="Roll" Type="real32" Units="degree" />
+
+            <!-- roll-rate of vehicle (angular velocity around body x-axis).  Positive right-wing down. -->
+            <Field Name="p" Type="real32" Units="degree/sec" />
+
+            <!-- pitch rate of the vehicle (angular velocity around body y-axis).  Positive nose-up.-->
+            <Field Name="q" Type="real32" Units="degree/sec" />
+
+            <!-- yaw rate of the vehicle (angular velocity around body z-axis).  Positive nose right. -->
+            <Field Name="r" Type="real32" Units="degree/sec" />
+
+            <!-- Course/Groundtrack angle of the entity referenced to true North -->
+            <Field Name="Course" Type="real32" Units="degrees" />
+            
+            <!-- Current entity ground speed -->
+            <Field Name="Groundspeed" Type="real32" Units="m/s" />
+
+            <!-- The perceived entity location -->
+            <Field Name="Location" Type="Location3D" />
+            
+            <!-- The available energy remaining, expressed in terms of the percentage of maximum capacity -->
+            <Field Name="EnergyAvailable" Type="real32" Units="%" />
+			
+			<!-- The consumption rate of available energy, expressed in terms of the percentage of maximum capacity
+                used per second. -->
+            <Field Name="ActualEnergyRate" Type="real32" Units="%/sec" />
+
+            <!-- A list of states for any onboard payloads -->
+            <Field Name="PayloadStateList" Type="PayloadState[]" />
+			
+			<!--
+                The ID of the current waypoint. Only valid if the vehicle is in waypoint following mode.
+            -->
+            <Field Name="CurrentWaypoint" Type="int64" Units="None" />
+
+            <!-- Current command (VehicleActionCommand or MissionCommand) being executed. A value of zero denotes no command being executed,
+            or that a command without an set identifier (CommandID) is being executed.
+            -->
+            <Field Name="CurrentCommand" Type="int64"/>
+
+            <!--
+                The current mode for this vehicle. 
+            -->
+            <Field Name="Mode" Type="NavigationMode" Units="None" />
+
+            <!--
+                Tasks that this entity is currently executing.  An empty list indicates no associated tasks.  The task number should
+                coincide with the task number in the task request.  For instance, if a waypoint is associated with a search task, then the
+                task number associated with that search should be included in this list.
+            -->
+            <Field Name="AssociatedTasks" Type="int64[]" Units="None"/>
+            
+            <!-- time stamp of this data. Time datum is defined by the application, but unless otherwise specified is milliseconds since 1 Jan 1970 -->
+            <Field Name="Time" Type="int64" Units="millisecond" />
+			
+			<!-- A list that maps keys to values for the inclusion of extra, custom information about this entity -->
+            <Field Name="Info" Type="KeyValuePair[]" />
+
+        </Struct>
+        
+        <!--
+            Provides basic information regarding the vehicle state with regard to its location and orientation in the
+            world, and current velocity in body axis.  <br/>
+
+            Provides basic state information regarding entity position, orientation, velocity, and acceleration.
+            The entity body right-hand coordinate system is used, where X is out the nose, Y is out the right side, and Z
+            is downward.  The order of rotation from inertial to body coordinates is yaw-pitch-roll. <br/>
+            The direction cosine matrix (DCM) for conversion from body to inertial coordinates is:<br/><br/>
+            [cTheta*cPsi, cTheta*sPsi, -sTheta]<br/>
+            [sPhi*sTheta*cPsi-cPhi*sPsi, sPhi*sTheta*sPsi+cPhi*cPsi, sPhi*cTheta]<br/>
+            [cPhi*sTheta*cPsi+sPhi*sPsi, cPhi*sTheta*sPsi-sPhi*cPsi, cPhi*cTheta]<br/><br/>
+            where, c denotes cosine and s denotes sine.
+            <br/><br/>
+            To convert from body to inertial velocities, use,<br/>
+            [North Vel, East Vel, Down Vel]' = DCM' * [Vx, Vy, Vz]'  where [Vx, Vy, Vz] is the body vel or accel.
+        -->
+        <Struct Name="AirVehicleState" Extends="EntityState">
+            
+            <!-- vehicle true airspeed -->
+            <Field Name="Airspeed" Type="real32" Units="meter/sec" />
+
+            <!-- Vertical speed (positive upwards) of the vehicle in the inertial frame (rate of change of altitude) -->
+            <Field Name="VerticalSpeed" Type="real32" Units="meter/sec" />
+
+            <!-- Wind speed as detected or computed by the vehicle -->
+            <Field Name="WindSpeed" Type="real32" Units="meter/sec"/>
+
+            <!-- Wind source direction (true) as detected or computed by the vehicle-->
+            <Field Name="WindDirection" Type="real32" Units="degree"/>
+
+            
+
+        </Struct>
+
+        <!--
+            Defines an angular range for use in setting constraints or desired approaches to tasks.  In most cases, wedges are
+            defined in the inertial sense, where azimuth is the angle between North and the center of the wedge, elevation is the
+            angle between the horizon and the center of the wedge.  In some instances, other coordinate systems are defined, such as
+            angles relative to a line.
+        -->
+        <Struct Name="Wedge">
+            <!-- Azimuthal centerline of the wedge. -->
+            <Field Name="AzimuthCenterline" Type="real32" Units="degree"/>
+            <!-- Vertical centerline of the wedge.  -->
+            <Field Name="VerticalCenterline" Type="real32" Units="degree"/>
+            <!-- Azimuthal angular extent of the wedge.  The extent is centered around the centerline.
+            A value of zero denotes that this wedge is defined as a single angle. -->
+            <Field Name="AzimuthExtent" Type="real32" Units="degree"/>
+            <!-- Vertical angular extent of the wedge.  The extent is centered around the centerline.
+            A value of zero denotes that this wedge is defined as a single angle. -->
+            <Field Name="VerticalExtent" Type="real32" Units="degree"/>
+        </Struct>
+        
+        <!-- Area search task -->
+        <Struct Name="AreaSearchTask" Extends="SearchTask">
+
+            <!-- Area to search -->
+            <Field Name="SearchArea" Type="AbstractGeometry" />
+
+            <!-- A list of acceptable look-angles for this task.  Each wedge is defined relative to true North. To be a valid
+                 look angle, a sensor must be looking from a direction within the bounds of the wedge.
+            -->
+            <Field Name="ViewAngleList" Type="Wedge[]"/>
+
+        </Struct>
+
+        <!--
+            An action for controlling a camera that is mounted on a gimbal.
+        -->
+        <Struct Name="CameraAction" Extends="PayloadAction">
+            <!-- The commanded horizontal (azimuth) field of view. -->
+            <Field Name="HorizontalFieldOfView" Type="real32" Units="degree" />
+            <!-- Associated payload actions that should be performed simultaneously with the change in field of view. A frequent use case would be a gimbal pointing action. If payload ID is zero, then the gimbal on which the camera is mounted is selected. Note that this has the side-effect of steering all other payloads associated to that gimbal. -->
+            <Field Name="AssociatedActions" Type="PayloadAction[]" />
+
+        </Struct>
+
+        <!--
+            Description of capabilities of a camera (EO, LWIR, SWIR, MWIR, etc.). If a camera has multiple bands,
+            then a CameraConfiguration for each camera mode should be included in the PayloadConfigurationList.<br/>
+            <i>Note on Aspect ratio:</i> Aspect ratio is computed by taking the ratio of VideoStreamHorizontalResolution and
+            VideoStreamVerticalResolution.  It is assumed that the camera has a constant aspect ratio through all
+            fields-of-view and that the field-of-view aspect ratio is the same as the video stream aspect ratio.
+        -->
+        <Struct Name="CameraConfiguration" Extends="PayloadConfiguration">
+            
+            <!-- The supported wavelength band of this camera -->
+            <Field Name="SupportedWavelengthBand" Type="WavelengthBand" Default="EO"/>
+
+            <!-- The manner in which field of views are commanded:
+                 Continuous (any FOV between MinHorizontalFieldOfView and MaxHorizontalFieldOfView can be commanded), or
+                 Discrete (the only supported FOVs are listed in DiscreteHorizontalFieldOfViewList). -->
+            <Field Name="FieldOfViewMode" Type="FOVOperationMode" Units="None" />
+
+            <!-- The minimum horizontal field of view of the sensor. Only used if FieldOfViewMode is Continuous. -->
+            <Field Name="MinHorizontalFieldOfView" Type="real32" Units="degree" />
+
+            <!-- The maximum horizontal field of view of the sensor. Only used if FieldOfViewMode is Continuous. -->
+            <Field Name="MaxHorizontalFieldOfView" Type="real32" Units="degree" />
+
+            <!-- The horizontal field of views supported by the sensor. Only used if FieldOfViewMode is Discrete. -->
+            <Field Name="DiscreteHorizontalFieldOfViewList" Type="real32[]" Units="degree" />
+
+            <!-- The number of horizontal pixels in the output live-motion video stream. -->
+            <Field Name="VideoStreamHorizontalResolution" Type="uint32" Units="pixel" />
+
+            <!-- The number of vertical pixels in the output live-motion video stream. -->
+            <Field Name="VideoStreamVerticalResolution" Type="uint32" Units="pixel" />
+        </Struct>
+
+        <!-- Describes the current state of a camera. -->
+        <Struct Name="GimballedPayloadState" Extends="PayloadState">
+            <!-- Current pointing mode of the gimbal to which this payload is attached-->
+            <Field Name="PointingMode" Type="GimbalPointingMode" Default="Unknown" />
+
+            <!-- Current azimuth angle of the gimbal boresight (positive from vehicle x-axis). -->
+            <Field Name="Azimuth" Type="real32" Units="degree" />
+
+            <!-- Current elevation angle of the gimbal boresight (positive from vehicle x-y plane). -->
+            <Field Name="Elevation" Type="real32" Units="degree" />
+
+            <!-- Current rotation angle of the gimbal boresight (0 degrees aligned with aircraft normal, positive clockwise). -->
+            <Field Name="Rotation" Type="real32" Units="degree" />
+            
+        </Struct>
+
+        <!-- Describes the current state of a camera. -->
+        <Struct Name="CameraState" Extends="GimballedPayloadState">
+            
+            <!-- The current horizontal field of view (in sensor axis). -->
+            <Field Name="HorizontalFieldOfView" Type="real32" Units="degree" />
+
+            <!-- The current vertical field of view (in sensor axis). -->
+            <Field Name="VerticalFieldOfView" Type="real32" Units="degree" />
+            
+            <!-- The current sensor footprint of the camera represented as a polygon with n-vertices.
+                 If this field contains zero items then the footprint is unavailable or was not calculated. -->
+            <Field Name="Footprint" Type="Location3D[]" Units="None" />
+
+            <!-- the current location according to the intersection of a ray along the center axis of the current
+                camera field of view with the ground.  If this field is null, then the location was not computed.
+            -->
+            <Field Name="Centerpoint" Type="Location3D" Default="null"/>
+        </Struct>
+
+        <!-- Defines a circular shape based on a center point and radius -->
+        <Struct Name="Circle" Extends="AbstractGeometry">
+            <!-- Center point of the circle -->
+            <Field Name="CenterPoint" Type="Location3D"/>
+            <!-- Radius of the circle -->
+            <Field Name="Radius" Type="real32" Units="meter"/>
+        </Struct>
+
+        <!--
+            An action for controlling the movement of a gimbal. Individual sensors on the gimbal are controlled
+            via the {@link CameraAction} message.<br/>
+            Azimuth is defined as the angle between the long axis of the aircraft and the sensor boresight, positive clockwise.<br/>
+            Elevation is defined as the angle between the aircraft long-lat plane and the sensor boresight, positive upwards.<br/>
+            Rotation is defined as rotation from the aircraft normal (Up), positive clockwise.<br/>
+        -->
+        <Struct Name="GimbalAngleAction" Extends="PayloadAction">
+
+            <!-- The commanded azimuth angle (0 degrees out of nose, positive clockwise).  -->
+            <Field Name="Azimuth" Type="real32" Units="degree" />
+
+            <!-- The commanded elevation angle (0 degrees horizontal, positive upwards).  -->
+            <Field Name="Elevation" Type="real32" Units="degree" />
+
+            <!-- The commanded rotation angle (0 degrees aligned with aircraft normal, positive clockwise).  -->
+            <Field Name="Rotation" Type="real32" Units="degree" />
+        </Struct>
+
+        <!--
+            Description of a gimbal's capabilities. A gimbal is defined as the mount of a sensor or set of sensors
+            that may or may not have freedom of motion (for instance, the fixed mounting of a camera would still be
+            considered a gimbal payload that must be defined).<br/>
+            Azimuth is defined as the angle between the long axis of the aircraft and the sensor boresight, positive clockwise.<br/>
+            Elevation is defined as the angle between the aircraft long-lat plane and the sensor boresight, positive upwards.<br/>
+            Rotation is defined as rotation from the aircraft normal (Up), positive clockwise.<br/>
+        -->
+        <Struct Name="GimbalConfiguration" Extends="PayloadConfiguration">
+
+            <!--
+                The pointing modes supported by the gimbal
+            -->
+            <Field Name="SupportedPointingModes" Type="GimbalPointingMode[]" Units="None" />
+
+            <!--
+                Minimum azimuth that this sensor can slew in body axis (0 degrees out of nose, positive clockwise).
+                If this is a fixed-azimuth sensor, then this should be set to the fixed azimuth value.
+            -->
+            <Field Name="MinAzimuth" Type="real32" Units="degree" Default="-180" />
+
+            <!--
+                Maximum azimuth that this sensor can slew in body axis (0 degrees out of nose, positive clockwise).
+                If this is a fixed-azimuth sensor, then this should be set to the fixed azimuth value.
+            -->
+            <Field Name="MaxAzimuth" Type="real32" Units="degree" Default="180" />
+
+            <!--
+                Determines whether there are any limits on the azimuth of the gimbal. If this is set to
+                false, then MinAzimuth and MaxAzimuth are not used, and the gimbal is capable of
+                continuously spinning in a 360 degree circle without hitting any stops.
+            -->
+            <Field Name="IsAzimuthClamped" Type="bool" Units="None" Default="false" />
+
+            <!--
+                Minimum elevation that this sensor can slew in body axis (0 degrees horizontal, positive upwards).
+                If this is a fixed-elevation sensor, then this should be set to the fixed elevation value.
+            -->
+            <Field Name="MinElevation" Type="real32" Units="degree" Default="-180" />
+
+            <!--
+                Maximum elevation that this sensor can slew in body axis (0 degrees horizontal, positive upwards).
+                If this is a fixed-elevation sensor, then this should be set to the fixed elevation value.
+            -->
+            <Field Name="MaxElevation" Type="real32" Units="degree" Default="180" />
+
+            <!--
+                Determines whether there are any limits on the elevation of the gimbal. If this is set to
+                false, then MinElevation and MaxElevation are not used, and the gimbal is capable of
+                continuously spinning in a 360 degree circle without hitting any stops.
+            -->
+            <Field Name="IsElevationClamped" Type="bool" Units="None" Default="false" />
+
+            <!--
+                Minimum rotation that this sensor can slew in body axis (0 degrees aligned with aircraft normal, positive clockwise).
+                If this is a fixed-rotation sensor, then this should be set to the fixed rotation value.
+            -->
+            <Field Name="MinRotation" Type="real32" Units="degree" Default="0" />
+
+            <!--
+                Maximum rotation that this sensor can slew in body axis (0 degrees aligned with aircraft normal, positive clockwise).
+                If this is a fixed-rotation sensor, then this should be set to the fixed rotation value.
+            -->
+            <Field Name="MaxRotation" Type="real32" Units="degree" Default="0" />
+
+            <!--
+                Determines whether there are any limits on the rotation of the gimbal. If this is set to
+                false, then MinRotation and MaxRotation are not used, and the gimbal is capable of
+                continuously rotating in a 360 degree circle without hitting any stops.
+            -->
+            <Field Name="IsRotationClamped" Type="bool" Units="None" Default="true" />
+
+            <!-- Rate of maximum horizontal slew for this gimbal. -->
+            <Field Name="MaxAzimuthSlewRate" Type="real32" Units="degree/sec" />
+
+            <!-- Rate of maximum vertical slew for this gimbal. -->
+            <Field Name="MaxElevationSlewRate" Type="real32" Units="degree/sec" />
+
+            <!-- Rate of maximum rotation for this gimbal. -->
+            <Field Name="MaxRotationRate" Type="real32" Units="degree/sec" />
+
+            <!--
+                Lists the PayloadID of each sensor physically located within the gimbal and that shares
+                the same gimbal angles. It is assumed that all sensors are boresighted.
+            -->
+            <Field Name="ContainedPayloadList" Type="int64[]" Units="None" />
+        </Struct>
+
+        <!--
+            Parameters for controlling the movement of a sensor in a continuous motion.  This can be used to start a back-and-forth or rotational
+            scan over time.  The sensor will sweep in a box pattern from the corner defined by:
+            (StartAzimuth, StartElevation) to (StartAzimuth, EndElevation) to (EndAzimuth, EndElevation)
+            to (EndAzimuth, StartElevation) and back to the origin.
+        -->
+        <Struct Name="GimbalScanAction" Extends="PayloadAction">
+            <!--
+                 sets the time-to-scan in the azimuthal direction. This is the time to complete one sweep through the
+                 the length of EndAzimuth - StartAzimuth.
+            -->
+            <Field Name="AzimuthSlewRate" Type="real32" Units="degree/second" />
+
+            <!--
+                 sets the time-to-scan in the elevation direction. This is the time to complete one sweep through the
+                 the length of EndElevation - StartElevation.
+            -->
+            <Field Name="ElevationSlewRate" Type="real32" Units="degree/second" />
+
+            <!-- The starting azimuth for the sensor scan (boresight angle right of aircraft long axis)-->
+            <Field Name="StartAzimuth" Type="real32" Units="degree"/>
+
+            <!-- The ending azimuth for the sensor scan (boresight angle right of aircraft long axis) -->
+            <Field Name="EndAzimuth" Type="real32" Units="degree"/>
+
+            <!-- The starting elevation for the sensor scan (boresight angle positive from aircraft x-y plane)-->
+            <Field Name="StartElevation" Type="real32" Units="degree"/>
+
+            <!-- The ending elevation for the sensor scan (boresight angle positive from aircraft x-y plane)-->
+            <Field Name="EndElevation" Type="real32" Units="degree"/>
+
+            <!-- Number of sensor sweeps to perform.  A zero value denotes indefinite number of sweeps. -->
+            <Field Name="Cycles" Type="uint32"/>
+        </Struct>
+
+        <!--
+            An action that commands a gimbal to make necessary rotations to allow mounted sensors to stare at the
+            given location.Individual sensors on the gimbal are controlled via the {@link CameraAction} message.<br/>
+        -->
+        <Struct Name="GimbalStareAction" Extends="PayloadAction">
+
+            <!-- The commanded stare point. -->
+            <Field Name="Starepoint" Type="Location3D" Units="None"/>
+            
+            <!-- Duration for the stare operation.  Zero denotes an indefinate stare time -->
+            <Field Name="Duration" Type="int64" Units="milliseconds"/>
+
+        </Struct>
+
+        <!-- Describes the current state of a gimbal and the sensors mounted within it. -->
+        <Struct Name="GimbalState" Extends="PayloadState">
+            <!-- Current pointing mode of the gimbal -->
+            <Field Name="PointingMode" Type="GimbalPointingMode" Units="None" />
+
+            <!-- Current azimuth angle of the gimbal boresight (positive from vehicle x-axis). -->
+            <Field Name="Azimuth" Type="real32" Units="degree" />
+
+            <!-- Current elevation angle of the gimbal boresight (positive from vehicle x-y plane). -->
+            <Field Name="Elevation" Type="real32" Units="degree" />
+
+            <!-- Current rotation angle of the gimbal boresight (0 degrees aligned with aircraft normal, positive clockwise). -->
+            <Field Name="Rotation" Type="real32" Units="degree" />
+        </Struct>
+
+        <!-- Commands an aircraft to start flying towards a given waypoint in its waypoint list.  This action depends on an
+        aircraft already having the given waypoint in its current list.  A {@link MissionCommand} should be sent if new waypoints
+        are required.  The aircraft will remain in waypoint mode and will continue to fly its linked-list waypoint route until
+        otherwise commanded.
+        -->
+        <Struct Name="GoToWaypointAction" Extends="NavigationAction">
+            <!-- Waypoint number to which the aircraft should fly. -->
+            <Field Name="WaypointNumber" Type="int64"/>
+        </Struct>
+
+        <!--
+            Describes the outer boundary of operations for the entire UAV team or a subset of the vehicle team.
+        -->
+        <Struct Name="KeepInZone" Extends="AbstractZone">
+        </Struct>
+
+        <!--
+            Defines a keep-out zone.  This describes a volume where vehicles are not allowed
+            to fly. For standard zones, this Struct defines lateral boundaries.
+        -->
+        <Struct Name="KeepOutZone" Extends="AbstractZone">
+            <!--
+                The type of zone <br/>
+                Physical (physical boundary such as terrain or buildings) <br/>
+                Regulatory (fire control, flight corridor)  <br/>
+                Acoustic  Defines an area for acoustical avoidance <br/>
+                Threat  Defines an area where a threat is present.
+            -->
+            <Field Name="ZoneType" Type="ZoneAvoidanceType" Units="None" />
+        </Struct>
+
+        <!-- Defines a line search task.
+            A line search is a list of points that forms a polyline.  The ViewAngleList determines
+            from which direction the line may be viewed.  View angles are specified using the {@link Wedge} type. If the
+            UseInertialViewAngles option is true, then wedges are defined in terms of North-East coordinates, otherwise
+            wedges are defined relative to the line segment currently being viewed (a vector from point i through point i+1).
+            To be a valid look angle, the line segment must be viewed from an angle within the bounds of the wedge.
+        -->
+        <Struct Name="LineSearchTask" Extends="SearchTask">
+
+            <!-- Line to search -->
+            <Field Name="PointList" Type="Location3D[]" />
+
+            <!-- Defines a list of acceptable look-angles for this task.  See the documentation above for details. -->
+            <Field Name="ViewAngleList" Type="Wedge[]"/>
+
+            <!-- If true, the ViewAngleList specifies inertial (North-East) angles. See documentation above. -->
+            <Field Name="UseInertialViewAngles" Type="bool" Default="false"/>
+
+        </Struct>
+        
+        <!--
+         Base action class for all navigation actions that the vehicle may take
+         -->
+         <Struct Name="NavigationAction" Extends="VehicleAction">
+         </Struct>
+         
+        <!--
+            Used to command a vehicle to go into a vehicle-specific hold pattern.
+        -->
+        <Struct Name="LoiterAction" Extends="NavigationAction">
+            <!--
+                The loiter shape that the vehicle should fly
+            -->
+            <Field Name="LoiterType" Type="LoiterType" Units="none" Default="VehicleDefault"/>
+
+            <!--
+                The radius for the loiter. May be used for any curvature parameter of the vehicle specific hold pattern.
+            -->
+            <Field Name="Radius" Type="real32" Units="meter"/>
+
+            <!--
+                Direction of the major axis of the vehicle specific hold pattern.  For Racetracks and Figure-Eights, this is the direction of
+                the long axis.  Hovering loiters, this is direction the aircraft should face in the loiter.
+            -->
+            <Field Name="Axis" Type="real32" Units="degree" Default="0"/>
+
+            <!-- Used in racetrack and figure-eight loiters. For figure-eight loiters, this is the length between the focii of
+                 the turn circles. For racetracks, this is the length of the straight-away. Both types have a total length of
+                 Length + 2 * Radius.  For figure-eight loiters, if Length is less than 2 * radius, then this field is ignored.
+            -->
+            <Field Name="Length" Type="real32" Units="meter"/>
+
+            <!--
+                Direction of travel. 
+            -->
+            <Field Name="Direction" Type="LoiterDirection" Units="None" Default="VehicleDefault"/>
+
+            <!--
+                The time to loiter at this point before continuing.  A negative time value denotes
+                perpetual orbit.
+            -->
+            <Field Name="Duration" Type="int64" Units="milliseconds"/>
+
+            <!-- Commanded True Airspeed -->
+            <Field Name="Airspeed" Type="real32" Units="meter/sec" />
+
+            <!-- The geometric center point of the loiter. -->
+            <Field Name="Location" Type="Location3D"/>
+
+        </Struct>
+
+        <!-- Used to define a loiter request from the automation service. -->
+        <Struct Name="LoiterTask" Extends="Task">
+
+            <!--
+                The desired loiter action to take
+            -->
+            <Field Name="DesiredAction" Type="LoiterAction" Units="none"/>
+
+        </Struct>
+
+        <!--
+            A simple waypoint class for vehicle routing
+        -->
+        <Struct Name="Waypoint" Extends="Location3D">
+            <!-- A unique waypoint number -->
+            <Field Name="Number" Type="int64" Units="None" />
+
+            <!--
+                The index of the next waypoint in the list. Consecutively numbered waypoints are <b>not</b> considered linked, the link must be explicitly stated in this field.
+            -->
+            <Field Name="NextWaypoint" Type="int64" Units="None" />
+
+            <!-- Commanded speed for this waypoint.  See SpeedType for defintion of this field. -->
+            <Field Name="Speed" Type="real32" Units="meter/sec" />
+
+            <!-- Type of commanded speed
+            -->
+            <Field Name="SpeedType" Type="SpeedType"/>
+
+            <!-- The commanded climb rate.  Positive values upwards.  For surface (ground and sea) entities, this value is ignored. -->
+            <Field Name="ClimbRate" Type="real32" Units="meter/sec" />
+
+            <!-- The type of turn to execute
+            -->
+            <Field Name="TurnType" Type="TurnType" Default="TurnShort"/>
+
+
+            <!-- A list of actions to perform at this waypoint -->
+            <Field Name="VehicleActionList" Type="VehicleAction[]" Units="None" />
+
+            <!-- A waypoint for contingency (e.g. lost-comm, alternate mission) operations.  A value of zero denotes
+            that no contingency point is specified. -->
+            <Field Name="ContingencyWaypointA" Type="int64" Default="0"/>
+            
+            <!-- A waypoint for contingency (e.g. lost-comm, alternate mission) operations.  A value of zero denotes
+            that no contingency point is specified. -->
+            <Field Name="ContingencyWaypointB" Type="int64" Default="0"/>
+
+            <!--
+                A list of tasks that are associated with this waypoint.  A length of zero denotes no associated tasks.
+                This field is for analysis purposes.  The automation service should associate a list of tasks with each waypoint to enable
+                analysis of the allocation of tasks to vehicles.
+            -->
+            <Field Name="AssociatedTasks" Type="int64[]"/>
+
+        </Struct>
+
+        <!--
+            A mission to be performed by a vehicle.  This sends a new list of waypoints to an aircraft and commands the aircraft
+            to start flying the mission starting at the specified "FirstWaypoint".  A Mission command is made up of a linked
+            list of waypoints.  However, the waypoint list may contain other waypoints that are not linked to the main route path
+            that begins with "FirstWaypoint".<br/>
+            <i>Note on end-of-mission behavior: </i> The last waypoint in the linked route list should include some terminal
+            behavior. For instance, the last waypoint should be directed with itself as the "Next Waypoint" or there should be
+            an indefinite loiter assigned in the last waypoint's "VehicleActionList".<br/>
+            VehicleActionLists are performed immediately when MissionCommand is received, e.g. camera pointed toward first waypoint.
+        -->
+        <Struct Name="MissionCommand" Extends="VehicleActionCommand">
+
+            <!-- The list of waypoints associated with this mission task.  Waypoints are linked, but the waypoint list may
+            contain waypoints that are not necessarily linked.  Multiple linked routes may be sent in a single waypoint list.
+            Waypoints are not necessarily ordered in the list.
+            -->
+            <Field Name="WaypointList" Type="Waypoint[]" Units="None" />
+
+            <!-- ID of the first waypoint to follow. -->
+            <Field Name="FirstWaypoint" Type="int64"/>
+        </Struct>
+
+        <!--
+            Used to request a must-fly task with optional action list.
+        -->
+        <Struct Name="MustFlyTask" Extends="Task">
+
+            <!-- point that must vehicle must fly through -->
+            <Field Name="Position" Type="Location3D"/>
+
+            <!-- Denotes whether altitude should be used in this MustFlyTask. If false, the
+            aircraft should maintain altitude according to previous commands.
+            -->
+            <Field Name="UseAltitude" Type="bool" Default="true"/>
+
+        </Struct>
+
+        <!--
+            Used to send operator interaction information to automation system during task execution
+        -->
+        <Struct Name="OperatorSignal">
+
+            <!-- Content of signal (e.g. button clicked) -->
+            <Field Name="Signals" Type="KeyValuePair[]"/>
+
+        </Struct>
+
+        <!-- Collection of extrusions/zones that define operating region -->
+        <Struct Name="OperatingRegion">
+            
+            <!-- Operating region ID -->
+            <Field Name="ID" Type="int64" />
+            
+            <!-- Abstract Zone IDs in which the entity must remain during operation -->
+            <Field Name="KeepInAreas" Type="int64[]" />
+            
+            <!-- Keep Out Zone IDs that an entity must remain out of during operation -->
+            <Field Name="KeepOutAreas" Type="int64[]" />
+        </Struct>
+        
+        <!--
+            This is the primary message for requesting action from the automation service. The automation service is to use the list of
+            vehicles, tasks (with associated task relationships), keep-out zones, and keep-in zones to produce {@link MissionCommands}
+            for the vehicles requested. The automation service should only produce commands for the vehicles requested, but is not
+            required to produce plans for all vehicles. If multiple {@link AutomationRequest} messages are sent to the automation service, only
+            the last message will be considered, i.e. a new plan request supercedes all previous ones.
+        -->
+        <Struct Name="AutomationRequest">
+            <!-- List of entities to consider when planning. -->
+            <Field Name="EntityList" Type="int64[]"/>
+            <!-- list of task IDs (defined by {@link Task} messages) to be planned for by the automation service -->
+            <Field Name="TaskList" Type="int64[]"/>
+            <!-- string containing the relationship between requested tasks. If empty, all tasks are to be completed in any order. The
+                 format of the string is specific to the automation service. This relationship string is the mechanism for incorporating
+                 task precedence, priority, timing, etc. -->
+            <Field Name="TaskRelationships" Type="string"/>
+            <!-- Operating region ID to be considered during planning -->
+            <Field Name="OperatingRegion" Type="int64"/>
+            <!--
+                 Denotes that that the planner should restart any tasks that have been performed or are currently being performed.  This is useful in situations when a task
+                 request contains tasks that have been requested previously, and the operator wishes to restart the mission plans from the beginning.
+            -->
+            <Field Name="RedoAllTasks" Type="bool" Default="false"/>
+        </Struct>
+
+        <!-- Point search task -->
+        <Struct Name="PointSearchTask" Extends="SearchTask">
+
+            <!-- Point to search -->
+            <Field Name="SearchLocation" Type="Location3D" />
+
+            <!--Minimum distance that an aircraft must maintain from the point of interest. -->
+            <Field Name="StandoffDistance" Type="real32" Units="meter" Default="0"/>
+
+            <!-- A list of acceptable look-angles for this task.  Each wedge is defined relative to true North. To be a valid
+                 look angle, a sensor must be looking from a direction within the bounds of the wedge.
+            -->
+            <Field Name="ViewAngleList" Type="Wedge[]"/>
+
+        </Struct>
+
+        <!-- Describes a polygon defined by geographic locations. Altitude value of points is ignored. -->
+        <Struct Name="Polygon" Extends="AbstractGeometry">
+            <!-- Boundary points for the polygon -->
+            <Field Name="BoundaryPoints" Type="Location3D[]" />
+        </Struct>
+
+        <!-- Defines a rectangular shape based on a corner point, width, height, and rotation -->
+        <Struct Name="Rectangle" Extends="AbstractGeometry">
+            <!-- Center point of the rectangle. Altitude value is ignored -->
+            <Field Name="CenterPoint" Type="Location3D"/>
+            <!-- Width of the rectangle -->
+            <Field Name="Width" Type="real32" Units="meter"/>
+            <!-- Height of the rectangle -->
+            <Field Name="Height" Type="real32" Units="meter"/>
+            <!-- Rotation of the rectangle around the center point (positive from north axis towards east) -->
+            <Field Name="Rotation" Type="real32" Units="degree" Default="0"/>
+        </Struct>
+
+        <!--
+            Sent to denote that the target id numbers in the list are obsolete and will not be requested again. This can occur when the user
+            has replaced an old task with a new one, or has deleted a task permanently.  This is an optional message that automation services can ignore,
+            depending on how they manage tasks.
+        -->
+        <Struct Name="RemoveTasks">
+            <Field Name="TaskList" Type="int64[]"/>
+        </Struct>
+
+
+
+        <!--
+            Provides information regarding automation service compuation percent complete.  The automation service should send this when the computation of a
+            mission plan may take more than a few seconds, or when an error occurs (such as the inability to create one or more
+            mission commands given the task set)
+        -->
+        <Struct Name="ServiceStatus">
+
+            <!-- The estimated percentage completed for an automation process. -->
+            <Field Name="PercentComplete" Type="real32" />
+
+            <!-- Status from the automation service to the simulation regarding errors or conditions. -->
+            <Field Name="Info" Type="KeyValuePair[]"/>
+
+            <!--
+                Describes the type of message conveyed. <br/>
+                Information.  Used to note normal progress updates <br/>
+                Warning.  Notes non-fatal problem(s) in data or processing <br/>
+                Error.  Notes fatal problem(s) <br/>
+            -->
+            <Field Name="StatusType" Type="ServiceStatusType"/>
+        </Struct>
+
+        <!--
+            Provides information regarding the state of a simulation or real-world.  <br/>
+        -->
+        <Struct Name="SessionStatus">
+            <!-- The current state of the session -->
+            <Field Name="State" Type="SimulationStatusType" />
+
+            <!--
+                The simulation or scenario start time.  This is absolute time in milliseconds since epoch (1 Jan 1970 00:00 GMT).
+                If this field is zero, then no start time is specfied and each sim component is to use the first receipt of
+                this Struct with a SimStatus of "Running" as the start time.
+            -->
+            <Field Name="StartTime" Type="int64" Units="millisecond" />
+
+            <!--
+                The current time in scenario time .  This is the internal time for the simulation, not the absolute time
+                since epoch, as in "StartTime".  The internal simualation time is based on the start time and the real-time
+                muiltiple, which can change throughout the simulation.
+            -->
+            <Field Name="ScenarioTime" Type="int64" Units="millisecond"/>
+
+            <!--
+                The ratio of simulation time to real time.  Values greater than 1.0 denote faster than real-time.  Values
+                less than 0.0 have no meaning.
+            -->
+            <Field Name="RealTimeMultiple" Type="real32"/>
+
+            <!--
+                A field to store command-line style parameters used to initialize or modify an execution.  
+            -->
+            <Field Name="Parameters" Type="KeyValuePair[]"/>
+        </Struct>
+
+        <!--
+            A message that specifies actions that should be performed by the specified aircraft.  Actions can be navigational modes
+            or payload actions.
+        -->
+        <Struct Name="VehicleActionCommand">
+
+            <!-- A unique id for this command.  automation services should issue new ids with every new command -->
+            <Field Name="CommandID" Type="int64"/>
+
+            <!-- The id of the vehicle for this command. -->
+            <Field Name="VehicleID" Type="int64" Units="None" />
+
+            <!-- a set of actions to be performed immediately by the vehicle. -->
+            <Field Name="VehicleActionList" Type="VehicleAction[]"/>
+
+            <!-- Denotes the current execution status of this command. -->
+            <Field Name="Status" Type="CommandStatusType"/>
+            
+        </Struct>
+
+        <!-- An action for controlling which sensor is being transmitted on a video stream. -->
+        <Struct Name="VideoStreamAction" Extends="VehicleAction">
+            <!-- A unique id for the video stream. -->
+            <Field Name="VideoStreamID" Type="int32" Units="None" />
+
+            <!-- The PayloadID of the sensor which should be activated on this video stream. -->
+            <Field Name="ActiveSensor" Type="int32" Units="None" />
+        </Struct>
+
+
+
+        <!--
+            Description of a video stream transmitted by the aircraft (specifically, what sensors
+            are available to be transmitted via the stream).
+        -->
+        <Struct Name="VideoStreamConfiguration" Extends="PayloadConfiguration">
+            <!--
+                 List the PayloadID of each sensor that is multiplexed into this stream. The {@link VideoStreamAction} message
+                 selects which of these sensors is currently active on the stream.
+            -->
+            <Field Name="AvailableSensorList" Type="int64[]" Units="None" />
+        </Struct>
+
+        <!-- Describes the current state of a video stream. -->
+        <Struct Name="VideoStreamState" Extends="PayloadState">
+
+            <!-- The PayloadID of the sensor which is active on this video stream.. -->
+            <Field Name="ActiveSensor" Type="int64" Units="None" />
+        </Struct>
+
+        <!-- Encapsulates data from an automation service to a client.  The automation service may respond with
+        MissionCommands, VehicleActionCommands, or no commands at all.  This type is meant to serve as a single
+        container for commands that are a response to {@link AutomationRequest}
+        -->
+        <Struct Name="AutomationResponse">
+            <!-- A list of MissionCommands issued by the automation service -->
+            <Field Name="MissionCommandList" Type="MissionCommand[]"/>
+            <!-- A list of VehicleActionCommands issued by the automation service -->
+            <Field Name="VehicleCommandList" Type="VehicleActionCommand[]"/>
+            <!-- Status from the automation service to the simulation regarding errors or conditions. -->
+            <Field Name="Info" Type="KeyValuePair[]"/>
+        </Struct>
+
+        <!-- Denotes a list of zones that should be removed permanently from the scenario. -->
+        <Struct Name="RemoveZones">
+            <!-- List of zones to remove -->
+            <Field Name="ZoneList" Type="int64[]"/>
+        </Struct>
+
+        <!-- Denotes a list of entities that should be removed permanently from the scenario. -->
+        <Struct Name="RemoveEntities">
+            <!-- List of entities to remove -->
+            <Field Name="EntityList" Type="int64[]"/>
+        </Struct>
+
+        <!-- A command to "direct" the aircraft on a particular vector. This can be passed directly to the
+            autopilot, or be directed to the operator as the current command to follow. -->
+        <Struct Name="FlightDirectorAction" Extends="NavigationAction">
+            <!-- Speed to fly -->
+            <Field Name="Speed" Type="real32" Units="meter/sec"/>
+            <!-- type of speed to fly -->
+            <Field Name="SpeedType" Type="SpeedType" Default="Airspeed"/>
+            <!-- True heading to fly -->
+            <Field Name="Heading" Type="real32" Units="degree"/>
+            <!-- Altitude to maintain.  -->
+            <Field Name="Altitude" Type="real32" Units="meter"/>
+            <!-- Altitude type for specified altitude -->
+            <Field Name="AltitudeType" Type="AltitudeType" Default="MSL" />
+            <!-- target climb/descent rate for changing altitude -->
+            <Field Name="ClimbRate" Type="real32" Units="meter/sec"/>
+        </Struct>
+
+        <!-- Reports current weather conditions.  A weather report can cover a given geographic area or
+             the entire scenario.  Multiple reports can be issued during a scenario to indicate
+             varying weather conditions over time or space. Mission planners can use weather reports
+             to plan or can read current wind conditions as reported by aircraft as part of
+             {@link AirVehicleState}.
+        -->
+        <Struct Name="WeatherReport">
+
+            <!-- The area for which this report pertains.  If this is null, then the report
+                 pertains to the entire area. -->
+            <Field Name="Area" Type="AbstractZone" Default="null"/>
+
+            <!-- Windspeed value for this area -->
+            <Field Name="WindSpeed" Type="real32" Units="meter/sec"/>
+
+            <!-- Wind direction.  Direction is the true heading from which the wind is blowing. -->
+            <Field Name="WindDirection" Type="real32" Units="degree"/>
+
+            <!-- Visibility, according to the <a href="http://en.wikipedia.org/wiki/Visibility">ICAO definition</a>. -->
+            <Field Name="Visibility" Type="real32" Units="meter"/>
+
+            <!-- Height of the bottom of a cloud layer, in MSL altitude. If there is more than one cloud layer, create
+                 WeatherReports for each zone that contains a cloud layer. A value of "0" denotes free-of-clouds -->
+            <Field Name="CloudCeiling" Type="real32" Units="meter"/>
+
+            <!-- Amount of cloud coverage for the given cloud layer.  Values should be 0..1, 0 denoting
+                 free-of-clouds, and 1 denoting overcast. -->
+            <Field Name="CloudCoverage" Type="real32"/>
+
+        </Struct>
+        
+        <!-- A command to follow a set of ground waypoints.  This is analogous to a {@link MissionCommand} for aircraft. -->
+        <Struct Name="FollowPathCommand" Extends="VehicleActionCommand" >
+            
+            <!-- The first waypoint to follow.  This should correspond to the number of a waypoint in the 
+            waypoint list. If this is zero, no waypoint will be followed. -->
+            <Field Name="FirstWaypoint" Type="int64"/>
+            
+            <!-- A list of waypoints to follow -->
+            <Field Name="WaypointList" Type="PathWaypoint[]"/>
+            
+            <!-- Describes the start time for this action, in scenario time.  If this field is zero, the action is
+            completed immediately. -->
+            <Field Name="StartTime" Type="int64" Units="milliseconds" Default="0"/>
+            
+            <!-- Describes the end time for this action, in scenario time.  If this field is zero, it should be ignored, otherwise
+            The entity will travel until the stop time is reached. -->
+            <Field Name="StopTime" Type="int64" Units="milliseconds" Default="0"/>
+            
+            <!-- Describes how the entity should treat the end-of-path. Entities can complete the path once, or continuously.-->
+            <Field Name="RepeatMode" Type="TravelMode" Default="SinglePass"/>
+        </Struct>
+        
+        <!-- A waypoint that can be used as part of commanding entities' movement -->
+        <Struct Name="PathWaypoint" Extends="Waypoint">
+            <!-- The amount of time that an entity should pause before moving to the next waypoint. -->
+            <Field Name="PauseTime" Type="int64" Units="milliseconds" Default="0"/>
+        </Struct>
+        
+        <!-- Tells the Entity to stop at the given location.  If the location is null, then the 
+        entity will stop immediately. -->
+        <Struct Name="StopMovementAction" Extends="VehicleAction" >
+            <!-- A location at which the entity should stop.  If this is null, the entity will stop immediately. -->
+            <Field Name="Location" Type="Location3D" Series="CMASI" Default="null"/>
+        </Struct>
+        
+        <!-- Handles the transfer of waypoints.  This does not affect the current navigation of the 
+             aircraft.  This can be used to transfer, or request the transfer of, waypoints. -->
+        <Struct Name="WaypointTransfer">
+            <!-- ID of the entity assoicated with the waypoints -->
+            <Field Name="EntityID" Type="int64"/>
+            
+            <!-- A list of wayppoints to transfer.  This may be empty if the transfer type is "RequestWaypoints" or "ClearWaypoints" -->
+            <Field Name="Waypoints" Type="Waypoint[]"/>
+            
+            <!-- describes the transfer action to take -->
+            <Field Name="TransferMode" Type="WaypointTransferMode" Default="AddWaypoints"/>
+        </Struct>
+        
+        <!-- Commands a payload to stow. -->
+        <Struct Name="PayloadStowAction">
+            <!-- payload to stow -->
+            <Field Name="PayloadID" Type="int64"/>
+        </Struct>
+		
+		
+    </StructList>
+</MDM>
+
+
+
+
diff --git a/src/LMCP/IMPACT.xml b/src/LMCP/IMPACT.xml
new file mode 100644
index 0000000..18436a5
--- /dev/null
+++ b/src/LMCP/IMPACT.xml
@@ -0,0 +1,599 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE MDM SYSTEM 'MDM.DTD'>
+
+<!--
+        <h2>Introduction</h2>
+        IMPACT message definitions. Defines data relevant to flexible, automation-assisted play calling.
+ 
+        <h2>Changes</h2>
+        <h3>23 Oct 2015</h3>
+        <ul>
+            <li>Added request/response IDs to Batch messages</li>
+            <li>Created ImpactAutomationRequest to add ID and alt/speed override</li>
+        </ul>
+
+        <h3>29 Sept 2015</h3>
+        <ul>
+            <li>Added message for deploying IMPACT specific payloads</li>
+            <li>Re-worked batch requests to include summary information</li>
+            <li>Tasks for scout, multi-vehicle overwatch, and cordon/blockade added</li>
+        </ul>
+        
+        <h3>18 May 2015</h3>
+        <ul>
+            <li>Added batch route planning messages</li>
+        </ul>
+ 
+		<h3>18 March 2015</h3>
+		<ul>
+            <li>All ID fields updated from uint32 to int64</li>
+            <li>All time fields converted to integer milliseconds</li>
+            <li>Route plan requests rely on operating region rather than lists of zones</li>
+            <li>GroundVehicle and SurfaceVehicle extend from Entity</li>
+        </ul>
+-->
+
+<MDM>
+    <SeriesName>IMPACT</SeriesName>
+    <Namespace>afrl/impact</Namespace>
+    <Version>11</Version>
+    
+    <EnumList>
+        
+        <!-- Area Search Pattern -->
+        <Enum Name="AreaSearchPattern">
+            <!-- Spiral search -->
+            <Entry Name="Spiral" Value="0"/>
+            <!-- Sector -->
+            <Entry Name="Sector" Value="1"/>
+            <!-- Sweep -->
+            <Entry Name="Sweep" Value="2"/>
+        </Enum>
+        
+        <!-- Vehicle Power Plant -->
+        <Enum Name="PowerPlant">
+            <!-- Conventional gasoline -->
+            <Entry Name="Gasoline" Value="0"/>
+            <!-- Heavy Fuel (JP5) -->
+            <Entry Name="JP5" Value="1"/>
+            <!-- Heavy Fuel (JP8) -->
+            <Entry Name="JP8" Value="2"/>
+            <!-- Fuel Cell (Hydrogen) -->
+            <Entry Name="FuelCell" Value="3"/>
+            <!-- Hybrid electric/gasoline -->
+            <Entry Name="Hybrid" Value="4"/>
+        </Enum>
+        
+        <!-- Impact specific payload types -->
+        <Enum Name="ImpactPayloadType">
+            <!-- Unknown -->
+            <Entry Name="Unknown" Value="0"/>
+            <!-- EO -->
+            <Entry Name="EO" Value="1"/>
+            <!-- Forward Looking Infra Red -->
+            <Entry Name="FLIR" Value="2"/>
+            <!-- Mid Wave Infra Red -->
+            <Entry Name="MWIR" Value="3"/>
+            <!-- LFIR -->
+            <Entry Name="LFIR" Value="4"/>
+            <!-- Auto-tracking payload -->
+            <Entry Name="Track" Value="5"/>
+            <!-- Placement of physical tag for tracking -->
+            <Entry Name="Tag" Value="6"/>
+            <!-- Megaphone -->
+            <Entry Name="Megaphone" Value="7"/>
+            <!-- Siren -->
+            <Entry Name="Siren" Value="8"/>
+            <!-- Search Light -->
+            <Entry Name="SearchLight" Value="9"/>
+            <!-- Browning .50 caliber weapon -->
+            <Entry Name="FiftyCal" Value="10"/>
+            <!-- M240B -->
+            <Entry Name="M240B" Value="11"/>
+            <!-- Flashbang -->
+            <Entry Name="Flashbang" Value="12"/>
+            <!-- Tear Gas -->
+            <Entry Name="TearGas" Value="13"/>
+            <!-- Taser -->
+            <Entry Name="Taser" Value="14"/>
+            <!-- Heat Beam -->
+            <Entry Name="HeatBeam" Value="15"/>
+            <!-- Scan Eagle Guided Munition -->
+            <Entry Name="SEGM" Value="16"/>
+            <!-- Comm Relay -->
+            <Entry Name="CommRelay" Value="17"/>
+            <!-- Ground Moving Target Indicator -->
+            <Entry Name="GMTI" Value="18"/>
+            <!-- Laser Designator -->
+            <Entry Name="LaserDesignator" Value="19"/>
+        </Enum>
+        
+    </EnumList>
+
+    <StructList>
+    
+        <!-- Indicates the power plant configuration carried by a vehicle -->
+        <Struct Name="PowerConfiguration" Extends="PayloadConfiguration" Series="CMASI" >
+            <!-- Power generation system (used for acoustic signature) -->
+            <Field Name="NominalPowerConfiguration" Type="PowerPlant" Default="Gasoline" />
+        </Struct>
+    
+        <!-- Indicates the radio specification carried by an entity -->
+        <Struct Name="RadioConfiguration" Extends="PayloadConfiguration" Series="CMASI" >
+            <!-- The range of the radio -->
+            <Field Name="Range" Type="real32" Units="meters" Default="1500.0" />
+            <!-- The vehicle's rally point -->
+            <Field Name="RallyPoint" Type="Location3D" Series="CMASI" />
+            <!-- Time after loss of communications the vehicle should return to its rally point -->
+            <Field Name="Timeout" Type="int64" Units="milliseconds" Default="120000" />
+        </Struct>
+		
+        <!-- Indicates a radio tower -->
+        <Struct Name="RadioTowerConfiguration" Extends="EntityConfiguration" Series="CMASI" >
+            <!-- The position of the tower -->
+            <Field Name="Position" Type="Location3D" Series="CMASI" />
+            <!-- The range of the radio -->
+            <Field Name="Range" Type="real32" Units="meters" Default="1500.0" />
+            <!-- Whether the radio is enabled -->
+            <Field Name="Enabled" Type="bool" Default="true" />
+        </Struct>
+		
+        <!-- Indicates the radio state -->
+        <Struct Name="RadioState" Extends="PayloadState" Series="CMASI" >
+            <!-- Whether the radio is enabled -->
+            <Field Name="Enabled" Type="bool" Default="true" />
+            <!-- Whether the vehicle is in communications range -->
+            <Field Name="InRange" Type="bool" />
+        </Struct>
+		
+        <!-- Indicates a radio tower state -->
+        <Struct Name="RadioTowerState" Extends="EntityState" Series="CMASI" >
+            <!-- Whether the radio is enabled -->
+            <Field Name="Enabled" Type="bool" Default="true" />
+        </Struct>
+		
+        <!-- Indicates the IMPACT specific payloads carried by an entity -->
+        <Struct Name="ImpactPayloadConfiguration" Extends="PayloadConfiguration" Series="CMASI" >
+            <!-- Payloads available for this entity -->
+            <Field Name="AvailablePayloads" Type="ImpactPayloadType[]" />
+        </Struct>
+        
+        <!-- Indicator for use of an IMPACT payload -->
+        <Struct Name="DeployImpactPayload" Extends="CMASI/VehicleAction">
+            <!-- IMPACT vehicle from which to deploy payload -->
+            <Field Name="VehicleID" Type="int64" />
+            <!-- Payload to deploy -->
+            <Field Name="DeployedPayload" Type="ImpactPayloadType" />
+            <!-- Entity to which the payload will be deployed. If zero, then
+            payload is assumed deployed at the current position of the deploying
+            vehicle. -->
+            <Field Name="TargetEntityID" Type="int64" />
+        </Struct>
+        
+        <!-- Describes the current state of the power system -->
+        <Struct Name="PowerPlantState" Extends="PayloadState" Series="CMASI" >
+            <!-- The active power plant -->
+            <Field Name="ActivePowerPlant" Type="PowerPlant" Default="Gasoline" />
+        </Struct>
+        
+        <!-- Batch Route plan request. Plans from current vehicle locations to the start of
+        each task in 'TaskList' -->
+        <Struct Name="BatchRoutePlanRequest" >
+            <!-- Request ID for correlating with response -->
+            <Field Name="RequestID" Type="int64" />
+            <!-- An array of vehicles (by ID) to consider when planning -->
+            <Field Name="Vehicles" Type="int64[]" />
+            <!-- List of task IDs to be planned to -->
+            <Field Name="TaskList" Type="int64[]" />
+            <!-- Operating region to be considered during planning -->
+            <Field Name="OperatingRegion" Type="int64" />
+            <!-- Flag to report timing between tasks -->
+            <Field Name="ComputeTaskToTaskTiming" Type="bool" Default="false" />
+            <!-- Flag to report timing between incremental progress on task and subsequent tasks -->
+            <Field Name="ComputeInterTaskToTaskTiming" Type="bool" Default="false" />
+            <!-- List of task percentages along task to plan from -->
+            <Field Name="InterTaskPercentage" Type="real32[]" />
+        </Struct>
+        
+        <!-- Batch Route plan response with vehicle-to-task timing reported. -->
+        <Struct Name="BatchRoutePlanResponse" >
+            <!-- Response ID matching request from ({@link BatchRoutePlanRequest}) -->
+            <Field Name="ResponseID" Type="int64" />
+            <!-- Set of task-to-task timings for each requested vehicle -->
+            <Field Name="VehicleTiming" Type="TaskTimingPair[]" />
+        </Struct>
+        
+        <!-- Single task/vehicle timing information capturing the estimated time for
+        the specified vehicle to travel to or between tasks -->
+        <Struct Name="TaskTimingPair" >
+            <!-- Corresponding Vehicle ID -->
+            <Field Name="VehicleID" Type="int64" />
+            <!-- Initial task ID (if zero, corresponds to current vehicle location) -->
+            <Field Name="InitialTaskID" Type="int64" />
+            <!-- Normalized progress along initial task (0.0 .. 1.0) -->
+            <Field Name="InitialTaskPercentage" Type="real32" />
+            <!-- Destination task ID -->
+            <Field Name="DestinationTaskID" Type="int64" />
+            <!-- Timing corresponding to travel between tasks. If time is less than zero, no feasible path exists between tasks. If 'DestinationTaskID' is equal to 'InitialTaskID' then 'TimeToGo' is the time to complete the task when performed by 'VehicleID' -->
+            <Field Name="TimeToGo" Type="int64" Units="milliseconds" />
+        </Struct>
+        
+        <!-- Batch summary request whereby vehicle-to-task information is requested -->
+        <Struct Name="BatchSummaryRequest" >
+            <!-- Request ID for correlating with response -->
+            <Field Name="RequestID" Type="int64" />
+            <!-- An array of vehicles (by ID) to consider when planning -->
+            <Field Name="Vehicles" Type="int64[]" />
+            <!-- List of task IDs to be planned to -->
+            <Field Name="TaskList" Type="int64[]" />
+            <!-- List of task percentages along task to plan from -->
+            <Field Name="InterTaskPercentage" Type="real32[]" />
+            <!-- Operating region to be considered during planning -->
+            <Field Name="OperatingRegion" Type="int64" />
+        </Struct>
+        
+        <!-- Batch summary response as a list of all vehicle-to-task information -->
+        <Struct Name="BatchSummaryResponse" >
+            <!-- Response ID matching request from ({@link BatchSummaryRequest}) -->
+            <Field Name="ResponseID" Type="int64" />
+            <!-- Set of vehicle-to-task and task-to-task summaries including timing, communication, and remaining energy -->
+            <Field Name="Summaries" Type="TaskSummary[]" />
+        </Struct>
+        
+        <!-- Summary information that describes a particular way to carry out the task.
+        In general, multiple task summaries for each task will be sent corresponding to
+        each eligible vehicle completing the task. In the case where a task is completed
+        by multiple vehicles simultaneously, then each TaskSummary will include the set of
+        vehicles that would be used to complete the task. -->
+        <Struct Name="TaskSummary" >
+            <!-- ID of task in consideration -->
+            <Field Name="TaskID" Type="int64" />
+            <!-- Summary of information for each vehicle used simultaneously to complete this task.
+            If there are zero performing vehicles, then 'TaskID' cannot be completed with any set of
+            available vehicles in the system. -->
+            <Field Name="PerformingVehicles" Type="VehicleSummary[]" />
+            <!-- Task cannot be completed as specified and is using best effort. Estimated percent
+            achieved while using best effort strategy. -->
+            <Field Name="BestEffort" Type="real32" Units="%" Default="100.0" />
+        </Struct>
+        
+        <!-- Single vehicle-to-task summary information -->
+        <Struct Name="VehicleSummary" >
+            <!-- ID of vehicle considered to complete 'DestinationTaskID' -->
+            <Field Name="VehicleID" Type="int64" />
+            <!-- ID of task for which 'VehicleID' is considered to perform -->
+            <Field Name="DestinationTaskID" Type="int64" />
+            <!-- ID of task from which 'VehicleID' is considered leave from. If zero, from current position of vehicle -->
+            <Field Name="InitialTaskID" Type="int64" />
+            <!-- Percentage along initial task that vehicle should plan from -->
+            <Field Name="InitialTaskPercentage" Type="real32" />
+            <!-- Estimated time from start of task to task-percentage location -->
+            <Field Name="EstimateTimeToTaskPercentage" Type="int64" Units="milliseconds" />
+            <!-- Travel time from the current vehicle location to the start of the task. -->
+            <Field Name="TimeToArrive" Type="int64" Units="milliseconds" />
+            <!-- Time for this task to be completed by the specified vehicle -->
+            <Field Name="TimeOnTask" Type="int64" Units="milliseconds" />
+            <!-- Energy remaining for vehicle after task has been completed,
+            expressed in terms of the percentage of maximum capacity -->
+            <Field Name="EnergyRemaining" Type="real32" Units="%" />
+            <!-- Flag for indicating that the vehicle will leave communication range
+            either enroute or during the task -->
+            <Field Name="BeyondCommRange" Type="bool" Default="false" />
+        </Struct>
+
+        <!-- Component heartbeat expected to be sent out @ 1Hz-->
+        <Struct Name="ImpactHeartbeat" >
+        <!-- Label of system component sending heartbeat -->
+            <Field Name="ComponentLabel" Type="string" />
+            <!-- Time at which this heatbeat was sent (milliseconds since 1 Jan 1970 00:00 GMT) -->
+            <Field Name="HeartbeatTime" Type="int64" Units="milliseconds"/>
+        </Struct>
+        
+        <!-- Component Join -->
+        <Struct Name="ImpactComponentJoin" >
+            <!-- Label of component joining network -->
+            <Field Name="ComponentLabel" Type="string" />
+        </Struct>
+        
+        <!-- Component Leave -->
+        <Struct Name="ImpactComponentLeave" >
+            <!-- Label of component leaving network -->
+            <Field Name="ComponentLabel" Type="string" />
+        </Struct>
+        
+        <!-- Data structure for associating a vehicle to a particular altitude and speed -->
+        <Struct Name="SpeedAltPair" >
+            <!-- ID of vehicle for which altitude and speed is attached -->
+            <Field Name="VehicleID" Type="int64" />
+            <!-- The speed attached to this vehicle -->
+            <Field Name="Speed" Type="real32" Units="meter/sec" />
+            <!-- Altitude attached to this vehicle -->
+            <Field Name="Altitude" Type="real32" Units="meter"/>
+            <!-- Altitude type for specified altitude -->
+            <Field Name="AltitudeType" Type="CMASI/AltitudeType" Default="AGL" />
+        </Struct>
+        
+        <!-- Automation request specific to IMPACT (includes 'sandbox' feature and play/soln IDs) -->
+        <Struct Name="ImpactAutomationRequest" >
+            <!-- Request ID for correlating with response -->
+            <Field Name="RequestID" Type="int64" />
+            <!-- Standard CMASI Automation request -->
+            <Field Name="TrialRequest" Type="AutomationRequest" Series="CMASI" />
+            <!-- Override nominal speed/alt. If a vehicle is not in list, its nominal speed/alt is used -->
+            <Field Name="OverridePlanningConditions" Type="SpeedAltPair[]" />
+            <!-- Associated play ID -->
+            <Field Name="PlayID" Type="int64" />
+            <!-- Associated solution ID -->
+            <Field Name="SolutionID" Type="int64" />
+            <!-- Flag indicating 'sandbox', i.e. not to be implemented -->
+            <Field Name="Sandbox" Type="bool" Default="false" />
+        </Struct>
+        
+        <!-- Automation response with specific IMPACT supporting fields -->
+        <Struct Name="ImpactAutomationResponse" >
+            <!-- Response ID matching request from ({@link ImpactAutomationRequest}) -->
+            <Field Name="ResponseID" Type="int64" />
+            <!-- Automation response from the request -->
+            <Field Name="TrialResponse" Type="AutomationResponse" Series="CMASI" />
+            <!-- Associated play ID -->
+            <Field Name="PlayID" Type="int64" />
+            <!-- Associated solution ID -->
+            <Field Name="SolutionID" Type="int64" />
+            <!-- Flag indicating 'sandbox', i.e. not to be implemented -->
+            <Field Name="Sandbox" Type="bool" Default="false" />
+            <!-- Set of vehicle-to-task summaries that will be implemented by this automation response. Including timing, communication, and remaining energy -->
+            <Field Name="Summaries" Type="TaskSummary[]" />
+        </Struct>
+        
+        <!-- Point of interest -->
+        <Struct Name="PointOfInterest" >
+            <!-- ID for points of interest -->
+            <Field Name="PointID" Type="int64" />
+            
+            <!-- Point of interest location -->
+            <Field Name="Location" Type="Location3D" Series="CMASI" />
+            
+        </Struct>
+        
+        <!-- Line of interest -->
+        <Struct Name="LineOfInterest" >
+            <!-- ID for lines of interest -->
+            <Field Name="LineID" Type="int64" />
+            
+            <!-- List of points to search -->
+            <Field Name="Line" Type="Location3D[]" Series="CMASI" />
+        </Struct>
+        
+        <!-- Area of interest -->
+        <Struct Name="AreaOfInterest" >
+            <!-- ID for area of interest -->
+            <Field Name="AreaID" Type="int64" />
+            
+            <!-- Geometry describing the area -->
+            <Field Name="Area" Type="AbstractGeometry" Series="CMASI" />
+            
+        </Struct>
+        
+        <!-- Impact Point Search Task -->
+        <Struct Name="ImpactPointSearchTask" Extends="SearchTask" Series="CMASI" >
+            <!-- Point to search (from available points of interest). Only valid if ID is non-zero -->
+            <Field Name="SearchLocationID" Type="int64" />
+
+            <!-- If search location ID is zero, then use direct coordinates -->
+            <Field Name="SearchLocation" Type="Location3D" Series="CMASI" />
+
+            <!--Minimum distance that an aircraft must maintain from the point of interest. -->
+            <Field Name="StandoffDistance" Type="real32" Units="meter" Default="0" />
+
+            <!-- A list of acceptable look-angles for this task.  Each wedge is defined relative to true North. To be a valid look angle, a sensor must be looking from a direction within the bounds of the wedge. -->
+            <Field Name="ViewAngleList" Type="Wedge[]" Series="CMASI" />
+			
+            <!-- Loiter action to complete to fulfill task. If null, then simply points camera but main trajectory does not change. Otherwise, completes the specified loiter action. -->
+            <Field Name="DesiredAction" Type="LoiterAction" Series="CMASI" Default="null"/>
+        </Struct>
+        
+        <!-- Search task with specified search pattern -->
+        <Struct Name="PatternSearchTask" Extends="SearchTask" Series="CMASI" >
+            <!-- Point at which to search is centered (from available points of interest) -->
+            <Field Name="SearchLocationID" Type="int64" />
+            <!-- If search search location ID is zero, then use direct coordinates -->
+            <Field Name="SearchLocation" Type="Location3D" Series="CMASI" />
+            <!-- Search pattern to use -->
+            <Field Name="Pattern" Type="AreaSearchPattern" Default="Spiral" />
+            <!-- Pattern extent -->
+            <Field Name="Extent" Type="real32" Units="meters" Default="0.0" />
+        </Struct>
+        
+        <!-- Area search task with specified direction -->
+        <Struct Name="AngledAreaSearchTask" Extends="SearchTask" Series="CMASI" >
+            <!-- Area to search (from available areas of interest) -->
+            <Field Name="SearchAreaID" Type="int64" />
+
+            <!-- Sweep angle defined from true North in clockwise manner -->
+            <Field Name="SweepAngle" Type="real32" Units="degrees" />
+            
+            <!-- Start point for this search -->
+            <Field Name="StartPoint" Type="Location3D" Series="CMASI" />
+        </Struct>
+        
+        <!-- Defines a line search task.
+            A line search is a list of points that forms a polyline.  The ViewAngleList determines
+            from which direction the line may be viewed.  View angles are specified using the {@link Wedge} type. If the
+            UseInertialViewAngles option is true, then wedges are defined in terms of North-East coordinates, otherwise
+            wedges are defined relative to the line segment currently being viewed (a vector from point i through point i+1).
+            To be a valid look angle, the line segment must be viewed from an angle within the bounds of the wedge.
+        -->
+        <Struct Name="ImpactLineSearchTask" Extends="SearchTask" Series="CMASI" >
+
+            <!-- ID of line to search (from available lines of interest) -->
+            <Field Name="LineID" Type="int64" />
+
+            <!-- Defines a list of acceptable look-angles for this task.  See the documentation above for details. -->
+            <Field Name="ViewAngleList" Type="Wedge[]" Series="CMASI" />
+
+            <!-- If true, the ViewAngleList specifies inertial (North-East) angles. See documentation above. -->
+            <Field Name="UseInertialViewAngles" Type="bool" Default="false"/>
+        </Struct>
+        
+        <!-- Vehicle Watch task -->
+        <Struct Name="WatchTask" Extends="SearchTask" Series="CMASI" >
+            <!-- Entity ID to follow and watch -->
+            <Field Name="WatchedEntityID" Type="int64" />
+        </Struct>
+        
+        <!-- Multi vehicle overwatch task -->
+        <Struct Name="MultiVehicleWatchTask" Extends="SearchTask" Series="CMASI" >
+            <!-- Entity ID to follow and watch -->
+            <Field Name="WatchedEntityID" Type="int64" />
+            <!-- Number of vehicles to simultaneously overwatch the target -->
+            <Field Name="NumberVehicles" Type="byte" Default="1" />
+        </Struct>
+		
+        <!-- Task for providing comm relay support -->
+        <Struct Name="CommRelayTask" Extends="Task" Series="CMASI" >
+            <!-- ID of entity which requires comm relay support -->
+            <Field Name="SupportedEntityID" Type="int64" />
+			
+            <!-- Destination location for supported entity -->
+            <Field Name="DestinationLocation" Type="CMASI/Location3D" />
+			
+            <!-- ID of entity to which communication will be delivered (i.e. Tower ID) -->
+            <Field Name="TowerID" Type="int64" />
+        </Struct>
+        
+        <!-- Task for using multiple ground vehicles to block access to an area. Given a
+        point to secure and a standoff distance, task identifies number (K) routes that must
+        be blocked to successfully deny access to the area. If there are not enough eligible
+        vehicles, then this task will use the maximum number of eligible vehicles in a best
+        effort strategy which attempts to maximize radial coverage. -->
+        <Struct Name="CordonTask" Extends="Task" Series="CMASI" >
+            <!-- Block road access to this location -->
+            <Field Name="CordonLocation" Type="CMASI/Location3D" />
+			
+            <!-- Distance away from 'CordonLocation' that access should be blocked -->
+            <Field Name="StandoffDistance" Type="real32" Units="meters" Default="100" />
+        </Struct>
+        
+        <!-- Task for using multiple vehicles to surround an entity, for example,
+        multiple surface vehicles surrounding incoming enemy ship. -->
+        <Struct Name="BlockadeTask" Extends="Task" Series="CMASI" >
+            <!-- Entity to surround and deny access -->
+            <Field Name="BlockedEntityID" Type="int64" />
+            <!-- When in blocking formation, the distance that vehicles should stand off. -->
+            <Field Name="StandoffDistance" Type="real32" Units="meters" Default="0" />
+            <!-- Number of vehicles to simultaneously block the target -->
+            <Field Name="NumberVehicles" Type="byte" Default="1" />
+            <!-- Biases the blockade so that more vehicles are between enemy and protected
+            location. If no location is given, then blockade attempts to block in direction
+            of enemy travel -->
+            <Field Name="ProtectedLocation" Type="CMASI/Location3D" Default="NULL" />
+        </Struct>
+        
+		<!-- Task for targeting surveillance at an offset of a moving entity, for example to
+        scout ahead of a convoy. -->
+        <Struct Name="EscortTask" Extends="SearchTask" Series="CMASI" >
+            <!-- ID of entity which will provide the basis for the escort. Tasked vehicle
+            will attempt to stay 'StandoffDistance' ahead of this entity on its route. -->
+            <Field Name="SupportedEntityID" Type="int64" />
+			
+            <!-- ID of line which describes the route that the 'SupportedEntityID' is following.
+            If the 'SupportedEntityID' is one of the controlled entities, such as a taskable ground
+            vehicle, then 'RouteID' can be zero and this task will use current, known route for that
+            vehicle. Otherwise, 'RouteID' must be an ID for a previously described '{@link LineOfInterest}'. -->
+            <Field Name="RouteID" Type="int64" />
+			
+            <!-- Waypoints that the supported entity is presumed to be following if 'RouteID' is zero -->
+            <Field Name="PrescribedWaypoints" Type="CMASI/Waypoint[]" />
+            
+            <!-- Distance ahead (positive) or behind (negative) that the vehicle will provide
+            surveillance relative to 'SupportedEntityID's location on route 'RouteID' -->
+            <Field Name="StandoffDistance" Type="real32" Units="meters" Default="100" />
+        </Struct>
+
+        <!-- Requests the latest configurations for vehicles in the system -->
+        <Struct Name="ConfigurationRequest">
+            <!-- Vehicle IDs for which the corresponding configuration should be sent. If the list is empty, all available configurations should be sent in response. -->
+            <Field Name="VehicleID" Type="int64[]" />
+        </Struct>
+        
+        <!-- Provides information regarding a vehicle's configuration items. -->
+        <Struct Name="GroundVehicleConfiguration" Extends="CMASI/EntityConfiguration">
+            
+            <!-- Valid operational road network. UGV adheres to positions defined in this graph. Indicated by previously sent GraphRegion's ID -->
+            <Field Name="RoadGraphID" Type="int64" />
+
+            <!-- The minimum speed that should be commanded for this vehicle -->
+            <Field Name="MinimumSpeed" Type="real32" Units="meter/sec" />
+
+            <!-- The maximum speed that should be commanded for this vehicle -->
+            <Field Name="MaximumSpeed" Type="real32" Units="meter/sec" />
+            
+            <!--
+                The consumption rate of available energy at nominal speed, expressed in terms of the percentage of maximum capacity used per second.
+            -->
+            <Field Name="EnergyRate" Type="real32" Units="%/sec" />
+
+        </Struct>
+        
+        <!--Provides basic state information regarding entity position, orientation, and velocity.
+        -->
+        <Struct Name="GroundVehicleState" Extends="CMASI/EntityState">
+
+        </Struct>
+         
+        <!-- Reports on navigability of the water in the "Area".  Based on the WeatherReport CMASI message, designed to allow changes during execution. -->
+        <Struct Name="WaterReport">
+            <!-- Area for which this report is valid -->
+            <Field Name="Area" Type="AbstractGeometry" Series="CMASI"/>
+            <!-- Speed of the current, e.g. due to tides or river flow -->
+            <Field Name="CurrentSpeed" Type="real32" Units="meters/sec"/>
+            <!-- Direction of the current -->
+            <Field Name="CurrentDirection" Type="real32" Units="degree"/>
+            <!-- Wave direction of travel.  Generally in the direction of the wind, except near sea coasts-->
+            <Field Name="WaveDirection" Type="real32" Units="degree"/>
+            <!-- Average wave height -->
+            <Field Name="WaveHeight" Type="real32" Units="meters"/>
+        </Struct>
+        
+        <!-- Region that defines water areas navigable for surface vehicles. Ground vehicles
+        should not enter this zone. -->
+        <Struct Name="WaterZone" Extends="CMASI/AbstractZone" />
+        
+        <!-- Provides information regarding a vehicle's configuration items. -->
+        <Struct Name="SurfaceVehicleConfiguration" Extends="CMASI/EntityConfiguration">
+            
+            <!-- Valid operational water zone (by ID). USV adheres to this area  -->
+            <Field Name="WaterArea" Type="int64" />
+
+            <!-- The minimum speed that should be commanded for this vehicle -->
+            <Field Name="MinimumSpeed" Type="real32" Units="meter/sec" />
+
+            <!-- The maximum speed that should be commanded for this vehicle -->
+            <Field Name="MaximumSpeed" Type="real32" Units="meter/sec" />
+            
+            <!--
+                The consumption rate of available energy at nominal speed, expressed in terms of the percentage of maximum capacity used per second.
+            -->
+            <Field Name="EnergyRate" Type="real32" Units="%/sec" />
+            
+            <!-- The maximum angle that this vehicle will bank -->
+            <Field Name="MaxBankAngle" Type="real32" Units="degree" />
+            
+            <!-- The maximum angular rate that this vehicle will bank -->
+            <Field Name="MaxBankRate" Type="real32" Units="degree/sec" />
+
+        </Struct>
+        
+        <!--Provides basic state information regarding entity position, orientation, and velocity.
+        -->
+        <Struct Name="SurfaceVehicleState" Extends="CMASI/EntityState">
+
+            <!-- Current bank angle of the surface vehicle -->
+            <Field Name="BankAngle" Type="real32" Units="degree" />
+
+            <!-- Forward speed of the vehicle relative to the mass of water -->
+            <Field Name="Speed" Type="real32" Units="meter/sec" />
+
+        </Struct>
+ </StructList>
+</MDM>
diff --git a/src/LMCP/LMCP.vcproj b/src/LMCP/LMCP.vcproj
new file mode 100644
index 0000000..fc9d4ff
--- /dev/null
+++ b/src/LMCP/LMCP.vcproj
@@ -0,0 +1,560 @@
+<!-- This file was auto-created by LmcpGen. Modifications will be overwritten. -->
+<?xml version="1.0" encoding="UTF-8"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="LMCPBuild"
+	ProjectGUID="{28301551-138D-49FD-8979-412110FBE88A}"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="0"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="4"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+                                AdditionalIncludeDirectories=".\"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="4"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="3"
+                                AdditionalIncludeDirectories="./"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{84C50A63-CB84-451A-8259-C8D30604F6E3}"
+			>
+			<Filter Name="lmcp">
+			   <File RelativePath=".\avtas\lmcp\ByteBuffer.h"> </File>
+			   <File RelativePath=".\avtas\lmcp\Factory.h"> </File>
+			   <File RelativePath=".\avtas\lmcp\LmcpXMLReader.h"> </File>
+			   <File RelativePath=".\avtas\lmcp\Node.h"> </File>
+			   <File RelativePath=".\avtas\lmcp\NodeUtil.h"> </File>
+			   <File RelativePath=".\avtas\lmcp\Object.h"> </File>
+			   <File RelativePath=".\avtas\lmcp\XMLParser.h"> </File>
+			</Filter>
+			<Filter Name="uxas\messages\task">
+			   <File RelativePath=".\uxas\messages\task\AssignmentCoordinatorTask.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\PlanningState.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\AssignmentCoordination.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\CoordinatedAutomationRequest.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskAutomationRequest.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskAutomationResponse.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\UniqueAutomationRequest.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\UniqueAutomationResponse.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\SensorFootprintRequests.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\FootprintRequest.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\SensorFootprint.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\SensorFootprintResponse.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskImplementationRequest.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskImplementationResponse.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\AssignmentCostMatrix.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskOptionCost.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskAssignment.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskAssignmentSummary.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskOption.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskPlanOptions.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskPause.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskResume.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskProgress.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskProgressRequest.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskInitialized.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskActive.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\TaskComplete.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\CancelTask.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\UXTASKXMLReader.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\UXTASKEnum.h"> </File>
+			   <File RelativePath=".\uxas\messages\task\UXTASK.h"> </File>
+			</Filter>
+			<Filter Name="uxas\messages\uxnative">
+			   <File RelativePath=".\uxas\messages\uxnative\VideoRecord.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\StartupComplete.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\CreateNewService.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\KillService.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\IncrementWaypoint.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\EntityLocation.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\BandwidthTest.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\BandwidthReceiveReport.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\SubTaskExecution.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\SubTaskAssignment.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\AutopilotKeepAlive.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\OnboardProcessorIsAlive.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\EntityJoin.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\EntityExit.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\UXNATIVEXMLReader.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\UXNATIVEEnum.h"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\UXNATIVE.h"> </File>
+			</Filter>
+			<Filter Name="uxas\messages\route">
+			   <File RelativePath=".\uxas\messages\route\GraphNode.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\GraphEdge.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\GraphRegion.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\RouteConstraints.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\RouteRequest.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\RoutePlanRequest.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\RoutePlan.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\RoutePlanResponse.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\RouteResponse.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\EgressRouteRequest.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\EgressRouteResponse.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\ROUTEXMLReader.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\ROUTEEnum.h"> </File>
+			   <File RelativePath=".\uxas\messages\route\ROUTE.h"> </File>
+			</Filter>
+			<Filter Name="afrl\cmasi">
+			   <File RelativePath=".\afrl\cmasi\AbstractGeometry.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\KeyValuePair.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\Location3D.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\PayloadAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\PayloadConfiguration.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\PayloadState.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\VehicleAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\Task.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\SearchTask.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\AbstractZone.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\EntityConfiguration.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\FlightProfile.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\AirVehicleConfiguration.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\EntityState.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\AirVehicleState.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\Wedge.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\AreaSearchTask.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\CameraAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\CameraConfiguration.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\GimballedPayloadState.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\CameraState.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\Circle.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\GimbalAngleAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\GimbalConfiguration.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\GimbalScanAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\GimbalStareAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\GimbalState.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\GoToWaypointAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\KeepInZone.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\KeepOutZone.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\LineSearchTask.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\NavigationAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\LoiterAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\LoiterTask.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\Waypoint.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\MissionCommand.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\MustFlyTask.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\OperatorSignal.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\OperatingRegion.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\AutomationRequest.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\PointSearchTask.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\Polygon.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\Rectangle.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\RemoveTasks.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\ServiceStatus.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\SessionStatus.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\VehicleActionCommand.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\VideoStreamAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\VideoStreamConfiguration.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\VideoStreamState.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\AutomationResponse.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\RemoveZones.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\RemoveEntities.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\FlightDirectorAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\WeatherReport.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\FollowPathCommand.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\PathWaypoint.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\StopMovementAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\WaypointTransfer.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\PayloadStowAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\WavelengthBand.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\NavigationMode.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\FOVOperationMode.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\GimbalPointingMode.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\ZoneAvoidanceType.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\LoiterType.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\LoiterDirection.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\ServiceStatusType.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\SimulationStatusType.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\SpeedType.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\TurnType.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\CommandStatusType.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\AltitudeType.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\TravelMode.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\WaypointTransferMode.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\CMASIXMLReader.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\CMASIEnum.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\CMASI.h"> </File>
+			</Filter>
+			<Filter Name="afrl\impact">
+			   <File RelativePath=".\afrl\impact\PowerConfiguration.h"> </File>
+			   <File RelativePath=".\afrl\impact\RadioConfiguration.h"> </File>
+			   <File RelativePath=".\afrl\impact\RadioTowerConfiguration.h"> </File>
+			   <File RelativePath=".\afrl\impact\RadioState.h"> </File>
+			   <File RelativePath=".\afrl\impact\RadioTowerState.h"> </File>
+			   <File RelativePath=".\afrl\impact\ImpactPayloadConfiguration.h"> </File>
+			   <File RelativePath=".\afrl\impact\DeployImpactPayload.h"> </File>
+			   <File RelativePath=".\afrl\impact\PowerPlantState.h"> </File>
+			   <File RelativePath=".\afrl\impact\BatchRoutePlanRequest.h"> </File>
+			   <File RelativePath=".\afrl\impact\BatchRoutePlanResponse.h"> </File>
+			   <File RelativePath=".\afrl\impact\TaskTimingPair.h"> </File>
+			   <File RelativePath=".\afrl\impact\BatchSummaryRequest.h"> </File>
+			   <File RelativePath=".\afrl\impact\BatchSummaryResponse.h"> </File>
+			   <File RelativePath=".\afrl\impact\TaskSummary.h"> </File>
+			   <File RelativePath=".\afrl\impact\VehicleSummary.h"> </File>
+			   <File RelativePath=".\afrl\impact\ImpactHeartbeat.h"> </File>
+			   <File RelativePath=".\afrl\impact\ImpactComponentJoin.h"> </File>
+			   <File RelativePath=".\afrl\impact\ImpactComponentLeave.h"> </File>
+			   <File RelativePath=".\afrl\impact\SpeedAltPair.h"> </File>
+			   <File RelativePath=".\afrl\impact\ImpactAutomationRequest.h"> </File>
+			   <File RelativePath=".\afrl\impact\ImpactAutomationResponse.h"> </File>
+			   <File RelativePath=".\afrl\impact\PointOfInterest.h"> </File>
+			   <File RelativePath=".\afrl\impact\LineOfInterest.h"> </File>
+			   <File RelativePath=".\afrl\impact\AreaOfInterest.h"> </File>
+			   <File RelativePath=".\afrl\impact\ImpactPointSearchTask.h"> </File>
+			   <File RelativePath=".\afrl\impact\PatternSearchTask.h"> </File>
+			   <File RelativePath=".\afrl\impact\AngledAreaSearchTask.h"> </File>
+			   <File RelativePath=".\afrl\impact\ImpactLineSearchTask.h"> </File>
+			   <File RelativePath=".\afrl\impact\WatchTask.h"> </File>
+			   <File RelativePath=".\afrl\impact\MultiVehicleWatchTask.h"> </File>
+			   <File RelativePath=".\afrl\impact\CommRelayTask.h"> </File>
+			   <File RelativePath=".\afrl\impact\CordonTask.h"> </File>
+			   <File RelativePath=".\afrl\impact\BlockadeTask.h"> </File>
+			   <File RelativePath=".\afrl\impact\EscortTask.h"> </File>
+			   <File RelativePath=".\afrl\impact\ConfigurationRequest.h"> </File>
+			   <File RelativePath=".\afrl\impact\GroundVehicleConfiguration.h"> </File>
+			   <File RelativePath=".\afrl\impact\GroundVehicleState.h"> </File>
+			   <File RelativePath=".\afrl\impact\WaterReport.h"> </File>
+			   <File RelativePath=".\afrl\impact\WaterZone.h"> </File>
+			   <File RelativePath=".\afrl\impact\SurfaceVehicleConfiguration.h"> </File>
+			   <File RelativePath=".\afrl\impact\SurfaceVehicleState.h"> </File>
+			   <File RelativePath=".\afrl\impact\AreaSearchPattern.h"> </File>
+			   <File RelativePath=".\afrl\impact\PowerPlant.h"> </File>
+			   <File RelativePath=".\afrl\impact\ImpactPayloadType.h"> </File>
+			   <File RelativePath=".\afrl\impact\IMPACTXMLReader.h"> </File>
+			   <File RelativePath=".\afrl\impact\IMPACTEnum.h"> </File>
+			   <File RelativePath=".\afrl\impact\IMPACT.h"> </File>
+			</Filter>
+			<Filter Name="afrl\cmasi\perceive">
+			   <File RelativePath=".\afrl\cmasi\perceive\EntityPerception.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\perceive\TrackEntityAction.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\perceive\TrackEntityTask.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\perceive\PERCEIVEXMLReader.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\perceive\PERCEIVEEnum.h"> </File>
+			   <File RelativePath=".\afrl\cmasi\perceive\PERCEIVE.h"> </File>
+			</Filter>
+
+		</Filter>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{FDBB06A5-2790-4AE8-AD87-5F4AF152AB5B}"
+			>
+			<!--File
+				RelativePath=".\main.cpp"
+				>
+			</File-->
+			<Filter Name="lmcp">
+			   <File RelativePath=".\avtas\lmcp\ByteBuffer.cpp"> </File>
+			   <File RelativePath=".\avtas\lmcp\Factory.cpp"> </File>
+			   <File RelativePath=".\avtas\lmcp\Node.cpp"> </File>
+			   <File RelativePath=".\avtas\lmcp\NodeUtil.cpp"> </File>
+			   <File RelativePath=".\avtas\lmcp\XMLParser.cpp"> </File>
+			</Filter>
+			<Filter Name="uxas\messages\task">
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskAssignmentCoordinatorTask.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskPlanningState.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskAssignmentCoordination.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskCoordinatedAutomationRequest.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskAutomationRequest.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskAutomationResponse.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskUniqueAutomationRequest.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskUniqueAutomationResponse.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskSensorFootprintRequests.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskFootprintRequest.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskSensorFootprint.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskSensorFootprintResponse.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskImplementationRequest.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskImplementationResponse.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskAssignmentCostMatrix.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskOptionCost.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskAssignment.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskAssignmentSummary.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskOption.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskPlanOptions.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskPause.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskResume.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskProgress.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskProgressRequest.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskInitialized.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskActive.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskTaskComplete.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\uxasmessagestaskCancelTask.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\task\UXTASKXMLReader.cpp"> </File>
+			</Filter>
+			<Filter Name="uxas\messages\uxnative">
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeVideoRecord.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeStartupComplete.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeCreateNewService.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeKillService.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeIncrementWaypoint.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeEntityLocation.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeBandwidthTest.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeBandwidthReceiveReport.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeSubTaskExecution.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeSubTaskAssignment.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeAutopilotKeepAlive.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeOnboardProcessorIsAlive.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeEntityJoin.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\uxasmessagesuxnativeEntityExit.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\uxnative\UXNATIVEXMLReader.cpp"> </File>
+			</Filter>
+			<Filter Name="uxas\messages\route">
+			   <File RelativePath=".\uxas\messages\route\uxasmessagesrouteGraphNode.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\route\uxasmessagesrouteGraphEdge.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\route\uxasmessagesrouteGraphRegion.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\route\uxasmessagesrouteRouteConstraints.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\route\uxasmessagesrouteRouteRequest.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\route\uxasmessagesrouteRoutePlanRequest.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\route\uxasmessagesrouteRoutePlan.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\route\uxasmessagesrouteRoutePlanResponse.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\route\uxasmessagesrouteRouteResponse.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\route\uxasmessagesrouteEgressRouteRequest.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\route\uxasmessagesrouteEgressRouteResponse.cpp"> </File>
+			   <File RelativePath=".\uxas\messages\route\ROUTEXMLReader.cpp"> </File>
+			</Filter>
+			<Filter Name="afrl\cmasi">
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiAbstractGeometry.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiKeyValuePair.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiLocation3D.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiPayloadAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiPayloadConfiguration.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiPayloadState.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiVehicleAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiTask.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiSearchTask.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiAbstractZone.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiEntityConfiguration.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiFlightProfile.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiAirVehicleConfiguration.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiEntityState.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiAirVehicleState.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiWedge.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiAreaSearchTask.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiCameraAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiCameraConfiguration.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiGimballedPayloadState.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiCameraState.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiCircle.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiGimbalAngleAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiGimbalConfiguration.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiGimbalScanAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiGimbalStareAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiGimbalState.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiGoToWaypointAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiKeepInZone.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiKeepOutZone.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiLineSearchTask.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiNavigationAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiLoiterAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiLoiterTask.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiWaypoint.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiMissionCommand.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiMustFlyTask.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiOperatorSignal.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiOperatingRegion.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiAutomationRequest.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiPointSearchTask.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiPolygon.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiRectangle.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiRemoveTasks.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiServiceStatus.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiSessionStatus.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiVehicleActionCommand.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiVideoStreamAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiVideoStreamConfiguration.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiVideoStreamState.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiAutomationResponse.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiRemoveZones.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiRemoveEntities.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiFlightDirectorAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiWeatherReport.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiFollowPathCommand.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiPathWaypoint.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiStopMovementAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiWaypointTransfer.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\afrlcmasiPayloadStowAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\CMASIXMLReader.cpp"> </File>
+			</Filter>
+			<Filter Name="afrl\impact">
+			   <File RelativePath=".\afrl\impact\afrlimpactPowerConfiguration.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactRadioConfiguration.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactRadioTowerConfiguration.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactRadioState.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactRadioTowerState.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactImpactPayloadConfiguration.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactDeployImpactPayload.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactPowerPlantState.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactBatchRoutePlanRequest.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactBatchRoutePlanResponse.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactTaskTimingPair.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactBatchSummaryRequest.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactBatchSummaryResponse.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactTaskSummary.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactVehicleSummary.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactImpactHeartbeat.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactImpactComponentJoin.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactImpactComponentLeave.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactSpeedAltPair.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactImpactAutomationRequest.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactImpactAutomationResponse.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactPointOfInterest.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactLineOfInterest.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactAreaOfInterest.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactImpactPointSearchTask.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactPatternSearchTask.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactAngledAreaSearchTask.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactImpactLineSearchTask.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactWatchTask.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactMultiVehicleWatchTask.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactCommRelayTask.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactCordonTask.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactBlockadeTask.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactEscortTask.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactConfigurationRequest.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactGroundVehicleConfiguration.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactGroundVehicleState.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactWaterReport.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactWaterZone.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactSurfaceVehicleConfiguration.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\afrlimpactSurfaceVehicleState.cpp"> </File>
+			   <File RelativePath=".\afrl\impact\IMPACTXMLReader.cpp"> </File>
+			</Filter>
+			<Filter Name="afrl\cmasi\perceive">
+			   <File RelativePath=".\afrl\cmasi\perceive\afrlcmasiperceiveEntityPerception.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\perceive\afrlcmasiperceiveTrackEntityAction.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\perceive\afrlcmasiperceiveTrackEntityTask.cpp"> </File>
+			   <File RelativePath=".\afrl\cmasi\perceive\PERCEIVEXMLReader.cpp"> </File>
+			</Filter>
+
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/src/LMCP/LMCP.vcxproj b/src/LMCP/LMCP.vcxproj
new file mode 100644
index 0000000..67a1c3c
--- /dev/null
+++ b/src/LMCP/LMCP.vcxproj
@@ -0,0 +1,448 @@
+<!-- This file was auto-created by LmcpGen. Modifications will be overwritten. -->
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectName>LMCPBuild</ProjectName>
+    <ProjectGuid>{F84DA9F4-D917-4552-BC4A-A88E79EAF1A0}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v120</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v120</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Debug\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Debug\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Release\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Release\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>.\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <AdditionalIncludeDirectories>./;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+           <ClInclude Include="avtas\lmcp\ByteBuffer.h"/>
+       <ClInclude Include="avtas\lmcp\Factory.h"/>
+       <ClInclude Include="avtas\lmcp\LmcpXMLReader.h"/>
+       <ClInclude Include="avtas\lmcp\Node.h"/>
+       <ClInclude Include="avtas\lmcp\NodeUtil.h"/>
+       <ClInclude Include="avtas\lmcp\Object.h"/>
+       <ClInclude Include="avtas\lmcp\XMLParser.h"/>
+       <ClInclude Include="uxas\messages\task\AssignmentCoordinatorTask.h"/>
+       <ClInclude Include="uxas\messages\task\PlanningState.h"/>
+       <ClInclude Include="uxas\messages\task\AssignmentCoordination.h"/>
+       <ClInclude Include="uxas\messages\task\CoordinatedAutomationRequest.h"/>
+       <ClInclude Include="uxas\messages\task\TaskAutomationRequest.h"/>
+       <ClInclude Include="uxas\messages\task\TaskAutomationResponse.h"/>
+       <ClInclude Include="uxas\messages\task\UniqueAutomationRequest.h"/>
+       <ClInclude Include="uxas\messages\task\UniqueAutomationResponse.h"/>
+       <ClInclude Include="uxas\messages\task\SensorFootprintRequests.h"/>
+       <ClInclude Include="uxas\messages\task\FootprintRequest.h"/>
+       <ClInclude Include="uxas\messages\task\SensorFootprint.h"/>
+       <ClInclude Include="uxas\messages\task\SensorFootprintResponse.h"/>
+       <ClInclude Include="uxas\messages\task\TaskImplementationRequest.h"/>
+       <ClInclude Include="uxas\messages\task\TaskImplementationResponse.h"/>
+       <ClInclude Include="uxas\messages\task\AssignmentCostMatrix.h"/>
+       <ClInclude Include="uxas\messages\task\TaskOptionCost.h"/>
+       <ClInclude Include="uxas\messages\task\TaskAssignment.h"/>
+       <ClInclude Include="uxas\messages\task\TaskAssignmentSummary.h"/>
+       <ClInclude Include="uxas\messages\task\TaskOption.h"/>
+       <ClInclude Include="uxas\messages\task\TaskPlanOptions.h"/>
+       <ClInclude Include="uxas\messages\task\TaskPause.h"/>
+       <ClInclude Include="uxas\messages\task\TaskResume.h"/>
+       <ClInclude Include="uxas\messages\task\TaskProgress.h"/>
+       <ClInclude Include="uxas\messages\task\TaskProgressRequest.h"/>
+       <ClInclude Include="uxas\messages\task\TaskInitialized.h"/>
+       <ClInclude Include="uxas\messages\task\TaskActive.h"/>
+       <ClInclude Include="uxas\messages\task\TaskComplete.h"/>
+       <ClInclude Include="uxas\messages\task\CancelTask.h"/>
+       <ClInclude Include="uxas\messages\task\UXTASKXMLReader.h"/>
+       <ClInclude Include="uxas\messages\task\UXTASKEnum.h"/>
+       <ClInclude Include="uxas\messages\task\UXTASK.h"/>
+       <ClInclude Include="uxas\messages\uxnative\VideoRecord.h"/>
+       <ClInclude Include="uxas\messages\uxnative\StartupComplete.h"/>
+       <ClInclude Include="uxas\messages\uxnative\CreateNewService.h"/>
+       <ClInclude Include="uxas\messages\uxnative\KillService.h"/>
+       <ClInclude Include="uxas\messages\uxnative\IncrementWaypoint.h"/>
+       <ClInclude Include="uxas\messages\uxnative\EntityLocation.h"/>
+       <ClInclude Include="uxas\messages\uxnative\BandwidthTest.h"/>
+       <ClInclude Include="uxas\messages\uxnative\BandwidthReceiveReport.h"/>
+       <ClInclude Include="uxas\messages\uxnative\SubTaskExecution.h"/>
+       <ClInclude Include="uxas\messages\uxnative\SubTaskAssignment.h"/>
+       <ClInclude Include="uxas\messages\uxnative\AutopilotKeepAlive.h"/>
+       <ClInclude Include="uxas\messages\uxnative\OnboardProcessorIsAlive.h"/>
+       <ClInclude Include="uxas\messages\uxnative\EntityJoin.h"/>
+       <ClInclude Include="uxas\messages\uxnative\EntityExit.h"/>
+       <ClInclude Include="uxas\messages\uxnative\UXNATIVEXMLReader.h"/>
+       <ClInclude Include="uxas\messages\uxnative\UXNATIVEEnum.h"/>
+       <ClInclude Include="uxas\messages\uxnative\UXNATIVE.h"/>
+       <ClInclude Include="uxas\messages\route\GraphNode.h"/>
+       <ClInclude Include="uxas\messages\route\GraphEdge.h"/>
+       <ClInclude Include="uxas\messages\route\GraphRegion.h"/>
+       <ClInclude Include="uxas\messages\route\RouteConstraints.h"/>
+       <ClInclude Include="uxas\messages\route\RouteRequest.h"/>
+       <ClInclude Include="uxas\messages\route\RoutePlanRequest.h"/>
+       <ClInclude Include="uxas\messages\route\RoutePlan.h"/>
+       <ClInclude Include="uxas\messages\route\RoutePlanResponse.h"/>
+       <ClInclude Include="uxas\messages\route\RouteResponse.h"/>
+       <ClInclude Include="uxas\messages\route\EgressRouteRequest.h"/>
+       <ClInclude Include="uxas\messages\route\EgressRouteResponse.h"/>
+       <ClInclude Include="uxas\messages\route\ROUTEXMLReader.h"/>
+       <ClInclude Include="uxas\messages\route\ROUTEEnum.h"/>
+       <ClInclude Include="uxas\messages\route\ROUTE.h"/>
+       <ClInclude Include="afrl\cmasi\AbstractGeometry.h"/>
+       <ClInclude Include="afrl\cmasi\KeyValuePair.h"/>
+       <ClInclude Include="afrl\cmasi\Location3D.h"/>
+       <ClInclude Include="afrl\cmasi\PayloadAction.h"/>
+       <ClInclude Include="afrl\cmasi\PayloadConfiguration.h"/>
+       <ClInclude Include="afrl\cmasi\PayloadState.h"/>
+       <ClInclude Include="afrl\cmasi\VehicleAction.h"/>
+       <ClInclude Include="afrl\cmasi\Task.h"/>
+       <ClInclude Include="afrl\cmasi\SearchTask.h"/>
+       <ClInclude Include="afrl\cmasi\AbstractZone.h"/>
+       <ClInclude Include="afrl\cmasi\EntityConfiguration.h"/>
+       <ClInclude Include="afrl\cmasi\FlightProfile.h"/>
+       <ClInclude Include="afrl\cmasi\AirVehicleConfiguration.h"/>
+       <ClInclude Include="afrl\cmasi\EntityState.h"/>
+       <ClInclude Include="afrl\cmasi\AirVehicleState.h"/>
+       <ClInclude Include="afrl\cmasi\Wedge.h"/>
+       <ClInclude Include="afrl\cmasi\AreaSearchTask.h"/>
+       <ClInclude Include="afrl\cmasi\CameraAction.h"/>
+       <ClInclude Include="afrl\cmasi\CameraConfiguration.h"/>
+       <ClInclude Include="afrl\cmasi\GimballedPayloadState.h"/>
+       <ClInclude Include="afrl\cmasi\CameraState.h"/>
+       <ClInclude Include="afrl\cmasi\Circle.h"/>
+       <ClInclude Include="afrl\cmasi\GimbalAngleAction.h"/>
+       <ClInclude Include="afrl\cmasi\GimbalConfiguration.h"/>
+       <ClInclude Include="afrl\cmasi\GimbalScanAction.h"/>
+       <ClInclude Include="afrl\cmasi\GimbalStareAction.h"/>
+       <ClInclude Include="afrl\cmasi\GimbalState.h"/>
+       <ClInclude Include="afrl\cmasi\GoToWaypointAction.h"/>
+       <ClInclude Include="afrl\cmasi\KeepInZone.h"/>
+       <ClInclude Include="afrl\cmasi\KeepOutZone.h"/>
+       <ClInclude Include="afrl\cmasi\LineSearchTask.h"/>
+       <ClInclude Include="afrl\cmasi\NavigationAction.h"/>
+       <ClInclude Include="afrl\cmasi\LoiterAction.h"/>
+       <ClInclude Include="afrl\cmasi\LoiterTask.h"/>
+       <ClInclude Include="afrl\cmasi\Waypoint.h"/>
+       <ClInclude Include="afrl\cmasi\MissionCommand.h"/>
+       <ClInclude Include="afrl\cmasi\MustFlyTask.h"/>
+       <ClInclude Include="afrl\cmasi\OperatorSignal.h"/>
+       <ClInclude Include="afrl\cmasi\OperatingRegion.h"/>
+       <ClInclude Include="afrl\cmasi\AutomationRequest.h"/>
+       <ClInclude Include="afrl\cmasi\PointSearchTask.h"/>
+       <ClInclude Include="afrl\cmasi\Polygon.h"/>
+       <ClInclude Include="afrl\cmasi\Rectangle.h"/>
+       <ClInclude Include="afrl\cmasi\RemoveTasks.h"/>
+       <ClInclude Include="afrl\cmasi\ServiceStatus.h"/>
+       <ClInclude Include="afrl\cmasi\SessionStatus.h"/>
+       <ClInclude Include="afrl\cmasi\VehicleActionCommand.h"/>
+       <ClInclude Include="afrl\cmasi\VideoStreamAction.h"/>
+       <ClInclude Include="afrl\cmasi\VideoStreamConfiguration.h"/>
+       <ClInclude Include="afrl\cmasi\VideoStreamState.h"/>
+       <ClInclude Include="afrl\cmasi\AutomationResponse.h"/>
+       <ClInclude Include="afrl\cmasi\RemoveZones.h"/>
+       <ClInclude Include="afrl\cmasi\RemoveEntities.h"/>
+       <ClInclude Include="afrl\cmasi\FlightDirectorAction.h"/>
+       <ClInclude Include="afrl\cmasi\WeatherReport.h"/>
+       <ClInclude Include="afrl\cmasi\FollowPathCommand.h"/>
+       <ClInclude Include="afrl\cmasi\PathWaypoint.h"/>
+       <ClInclude Include="afrl\cmasi\StopMovementAction.h"/>
+       <ClInclude Include="afrl\cmasi\WaypointTransfer.h"/>
+       <ClInclude Include="afrl\cmasi\PayloadStowAction.h"/>
+       <ClInclude Include="afrl\cmasi\WavelengthBand.h"/>
+       <ClInclude Include="afrl\cmasi\NavigationMode.h"/>
+       <ClInclude Include="afrl\cmasi\FOVOperationMode.h"/>
+       <ClInclude Include="afrl\cmasi\GimbalPointingMode.h"/>
+       <ClInclude Include="afrl\cmasi\ZoneAvoidanceType.h"/>
+       <ClInclude Include="afrl\cmasi\LoiterType.h"/>
+       <ClInclude Include="afrl\cmasi\LoiterDirection.h"/>
+       <ClInclude Include="afrl\cmasi\ServiceStatusType.h"/>
+       <ClInclude Include="afrl\cmasi\SimulationStatusType.h"/>
+       <ClInclude Include="afrl\cmasi\SpeedType.h"/>
+       <ClInclude Include="afrl\cmasi\TurnType.h"/>
+       <ClInclude Include="afrl\cmasi\CommandStatusType.h"/>
+       <ClInclude Include="afrl\cmasi\AltitudeType.h"/>
+       <ClInclude Include="afrl\cmasi\TravelMode.h"/>
+       <ClInclude Include="afrl\cmasi\WaypointTransferMode.h"/>
+       <ClInclude Include="afrl\cmasi\CMASIXMLReader.h"/>
+       <ClInclude Include="afrl\cmasi\CMASIEnum.h"/>
+       <ClInclude Include="afrl\cmasi\CMASI.h"/>
+       <ClInclude Include="afrl\impact\PowerConfiguration.h"/>
+       <ClInclude Include="afrl\impact\RadioConfiguration.h"/>
+       <ClInclude Include="afrl\impact\RadioTowerConfiguration.h"/>
+       <ClInclude Include="afrl\impact\RadioState.h"/>
+       <ClInclude Include="afrl\impact\RadioTowerState.h"/>
+       <ClInclude Include="afrl\impact\ImpactPayloadConfiguration.h"/>
+       <ClInclude Include="afrl\impact\DeployImpactPayload.h"/>
+       <ClInclude Include="afrl\impact\PowerPlantState.h"/>
+       <ClInclude Include="afrl\impact\BatchRoutePlanRequest.h"/>
+       <ClInclude Include="afrl\impact\BatchRoutePlanResponse.h"/>
+       <ClInclude Include="afrl\impact\TaskTimingPair.h"/>
+       <ClInclude Include="afrl\impact\BatchSummaryRequest.h"/>
+       <ClInclude Include="afrl\impact\BatchSummaryResponse.h"/>
+       <ClInclude Include="afrl\impact\TaskSummary.h"/>
+       <ClInclude Include="afrl\impact\VehicleSummary.h"/>
+       <ClInclude Include="afrl\impact\ImpactHeartbeat.h"/>
+       <ClInclude Include="afrl\impact\ImpactComponentJoin.h"/>
+       <ClInclude Include="afrl\impact\ImpactComponentLeave.h"/>
+       <ClInclude Include="afrl\impact\SpeedAltPair.h"/>
+       <ClInclude Include="afrl\impact\ImpactAutomationRequest.h"/>
+       <ClInclude Include="afrl\impact\ImpactAutomationResponse.h"/>
+       <ClInclude Include="afrl\impact\PointOfInterest.h"/>
+       <ClInclude Include="afrl\impact\LineOfInterest.h"/>
+       <ClInclude Include="afrl\impact\AreaOfInterest.h"/>
+       <ClInclude Include="afrl\impact\ImpactPointSearchTask.h"/>
+       <ClInclude Include="afrl\impact\PatternSearchTask.h"/>
+       <ClInclude Include="afrl\impact\AngledAreaSearchTask.h"/>
+       <ClInclude Include="afrl\impact\ImpactLineSearchTask.h"/>
+       <ClInclude Include="afrl\impact\WatchTask.h"/>
+       <ClInclude Include="afrl\impact\MultiVehicleWatchTask.h"/>
+       <ClInclude Include="afrl\impact\CommRelayTask.h"/>
+       <ClInclude Include="afrl\impact\CordonTask.h"/>
+       <ClInclude Include="afrl\impact\BlockadeTask.h"/>
+       <ClInclude Include="afrl\impact\EscortTask.h"/>
+       <ClInclude Include="afrl\impact\ConfigurationRequest.h"/>
+       <ClInclude Include="afrl\impact\GroundVehicleConfiguration.h"/>
+       <ClInclude Include="afrl\impact\GroundVehicleState.h"/>
+       <ClInclude Include="afrl\impact\WaterReport.h"/>
+       <ClInclude Include="afrl\impact\WaterZone.h"/>
+       <ClInclude Include="afrl\impact\SurfaceVehicleConfiguration.h"/>
+       <ClInclude Include="afrl\impact\SurfaceVehicleState.h"/>
+       <ClInclude Include="afrl\impact\AreaSearchPattern.h"/>
+       <ClInclude Include="afrl\impact\PowerPlant.h"/>
+       <ClInclude Include="afrl\impact\ImpactPayloadType.h"/>
+       <ClInclude Include="afrl\impact\IMPACTXMLReader.h"/>
+       <ClInclude Include="afrl\impact\IMPACTEnum.h"/>
+       <ClInclude Include="afrl\impact\IMPACT.h"/>
+       <ClInclude Include="afrl\cmasi\perceive\EntityPerception.h"/>
+       <ClInclude Include="afrl\cmasi\perceive\TrackEntityAction.h"/>
+       <ClInclude Include="afrl\cmasi\perceive\TrackEntityTask.h"/>
+       <ClInclude Include="afrl\cmasi\perceive\PERCEIVEXMLReader.h"/>
+       <ClInclude Include="afrl\cmasi\perceive\PERCEIVEEnum.h"/>
+       <ClInclude Include="afrl\cmasi\perceive\PERCEIVE.h"/>
+
+  </ItemGroup>
+  <ItemGroup>
+       <ClCompile Include="avtas\lmcp\ByteBuffer.cpp"/>
+       <ClCompile Include="avtas\lmcp\Factory.cpp"/>
+       <ClCompile Include="avtas\lmcp\Node.cpp"/>
+       <ClCompile Include="avtas\lmcp\NodeUtil.cpp"/>
+       <ClCompile Include="avtas\lmcp\XMLParser.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskAssignmentCoordinatorTask.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskPlanningState.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskAssignmentCoordination.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskCoordinatedAutomationRequest.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskAutomationRequest.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskAutomationResponse.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskUniqueAutomationRequest.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskUniqueAutomationResponse.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskSensorFootprintRequests.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskFootprintRequest.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskSensorFootprint.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskSensorFootprintResponse.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskImplementationRequest.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskImplementationResponse.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskAssignmentCostMatrix.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskOptionCost.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskAssignment.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskAssignmentSummary.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskOption.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskPlanOptions.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskPause.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskResume.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskProgress.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskProgressRequest.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskInitialized.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskActive.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskComplete.cpp"/>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskCancelTask.cpp"/>
+       <ClCompile Include="uxas\messages\task\UXTASKXMLReader.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeVideoRecord.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeStartupComplete.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeCreateNewService.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeKillService.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeIncrementWaypoint.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeEntityLocation.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeBandwidthTest.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeBandwidthReceiveReport.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeSubTaskExecution.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeSubTaskAssignment.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeAutopilotKeepAlive.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeOnboardProcessorIsAlive.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeEntityJoin.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeEntityExit.cpp"/>
+       <ClCompile Include="uxas\messages\uxnative\UXNATIVEXMLReader.cpp"/>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteGraphNode.cpp"/>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteGraphEdge.cpp"/>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteGraphRegion.cpp"/>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteRouteConstraints.cpp"/>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteRouteRequest.cpp"/>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteRoutePlanRequest.cpp"/>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteRoutePlan.cpp"/>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteRoutePlanResponse.cpp"/>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteRouteResponse.cpp"/>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteEgressRouteRequest.cpp"/>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteEgressRouteResponse.cpp"/>
+       <ClCompile Include="uxas\messages\route\ROUTEXMLReader.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAbstractGeometry.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiKeyValuePair.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiLocation3D.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPayloadAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPayloadConfiguration.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPayloadState.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiVehicleAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiTask.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiSearchTask.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAbstractZone.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiEntityConfiguration.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiFlightProfile.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAirVehicleConfiguration.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiEntityState.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAirVehicleState.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiWedge.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAreaSearchTask.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiCameraAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiCameraConfiguration.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGimballedPayloadState.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiCameraState.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiCircle.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGimbalAngleAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGimbalConfiguration.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGimbalScanAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGimbalStareAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGimbalState.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGoToWaypointAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiKeepInZone.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiKeepOutZone.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiLineSearchTask.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiNavigationAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiLoiterAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiLoiterTask.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiWaypoint.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiMissionCommand.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiMustFlyTask.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiOperatorSignal.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiOperatingRegion.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAutomationRequest.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPointSearchTask.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPolygon.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiRectangle.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiRemoveTasks.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiServiceStatus.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiSessionStatus.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiVehicleActionCommand.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiVideoStreamAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiVideoStreamConfiguration.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiVideoStreamState.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAutomationResponse.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiRemoveZones.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiRemoveEntities.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiFlightDirectorAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiWeatherReport.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiFollowPathCommand.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPathWaypoint.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiStopMovementAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiWaypointTransfer.cpp"/>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPayloadStowAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\CMASIXMLReader.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactPowerConfiguration.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactRadioConfiguration.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactRadioTowerConfiguration.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactRadioState.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactRadioTowerState.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactImpactPayloadConfiguration.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactDeployImpactPayload.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactPowerPlantState.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactBatchRoutePlanRequest.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactBatchRoutePlanResponse.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactTaskTimingPair.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactBatchSummaryRequest.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactBatchSummaryResponse.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactTaskSummary.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactVehicleSummary.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactImpactHeartbeat.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactImpactComponentJoin.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactImpactComponentLeave.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactSpeedAltPair.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactImpactAutomationRequest.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactImpactAutomationResponse.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactPointOfInterest.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactLineOfInterest.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactAreaOfInterest.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactImpactPointSearchTask.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactPatternSearchTask.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactAngledAreaSearchTask.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactImpactLineSearchTask.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactWatchTask.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactMultiVehicleWatchTask.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactCommRelayTask.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactCordonTask.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactBlockadeTask.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactEscortTask.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactConfigurationRequest.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactGroundVehicleConfiguration.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactGroundVehicleState.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactWaterReport.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactWaterZone.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactSurfaceVehicleConfiguration.cpp"/>
+       <ClCompile Include="afrl\impact\afrlimpactSurfaceVehicleState.cpp"/>
+       <ClCompile Include="afrl\impact\IMPACTXMLReader.cpp"/>
+       <ClCompile Include="afrl\cmasi\perceive\afrlcmasiperceiveEntityPerception.cpp"/>
+       <ClCompile Include="afrl\cmasi\perceive\afrlcmasiperceiveTrackEntityAction.cpp"/>
+       <ClCompile Include="afrl\cmasi\perceive\afrlcmasiperceiveTrackEntityTask.cpp"/>
+       <ClCompile Include="afrl\cmasi\perceive\PERCEIVEXMLReader.cpp"/>
+
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
diff --git a/src/LMCP/LMCP.vcxproj.filters b/src/LMCP/LMCP.vcxproj.filters
new file mode 100644
index 0000000..3d91bf5
--- /dev/null
+++ b/src/LMCP/LMCP.vcxproj.filters
@@ -0,0 +1,1209 @@
+<!-- This file was auto-created by LmcpGen. Modifications will be overwritten. -->
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{642DD74A-0E75-4FBB-A0C8-B807BE6FC420}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{DFC22DCB-2496-4329-B7E9-F2D2D2157C2F}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files\lmcp">
+     <UniqueIdentifier>{84035538-D167-41EE-82B8-2D93AF6761FF}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\lmcp">
+     <UniqueIdentifier>{EA44B1E4-922F-4D76-9627-5434F4B2D048}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\uxas%255cmessages%255ctask">
+     <UniqueIdentifier>{E9C5A63C-4638-491A-BC3B-E4AA462A16D0}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\uxas%255cmessages%255ctask">
+     <UniqueIdentifier>{7138D722-336F-40CE-86A8-B89C8E1DA612}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\uxas%255cmessages%255cuxnative">
+     <UniqueIdentifier>{A1A08E7F-BE5A-4A6B-B8BD-1E0339E246D7}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\uxas%255cmessages%255cuxnative">
+     <UniqueIdentifier>{F3767B9A-BE99-4545-891B-B47DBCA8B664}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\uxas%255cmessages%255croute">
+     <UniqueIdentifier>{F7B1EF8E-25E3-41BA-8354-42AC42699444}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\uxas%255cmessages%255croute">
+     <UniqueIdentifier>{DE5653C8-2599-47AD-853A-15DC738EA49F}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\afrl%255ccmasi">
+     <UniqueIdentifier>{7756CE97-8198-411D-A1CA-582D8753B196}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\afrl%255ccmasi">
+     <UniqueIdentifier>{CC1F495E-8FF4-4FE7-9DB3-ABBCCFA1A19C}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\afrl%255cimpact">
+     <UniqueIdentifier>{E6E3CD31-893C-4795-8613-79CAB16EF980}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\afrl%255cimpact">
+     <UniqueIdentifier>{844E7601-379B-4D07-9621-BC3560DE0F0B}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\afrl%255ccmasi%255cperceive">
+     <UniqueIdentifier>{F53A5AAA-99A6-47D1-9A26-1B2619B112C3}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\afrl%255ccmasi%255cperceive">
+     <UniqueIdentifier>{B0C2FC56-EDD0-4870-AF05-F194F9C2C662}</UniqueIdentifier>
+    </Filter>
+
+  </ItemGroup>
+  <ItemGroup>
+       <ClInclude Include="avtas\lmcp\ByteBuffer.h">
+       <Filter>Header Files\lmcp</Filter>
+</ClInclude>
+       <ClInclude Include="avtas\lmcp\Factory.h">
+       <Filter>Header Files\lmcp</Filter>
+</ClInclude>
+       <ClInclude Include="avtas\lmcp\LmcpXMLReader.h">
+       <Filter>Header Files\lmcp</Filter>
+</ClInclude>
+       <ClInclude Include="avtas\lmcp\Node.h">
+       <Filter>Header Files\lmcp</Filter>
+</ClInclude>
+       <ClInclude Include="avtas\lmcp\NodeUtil.h">
+       <Filter>Header Files\lmcp</Filter>
+</ClInclude>
+       <ClInclude Include="avtas\lmcp\Object.h">
+       <Filter>Header Files\lmcp</Filter>
+</ClInclude>
+       <ClInclude Include="avtas\lmcp\XMLParser.h">
+       <Filter>Header Files\lmcp</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\AssignmentCoordinatorTask.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\PlanningState.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\AssignmentCoordination.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\CoordinatedAutomationRequest.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskAutomationRequest.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskAutomationResponse.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\UniqueAutomationRequest.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\UniqueAutomationResponse.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\SensorFootprintRequests.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\FootprintRequest.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\SensorFootprint.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\SensorFootprintResponse.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskImplementationRequest.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskImplementationResponse.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\AssignmentCostMatrix.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskOptionCost.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskAssignment.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskAssignmentSummary.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskOption.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskPlanOptions.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskPause.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskResume.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskProgress.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskProgressRequest.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskInitialized.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskActive.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\TaskComplete.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\CancelTask.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\UXTASKXMLReader.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\UXTASKEnum.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\task\UXTASK.h">
+ <Filter>Header Files\uxas%255cmessages%255ctask</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\VideoRecord.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\StartupComplete.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\CreateNewService.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\KillService.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\IncrementWaypoint.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\EntityLocation.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\BandwidthTest.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\BandwidthReceiveReport.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\SubTaskExecution.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\SubTaskAssignment.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\AutopilotKeepAlive.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\OnboardProcessorIsAlive.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\EntityJoin.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\EntityExit.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\UXNATIVEXMLReader.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\UXNATIVEEnum.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\uxnative\UXNATIVE.h">
+ <Filter>Header Files\uxas%255cmessages%255cuxnative</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\GraphNode.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\GraphEdge.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\GraphRegion.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\RouteConstraints.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\RouteRequest.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\RoutePlanRequest.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\RoutePlan.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\RoutePlanResponse.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\RouteResponse.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\EgressRouteRequest.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\EgressRouteResponse.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\ROUTEXMLReader.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\ROUTEEnum.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="uxas\messages\route\ROUTE.h">
+ <Filter>Header Files\uxas%255cmessages%255croute</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\AbstractGeometry.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\KeyValuePair.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\Location3D.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\PayloadAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\PayloadConfiguration.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\PayloadState.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\VehicleAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\Task.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\SearchTask.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\AbstractZone.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\EntityConfiguration.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\FlightProfile.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\AirVehicleConfiguration.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\EntityState.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\AirVehicleState.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\Wedge.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\AreaSearchTask.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\CameraAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\CameraConfiguration.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\GimballedPayloadState.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\CameraState.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\Circle.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\GimbalAngleAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\GimbalConfiguration.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\GimbalScanAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\GimbalStareAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\GimbalState.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\GoToWaypointAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\KeepInZone.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\KeepOutZone.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\LineSearchTask.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\NavigationAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\LoiterAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\LoiterTask.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\Waypoint.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\MissionCommand.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\MustFlyTask.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\OperatorSignal.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\OperatingRegion.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\AutomationRequest.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\PointSearchTask.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\Polygon.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\Rectangle.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\RemoveTasks.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\ServiceStatus.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\SessionStatus.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\VehicleActionCommand.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\VideoStreamAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\VideoStreamConfiguration.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\VideoStreamState.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\AutomationResponse.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\RemoveZones.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\RemoveEntities.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\FlightDirectorAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\WeatherReport.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\FollowPathCommand.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\PathWaypoint.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\StopMovementAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\WaypointTransfer.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\PayloadStowAction.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\WavelengthBand.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\NavigationMode.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\FOVOperationMode.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\GimbalPointingMode.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\ZoneAvoidanceType.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\LoiterType.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\LoiterDirection.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\ServiceStatusType.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\SimulationStatusType.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\SpeedType.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\TurnType.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\CommandStatusType.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\AltitudeType.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\TravelMode.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\WaypointTransferMode.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\CMASIXMLReader.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\CMASIEnum.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\CMASI.h">
+ <Filter>Header Files\afrl%255ccmasi</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\PowerConfiguration.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\RadioConfiguration.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\RadioTowerConfiguration.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\RadioState.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\RadioTowerState.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\ImpactPayloadConfiguration.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\DeployImpactPayload.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\PowerPlantState.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\BatchRoutePlanRequest.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\BatchRoutePlanResponse.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\TaskTimingPair.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\BatchSummaryRequest.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\BatchSummaryResponse.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\TaskSummary.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\VehicleSummary.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\ImpactHeartbeat.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\ImpactComponentJoin.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\ImpactComponentLeave.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\SpeedAltPair.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\ImpactAutomationRequest.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\ImpactAutomationResponse.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\PointOfInterest.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\LineOfInterest.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\AreaOfInterest.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\ImpactPointSearchTask.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\PatternSearchTask.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\AngledAreaSearchTask.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\ImpactLineSearchTask.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\WatchTask.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\MultiVehicleWatchTask.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\CommRelayTask.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\CordonTask.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\BlockadeTask.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\EscortTask.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\ConfigurationRequest.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\GroundVehicleConfiguration.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\GroundVehicleState.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\WaterReport.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\WaterZone.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\SurfaceVehicleConfiguration.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\SurfaceVehicleState.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\AreaSearchPattern.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\PowerPlant.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\ImpactPayloadType.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\IMPACTXMLReader.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\IMPACTEnum.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\impact\IMPACT.h">
+ <Filter>Header Files\afrl%255cimpact</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\perceive\EntityPerception.h">
+ <Filter>Header Files\afrl%255ccmasi%255cperceive</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\perceive\TrackEntityAction.h">
+ <Filter>Header Files\afrl%255ccmasi%255cperceive</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\perceive\TrackEntityTask.h">
+ <Filter>Header Files\afrl%255ccmasi%255cperceive</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\perceive\PERCEIVEXMLReader.h">
+ <Filter>Header Files\afrl%255ccmasi%255cperceive</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\perceive\PERCEIVEEnum.h">
+ <Filter>Header Files\afrl%255ccmasi%255cperceive</Filter>
+</ClInclude>
+       <ClInclude Include="afrl\cmasi\perceive\PERCEIVE.h">
+ <Filter>Header Files\afrl%255ccmasi%255cperceive</Filter>
+</ClInclude>
+
+  </ItemGroup>
+  <ItemGroup>
+       <ClCompile Include="avtas\lmcp\ByteBuffer.cpp">
+       <Filter>Source Files\lmcp</Filter>
+</ClCompile>
+       <ClCompile Include="avtas\lmcp\Factory.cpp">
+       <Filter>Source Files\lmcp</Filter>
+</ClCompile>
+       <ClCompile Include="avtas\lmcp\LmcpXMLReader.cpp">
+       <Filter>Source Files\lmcp</Filter>
+</ClCompile>
+       <ClCompile Include="avtas\lmcp\Node.cpp">
+       <Filter>Source Files\lmcp</Filter>
+</ClCompile>
+       <ClCompile Include="avtas\lmcp\NodeUtil.cpp">
+       <Filter>Source Files\lmcp</Filter>
+</ClCompile>
+       <ClCompile Include="avtas\lmcp\Object.cpp">
+       <Filter>Source Files\lmcp</Filter>
+</ClCompile>
+       <ClCompile Include="avtas\lmcp\XMLParser.cpp">
+       <Filter>Source Files\lmcp</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskAssignmentCoordinatorTask.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskPlanningState.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskAssignmentCoordination.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskCoordinatedAutomationRequest.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskAutomationRequest.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskAutomationResponse.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskUniqueAutomationRequest.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskUniqueAutomationResponse.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskSensorFootprintRequests.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskFootprintRequest.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskSensorFootprint.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskSensorFootprintResponse.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskImplementationRequest.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskImplementationResponse.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskAssignmentCostMatrix.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskOptionCost.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskAssignment.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskAssignmentSummary.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskOption.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskPlanOptions.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskPause.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskResume.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskProgress.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskProgressRequest.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskInitialized.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskActive.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskTaskComplete.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\uxasmessagestaskCancelTask.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\UXTASKXMLReader.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\UXTASKEnum.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\task\UXTASK.cpp">
+ <Filter>Source Files\uxas%255cmessages%255ctask</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeVideoRecord.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeStartupComplete.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeCreateNewService.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeKillService.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeIncrementWaypoint.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeEntityLocation.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeBandwidthTest.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeBandwidthReceiveReport.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeSubTaskExecution.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeSubTaskAssignment.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeAutopilotKeepAlive.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeOnboardProcessorIsAlive.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeEntityJoin.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\uxasmessagesuxnativeEntityExit.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\UXNATIVEXMLReader.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\UXNATIVEEnum.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\uxnative\UXNATIVE.cpp">
+ <Filter>Source Files\uxas%255cmessages%255cuxnative</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteGraphNode.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteGraphEdge.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteGraphRegion.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteRouteConstraints.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteRouteRequest.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteRoutePlanRequest.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteRoutePlan.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteRoutePlanResponse.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteRouteResponse.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteEgressRouteRequest.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\uxasmessagesrouteEgressRouteResponse.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\ROUTEXMLReader.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\ROUTEEnum.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="uxas\messages\route\ROUTE.cpp">
+ <Filter>Source Files\uxas%255cmessages%255croute</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAbstractGeometry.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiKeyValuePair.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiLocation3D.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPayloadAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPayloadConfiguration.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPayloadState.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiVehicleAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiTask.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiSearchTask.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAbstractZone.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiEntityConfiguration.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiFlightProfile.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAirVehicleConfiguration.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiEntityState.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAirVehicleState.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiWedge.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAreaSearchTask.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiCameraAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiCameraConfiguration.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGimballedPayloadState.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiCameraState.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiCircle.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGimbalAngleAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGimbalConfiguration.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGimbalScanAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGimbalStareAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGimbalState.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiGoToWaypointAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiKeepInZone.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiKeepOutZone.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiLineSearchTask.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiNavigationAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiLoiterAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiLoiterTask.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiWaypoint.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiMissionCommand.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiMustFlyTask.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiOperatorSignal.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiOperatingRegion.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAutomationRequest.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPointSearchTask.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPolygon.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiRectangle.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiRemoveTasks.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiServiceStatus.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiSessionStatus.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiVehicleActionCommand.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiVideoStreamAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiVideoStreamConfiguration.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiVideoStreamState.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiAutomationResponse.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiRemoveZones.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiRemoveEntities.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiFlightDirectorAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiWeatherReport.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiFollowPathCommand.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPathWaypoint.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiStopMovementAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiWaypointTransfer.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\afrlcmasiPayloadStowAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\CMASIXMLReader.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\CMASIEnum.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\CMASI.cpp">
+ <Filter>Source Files\afrl%255ccmasi</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactPowerConfiguration.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactRadioConfiguration.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactRadioTowerConfiguration.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactRadioState.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactRadioTowerState.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactImpactPayloadConfiguration.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactDeployImpactPayload.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactPowerPlantState.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactBatchRoutePlanRequest.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactBatchRoutePlanResponse.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactTaskTimingPair.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactBatchSummaryRequest.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactBatchSummaryResponse.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactTaskSummary.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactVehicleSummary.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactImpactHeartbeat.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactImpactComponentJoin.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactImpactComponentLeave.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactSpeedAltPair.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactImpactAutomationRequest.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactImpactAutomationResponse.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactPointOfInterest.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactLineOfInterest.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactAreaOfInterest.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactImpactPointSearchTask.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactPatternSearchTask.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactAngledAreaSearchTask.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactImpactLineSearchTask.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactWatchTask.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactMultiVehicleWatchTask.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactCommRelayTask.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactCordonTask.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactBlockadeTask.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactEscortTask.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactConfigurationRequest.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactGroundVehicleConfiguration.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactGroundVehicleState.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactWaterReport.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactWaterZone.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactSurfaceVehicleConfiguration.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\afrlimpactSurfaceVehicleState.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\IMPACTXMLReader.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\IMPACTEnum.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\impact\IMPACT.cpp">
+ <Filter>Source Files\afrl%255cimpact</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\perceive\afrlcmasiperceiveEntityPerception.cpp">
+ <Filter>Source Files\afrl%255ccmasi%255cperceive</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\perceive\afrlcmasiperceiveTrackEntityAction.cpp">
+ <Filter>Source Files\afrl%255ccmasi%255cperceive</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\perceive\afrlcmasiperceiveTrackEntityTask.cpp">
+ <Filter>Source Files\afrl%255ccmasi%255cperceive</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\perceive\PERCEIVEXMLReader.cpp">
+ <Filter>Source Files\afrl%255ccmasi%255cperceive</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\perceive\PERCEIVEEnum.cpp">
+ <Filter>Source Files\afrl%255ccmasi%255cperceive</Filter>
+</ClCompile>
+       <ClCompile Include="afrl\cmasi\perceive\PERCEIVE.cpp">
+ <Filter>Source Files\afrl%255ccmasi%255cperceive</Filter>
+</ClCompile>
+
+  </ItemGroup>
+</Project>
diff --git a/src/LMCP/Makefile b/src/LMCP/Makefile
new file mode 100644
index 0000000..ce9efe1
--- /dev/null
+++ b/src/LMCP/Makefile
@@ -0,0 +1,211 @@
+## This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+LIBNAME := liblmcp
+STATICLIBNAME := $(LIBNAME).a
+LIBDIR := ./
+
+LIBS := $(LIBDIR)/$(STATICLIBNAME)
+
+MKDIR   := mkdir
+
+# Compiler
+CXX := g++
+
+SOURCES := avtas/lmcp/ByteBuffer.cpp \
+	avtas/lmcp/Factory.cpp \
+	avtas/lmcp/NodeUtil.cpp \
+	avtas/lmcp/Node.cpp \
+	avtas/lmcp/XMLParser.cpp \
+	uxas/messages/task/uxasmessagestaskAssignmentCoordinatorTask.cpp\
+	uxas/messages/task/uxasmessagestaskPlanningState.cpp\
+	uxas/messages/task/uxasmessagestaskAssignmentCoordination.cpp\
+	uxas/messages/task/uxasmessagestaskCoordinatedAutomationRequest.cpp\
+	uxas/messages/task/uxasmessagestaskTaskAutomationRequest.cpp\
+	uxas/messages/task/uxasmessagestaskTaskAutomationResponse.cpp\
+	uxas/messages/task/uxasmessagestaskUniqueAutomationRequest.cpp\
+	uxas/messages/task/uxasmessagestaskUniqueAutomationResponse.cpp\
+	uxas/messages/task/uxasmessagestaskSensorFootprintRequests.cpp\
+	uxas/messages/task/uxasmessagestaskFootprintRequest.cpp\
+	uxas/messages/task/uxasmessagestaskSensorFootprint.cpp\
+	uxas/messages/task/uxasmessagestaskSensorFootprintResponse.cpp\
+	uxas/messages/task/uxasmessagestaskTaskImplementationRequest.cpp\
+	uxas/messages/task/uxasmessagestaskTaskImplementationResponse.cpp\
+	uxas/messages/task/uxasmessagestaskAssignmentCostMatrix.cpp\
+	uxas/messages/task/uxasmessagestaskTaskOptionCost.cpp\
+	uxas/messages/task/uxasmessagestaskTaskAssignment.cpp\
+	uxas/messages/task/uxasmessagestaskTaskAssignmentSummary.cpp\
+	uxas/messages/task/uxasmessagestaskTaskOption.cpp\
+	uxas/messages/task/uxasmessagestaskTaskPlanOptions.cpp\
+	uxas/messages/task/uxasmessagestaskTaskPause.cpp\
+	uxas/messages/task/uxasmessagestaskTaskResume.cpp\
+	uxas/messages/task/uxasmessagestaskTaskProgress.cpp\
+	uxas/messages/task/uxasmessagestaskTaskProgressRequest.cpp\
+	uxas/messages/task/uxasmessagestaskTaskInitialized.cpp\
+	uxas/messages/task/uxasmessagestaskTaskActive.cpp\
+	uxas/messages/task/uxasmessagestaskTaskComplete.cpp\
+	uxas/messages/task/uxasmessagestaskCancelTask.cpp\
+	uxas/messages/task/UXTASKXMLReader.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeVideoRecord.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeStartupComplete.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeCreateNewService.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeKillService.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeIncrementWaypoint.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeEntityLocation.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeBandwidthTest.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeBandwidthReceiveReport.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeSubTaskExecution.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeSubTaskAssignment.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeAutopilotKeepAlive.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeOnboardProcessorIsAlive.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeEntityJoin.cpp\
+	uxas/messages/uxnative/uxasmessagesuxnativeEntityExit.cpp\
+	uxas/messages/uxnative/UXNATIVEXMLReader.cpp\
+	uxas/messages/route/uxasmessagesrouteGraphNode.cpp\
+	uxas/messages/route/uxasmessagesrouteGraphEdge.cpp\
+	uxas/messages/route/uxasmessagesrouteGraphRegion.cpp\
+	uxas/messages/route/uxasmessagesrouteRouteConstraints.cpp\
+	uxas/messages/route/uxasmessagesrouteRouteRequest.cpp\
+	uxas/messages/route/uxasmessagesrouteRoutePlanRequest.cpp\
+	uxas/messages/route/uxasmessagesrouteRoutePlan.cpp\
+	uxas/messages/route/uxasmessagesrouteRoutePlanResponse.cpp\
+	uxas/messages/route/uxasmessagesrouteRouteResponse.cpp\
+	uxas/messages/route/uxasmessagesrouteEgressRouteRequest.cpp\
+	uxas/messages/route/uxasmessagesrouteEgressRouteResponse.cpp\
+	uxas/messages/route/ROUTEXMLReader.cpp\
+	afrl/cmasi/afrlcmasiAbstractGeometry.cpp\
+	afrl/cmasi/afrlcmasiKeyValuePair.cpp\
+	afrl/cmasi/afrlcmasiLocation3D.cpp\
+	afrl/cmasi/afrlcmasiPayloadAction.cpp\
+	afrl/cmasi/afrlcmasiPayloadConfiguration.cpp\
+	afrl/cmasi/afrlcmasiPayloadState.cpp\
+	afrl/cmasi/afrlcmasiVehicleAction.cpp\
+	afrl/cmasi/afrlcmasiTask.cpp\
+	afrl/cmasi/afrlcmasiSearchTask.cpp\
+	afrl/cmasi/afrlcmasiAbstractZone.cpp\
+	afrl/cmasi/afrlcmasiEntityConfiguration.cpp\
+	afrl/cmasi/afrlcmasiFlightProfile.cpp\
+	afrl/cmasi/afrlcmasiAirVehicleConfiguration.cpp\
+	afrl/cmasi/afrlcmasiEntityState.cpp\
+	afrl/cmasi/afrlcmasiAirVehicleState.cpp\
+	afrl/cmasi/afrlcmasiWedge.cpp\
+	afrl/cmasi/afrlcmasiAreaSearchTask.cpp\
+	afrl/cmasi/afrlcmasiCameraAction.cpp\
+	afrl/cmasi/afrlcmasiCameraConfiguration.cpp\
+	afrl/cmasi/afrlcmasiGimballedPayloadState.cpp\
+	afrl/cmasi/afrlcmasiCameraState.cpp\
+	afrl/cmasi/afrlcmasiCircle.cpp\
+	afrl/cmasi/afrlcmasiGimbalAngleAction.cpp\
+	afrl/cmasi/afrlcmasiGimbalConfiguration.cpp\
+	afrl/cmasi/afrlcmasiGimbalScanAction.cpp\
+	afrl/cmasi/afrlcmasiGimbalStareAction.cpp\
+	afrl/cmasi/afrlcmasiGimbalState.cpp\
+	afrl/cmasi/afrlcmasiGoToWaypointAction.cpp\
+	afrl/cmasi/afrlcmasiKeepInZone.cpp\
+	afrl/cmasi/afrlcmasiKeepOutZone.cpp\
+	afrl/cmasi/afrlcmasiLineSearchTask.cpp\
+	afrl/cmasi/afrlcmasiNavigationAction.cpp\
+	afrl/cmasi/afrlcmasiLoiterAction.cpp\
+	afrl/cmasi/afrlcmasiLoiterTask.cpp\
+	afrl/cmasi/afrlcmasiWaypoint.cpp\
+	afrl/cmasi/afrlcmasiMissionCommand.cpp\
+	afrl/cmasi/afrlcmasiMustFlyTask.cpp\
+	afrl/cmasi/afrlcmasiOperatorSignal.cpp\
+	afrl/cmasi/afrlcmasiOperatingRegion.cpp\
+	afrl/cmasi/afrlcmasiAutomationRequest.cpp\
+	afrl/cmasi/afrlcmasiPointSearchTask.cpp\
+	afrl/cmasi/afrlcmasiPolygon.cpp\
+	afrl/cmasi/afrlcmasiRectangle.cpp\
+	afrl/cmasi/afrlcmasiRemoveTasks.cpp\
+	afrl/cmasi/afrlcmasiServiceStatus.cpp\
+	afrl/cmasi/afrlcmasiSessionStatus.cpp\
+	afrl/cmasi/afrlcmasiVehicleActionCommand.cpp\
+	afrl/cmasi/afrlcmasiVideoStreamAction.cpp\
+	afrl/cmasi/afrlcmasiVideoStreamConfiguration.cpp\
+	afrl/cmasi/afrlcmasiVideoStreamState.cpp\
+	afrl/cmasi/afrlcmasiAutomationResponse.cpp\
+	afrl/cmasi/afrlcmasiRemoveZones.cpp\
+	afrl/cmasi/afrlcmasiRemoveEntities.cpp\
+	afrl/cmasi/afrlcmasiFlightDirectorAction.cpp\
+	afrl/cmasi/afrlcmasiWeatherReport.cpp\
+	afrl/cmasi/afrlcmasiFollowPathCommand.cpp\
+	afrl/cmasi/afrlcmasiPathWaypoint.cpp\
+	afrl/cmasi/afrlcmasiStopMovementAction.cpp\
+	afrl/cmasi/afrlcmasiWaypointTransfer.cpp\
+	afrl/cmasi/afrlcmasiPayloadStowAction.cpp\
+	afrl/cmasi/CMASIXMLReader.cpp\
+	afrl/impact/afrlimpactPowerConfiguration.cpp\
+	afrl/impact/afrlimpactRadioConfiguration.cpp\
+	afrl/impact/afrlimpactRadioTowerConfiguration.cpp\
+	afrl/impact/afrlimpactRadioState.cpp\
+	afrl/impact/afrlimpactRadioTowerState.cpp\
+	afrl/impact/afrlimpactImpactPayloadConfiguration.cpp\
+	afrl/impact/afrlimpactDeployImpactPayload.cpp\
+	afrl/impact/afrlimpactPowerPlantState.cpp\
+	afrl/impact/afrlimpactBatchRoutePlanRequest.cpp\
+	afrl/impact/afrlimpactBatchRoutePlanResponse.cpp\
+	afrl/impact/afrlimpactTaskTimingPair.cpp\
+	afrl/impact/afrlimpactBatchSummaryRequest.cpp\
+	afrl/impact/afrlimpactBatchSummaryResponse.cpp\
+	afrl/impact/afrlimpactTaskSummary.cpp\
+	afrl/impact/afrlimpactVehicleSummary.cpp\
+	afrl/impact/afrlimpactImpactHeartbeat.cpp\
+	afrl/impact/afrlimpactImpactComponentJoin.cpp\
+	afrl/impact/afrlimpactImpactComponentLeave.cpp\
+	afrl/impact/afrlimpactSpeedAltPair.cpp\
+	afrl/impact/afrlimpactImpactAutomationRequest.cpp\
+	afrl/impact/afrlimpactImpactAutomationResponse.cpp\
+	afrl/impact/afrlimpactPointOfInterest.cpp\
+	afrl/impact/afrlimpactLineOfInterest.cpp\
+	afrl/impact/afrlimpactAreaOfInterest.cpp\
+	afrl/impact/afrlimpactImpactPointSearchTask.cpp\
+	afrl/impact/afrlimpactPatternSearchTask.cpp\
+	afrl/impact/afrlimpactAngledAreaSearchTask.cpp\
+	afrl/impact/afrlimpactImpactLineSearchTask.cpp\
+	afrl/impact/afrlimpactWatchTask.cpp\
+	afrl/impact/afrlimpactMultiVehicleWatchTask.cpp\
+	afrl/impact/afrlimpactCommRelayTask.cpp\
+	afrl/impact/afrlimpactCordonTask.cpp\
+	afrl/impact/afrlimpactBlockadeTask.cpp\
+	afrl/impact/afrlimpactEscortTask.cpp\
+	afrl/impact/afrlimpactConfigurationRequest.cpp\
+	afrl/impact/afrlimpactGroundVehicleConfiguration.cpp\
+	afrl/impact/afrlimpactGroundVehicleState.cpp\
+	afrl/impact/afrlimpactWaterReport.cpp\
+	afrl/impact/afrlimpactWaterZone.cpp\
+	afrl/impact/afrlimpactSurfaceVehicleConfiguration.cpp\
+	afrl/impact/afrlimpactSurfaceVehicleState.cpp\
+	afrl/impact/IMPACTXMLReader.cpp\
+	afrl/cmasi/perceive/afrlcmasiperceiveEntityPerception.cpp\
+	afrl/cmasi/perceive/afrlcmasiperceiveTrackEntityAction.cpp\
+	afrl/cmasi/perceive/afrlcmasiperceiveTrackEntityTask.cpp\
+	afrl/cmasi/perceive/PERCEIVEXMLReader.cpp\
+
+
+OBJS    := $(SOURCES:.cpp=.o)
+
+INCDIR  := -I.
+
+DEPS	:= avtas/lmcp/Object.h 
+
+COMOPTS := -fPIC -std=c++11 -Wall
+
+DEFINES := -DLINUX
+
+.PHONY=all
+all:    $(LIBS)
+
+%.o:    %.cpp $(DEPS)
+	@echo "     Compiling $< ($@) ..."
+	$(CXX) $(INCDIR) $(DEFINES) $(COMOPTS) -c $< -o $@
+
+.PHONY=$(LIBDIR)/$(STATICLIBNAME)
+$(LIBDIR)/$(STATICLIBNAME):     $(OBJS)
+	@echo "  Creating static library $(STATICLIBNAME)"
+	@ar r $(LIBDIR)/$(STATICLIBNAME) $(OBJS)
+
+.PHONY=clean
+clean:
+	@echo "   Removing libraries ($(STATICLIBNAME)) ..."
+	@rm -f $(LIBS)
+	@echo "   Removing object code ..."
+	@rm -f $(OBJS)
diff --git a/src/LMCP/PERCEIVE.xml b/src/LMCP/PERCEIVE.xml
new file mode 100644
index 0000000..e9c1b51
--- /dev/null
+++ b/src/LMCP/PERCEIVE.xml
@@ -0,0 +1,111 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE MDM SYSTEM 'MDM.DTD'>
+
+<!--
+        <h2>Introduction</h2>
+        Perception message definitions. Depends upon CMASI MDM.
+
+-->
+<MDM>
+    <SeriesName>PERCEIVE</SeriesName>
+    <Namespace>afrl/cmasi/perceive</Namespace>
+    <Version>1</Version>
+
+
+    <StructList>
+		
+		<!-- A report of a potential target/tracked entity.  Perceptions are received from a
+             given sensor or set of sensors.  Entities can be perceived by scenario aircraft or other entities.
+        -->
+        <Struct Name="EntityPerception">
+            <!-- A scenario-unique ID for this target entity. IDs should be greater than zero.  Since this is a
+                 perception, the entity ID may not be known.  In that case, this field should be set to
+                 zero.
+            -->
+            <Field Name="PerceivedEntityID" Type="uint32"/>
+
+            <!-- ID of the entity or aircraft that reported the detection/perception -->
+            <Field Name="PerceiverID" Type="uint32"/>
+
+            <!-- The IDs of the payloads that reported this perception. -->
+            <Field Name="PerceiverPayloads" Type="uint32[]"/>
+
+            <!-- The perceived target velocity in three-dimensions.  The velocity should be stated
+                 in tangential-plane coordinates using the North-East-Down coordinate system.
+            -->
+            <Field Name="Velocity" Type="real32[3]" Units="meter/sec" />
+
+            <!-- Velocity error for this perception.  The error terms should be in the same
+                 coordinate system as the velocity.
+            -->
+            <Field Name="VelocityError" Type="real32[3]" Units="meter/sec" />
+
+            <!-- If true, denotes that the velocity and velocity error have meaning. -->
+            <Field Name="VelocityValid" Type="bool" Default="false"/>
+
+            <!-- Euler angle tangential-plane attitude for this entity.  Should be stated as
+                 Psi-Theta-Phi.  For information on Euler coordinates, see
+                 <a href="http://en.wikipedia.org/wiki/Euler_angle">Euler Angles</a>
+            -->
+            <Field Name="Attitude" Type="real32[3]" Units="degree"/>
+
+            <!-- Error in the perception of the entity attitude.  This should be in the same
+                 coordinate system as the attitude.
+            -->
+            <Field Name="AttitudeError" Type="real32[3]" Units="degree"/>
+
+            <!-- If true, denotes that the attitude and attitude error have meaning. -->
+            <Field Name="AttitudeValid" Type="bool" Default="false"/>
+
+            <!-- The entity location -->
+            <Field Name="Location" Type="CMASI/Location3D"/>
+
+            <!-- Error in the perception of the location of this entity.  The first index is North-South error, the second index
+                 is the East-West error, and the third index is the vertical error.  The result is an error cylinder.
+            -->
+            <Field Name="LocationError" Type="real32[3]" Units="meter"/>
+
+            <!-- Time that this entity was perceived since scenario start. -->
+            <Field Name="TimeLastSeen" Type="int64" Units="millisecond"/>
+
+        </Struct>
+		
+		
+		<!--
+             This puts an entity into a "track" mode, where the vehicle commands itself and its onboard sensors to attempt to
+             keep a target in view. If multiple sensors are to be used simultaneously, multiple track actions should be sent.
+        -->
+        <Struct Name="TrackEntityAction" Extends="CMASI/VehicleAction">
+
+            <!-- The unique identifier of the target to be tracked. -->
+            <Field Name="EntityID" Type="uint32"  />
+
+            <!-- The unique identifier of the sensor that is to be actively steered to track the target. -->
+            <Field Name="SensorID" Type="uint32" />
+            
+            <!-- The waypoint that this vehicle is to return to when complete (or lost track) -->
+            <Field Name="ReturnToWaypoint" Type="uint32"/>
+
+        </Struct>
+        
+        <!--
+            A request to track a specific entity.  It is assumed that the tracked entity can move at any time during the scenario.
+        -->
+        <Struct Name="TrackEntityTask" Extends="CMASI/Task" >
+            <!-- The ID of the target to be tracked. -->
+            <Field Name="EntityID" Type="uint32" Units="None" />
+			
+			<!-- Required sensor modality for tracking the target -->
+			<Field Name="SensorModality" Type="CMASI/WavelengthBand" Default="AllAny"/>
+            
+            <!-- The minimum ground sample distance that should be maintained for this target track operation. -->
+            <Field Name="GroundSampleDistance" Type="real32" Units="meter"/>
+        </Struct>
+		
+		
+    </StructList>
+</MDM>
+
+
+
+
diff --git a/src/LMCP/ROUTE.xml b/src/LMCP/ROUTE.xml
new file mode 100644
index 0000000..a44adf0
--- /dev/null
+++ b/src/LMCP/ROUTE.xml
@@ -0,0 +1,166 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE MDM SYSTEM 'MDM.DTD'>
+
+<!--
+        <h2>Introduction</h2>
+        This MDM defines the interface to a route planning service. It includes geometric constructs defining road networks to support the routing of ground vehicles.
+-->
+
+<MDM>
+    <SeriesName>ROUTE</SeriesName>
+    <Namespace>uxas/messages/route</Namespace>
+    <Version>3</Version>
+
+    <StructList>
+
+        <!-- Defines a base graph node for a geo-spatial graph. -->
+        <Struct Name="GraphNode">
+            <!-- Unique ID for the node, used to build edges between nodes -->
+            <Field Name="NodeID" Type="int64" Units="None" />
+            <!-- Lat/Lon coordinates of node -->
+            <Field Name="Coordinates" Type="CMASI/Location3D" />
+            <!-- IDs of edges that have this node as an endpoint -->
+            <Field Name="AssociatedEdges" Type="int64[]" />
+        </Struct>
+        
+        <!-- Defines an edge for a geo-spatial graph. An edge must connect two nodes defined by
+        GraphNodes. Each edge consists of a set of waypoints connecting the two endpoints.
+        All edges are considered bi-directional (i.e. one-way roads are not defined) -->
+        <Struct Name="GraphEdge">
+            <!-- Unique ID for the edge -->
+            <Field Name="EdgeID" Type="int64" Units="None" />
+            <!-- GraphNode ID which defines the start point of the edge -->
+            <Field Name="StartNode" Type="int64" Units="None" />
+            <!-- GraphNode ID which defines the end point of the edge -->
+            <Field Name="EndNode" Type="int64" Units="None" />
+            <!-- Optional waypoints describing physical edge in lat/lon coordinates -->
+            <Field Name="Waypoints" Type="CMASI/Location3D[]" />
+        </Struct>
+        
+        <!-- Defines a complete geo-spatial graph -->
+        <Struct Name="GraphRegion">
+            <!-- ID for full region data structure -->
+            <Field Name="ID" Type="int64" Units="None" />
+            <!-- List of all nodes that represent the network -->
+            <Field Name="NodeList" Type="GraphNode[]" LargeArray="true" />
+            <!-- List of all edges that represent the network -->
+            <Field Name="EdgeList" Type="GraphEdge[]" LargeArray="true" />
+        </Struct>
+
+
+
+         <!-- Start/end points and associated heading constraints for a route request -->
+         <Struct Name="RouteConstraints" >
+            <!-- ID denoting this set of route constraints -->
+            <Field Name="RouteID" Type="int64" />
+            
+            <!-- Location from which the planned route will start -->
+            <Field Name="StartLocation" Type="CMASI/Location3D" />
+            <!-- Heading of entity at the start of the route -->
+            <Field Name="StartHeading" Type="real32" Units="degrees"/>
+            <!-- If "true" the heading value in StartHeading must be used
+            to start the route. If not, any starting heading can be used. -->
+            <Field Name="UseStartHeading" Type="bool" Default="true" />
+            
+            <!-- Location to which the planned route will end -->
+            <Field Name="EndLocation" Type="CMASI/Location3D" />
+            <!-- Heading of entity at the end of the route -->
+            <Field Name="EndHeading" Type="real32" Units="degrees"/>
+            <!-- If "true" the heading value in EndHeading must be used
+            to end the route. If not, ant ending heading can be used. -->
+            <Field Name="UseEndHeading" Type="bool" Default="true" />
+            
+        </Struct>
+        
+	<!-- Route request: macro route request for a list of available vehicles -->
+	<Struct Name="RouteRequest" >
+            <!-- Request ID for correlating with response -->
+            <Field Name="RequestID" Type="int64" />
+            <!-- Associated Task ID (0 if no associated task) for this set of requests -->
+            <Field Name="AssociatedTaskID" Type="int64" Default="0" />
+            <!-- Vehicles to consider when planning. If list is empty, route planner
+            plans for all known vehicles. -->
+            <Field Name="VehicleID" Type="int64[]" />
+            <!-- Operating region to be considered during planning -->
+            <Field Name="OperatingRegion" Type="int64" />
+            <!-- List of all requests for this vehicle set + operating region situation -->
+            <Field Name="RouteRequests" Type="RouteConstraints[]" />
+            <!-- Request that planner only return costs of routes rather than complete waypoint plans -->
+            <Field Name="IsCostOnlyRequest" Type="bool" Default="true" />
+            
+        </Struct>
+        
+        <!-- Route plan request: find route from the current vehicle position to a point of interest or world location -->
+        <Struct Name="RoutePlanRequest" >
+            <!-- Request ID for correlating with response -->
+            <Field Name="RequestID" Type="int64" />
+            <!-- Associated Task ID (0 if no associated task) for this set of requests -->
+            <Field Name="AssociatedTaskID" Type="int64" Default="0" />
+            <!-- Vehicle to consider when planning -->
+            <Field Name="VehicleID" Type="int64" />
+            <!-- Operating region to be considered during planning -->
+            <Field Name="OperatingRegion" Type="int64" />
+            <!-- List of all requests for this vehicle + operating region situation -->
+            <Field Name="RouteRequests" Type="RouteConstraints[]" />
+            <!-- Request that planner only return costs of routes rather than complete waypoint plans -->
+            <Field Name="IsCostOnlyRequest" Type="bool" Default="true" />
+            
+        </Struct>
+        
+        <!-- Individual route plan -->
+        <Struct Name="RoutePlan" >
+            <!-- ID denoting this plan corresponding with requested route constraint pair -->
+            <Field Name="RouteID" Type="int64" />
+            <!-- Waypoints that connect the start location with the end location. Empty if only costs were requested -->
+            <Field Name="Waypoints" Type="CMASI/Waypoint[]" />
+            <!-- Time cost of route. If less than zero, a planning error has occurred -->
+            <Field Name="RouteCost" Type="int64" Units="milliseconds" Default="-1"/>
+            <!-- Error messages, if applicable -->
+            <Field Name="RouteError" Type="CMASI/KeyValuePair[]" />
+        </Struct>
+        
+        <!-- Route plan response: list of all fulfilled route requests -->
+	<Struct Name="RoutePlanResponse" >
+            <!-- Response ID matching ID from request ({@link RoutePlanRequest})-->
+            <Field Name="ResponseID" Type="int64" />
+            <!-- Associated Task ID (0 if no associated task) that this set of responses corresponds to -->
+            <Field Name="AssociatedTaskID" Type="int64" Default="0" />
+            <!-- Vehicle that was considered during planning -->
+            <Field Name="VehicleID" Type="int64" />
+            <!-- Operating region that was considered during planning -->
+            <Field Name="OperatingRegion" Type="int64" />
+            <!-- List of all responses for this vehicle + operating region situation -->
+            <Field Name="RouteResponses" Type="RoutePlan[]" />
+        </Struct>
+        
+        <!-- Route response: list of all fulfilled route requests for a complete
+        list of vehicles (see {@link RouteRequest})-->
+	<Struct Name="RouteResponse" >
+            <!-- Response ID matching ID from request ({@link RouteRequest}) -->
+            <Field Name="ResponseID" Type="int64" />
+            <!-- Corresponding route responses for all requested vehicles -->
+            <Field Name="Routes" Type="RoutePlanResponse[]" />
+        </Struct>
+		
+        <!-- Egress route request: find all egress routes (nearby intersections) from a point -->
+        <Struct Name="EgressRouteRequest" >
+            <!-- Request ID for correlating with response -->
+            <Field Name="RequestID" Type="int64" />
+            <!-- Location from which to calculate the routes -->
+            <Field Name="StartLocation" Type="CMASI/Location3D" />
+            <!-- The radius of the area of concern -->
+            <Field Name="Radius" Type="real32" Default="60" Units="meters" />
+        </Struct>
+		
+        <!-- Egress route response: returns egress routes (nearby intersections) from a point -->
+        <Struct Name="EgressRouteResponse" >
+            <!-- Response ID matching ID from request ({@link EgressRouteRequest}) -->
+            <Field Name="ResponseID" Type="int64" />
+            <!-- The route locations -->
+            <Field Name="NodeLocations" Type="CMASI/Location3D[]" />
+            <!-- The orientations -->
+            <Field Name="Headings" Type="real32[]" Units="degrees" />
+        </Struct>
+        
+    </StructList>
+</MDM>
diff --git a/src/LMCP/UXNATIVE.xml b/src/LMCP/UXNATIVE.xml
new file mode 100644
index 0000000..9b625b1
--- /dev/null
+++ b/src/LMCP/UXNATIVE.xml
@@ -0,0 +1,129 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE MDM SYSTEM 'MDM.DTD'>
+
+<!--
+        <h2>UxAS Message Set</h2>
+ 
+        <p>This message set describes the native/internal messages for UxAS</p>
+-->
+
+<MDM>
+    <SeriesName>UXNATIVE</SeriesName>
+    <Namespace>uxas/messages/uxnative</Namespace>
+    <Version>2</Version>
+    
+    <StructList>
+        
+        <!-- Start/Stop recording -->
+        <Struct Name="VideoRecord" >
+            <!-- Start [true] or stop [false] video recording -->
+            <Field Name="Record" Type="bool" Default="false" />
+        </Struct>
+        
+        <!-- Message sent when all services have been started -->
+        <Struct Name="StartupComplete" >
+        </Struct>
+        
+        <!-- Create a new service in UxAS -->
+        <Struct Name="CreateNewService" >
+            <!-- Globally unique ID for this service. Negative ServiceIDs are invalid. If ServiceID == 0, then a unique service ID will be generated.  -->
+            <Field Name="ServiceID" Type="int64"  Default="0"/>
+            <!-- XML configuration for this service -->
+            <Field Name="XmlConfiguration" Type="string[]" />
+        </Struct>
+        
+        <!-- Remove an existing service from UxAS -->
+        <Struct Name="KillService" >
+            <!-- Globally unique ID for the service to be removed. If ServiceID == 0, then no service will be killed. ServiceID == -1 causes all services to be killed and UxAS to be shutdown. -->
+            <Field Name="ServiceID" Type="int64"  Default="0"/>
+        </Struct>
+        
+        <!-- Indicate to the waypoint manager to move to the next waypoint in the current list -->
+        <Struct Name="IncrementWaypoint" >
+            <!-- ID of vehicle which should move to the next waypoint in its list -->
+            <Field Name="VehicleID" Type="int64" />
+        </Struct>
+    
+        <!-- Simple location broadcast from entities for tracking -->
+        <Struct Name="EntityLocation" >
+            <!-- Entity ID -->
+            <Field Name="EntityID" Type="int64" />
+            <!-- Current location of entity -->
+            <Field Name="Position" Type="CMASI/Location3D" />
+            <!-- Corresponding time in milli-seconds since 1 Jan 1970 -->
+            <Field Name="Time" Type="int64" Units="milliseconds" />
+        </Struct>
+    
+        <!-- Message for measuring actual bandwidth between entities -->
+        <Struct Name="BandwidthTest" Extends="EntityLocation">
+            <!-- Message ID to track message loss -->
+            <Field Name="MessageID" Type="int64" />
+            <!-- Data payload for creating arbitrarily sized messages -->
+            <Field Name="Payload" Type="string" />
+        </Struct>
+    
+        <!-- Report for a received message containing positions of both entities and the payload size -->
+        <Struct Name="BandwidthReceiveReport">
+            <!-- Entity from which the message was sent -->
+            <Field Name="EntitySender" Type="EntityLocation" />
+            <!-- Entity which received the message -->
+            <Field Name="EntityReceiver" Type="EntityLocation" />
+            <!-- Size of the message that was received -->
+            <Field Name="TransferPayloadSize" Type="uint32" />
+        </Struct>
+
+        <!-- Command entity to execute subtasks either in strict order or determined by optimization.
+        Replaces all current sub-tasks being executed. In addtion to executing the sub-tasks, the
+        mission command used to complete the sub-tasks is returned. -->
+        <Struct Name="SubTaskExecution" >
+            <!-- List of tasks that current entity should complete -->
+            <Field Name="SubTasks" Type="CMASI/Task[]" />
+            <!-- Enable strict ordering -->
+            <Field Name="StrictOrder" Type="bool" Default="false" />
+        </Struct>
+        
+        <!-- Command an entity to perform a complete task assignment for the entire team and then execute own role -->
+        <Struct Name="SubTaskAssignment" >
+            <!-- List of tasks that current team should complete -->
+            <Field Name="SubTasks" Type="CMASI/Task[]" />
+            <!-- Neighboring entities to consider -->
+            <Field Name="Neighbors" Type="CMASI/EntityState[]" />
+        </Struct>
+    
+        <!-- Message to enable onboard processor to send commands to the autopilot, and the gimbal -->
+        <Struct Name="AutopilotKeepAlive" >
+            <!-- Enable communications between UxAS and the autopilot -->
+            <Field Name="AutopilotEnabled" Type="bool" Default="true" />
+            <!-- Enable communications between UxAS and the Gimbal.
+            Note: this does not effect the video stream. -->
+            <Field Name="GimbalEnabled" Type="bool" Default="true" />
+            <!-- Time that this message was sent -->
+            <Field Name="TimeSent" Type="int64" Units="milliseconds since 1 Jan 1970" />
+        </Struct>
+    
+        <!-- Message reporting that the onboard processor is functioning -->
+        <Struct Name="OnboardProcessorIsAlive" >
+            <!-- ID of vehicle with onboard processor -->
+            <Field Name="VehicleID" Type="int64" />
+            <!-- Time that this message was sent -->
+            <Field Name="TimeSent" Type="int64" Units="milliseconds since 1 Jan 1970" />
+        </Struct>
+        
+        <!-- Entity Join -->
+        <Struct Name="EntityJoin" >
+            <!-- ID of entity joining network -->
+            <Field Name="EntityID" Type="int64" />
+            <!-- Label of entity joining network -->
+            <Field Name="Label" Type="string" />
+        </Struct>
+
+        <!-- Entity Exit -->
+        <Struct Name="EntityExit" >
+            <!-- ID of entity exiting network -->
+            <Field Name="EntityID" Type="int64" />
+            <!-- Label of entity exiting network -->
+            <Field Name="Label" Type="string" />
+        </Struct>  
+
+ </StructList>
+</MDM>
diff --git a/src/LMCP/UXTASK.xml b/src/LMCP/UXTASK.xml
new file mode 100644
index 0000000..209c57c
--- /dev/null
+++ b/src/LMCP/UXTASK.xml
@@ -0,0 +1,421 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE MDM SYSTEM 'MDM.DTD'>
+
+<!--
+        <h2>Introduction</h2>
+        This MDM defines the interface for stand-alone (possibly external) tasks managed by UxAS
+-->
+
+<MDM>
+    <SeriesName>UXTASK</SeriesName>
+    <Namespace>uxas/messages/task</Namespace>
+    <Version>6</Version>
+    
+    <EnumList>
+    </EnumList>
+    
+    <StructList>
+        
+        <!-- This task facilitates assignment coordination. When a {@link CoordinatedAutomationRequest}
+        message is received, the {@link AssignmentCoordinatorTask} task waits for up to {@link MaximumResponseTime}
+        for {@link AssignmentCoordination} from all the other entities in the EligibleEtities list of
+        the {@link CoordinatedAutomationRequest} message. Once states have been 
+        received for all the EligibleEntities, they are used for planning and assignmnet for 
+        the specified {@link CoordinatedAutomationRequest}-->
+        <Struct Name="AssignmentCoordinatorTask" Extends="CMASI/Task">
+        </Struct>
+
+        <!-- The state of an entity to be used as the initial planning state when 
+        constructing assignments/plans. -->
+        <Struct Name="PlanningState">
+            <!-- Identifier of the entitiy -->
+            <Field Name="EntityID" Type="int64" />
+            <!-- Initial position of this entity for the plan -->
+            <Field Name="PlanningPosition" Type="CMASI/Location3D" />
+             <!-- Initial heading of this entity for the plan -->
+            <Field Name="PlanningHeading" Type="real32" />
+        </Struct>
+        
+        <!-- This messages is used to syncronize the entity states, used for planning, to 
+        facilitate assignment coordination. When an entity receives a {@link CoordinatedAutomationRequest} 
+        message it's {@link AssignmentCoordinatorTask} task sends out a AssignmentCoordination message with the entity's planning state. -->
+        <Struct Name="AssignmentCoordination">
+            <!-- Identifier of the associated CoordinatedAutomationRequest -->
+            <Field Name="CoordinatedAutomationRequestID" Type="int64" />
+            <!-- The state of the entity that will used for planning/assignment of 
+            the given automation request.  -->
+            <Field Name="PlanningState" Type="PlanningState" />
+        </Struct>
+        
+        <!-- A CMASI automation request (with Identifier) that requires coordination among 
+        the eligible entities. Note: entities must have a {@link AssignmentCoordinatorTask} task
+        running to utilize this this message.-->
+        <Struct Name="CoordinatedAutomationRequest">
+            <!-- Identifier for tracking requests and coordination -->
+            <Field Name="RequestID" Type="int64" />
+            <!-- This is the maximum time to wait for {@link AssignmentCoordination} messages
+            from the other eligible entities, before proceeding with the assignment. 
+            Note: the value of -1 indicates that there is no limit. If there are no eligble entites
+            listed in the {@link CoordinatedAutomationRequest}, then {@link MaximumResponseTime} is the
+            amount of time the {@link AssignmentCoordinatorTask} waits for {@link AssignmentCoordination} messages
+            before proceeding with the assignment. Note: if there are no eligble entities and the 
+            {@link MaximumResponseTime} is -1, then the {@link AssignmentCoordination} proceeds with
+            the assignment immediately. -->
+            <Field Name="MaximumResponseTime" Type="int64"  Default="-1"  Units="milliseconds"/>
+            <!-- Original automation request without a unique identifier -->
+            <Field Name="OriginalRequest" Type="CMASI/AutomationRequest" />
+            <!-- The initial states of entities used in planning. Note: if an eligible
+            entity does not have a PlanningState, then it must be obtained from the entity
+            in an {@link AssignmentCoordination} message. -->
+            <Field Name="PlanningStates" Type="PlanningState[]" />
+        </Struct>
+        
+        <!-- A CMASI automation request (with Identifier) that is sent by tasks. -->
+        <Struct Name="TaskAutomationRequest">
+            <!-- Identifier for tracking requests and responses -->
+            <Field Name="RequestID" Type="int64" />
+            <!-- Original automation request without a unique identifier -->
+            <Field Name="OriginalRequest" Type="CMASI/AutomationRequest" />
+            <!-- If this boolean is true, then the resulting plans based on this
+            automation request will not be directly implemented, for example, tasks should 
+            not expect the waypoints generated for this request to be active -->
+            <Field Name="SandBoxRequest" Type="bool" Default="false" />
+            <!-- The initial states of entities used in planning. Note: if an eligible
+            entity does not have a PlanningState, then it's most recent EntityState is used for 
+            plannning. -->
+            <Field Name="PlanningStates" Type="PlanningState[]" />
+        </Struct>
+        
+        <!-- A CMASI automation response (with Identifier) that is sent back to tasks. -->
+        <Struct Name="TaskAutomationResponse">
+            <!-- Identifier for tracking requests and responses. Must match RequestID
+            from corresponding TaskAutomationRequest -->
+            <Field Name="ResponseID" Type="int64" />
+            <!-- Original automation request without a unique identifier -->
+            <Field Name="OriginalResponse" Type="CMASI/AutomationResponse" />
+        </Struct>
+        
+        <!-- Patches CMASI automation request to add a unique identifier -->
+        <Struct Name="UniqueAutomationRequest">
+            <!-- Identifier for tracking requests and responses -->
+            <Field Name="RequestID" Type="int64" />
+            <!-- Original automation request without a unique identifier -->
+            <Field Name="OriginalRequest" Type="CMASI/AutomationRequest" />
+            <!-- If this boolean is true, then the resulting plans based on this
+            automation request will not be directly implemented, for example, tasks should 
+            not expect the waypoints generated for this request to be active -->
+            <Field Name="SandBoxRequest" Type="bool" Default="false" />
+            <!-- The initial states of entities used in planning. Note: if an eligible
+            entity does not have a PlanningState, then it's most recent EntityState is used for 
+            plannning. -->
+            <Field Name="PlanningStates" Type="PlanningState[]" />
+        </Struct>
+        
+        <!-- Patches CMASI automation response to add a unique identifier -->
+        <Struct Name="UniqueAutomationResponse">
+            <!-- Identifier for tracking requests and responses. Must match RequestID
+            from corresponding UniqueAutomationRequest -->
+            <Field Name="ResponseID" Type="int64" />
+            <!-- Original automation request without a unique identifier -->
+            <Field Name="OriginalResponse" Type="CMASI/AutomationResponse" />
+        </Struct>
+        
+        <!-- Request to compute a set of sensor footprints from possible vehicles in the system -->
+        <Struct Name="SensorFootprintRequests">
+            <!-- Request ID for correlating to response -->
+            <Field Name="RequestID" Type="int64" />
+            <!-- Request ID for correlating to response -->
+            <Field Name="Footprints" Type="FootprintRequest[]" />
+        </Struct>
+        
+        <!-- Request to compute potential eligible sensor footprint for a single vehicle at
+        various GSDs and altitudes from available sensors on the vehicle -->
+        <Struct Name="FootprintRequest">
+            <!-- ID corresponding to this specific footprint request -->
+            <Field Name="FootprintRequestID" Type="int64" />
+            <!-- Single vehicle to be considered for sensor request. -->
+            <Field Name="VehicleID" Type="int64" />
+            <!-- Camera wavelength to be considered. If list is empty, planner
+            should plan for all available sensors on each entity -->
+            <Field Name="EligibleWavelengths" Type="CMASI/WavelengthBand[]" />
+            <!-- Desired ground sample distance for an eligible sensor. If list is
+            empty, then footprint calculation uses the max ground sample distance
+            for the specified altitude. -->
+            <Field Name="GroundSampleDistances" Type="real32[]" />
+            <!-- AGL Altitude to consider during sensor information calculation.
+            If 'AglAltitudes' list is empty, sensor planner should use nominal
+            altitude from entity configurations -->
+            <Field Name="AglAltitudes" Type="real32[]" Units="meters" />
+            <!-- Desired camera elevation angles. If list is empty, then uses an
+            optimal elevation angle for achieving max GSD -->
+            <Field Name="ElevationAngles" Type="real32[]" Units="deg" />
+        </Struct>
+        
+        <!-- Description of a sensor footprint -->
+        <Struct Name="SensorFootprint">
+            <!-- Response ID that matches corresponding request ID. Note that multiple
+            responses may be generated from a single request (such as multiple cameras
+            which all meet the specification). Each response must contain the matching
+            request ID in it's FootprintResponseID field. -->
+            <Field Name="FootprintResponseID" Type="int64" />
+            <!-- Vehicle for which the footprint calculation applies -->
+            <Field Name="VehicleID" Type="int64" />
+            <!-- Camera from which settings (such as zoom and field of view)
+            were used in the footprint calculation -->
+            <Field Name="CameraID" Type="int64" />
+            <!-- Gimbal from which parameters such as allowable steering angles
+            were used in the footprint calculation -->
+            <Field Name="GimbalID" Type="int64" />
+            <!-- The selected horizontal field of view of the camera necessary
+            to get the reported footprint (equivalent to zoom) -->
+            <Field Name="HorizontalFOV" Type="real32" Units="degrees" />
+            <!-- Altitude above ground level for which the footprint was calculated -->
+            <Field Name="AglAltitude" Type="real32" Units="meters" />
+            <!-- Commanded gimbal elevation to achieve sensor footprint -->
+            <Field Name="GimbalElevation" Type="real32" Units="degrees" />
+            <!-- Aspect ratio (width/height) of the camera image used for footprint calculation.
+            Note: combine with horizontal field of view to determine camera vertical field of view. -->
+            <Field Name="AspectRatio" Type="real32" Units="None" />
+            <!-- Ground sample distance obtained with this sensor footprint -->
+            <Field Name="AchievedGSD" Type="real32" Units="meters/pixel" />
+            <!-- Sensor wavelength used applicable to this footprint calculation -->
+            <Field Name="CameraWavelength" Type="CMASI/WavelengthBand" />
+            <!-- Distance out front of the entity to the leading edge -->
+            <Field Name="HorizontalToLeadingEdge" Type="real32" Units="meters" />
+            <!-- Distance out front of the entity to the trailing edge -->
+            <Field Name="HorizontalToTrailingEdge" Type="real32" Units="meters" />
+            <!-- Distance out front of the entity to the center of the footprint -->
+            <Field Name="HorizontalToCenter" Type="real32" Units="meters" />
+            <!-- Width of the footprint at the vertical center -->
+            <Field Name="WidthCenter" Type="real32" Units="meters" />
+            <!-- At the prescribed settings (e.g. altitude, elevation angle, etc) the distance
+            from the camera to the center of the footprint -->
+            <Field Name="SlantRangeToCenter" Type="real32" Units="meters" />
+        </Struct>
+        
+        <!-- Response to a Sensor Footprint Request containing all sensor
+        footprint information -->
+        <Struct Name="SensorFootprintResponse">
+            <!-- ID matching initial request ID -->
+            <Field Name="ResponseID" Type="int64" />
+            <!-- All sensor footprints calculated during request -->
+            <Field Name="Footprints" Type="SensorFootprint[]" />
+        </Struct>
+        
+        <!-- Request to generate waypoints enroute to the task as well as to complete a task.
+        From a given start position and heading, a task must plan enroute waypoints to reach
+        the task and then append task waypoints for computing the task and then report final
+        position and heading of the vehicle. -->
+        <Struct Name="TaskImplementationRequest">
+            <!-- Request ID for correlating to matching response -->
+            <Field Name="RequestID" Type="int64" />
+            <!-- Starting waypoint ID that task must use when building response. Note that
+            Plan Builder reserves all values greater than 1,000,000,000. Therefore all
+            *internal* task waypoints must be less than 1e9 and can be obtained from the
+            reported waypoint number by "waypoint->getNumber()%1e9" .-->
+            <Field Name="StartingWaypointID" Type="int64" />
+            <!-- Assigned vehicle ID -->
+            <Field Name="VehicleID" Type="int64" />
+            <!-- Initial position of entity before task -->
+            <Field Name="StartPosition" Type="CMASI/Location3D" />
+            <!-- Initial heading of entity before task -->
+            <Field Name="StartHeading" Type="real32" Units="degrees" />
+            <!-- Time when vehicle is at the starting location -->
+            <Field Name="StartTime" Type="int64" Units="milliseconds since 1 Jan 1970" />
+            <!-- ID for full region in which entity should plan -->
+            <Field Name="RegionID" Type="int64" />
+            <!-- Task ID to be completed -->
+            <Field Name="TaskID" Type="int64" />
+            <!-- Using option ID to complete this task -->
+            <Field Name="OptionID" Type="int64" />
+            <!-- Time before which this task cannot begin -->
+            <Field Name="TimeThreshold" Type="int64" Units="milliseconds since 1 Jan 1970" />
+        </Struct>
+        
+        <!-- Response to a final task implementation request (one for each vehicle assigned).
+        Note that in addition to calculating task waypoints that achieve that task purpose,
+        a task implementation also includes the enroute waypoints to get the vehicle(s) to 
+        that task to be completed. Finally, an ending position and heading for the vehicle is
+        reported so that the next task in order will have a valid start position and heading. -->
+        <Struct Name="TaskImplementationResponse">
+            <!-- Response ID that matches the initial request -->
+            <Field Name="ResponseID" Type="int64" />
+            <!-- Task ID -->
+            <Field Name="TaskID" Type="int64" />
+            <!-- Option ID that was selected for this task -->
+            <Field Name="OptionID" Type="int64" />
+            <!-- Vehicle ID -->
+            <Field Name="VehicleID" Type="int64" />
+            <!-- Waypoints that implement this task for the indicated vehicle -->
+            <Field Name="TaskWaypoints" Type="CMASI/Waypoint[]" />
+            <!-- Vehicle location when this task is complete -->
+            <Field Name="FinalLocation" Type="CMASI/Location3D" />
+            <!-- Vehicle heading when this task is complete -->
+            <Field Name="FinalHeading" Type="real32" Units="degrees" />
+            <!-- Time when vehicle is at the final location -->
+            <Field Name="FinalTime" Type="int64" Units="milliseconds since 1 Jan 1970" />
+        </Struct>
+        
+        <!-- Matrix of costs consisting of:
+        (1) costs from initial vehicle positions to all task options; and
+        (2) costs from each task option to every other task option -->
+	<Struct Name="AssignmentCostMatrix" >
+            <!-- ID that matches this cost matrix with the appropriate unique automation request -->
+            <Field Name="CorrespondingAutomationRequestID" Type="int64" />
+            <!-- Over-arching task relationship description (directly from
+            automation request). A process algebra string with only task IDs. -->
+            <Field Name="TaskLevelRelationship" Type="string" />
+            <!-- List of all tasks that this cost matrix includes -->
+            <Field Name="TaskList" Type="int64[]" />
+            <!-- Operating region that was used during matrix calculation -->
+            <Field Name="OperatingRegion" Type="int64" />
+            <!-- Set of task-to-task timings for each requested vehicle -->
+            <Field Name="CostMatrix" Type="TaskOptionCost[]" />
+        </Struct>
+        
+        <!-- Single task option cost for a particular vehicle -->
+	<Struct Name="TaskOptionCost" >
+            <!-- Corresponding Vehicle ID -->
+            <Field Name="VehicleID" Type="int64" />
+            <!-- Initial task ID (if zero, corresponds to current vehicle location) -->
+            <Field Name="IntialTaskID" Type="int64" />
+            <!-- Initial task option -->
+            <Field Name="IntialTaskOption" Type="int64" />
+            <!-- Destination task ID -->
+            <Field Name="DestinationTaskID" Type="int64" />
+            <!-- Destination task option -->
+            <Field Name="DestinationTaskOption" Type="int64" />
+            <!-- Timing corresponding to travel between ('InitialTask' using 'InitialTaskOption')
+            and ('DestinationTask' using 'DestinationTaskOption'). If time is less than zero,
+            no feasible path exists between tasks. -->
+            <Field Name="TimeToGo" Type="int64" Units="milliseconds" />
+        </Struct>
+        
+        <!-- Representation of the assignment of entities to a task -->
+        <Struct Name="TaskAssignment">
+            <!-- Task ID -->
+            <Field Name="TaskID" Type="int64" />
+            <!-- Option ID that was selected for this task -->
+            <Field Name="OptionID" Type="int64" />
+            <!-- Vehicle that is assigned to this task -->
+            <Field Name="AssignedVehicle" Type="int64" />
+            <!-- Time before which this task cannot begin -->
+            <Field Name="TimeThreshold" Type="int64" Units="milliseconds since 1 Jan 1970" />
+            <!-- Time that this task is assigned to be completed. -->
+            <Field Name="TimeTaskCompleted" Type="int64" Units="milliseconds since 1 Jan 1970" />
+        </Struct>
+        
+        <!-- A completed assignment consisting of an <b>ordered</b> list of tasks -->
+        <Struct Name="TaskAssignmentSummary">
+            <!-- ID that matches this summary with the appropriate unique automation request -->
+            <Field Name="CorrespondingAutomationRequestID" Type="int64" />
+            <!-- Operating region which was considered during this assignment -->
+            <Field Name="OperatingRegion" Type="int64" />
+            <!-- Ordered list of tasks to be completed -->
+            <Field Name="TaskList" Type="TaskAssignment[]" />
+        </Struct>
+
+        <!-- Start/end locations and headings and cost for implementing the task from this configuration -->
+        <Struct Name="TaskOption">
+            <!-- Task ID -->
+            <Field Name="TaskID" Type="int64" />
+            <!-- ID for this option -->
+            <Field Name="OptionID" Type="int64" />
+            <!-- Eligible entities for completing this option with identical cost to complete. If list is empty, then all vehicles are assumed to be eligible. -->
+            <Field Name="EligibleEntities" Type="int64[]" />
+            <!-- Cost to complete option in terms of time (given in milliseconds) -->
+            <Field Name="Cost" Type="int64" Units="milliseconds"/>
+            <!-- Start location entering the option -->
+            <Field Name="StartLocation" Type="CMASI/Location3D" />
+            <!-- Start heading entering the option -->
+            <Field Name="StartHeading" Type="real32" Units="degrees" />
+            <!-- Ending location for this option -->
+            <Field Name="EndLocation" Type="CMASI/Location3D" />
+            <!-- Ending heading for this option -->
+            <Field Name="EndHeading" Type="real32" Units="degrees" />
+        </Struct>
+        
+        <!-- Summary of available options to complete this task -->
+        <Struct Name="TaskPlanOptions">
+            <!-- ID that matches this message with the appropriate unique automation request -->
+            <Field Name="CorrespondingAutomationRequestID" Type="int64" />
+            <!-- Task ID -->
+            <Field Name="TaskID" Type="int64" />
+            <!-- Process algebra string encoding all of the different options -->
+            <Field Name="Composition" Type="string" />
+            <!-- List of options -->
+            <Field Name="Options" Type="TaskOption[]" />
+        </Struct>
+        
+        <!-- Place a task in a 'paused' state where it no longer sends commands to any entities -->
+        <Struct Name="TaskPause">
+            <!-- Task ID -->
+            <Field Name="TaskID" Type="int64" />
+        </Struct>
+        
+        <!-- Resumes execution of a task from it's paused state -->
+        <Struct Name="TaskResume">
+            <!-- Task ID -->
+            <Field Name="TaskID" Type="int64" />
+            <!-- Instead of resuming from paused task state, re-start the complete task -->
+            <Field Name="RestartCompletely" Type="bool" Default="false" />
+            <!-- Instead of resuming from paused task state with the previously assigned entities, resume task with new assignment options -->
+            <Field Name="ReAssign" Type="TaskAssignment" Default="NULL" />
+        </Struct>
+        
+        <!-- Reports the progress of the task -->
+        <Struct Name="TaskProgress">
+            <!-- Response ID that matches the task progress request -->
+            <Field Name="ResponseID" Type="int64" />
+            <!-- Task ID -->
+            <Field Name="TaskID" Type="int64" />
+            <!-- Percentage of progress on task -->
+            <Field Name="PercentComplete" Type="real32" />
+            <!-- Entities that are working this task -->
+            <Field Name="EntitiesEngaged" Type="int64[]" />
+        </Struct>
+        
+        <!-- Optional task progress query -->
+        <Struct Name="TaskProgressRequest">
+            <!-- Task progress request ID for properly matching corresponding response -->
+            <Field Name="RequestID" Type="int64" />
+            <!-- Task ID to report current progress -->
+            <Field Name="TaskID" Type="int64" />
+        </Struct>
+        
+        <!-- Task initialized message indicating that the corresponding task service is available for use in automation requests -->
+        <Struct Name="TaskInitialized" >
+            <!-- Task ID is initialized and ready for use in automation requests -->
+            <Field Name="TaskID" Type="int64" />
+        </Struct>
+
+        <!-- Task Active message. Sent when task becomes active -->
+        <Struct Name="TaskActive" >
+            <!-- Task ID that was just activated -->
+            <Field Name="TaskID" Type="int64" />
+            <!-- Entity ID that activated the task -->
+            <Field Name="EntityID" Type="int64" />
+            <!-- Time that this task was activated. -->
+            <Field Name="TimeTaskActivated" Type="int64" Units="milliseconds since 1 Jan 1970" />
+        </Struct>
+
+        <!-- Task complete message -->
+        <Struct Name="TaskComplete" >
+            <!-- Task ID that was just completed -->
+            <Field Name="TaskID" Type="int64" />
+            <!-- Entity IDs that completed the task -->
+            <Field Name="EntitiesInvolved" Type="int64[]" />
+            <!-- Time that this task was completed. -->
+            <Field Name="TimeTaskCompleted" Type="int64" Units="milliseconds since 1 Jan 1970" />
+        </Struct>
+        
+        <!-- Task cancel message -->
+        <Struct Name="CancelTask" >
+            <!-- List of vehicle IDs that are directed to cancel tasks. If empty, all vehicles currently on a listed task will be directed to cancel. -->
+            <Field Name="Vehicles" Type="int64[]" />
+            <!-- Task ID(s) to be removed from task lists of indicated vehicles. If empty, then only the current task is removed. -->
+            <Field Name="CanceledTasks" Type="int64[]" />
+        </Struct>
+        
+    </StructList>
+</MDM>
diff --git a/src/LMCP/afrl/cmasi/AbstractGeometry.h b/src/LMCP/afrl/cmasi/AbstractGeometry.h
new file mode 100644
index 0000000..7989644
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AbstractGeometry.h
@@ -0,0 +1,100 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_ABSTRACTGEOMETRY_H_
+#define _AFRL_CMASI_ABSTRACTGEOMETRY_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isAbstractGeometry(avtas::lmcp::Object* obj);
+   bool isAbstractGeometry(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AbstractGeometryDescendants();
+   
+   class AbstractGeometry : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AbstractGeometry(void);
+
+      // Copy Constructor
+      AbstractGeometry(const AbstractGeometry &that);
+
+      // Assignment Operator
+      AbstractGeometry & operator=(const AbstractGeometry &that);
+
+      // Destructor
+      virtual ~AbstractGeometry(void);
+
+      // Equals overload
+      bool operator==(const AbstractGeometry & that);
+      bool operator!=(const AbstractGeometry & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AbstractGeometry* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 1; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+
+
+   protected:
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_ABSTRACTGEOMETRY_H_
diff --git a/src/LMCP/afrl/cmasi/AbstractGeometryDescendants.h b/src/LMCP/afrl/cmasi/AbstractGeometryDescendants.h
new file mode 100644
index 0000000..d3f65a2
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AbstractGeometryDescendants.h
@@ -0,0 +1,15 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/Circle.h"
+#include "afrl/cmasi/Polygon.h"
+#include "afrl/cmasi/Rectangle.h"
+
diff --git a/src/LMCP/afrl/cmasi/AbstractZone.h b/src/LMCP/afrl/cmasi/AbstractZone.h
new file mode 100644
index 0000000..0e853c7
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AbstractZone.h
@@ -0,0 +1,169 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_ABSTRACTZONE_H_
+#define _AFRL_CMASI_ABSTRACTZONE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AltitudeType.h"
+#include "afrl/cmasi/AltitudeType.h"
+#include "afrl/cmasi/AbstractGeometry.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isAbstractZone(avtas::lmcp::Object* obj);
+   bool isAbstractZone(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AbstractZoneDescendants();
+   
+   class AbstractZone : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AbstractZone(void);
+
+      // Copy Constructor
+      AbstractZone(const AbstractZone &that);
+
+      // Assignment Operator
+      AbstractZone & operator=(const AbstractZone &that);
+
+      // Destructor
+      virtual ~AbstractZone(void);
+
+      // Equals overload
+      bool operator==(const AbstractZone & that);
+      bool operator!=(const AbstractZone & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AbstractZone* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 10; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** A globally unique reference number for this zone (Units: None)*/
+      int64_t getZoneID(void) const { return __ZoneID; }
+      AbstractZone& setZoneID(const int64_t val);
+
+      /** Lower altitude bound for the zone (Units: meter)*/
+      float getMinAltitude(void) const { return __MinAltitude; }
+      AbstractZone& setMinAltitude(const float val);
+
+      /** Altitude type for min altitude (Units: None)*/
+      afrl::cmasi::AltitudeType::AltitudeType getMinAltitudeType(void) const { return __MinAltitudeType; }
+      AbstractZone& setMinAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val);
+
+      /** Maximum altitude for operations (Units: meter)*/
+      float getMaxAltitude(void) const { return __MaxAltitude; }
+      AbstractZone& setMaxAltitude(const float val);
+
+      /** Altitude type for max altitude (Units: None)*/
+      afrl::cmasi::AltitudeType::AltitudeType getMaxAltitudeType(void) const { return __MaxAltitudeType; }
+      AbstractZone& setMaxAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val);
+
+      /** A list of aircraft IDs that this zone applies to. If the list is empty, then it is assumed that the boundary applies to all aircraft. (Units: None)*/
+      std::vector<int64_t> & getAffectedAircraft(void) { return __AffectedAircraft; }
+
+      /** Time at which this zone becomes active. Time datum is defined by the application, but unless otherwise specified is milliseconds since 1 Jan 1970 (Units: milliseconds)*/
+      int64_t getStartTime(void) const { return __StartTime; }
+      AbstractZone& setStartTime(const int64_t val);
+
+      /** Time at which this zone becomes inactive. Time datum is defined by the application, but unless otherwise specified is milliseconds since 1 Jan 1970 (Units: milliseconds)*/
+      int64_t getEndTime(void) const { return __EndTime; }
+      AbstractZone& setEndTime(const int64_t val);
+
+      /** Buffer to add/subtract around the border of the zone (Units: meters)*/
+      float getPadding(void) const { return __Padding; }
+      AbstractZone& setPadding(const float val);
+
+      /** Optional label for this zone (Units: None)*/
+      std::string getLabel(void) const { return __Label; }
+      AbstractZone& setLabel(const std::string val);
+
+      /** Geometry object describing the boundary. This boundary is 2-dimensional. The zone boundary is defined as an extrusion of this boundary from MinAltitude to MaxAltitude. (Units: None)*/
+      afrl::cmasi::AbstractGeometry* const getBoundary(void) { return __Boundary; }
+      AbstractZone& setBoundary(const afrl::cmasi::AbstractGeometry* const val);
+
+
+
+   protected:
+      /** A globally unique reference number for this zone */
+      int64_t __ZoneID;
+      /** Lower altitude bound for the zone */
+      float __MinAltitude;
+      /** Altitude type for min altitude */
+      afrl::cmasi::AltitudeType::AltitudeType __MinAltitudeType;
+      /** Maximum altitude for operations */
+      float __MaxAltitude;
+      /** Altitude type for max altitude */
+      afrl::cmasi::AltitudeType::AltitudeType __MaxAltitudeType;
+      /** A list of aircraft IDs that this zone applies to. If the list is empty, then it is assumed that the boundary applies to all aircraft. */
+      std::vector< int64_t > __AffectedAircraft;
+      /** Time at which this zone becomes active. Time datum is defined by the application, but unless otherwise specified is milliseconds since 1 Jan 1970 */
+      int64_t __StartTime;
+      /** Time at which this zone becomes inactive. Time datum is defined by the application, but unless otherwise specified is milliseconds since 1 Jan 1970 */
+      int64_t __EndTime;
+      /** Buffer to add/subtract around the border of the zone */
+      float __Padding;
+      /** Optional label for this zone */
+      std::string __Label;
+      /** Geometry object describing the boundary. This boundary is 2-dimensional. The zone boundary is defined as an extrusion of this boundary from MinAltitude to MaxAltitude. */
+      afrl::cmasi::AbstractGeometry* __Boundary;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_ABSTRACTZONE_H_
diff --git a/src/LMCP/afrl/cmasi/AbstractZoneDescendants.h b/src/LMCP/afrl/cmasi/AbstractZoneDescendants.h
new file mode 100644
index 0000000..7c74872
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AbstractZoneDescendants.h
@@ -0,0 +1,15 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/KeepInZone.h"
+#include "afrl/cmasi/KeepOutZone.h"
+#include "afrl/impact/WaterZone.h"
+
diff --git a/src/LMCP/afrl/cmasi/AirVehicleConfiguration.h b/src/LMCP/afrl/cmasi/AirVehicleConfiguration.h
new file mode 100644
index 0000000..21a5071
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AirVehicleConfiguration.h
@@ -0,0 +1,164 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_AIRVEHICLECONFIGURATION_H_
+#define _AFRL_CMASI_AIRVEHICLECONFIGURATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/EntityConfiguration.h"
+#include "afrl/cmasi/FlightProfile.h"
+#include "afrl/cmasi/FlightProfile.h"
+#include "afrl/cmasi/LoiterType.h"
+#include "afrl/cmasi/TurnType.h"
+#include "afrl/cmasi/AltitudeType.h"
+#include "afrl/cmasi/AltitudeType.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isAirVehicleConfiguration(avtas::lmcp::Object* obj);
+   bool isAirVehicleConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AirVehicleConfigurationDescendants();
+   
+   class AirVehicleConfiguration : public afrl::cmasi::EntityConfiguration {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AirVehicleConfiguration(void);
+
+      // Copy Constructor
+      AirVehicleConfiguration(const AirVehicleConfiguration &that);
+
+      // Assignment Operator
+      AirVehicleConfiguration & operator=(const AirVehicleConfiguration &that);
+
+      // Destructor
+      virtual ~AirVehicleConfiguration(void);
+
+      // Equals overload
+      bool operator==(const AirVehicleConfiguration & that);
+      bool operator!=(const AirVehicleConfiguration & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AirVehicleConfiguration* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 13; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The minimum true airspeed that should be commanded for this aircraft (Units: meter/sec)*/
+      float getMinimumSpeed(void) const { return __MinimumSpeed; }
+      AirVehicleConfiguration& setMinimumSpeed(const float val);
+
+      /** The maximum true airspeed that should be commanded for this aircraft (Units: meter/sec)*/
+      float getMaximumSpeed(void) const { return __MaximumSpeed; }
+      AirVehicleConfiguration& setMaximumSpeed(const float val);
+
+      /** Describes the preferred operating mode for most planning purposes. This can be a max range or endurance speed profile, or any other operating point chosen by a user. This field may not be null. (Units: None)*/
+      afrl::cmasi::FlightProfile* const getNominalFlightProfile(void) { return __NominalFlightProfile; }
+      AirVehicleConfiguration& setNominalFlightProfile(const afrl::cmasi::FlightProfile* const val);
+
+      /** A list of all flight configurations described for this vehicle. Each flight configuration specifies a different mode of flight, for instance: climb, cruise, dash, loiter. This list may be empty, and does not necessarily contain the nominal flight configuration. (Units: None)*/
+      std::vector<afrl::cmasi::FlightProfile*> & getAlternateFlightProfiles(void) { return __AlternateFlightProfiles; }
+
+      /** A list of available loiter types for this aircraft (Units: None)*/
+      std::vector<afrl::cmasi::LoiterType::LoiterType> & getAvailableLoiterTypes(void) { return __AvailableLoiterTypes; }
+
+      /** A list of available turning modes for this aircraft (Units: None)*/
+      std::vector<afrl::cmasi::TurnType::TurnType> & getAvailableTurnTypes(void) { return __AvailableTurnTypes; }
+
+      /** Minimum MSL altitude that this aircraft is allowed to fly. This value should be treated as a regulatory or safety-of-flight parameter and therefore takes precedence over other requests. (Units: meter)*/
+      float getMinimumAltitude(void) const { return __MinimumAltitude; }
+      AirVehicleConfiguration& setMinimumAltitude(const float val);
+
+      /** Altitude type for min altitude (Units: None)*/
+      afrl::cmasi::AltitudeType::AltitudeType getMinAltitudeType(void) const { return __MinAltitudeType; }
+      AirVehicleConfiguration& setMinAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val);
+
+      /** Maximum MSL altitude that this aircraft is allowed to fly. This value should be treated as a regulatory or safety-of-flight parameter and therefore takes precedence over other requests. (Units: meter)*/
+      float getMaximumAltitude(void) const { return __MaximumAltitude; }
+      AirVehicleConfiguration& setMaximumAltitude(const float val);
+
+      /** Altitude type for max altitude (Units: None)*/
+      afrl::cmasi::AltitudeType::AltitudeType getMaxAltitudeType(void) const { return __MaxAltitudeType; }
+      AirVehicleConfiguration& setMaxAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val);
+
+
+
+   protected:
+      /** The minimum true airspeed that should be commanded for this aircraft */
+      float __MinimumSpeed;
+      /** The maximum true airspeed that should be commanded for this aircraft */
+      float __MaximumSpeed;
+      /** Describes the preferred operating mode for most planning purposes. This can be a max range or endurance speed profile, or any other operating point chosen by a user. This field may not be null. */
+      afrl::cmasi::FlightProfile* __NominalFlightProfile;
+      /** A list of all flight configurations described for this vehicle. Each flight configuration specifies a different mode of flight, for instance: climb, cruise, dash, loiter. This list may be empty, and does not necessarily contain the nominal flight configuration. */
+      std::vector< afrl::cmasi::FlightProfile* > __AlternateFlightProfiles;
+      /** A list of available loiter types for this aircraft */
+      std::vector< afrl::cmasi::LoiterType::LoiterType > __AvailableLoiterTypes;
+      /** A list of available turning modes for this aircraft */
+      std::vector< afrl::cmasi::TurnType::TurnType > __AvailableTurnTypes;
+      /** Minimum MSL altitude that this aircraft is allowed to fly. This value should be treated as a regulatory or safety-of-flight parameter and therefore takes precedence over other requests. */
+      float __MinimumAltitude;
+      /** Altitude type for min altitude */
+      afrl::cmasi::AltitudeType::AltitudeType __MinAltitudeType;
+      /** Maximum MSL altitude that this aircraft is allowed to fly. This value should be treated as a regulatory or safety-of-flight parameter and therefore takes precedence over other requests. */
+      float __MaximumAltitude;
+      /** Altitude type for max altitude */
+      afrl::cmasi::AltitudeType::AltitudeType __MaxAltitudeType;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_AIRVEHICLECONFIGURATION_H_
diff --git a/src/LMCP/afrl/cmasi/AirVehicleConfigurationDescendants.h b/src/LMCP/afrl/cmasi/AirVehicleConfigurationDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AirVehicleConfigurationDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/AirVehicleState.h b/src/LMCP/afrl/cmasi/AirVehicleState.h
new file mode 100644
index 0000000..c480e49
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AirVehicleState.h
@@ -0,0 +1,124 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_AIRVEHICLESTATE_H_
+#define _AFRL_CMASI_AIRVEHICLESTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/EntityState.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isAirVehicleState(avtas::lmcp::Object* obj);
+   bool isAirVehicleState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AirVehicleStateDescendants();
+   
+   class AirVehicleState : public afrl::cmasi::EntityState {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AirVehicleState(void);
+
+      // Copy Constructor
+      AirVehicleState(const AirVehicleState &that);
+
+      // Assignment Operator
+      AirVehicleState & operator=(const AirVehicleState &that);
+
+      // Destructor
+      virtual ~AirVehicleState(void);
+
+      // Equals overload
+      bool operator==(const AirVehicleState & that);
+      bool operator!=(const AirVehicleState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AirVehicleState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 15; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** vehicle true airspeed (Units: meter/sec)*/
+      float getAirspeed(void) const { return __Airspeed; }
+      AirVehicleState& setAirspeed(const float val);
+
+      /** Vertical speed (positive upwards) of the vehicle in the inertial frame (rate of change of altitude) (Units: meter/sec)*/
+      float getVerticalSpeed(void) const { return __VerticalSpeed; }
+      AirVehicleState& setVerticalSpeed(const float val);
+
+      /** Wind speed as detected or computed by the vehicle (Units: meter/sec)*/
+      float getWindSpeed(void) const { return __WindSpeed; }
+      AirVehicleState& setWindSpeed(const float val);
+
+      /** Wind source direction (true) as detected or computed by the vehicle(Units: degree)*/
+      float getWindDirection(void) const { return __WindDirection; }
+      AirVehicleState& setWindDirection(const float val);
+
+
+
+   protected:
+      /** vehicle true airspeed */
+      float __Airspeed;
+      /** Vertical speed (positive upwards) of the vehicle in the inertial frame (rate of change of altitude) */
+      float __VerticalSpeed;
+      /** Wind speed as detected or computed by the vehicle */
+      float __WindSpeed;
+      /** Wind source direction (true) as detected or computed by the vehicle*/
+      float __WindDirection;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_AIRVEHICLESTATE_H_
diff --git a/src/LMCP/afrl/cmasi/AirVehicleStateDescendants.h b/src/LMCP/afrl/cmasi/AirVehicleStateDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AirVehicleStateDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/AltitudeType.h b/src/LMCP/afrl/cmasi/AltitudeType.h
new file mode 100644
index 0000000..01ce3de
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AltitudeType.h
@@ -0,0 +1,56 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_ALTITUDETYPE_H_
+#define _AFRL_CMASI_ALTITUDETYPE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace AltitudeType {
+   enum AltitudeType {
+       /**  Height above ground/survace level  */
+       AGL = 0,
+       /**  Height above WGS84 ellipsoid, mean sea level  */
+       MSL = 1
+
+   };
+
+   // generates a new AltitudeType value for the passed string
+   inline AltitudeType get_AltitudeType(std::string str) {
+       if ( str == "AGL") return AGL;
+       if ( str == "MSL") return MSL;
+        return AGL;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(AltitudeType e) {
+       switch(e) {
+        case AGL: return "AGL";
+        case MSL: return "MSL";
+        default: return "AGL";
+
+       }
+   }
+
+   }  // namespace AltitudeType
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_ALTITUDETYPE_H_
diff --git a/src/LMCP/afrl/cmasi/AreaSearchTask.h b/src/LMCP/afrl/cmasi/AreaSearchTask.h
new file mode 100644
index 0000000..a412195
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AreaSearchTask.h
@@ -0,0 +1,114 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_AREASEARCHTASK_H_
+#define _AFRL_CMASI_AREASEARCHTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/AbstractGeometry.h"
+#include "afrl/cmasi/Wedge.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isAreaSearchTask(avtas::lmcp::Object* obj);
+   bool isAreaSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AreaSearchTaskDescendants();
+   
+   class AreaSearchTask : public afrl::cmasi::SearchTask {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AreaSearchTask(void);
+
+      // Copy Constructor
+      AreaSearchTask(const AreaSearchTask &that);
+
+      // Assignment Operator
+      AreaSearchTask & operator=(const AreaSearchTask &that);
+
+      // Destructor
+      virtual ~AreaSearchTask(void);
+
+      // Equals overload
+      bool operator==(const AreaSearchTask & that);
+      bool operator!=(const AreaSearchTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AreaSearchTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 17; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Area to search (Units: None)*/
+      afrl::cmasi::AbstractGeometry* const getSearchArea(void) { return __SearchArea; }
+      AreaSearchTask& setSearchArea(const afrl::cmasi::AbstractGeometry* const val);
+
+      /** A list of acceptable look-angles for this task. Each wedge is defined relative to true North. To be a valid look angle, a sensor must be looking from a direction within the bounds of the wedge. (Units: None)*/
+      std::vector<afrl::cmasi::Wedge*> & getViewAngleList(void) { return __ViewAngleList; }
+
+
+
+   protected:
+      /** Area to search */
+      afrl::cmasi::AbstractGeometry* __SearchArea;
+      /** A list of acceptable look-angles for this task. Each wedge is defined relative to true North. To be a valid look angle, a sensor must be looking from a direction within the bounds of the wedge. */
+      std::vector< afrl::cmasi::Wedge* > __ViewAngleList;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_AREASEARCHTASK_H_
diff --git a/src/LMCP/afrl/cmasi/AreaSearchTaskDescendants.h b/src/LMCP/afrl/cmasi/AreaSearchTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AreaSearchTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/AutomationRequest.h b/src/LMCP/afrl/cmasi/AutomationRequest.h
new file mode 100644
index 0000000..b1550ab
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AutomationRequest.h
@@ -0,0 +1,129 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_AUTOMATIONREQUEST_H_
+#define _AFRL_CMASI_AUTOMATIONREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isAutomationRequest(avtas::lmcp::Object* obj);
+   bool isAutomationRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AutomationRequestDescendants();
+   
+   class AutomationRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AutomationRequest(void);
+
+      // Copy Constructor
+      AutomationRequest(const AutomationRequest &that);
+
+      // Assignment Operator
+      AutomationRequest & operator=(const AutomationRequest &that);
+
+      // Destructor
+      virtual ~AutomationRequest(void);
+
+      // Equals overload
+      bool operator==(const AutomationRequest & that);
+      bool operator!=(const AutomationRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AutomationRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 40; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** List of entities to consider when planning. (Units: None)*/
+      std::vector<int64_t> & getEntityList(void) { return __EntityList; }
+
+      /** list of task IDs (defined by {@link Task} messages) to be planned for by the automation service (Units: None)*/
+      std::vector<int64_t> & getTaskList(void) { return __TaskList; }
+
+      /** string containing the relationship between requested tasks. If empty, all tasks are to be completed in any order. The format of the string is specific to the automation service. This relationship string is the mechanism for incorporating task precedence, priority, timing, etc. (Units: None)*/
+      std::string getTaskRelationships(void) const { return __TaskRelationships; }
+      AutomationRequest& setTaskRelationships(const std::string val);
+
+      /** Operating region ID to be considered during planning (Units: None)*/
+      int64_t getOperatingRegion(void) const { return __OperatingRegion; }
+      AutomationRequest& setOperatingRegion(const int64_t val);
+
+      /** Denotes that that the planner should restart any tasks that have been performed or are currently being performed. This is useful in situations when a task request contains tasks that have been requested previously, and the operator wishes to restart the mission plans from the beginning. (Units: None)*/
+      bool getRedoAllTasks(void) const { return __RedoAllTasks; }
+      AutomationRequest& setRedoAllTasks(const bool val);
+
+
+
+   protected:
+      /** List of entities to consider when planning. */
+      std::vector< int64_t > __EntityList;
+      /** list of task IDs (defined by {@link Task} messages) to be planned for by the automation service */
+      std::vector< int64_t > __TaskList;
+      /** string containing the relationship between requested tasks. If empty, all tasks are to be completed in any order. The format of the string is specific to the automation service. This relationship string is the mechanism for incorporating task precedence, priority, timing, etc. */
+      std::string __TaskRelationships;
+      /** Operating region ID to be considered during planning */
+      int64_t __OperatingRegion;
+      /** Denotes that that the planner should restart any tasks that have been performed or are currently being performed. This is useful in situations when a task request contains tasks that have been requested previously, and the operator wishes to restart the mission plans from the beginning. */
+      bool __RedoAllTasks;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_AUTOMATIONREQUEST_H_
diff --git a/src/LMCP/afrl/cmasi/AutomationRequestDescendants.h b/src/LMCP/afrl/cmasi/AutomationRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AutomationRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/AutomationResponse.h b/src/LMCP/afrl/cmasi/AutomationResponse.h
new file mode 100644
index 0000000..845092a
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AutomationResponse.h
@@ -0,0 +1,119 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_AUTOMATIONRESPONSE_H_
+#define _AFRL_CMASI_AUTOMATIONRESPONSE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/MissionCommand.h"
+#include "afrl/cmasi/VehicleActionCommand.h"
+#include "afrl/cmasi/KeyValuePair.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isAutomationResponse(avtas::lmcp::Object* obj);
+   bool isAutomationResponse(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AutomationResponseDescendants();
+   
+   class AutomationResponse : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AutomationResponse(void);
+
+      // Copy Constructor
+      AutomationResponse(const AutomationResponse &that);
+
+      // Assignment Operator
+      AutomationResponse & operator=(const AutomationResponse &that);
+
+      // Destructor
+      virtual ~AutomationResponse(void);
+
+      // Equals overload
+      bool operator==(const AutomationResponse & that);
+      bool operator!=(const AutomationResponse & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AutomationResponse* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 51; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** A list of MissionCommands issued by the automation service (Units: None)*/
+      std::vector<afrl::cmasi::MissionCommand*> & getMissionCommandList(void) { return __MissionCommandList; }
+
+      /** A list of VehicleActionCommands issued by the automation service (Units: None)*/
+      std::vector<afrl::cmasi::VehicleActionCommand*> & getVehicleCommandList(void) { return __VehicleCommandList; }
+
+      /** Status from the automation service to the simulation regarding errors or conditions. (Units: None)*/
+      std::vector<afrl::cmasi::KeyValuePair*> & getInfo(void) { return __Info; }
+
+
+
+   protected:
+      /** A list of MissionCommands issued by the automation service */
+      std::vector< afrl::cmasi::MissionCommand* > __MissionCommandList;
+      /** A list of VehicleActionCommands issued by the automation service */
+      std::vector< afrl::cmasi::VehicleActionCommand* > __VehicleCommandList;
+      /** Status from the automation service to the simulation regarding errors or conditions. */
+      std::vector< afrl::cmasi::KeyValuePair* > __Info;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_AUTOMATIONRESPONSE_H_
diff --git a/src/LMCP/afrl/cmasi/AutomationResponseDescendants.h b/src/LMCP/afrl/cmasi/AutomationResponseDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/AutomationResponseDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/CMASI.h b/src/LMCP/afrl/cmasi/CMASI.h
new file mode 100644
index 0000000..7a1fdb2
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/CMASI.h
@@ -0,0 +1,93 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_ENTIRESERIESHEADER_H_
+#define _AFRL_CMASI_ENTIRESERIESHEADER_H_
+
+#include "afrl/cmasi/AbstractGeometry.h"
+#include "afrl/cmasi/KeyValuePair.h"
+#include "afrl/cmasi/Location3D.h"
+#include "afrl/cmasi/PayloadAction.h"
+#include "afrl/cmasi/PayloadConfiguration.h"
+#include "afrl/cmasi/PayloadState.h"
+#include "afrl/cmasi/VehicleAction.h"
+#include "afrl/cmasi/Task.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/AbstractZone.h"
+#include "afrl/cmasi/EntityConfiguration.h"
+#include "afrl/cmasi/FlightProfile.h"
+#include "afrl/cmasi/AirVehicleConfiguration.h"
+#include "afrl/cmasi/EntityState.h"
+#include "afrl/cmasi/AirVehicleState.h"
+#include "afrl/cmasi/Wedge.h"
+#include "afrl/cmasi/AreaSearchTask.h"
+#include "afrl/cmasi/CameraAction.h"
+#include "afrl/cmasi/CameraConfiguration.h"
+#include "afrl/cmasi/GimballedPayloadState.h"
+#include "afrl/cmasi/CameraState.h"
+#include "afrl/cmasi/Circle.h"
+#include "afrl/cmasi/GimbalAngleAction.h"
+#include "afrl/cmasi/GimbalConfiguration.h"
+#include "afrl/cmasi/GimbalScanAction.h"
+#include "afrl/cmasi/GimbalStareAction.h"
+#include "afrl/cmasi/GimbalState.h"
+#include "afrl/cmasi/GoToWaypointAction.h"
+#include "afrl/cmasi/KeepInZone.h"
+#include "afrl/cmasi/KeepOutZone.h"
+#include "afrl/cmasi/LineSearchTask.h"
+#include "afrl/cmasi/NavigationAction.h"
+#include "afrl/cmasi/LoiterAction.h"
+#include "afrl/cmasi/LoiterTask.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/MissionCommand.h"
+#include "afrl/cmasi/MustFlyTask.h"
+#include "afrl/cmasi/OperatorSignal.h"
+#include "afrl/cmasi/OperatingRegion.h"
+#include "afrl/cmasi/AutomationRequest.h"
+#include "afrl/cmasi/PointSearchTask.h"
+#include "afrl/cmasi/Polygon.h"
+#include "afrl/cmasi/Rectangle.h"
+#include "afrl/cmasi/RemoveTasks.h"
+#include "afrl/cmasi/ServiceStatus.h"
+#include "afrl/cmasi/SessionStatus.h"
+#include "afrl/cmasi/VehicleActionCommand.h"
+#include "afrl/cmasi/VideoStreamAction.h"
+#include "afrl/cmasi/VideoStreamConfiguration.h"
+#include "afrl/cmasi/VideoStreamState.h"
+#include "afrl/cmasi/AutomationResponse.h"
+#include "afrl/cmasi/RemoveZones.h"
+#include "afrl/cmasi/RemoveEntities.h"
+#include "afrl/cmasi/FlightDirectorAction.h"
+#include "afrl/cmasi/WeatherReport.h"
+#include "afrl/cmasi/FollowPathCommand.h"
+#include "afrl/cmasi/PathWaypoint.h"
+#include "afrl/cmasi/StopMovementAction.h"
+#include "afrl/cmasi/WaypointTransfer.h"
+#include "afrl/cmasi/PayloadStowAction.h"
+#include "afrl/cmasi/WavelengthBand.h"
+#include "afrl/cmasi/NavigationMode.h"
+#include "afrl/cmasi/FOVOperationMode.h"
+#include "afrl/cmasi/GimbalPointingMode.h"
+#include "afrl/cmasi/ZoneAvoidanceType.h"
+#include "afrl/cmasi/LoiterType.h"
+#include "afrl/cmasi/LoiterDirection.h"
+#include "afrl/cmasi/ServiceStatusType.h"
+#include "afrl/cmasi/SimulationStatusType.h"
+#include "afrl/cmasi/SpeedType.h"
+#include "afrl/cmasi/TurnType.h"
+#include "afrl/cmasi/CommandStatusType.h"
+#include "afrl/cmasi/AltitudeType.h"
+#include "afrl/cmasi/TravelMode.h"
+#include "afrl/cmasi/WaypointTransferMode.h"
+#include "afrl/cmasi/CMASIEnum.h"
+
+
+#endif //_AFRL_CMASI_ENTIRESERIESHEADER_H_
diff --git a/src/LMCP/afrl/cmasi/CMASIEnum.h b/src/LMCP/afrl/cmasi/CMASIEnum.h
new file mode 100644
index 0000000..99f45a2
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/CMASIEnum.h
@@ -0,0 +1,91 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_CMASIENUM_H_
+#define _AFRL_CMASI_CMASIENUM_H_
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   namespace CMASIEnum {
+
+      enum LmcpType {
+         ABSTRACTGEOMETRY = 1,
+         KEYVALUEPAIR = 2,
+         LOCATION3D = 3,
+         PAYLOADACTION = 4,
+         PAYLOADCONFIGURATION = 5,
+         PAYLOADSTATE = 6,
+         VEHICLEACTION = 7,
+         TASK = 8,
+         SEARCHTASK = 9,
+         ABSTRACTZONE = 10,
+         ENTITYCONFIGURATION = 11,
+         FLIGHTPROFILE = 12,
+         AIRVEHICLECONFIGURATION = 13,
+         ENTITYSTATE = 14,
+         AIRVEHICLESTATE = 15,
+         WEDGE = 16,
+         AREASEARCHTASK = 17,
+         CAMERAACTION = 18,
+         CAMERACONFIGURATION = 19,
+         GIMBALLEDPAYLOADSTATE = 20,
+         CAMERASTATE = 21,
+         CIRCLE = 22,
+         GIMBALANGLEACTION = 23,
+         GIMBALCONFIGURATION = 24,
+         GIMBALSCANACTION = 25,
+         GIMBALSTAREACTION = 26,
+         GIMBALSTATE = 27,
+         GOTOWAYPOINTACTION = 28,
+         KEEPINZONE = 29,
+         KEEPOUTZONE = 30,
+         LINESEARCHTASK = 31,
+         NAVIGATIONACTION = 32,
+         LOITERACTION = 33,
+         LOITERTASK = 34,
+         WAYPOINT = 35,
+         MISSIONCOMMAND = 36,
+         MUSTFLYTASK = 37,
+         OPERATORSIGNAL = 38,
+         OPERATINGREGION = 39,
+         AUTOMATIONREQUEST = 40,
+         POINTSEARCHTASK = 41,
+         POLYGON = 42,
+         RECTANGLE = 43,
+         REMOVETASKS = 44,
+         SERVICESTATUS = 45,
+         SESSIONSTATUS = 46,
+         VEHICLEACTIONCOMMAND = 47,
+         VIDEOSTREAMACTION = 48,
+         VIDEOSTREAMCONFIGURATION = 49,
+         VIDEOSTREAMSTATE = 50,
+         AUTOMATIONRESPONSE = 51,
+         REMOVEZONES = 52,
+         REMOVEENTITIES = 53,
+         FLIGHTDIRECTORACTION = 54,
+         WEATHERREPORT = 55,
+         FOLLOWPATHCOMMAND = 56,
+         PATHWAYPOINT = 57,
+         STOPMOVEMENTACTION = 58,
+         WAYPOINTTRANSFER = 59,
+         PAYLOADSTOWACTION = 60
+      };
+
+   }
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif //_AFRL_CMASI_CMASIENUM_H_
diff --git a/src/LMCP/afrl/cmasi/CMASIXMLReader.cpp b/src/LMCP/afrl/cmasi/CMASIXMLReader.cpp
new file mode 100644
index 0000000..e7d73a1
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/CMASIXMLReader.cpp
@@ -0,0 +1,3340 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/CMASIXMLReader.h"
+#include "avtas/lmcp/XMLParser.h"
+#include <vector>
+#include <string>
+#include "avtas/lmcp/LmcpXMLReader.h"
+
+#include "afrl/cmasi/AbstractGeometry.h"
+#include "afrl/cmasi/KeyValuePair.h"
+#include "afrl/cmasi/Location3D.h"
+#include "afrl/cmasi/PayloadAction.h"
+#include "afrl/cmasi/PayloadConfiguration.h"
+#include "afrl/cmasi/PayloadState.h"
+#include "afrl/cmasi/VehicleAction.h"
+#include "afrl/cmasi/Task.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/AbstractZone.h"
+#include "afrl/cmasi/EntityConfiguration.h"
+#include "afrl/cmasi/FlightProfile.h"
+#include "afrl/cmasi/AirVehicleConfiguration.h"
+#include "afrl/cmasi/EntityState.h"
+#include "afrl/cmasi/AirVehicleState.h"
+#include "afrl/cmasi/Wedge.h"
+#include "afrl/cmasi/AreaSearchTask.h"
+#include "afrl/cmasi/CameraAction.h"
+#include "afrl/cmasi/CameraConfiguration.h"
+#include "afrl/cmasi/GimballedPayloadState.h"
+#include "afrl/cmasi/CameraState.h"
+#include "afrl/cmasi/Circle.h"
+#include "afrl/cmasi/GimbalAngleAction.h"
+#include "afrl/cmasi/GimbalConfiguration.h"
+#include "afrl/cmasi/GimbalScanAction.h"
+#include "afrl/cmasi/GimbalStareAction.h"
+#include "afrl/cmasi/GimbalState.h"
+#include "afrl/cmasi/GoToWaypointAction.h"
+#include "afrl/cmasi/KeepInZone.h"
+#include "afrl/cmasi/KeepOutZone.h"
+#include "afrl/cmasi/LineSearchTask.h"
+#include "afrl/cmasi/NavigationAction.h"
+#include "afrl/cmasi/LoiterAction.h"
+#include "afrl/cmasi/LoiterTask.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/MissionCommand.h"
+#include "afrl/cmasi/MustFlyTask.h"
+#include "afrl/cmasi/OperatorSignal.h"
+#include "afrl/cmasi/OperatingRegion.h"
+#include "afrl/cmasi/AutomationRequest.h"
+#include "afrl/cmasi/PointSearchTask.h"
+#include "afrl/cmasi/Polygon.h"
+#include "afrl/cmasi/Rectangle.h"
+#include "afrl/cmasi/RemoveTasks.h"
+#include "afrl/cmasi/ServiceStatus.h"
+#include "afrl/cmasi/SessionStatus.h"
+#include "afrl/cmasi/VehicleActionCommand.h"
+#include "afrl/cmasi/VideoStreamAction.h"
+#include "afrl/cmasi/VideoStreamConfiguration.h"
+#include "afrl/cmasi/VideoStreamState.h"
+#include "afrl/cmasi/AutomationResponse.h"
+#include "afrl/cmasi/RemoveZones.h"
+#include "afrl/cmasi/RemoveEntities.h"
+#include "afrl/cmasi/FlightDirectorAction.h"
+#include "afrl/cmasi/WeatherReport.h"
+#include "afrl/cmasi/FollowPathCommand.h"
+#include "afrl/cmasi/PathWaypoint.h"
+#include "afrl/cmasi/StopMovementAction.h"
+#include "afrl/cmasi/WaypointTransfer.h"
+#include "afrl/cmasi/PayloadStowAction.h"
+#include "afrl/cmasi/WavelengthBand.h"
+#include "afrl/cmasi/NavigationMode.h"
+#include "afrl/cmasi/FOVOperationMode.h"
+#include "afrl/cmasi/GimbalPointingMode.h"
+#include "afrl/cmasi/ZoneAvoidanceType.h"
+#include "afrl/cmasi/LoiterType.h"
+#include "afrl/cmasi/LoiterDirection.h"
+#include "afrl/cmasi/ServiceStatusType.h"
+#include "afrl/cmasi/SimulationStatusType.h"
+#include "afrl/cmasi/SpeedType.h"
+#include "afrl/cmasi/TurnType.h"
+#include "afrl/cmasi/CommandStatusType.h"
+#include "afrl/cmasi/AltitudeType.h"
+#include "afrl/cmasi/TravelMode.h"
+#include "afrl/cmasi/WaypointTransferMode.h"
+#include "afrl/cmasi/CMASIEnum.h"
+
+
+using namespace avtas::lmcp;
+using namespace avtas::lmcp::xml;
+
+
+namespace afrl {
+namespace cmasi {
+
+
+    avtas::lmcp::Object* SeriesXMLReader :: visitType(avtas::lmcp::Node* el){
+
+        if (el == NULL) return NULL;
+        
+        std::string type = el->getTagName();
+            
+        if (type == "AbstractGeometry"){
+           AbstractGeometry* o = new AbstractGeometry();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+           }
+           return o;
+        }
+        if (type == "KeyValuePair"){
+           KeyValuePair* o = new KeyValuePair();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Key")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setKey( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Value")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setValue( get_string( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "Location3D"){
+           Location3D* o = new Location3D();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Latitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLatitude( get_real64( tmp ));
+                 continue;
+              }
+              if(name == "Longitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLongitude( get_real64( tmp ));
+                 continue;
+              }
+              if(name == "Altitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "AltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "PayloadAction"){
+           PayloadAction* o = new PayloadAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "PayloadConfiguration"){
+           PayloadConfiguration* o = new PayloadConfiguration();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PayloadKind")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadKind( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "PayloadState"){
+           PayloadState* o = new PayloadState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "VehicleAction"){
+           VehicleAction* o = new VehicleAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "Task"){
+           Task* o = new Task();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "SearchTask"){
+           SearchTask* o = new SearchTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "DesiredWavelengthBands")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getDesiredWavelengthBands().push_back( afrl::cmasi::WavelengthBand::get_WavelengthBand(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "DwellTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDwellTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "GroundSampleDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundSampleDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "AbstractZone"){
+           AbstractZone* o = new AbstractZone();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ZoneID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setZoneID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "MinAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MinAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "MaxAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "AffectedAircraft")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAffectedAircraft().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "StartTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "EndTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEndTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Padding")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPadding( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Boundary")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setBoundary((afrl::cmasi::AbstractGeometry*) oo );
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "EntityConfiguration"){
+           EntityConfiguration* o = new EntityConfiguration();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Affiliation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAffiliation( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EntityType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityType( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "NominalSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "NominalAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "NominalAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "PayloadConfigurationList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPayloadConfigurationList().push_back( (afrl::cmasi::PayloadConfiguration*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Info")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getInfo().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "FlightProfile"){
+           FlightProfile* o = new FlightProfile();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Name")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setName( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Airspeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAirspeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "PitchAngle")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPitchAngle( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "VerticalSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVerticalSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxBankAngle")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxBankAngle( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "EnergyRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEnergyRate( get_real32( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "AirVehicleConfiguration"){
+           AirVehicleConfiguration* o = new AirVehicleConfiguration();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "MinimumSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinimumSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaximumSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaximumSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "NominalFlightProfile")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setNominalFlightProfile((afrl::cmasi::FlightProfile*) oo );
+                 continue;
+              }
+              if(name == "AlternateFlightProfiles")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getAlternateFlightProfiles().push_back( (afrl::cmasi::FlightProfile*) oo);
+                 }
+                 continue;
+              }
+              if(name == "AvailableLoiterTypes")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAvailableLoiterTypes().push_back( afrl::cmasi::LoiterType::get_LoiterType(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "AvailableTurnTypes")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAvailableTurnTypes().push_back( afrl::cmasi::TurnType::get_TurnType(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "MinimumAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinimumAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MinAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "MaximumAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaximumAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "ID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Affiliation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAffiliation( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EntityType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityType( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "NominalSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "NominalAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "NominalAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "PayloadConfigurationList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPayloadConfigurationList().push_back( (afrl::cmasi::PayloadConfiguration*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Info")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getInfo().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "EntityState"){
+           EntityState* o = new EntityState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "u")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setU( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "v")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setV( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "w")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setW( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "udot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setUdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "vdot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "wdot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Heading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHeading( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Pitch")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPitch( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Roll")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRoll( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "p")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setP( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "q")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setQ( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "r")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setR( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Course")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCourse( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Groundspeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundspeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Location")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "EnergyAvailable")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEnergyAvailable( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ActualEnergyRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setActualEnergyRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "PayloadStateList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPayloadStateList().push_back( (afrl::cmasi::PayloadState*) oo);
+                 }
+                 continue;
+              }
+              if(name == "CurrentWaypoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCurrentWaypoint( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "CurrentCommand")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCurrentCommand( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Mode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMode( afrl::cmasi::NavigationMode::get_NavigationMode( get_string( tmp )));
+                 continue;
+              }
+              if(name == "AssociatedTasks")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTasks().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "Time")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Info")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getInfo().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "AirVehicleState"){
+           AirVehicleState* o = new AirVehicleState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Airspeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAirspeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "VerticalSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVerticalSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "WindSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWindSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "WindDirection")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWindDirection( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "u")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setU( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "v")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setV( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "w")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setW( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "udot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setUdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "vdot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "wdot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Heading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHeading( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Pitch")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPitch( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Roll")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRoll( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "p")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setP( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "q")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setQ( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "r")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setR( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Course")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCourse( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Groundspeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundspeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Location")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "EnergyAvailable")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEnergyAvailable( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ActualEnergyRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setActualEnergyRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "PayloadStateList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPayloadStateList().push_back( (afrl::cmasi::PayloadState*) oo);
+                 }
+                 continue;
+              }
+              if(name == "CurrentWaypoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCurrentWaypoint( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "CurrentCommand")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCurrentCommand( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Mode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMode( afrl::cmasi::NavigationMode::get_NavigationMode( get_string( tmp )));
+                 continue;
+              }
+              if(name == "AssociatedTasks")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTasks().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "Time")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Info")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getInfo().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "Wedge"){
+           Wedge* o = new Wedge();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "AzimuthCenterline")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAzimuthCenterline( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "VerticalCenterline")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVerticalCenterline( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "AzimuthExtent")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAzimuthExtent( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "VerticalExtent")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVerticalExtent( get_real32( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "AreaSearchTask"){
+           AreaSearchTask* o = new AreaSearchTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "SearchArea")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setSearchArea((afrl::cmasi::AbstractGeometry*) oo );
+                 continue;
+              }
+              if(name == "ViewAngleList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getViewAngleList().push_back( (afrl::cmasi::Wedge*) oo);
+                 }
+                 continue;
+              }
+              if(name == "DesiredWavelengthBands")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getDesiredWavelengthBands().push_back( afrl::cmasi::WavelengthBand::get_WavelengthBand(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "DwellTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDwellTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "GroundSampleDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundSampleDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "CameraAction"){
+           CameraAction* o = new CameraAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "HorizontalFieldOfView")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHorizontalFieldOfView( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedActions")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getAssociatedActions().push_back( (afrl::cmasi::PayloadAction*) oo);
+                 }
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "CameraConfiguration"){
+           CameraConfiguration* o = new CameraConfiguration();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "SupportedWavelengthBand")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSupportedWavelengthBand( afrl::cmasi::WavelengthBand::get_WavelengthBand( get_string( tmp )));
+                 continue;
+              }
+              if(name == "FieldOfViewMode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setFieldOfViewMode( afrl::cmasi::FOVOperationMode::get_FOVOperationMode( get_string( tmp )));
+                 continue;
+              }
+              if(name == "MinHorizontalFieldOfView")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinHorizontalFieldOfView( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxHorizontalFieldOfView")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxHorizontalFieldOfView( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "DiscreteHorizontalFieldOfViewList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getDiscreteHorizontalFieldOfViewList().push_back( get_real32( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "VideoStreamHorizontalResolution")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVideoStreamHorizontalResolution( get_uint32( tmp ));
+                 continue;
+              }
+              if(name == "VideoStreamVerticalResolution")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVideoStreamVerticalResolution( get_uint32( tmp ));
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PayloadKind")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadKind( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "GimballedPayloadState"){
+           GimballedPayloadState* o = new GimballedPayloadState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "PointingMode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPointingMode( afrl::cmasi::GimbalPointingMode::get_GimbalPointingMode( get_string( tmp )));
+                 continue;
+              }
+              if(name == "Azimuth")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAzimuth( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Elevation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setElevation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Rotation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRotation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "CameraState"){
+           CameraState* o = new CameraState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "HorizontalFieldOfView")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHorizontalFieldOfView( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "VerticalFieldOfView")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVerticalFieldOfView( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Footprint")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getFootprint().push_back( (afrl::cmasi::Location3D*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Centerpoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setCenterpoint((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "PointingMode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPointingMode( afrl::cmasi::GimbalPointingMode::get_GimbalPointingMode( get_string( tmp )));
+                 continue;
+              }
+              if(name == "Azimuth")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAzimuth( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Elevation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setElevation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Rotation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRotation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "Circle"){
+           Circle* o = new Circle();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "CenterPoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setCenterPoint((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "Radius")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRadius( get_real32( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "GimbalAngleAction"){
+           GimbalAngleAction* o = new GimbalAngleAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Azimuth")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAzimuth( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Elevation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setElevation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Rotation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRotation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "GimbalConfiguration"){
+           GimbalConfiguration* o = new GimbalConfiguration();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "SupportedPointingModes")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getSupportedPointingModes().push_back( afrl::cmasi::GimbalPointingMode::get_GimbalPointingMode(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "MinAzimuth")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinAzimuth( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxAzimuth")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxAzimuth( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "IsAzimuthClamped")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setIsAzimuthClamped( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "MinElevation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinElevation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxElevation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxElevation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "IsElevationClamped")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setIsElevationClamped( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "MinRotation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinRotation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxRotation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxRotation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "IsRotationClamped")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setIsRotationClamped( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "MaxAzimuthSlewRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxAzimuthSlewRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxElevationSlewRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxElevationSlewRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxRotationRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxRotationRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ContainedPayloadList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getContainedPayloadList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PayloadKind")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadKind( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "GimbalScanAction"){
+           GimbalScanAction* o = new GimbalScanAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "AzimuthSlewRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAzimuthSlewRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ElevationSlewRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setElevationSlewRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "StartAzimuth")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartAzimuth( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "EndAzimuth")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEndAzimuth( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "StartElevation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartElevation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "EndElevation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEndElevation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Cycles")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCycles( get_uint32( tmp ));
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "GimbalStareAction"){
+           GimbalStareAction* o = new GimbalStareAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Starepoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setStarepoint((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "Duration")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDuration( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "GimbalState"){
+           GimbalState* o = new GimbalState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "PointingMode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPointingMode( afrl::cmasi::GimbalPointingMode::get_GimbalPointingMode( get_string( tmp )));
+                 continue;
+              }
+              if(name == "Azimuth")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAzimuth( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Elevation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setElevation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Rotation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRotation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "GoToWaypointAction"){
+           GoToWaypointAction* o = new GoToWaypointAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "WaypointNumber")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWaypointNumber( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "KeepInZone"){
+           KeepInZone* o = new KeepInZone();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ZoneID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setZoneID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "MinAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MinAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "MaxAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "AffectedAircraft")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAffectedAircraft().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "StartTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "EndTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEndTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Padding")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPadding( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Boundary")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setBoundary((afrl::cmasi::AbstractGeometry*) oo );
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "KeepOutZone"){
+           KeepOutZone* o = new KeepOutZone();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ZoneType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setZoneType( afrl::cmasi::ZoneAvoidanceType::get_ZoneAvoidanceType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "ZoneID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setZoneID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "MinAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MinAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "MaxAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "AffectedAircraft")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAffectedAircraft().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "StartTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "EndTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEndTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Padding")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPadding( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Boundary")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setBoundary((afrl::cmasi::AbstractGeometry*) oo );
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "LineSearchTask"){
+           LineSearchTask* o = new LineSearchTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "PointList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPointList().push_back( (afrl::cmasi::Location3D*) oo);
+                 }
+                 continue;
+              }
+              if(name == "ViewAngleList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getViewAngleList().push_back( (afrl::cmasi::Wedge*) oo);
+                 }
+                 continue;
+              }
+              if(name == "UseInertialViewAngles")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setUseInertialViewAngles( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "DesiredWavelengthBands")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getDesiredWavelengthBands().push_back( afrl::cmasi::WavelengthBand::get_WavelengthBand(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "DwellTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDwellTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "GroundSampleDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundSampleDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "NavigationAction"){
+           NavigationAction* o = new NavigationAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "LoiterAction"){
+           LoiterAction* o = new LoiterAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "LoiterType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLoiterType( afrl::cmasi::LoiterType::get_LoiterType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "Radius")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRadius( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Axis")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAxis( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Length")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLength( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Direction")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDirection( afrl::cmasi::LoiterDirection::get_LoiterDirection( get_string( tmp )));
+                 continue;
+              }
+              if(name == "Duration")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDuration( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Airspeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAirspeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Location")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "LoiterTask"){
+           LoiterTask* o = new LoiterTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "DesiredAction")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setDesiredAction((afrl::cmasi::LoiterAction*) oo );
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "Waypoint"){
+           Waypoint* o = new Waypoint();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Number")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNumber( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "NextWaypoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNextWaypoint( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Speed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "SpeedType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSpeedType( afrl::cmasi::SpeedType::get_SpeedType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "ClimbRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setClimbRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TurnType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTurnType( afrl::cmasi::TurnType::get_TurnType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "VehicleActionList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getVehicleActionList().push_back( (afrl::cmasi::VehicleAction*) oo);
+                 }
+                 continue;
+              }
+              if(name == "ContingencyWaypointA")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setContingencyWaypointA( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "ContingencyWaypointB")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setContingencyWaypointB( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTasks")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTasks().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "Latitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLatitude( get_real64( tmp ));
+                 continue;
+              }
+              if(name == "Longitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLongitude( get_real64( tmp ));
+                 continue;
+              }
+              if(name == "Altitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "AltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "MissionCommand"){
+           MissionCommand* o = new MissionCommand();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "WaypointList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getWaypointList().push_back( (afrl::cmasi::Waypoint*) oo);
+                 }
+                 continue;
+              }
+              if(name == "FirstWaypoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setFirstWaypoint( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "CommandID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCommandID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleActionList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getVehicleActionList().push_back( (afrl::cmasi::VehicleAction*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Status")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStatus( afrl::cmasi::CommandStatusType::get_CommandStatusType( get_string( tmp )));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "MustFlyTask"){
+           MustFlyTask* o = new MustFlyTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Position")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setPosition((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "UseAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setUseAltitude( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "OperatorSignal"){
+           OperatorSignal* o = new OperatorSignal();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Signals")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getSignals().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "OperatingRegion"){
+           OperatingRegion* o = new OperatingRegion();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "KeepInAreas")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getKeepInAreas().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "KeepOutAreas")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getKeepOutAreas().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "AutomationRequest"){
+           AutomationRequest* o = new AutomationRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "EntityList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEntityList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "TaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "TaskRelationships")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskRelationships( get_string( tmp ));
+                 continue;
+              }
+              if(name == "OperatingRegion")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setOperatingRegion( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "RedoAllTasks")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRedoAllTasks( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "PointSearchTask"){
+           PointSearchTask* o = new PointSearchTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "SearchLocation")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setSearchLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "StandoffDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStandoffDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ViewAngleList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getViewAngleList().push_back( (afrl::cmasi::Wedge*) oo);
+                 }
+                 continue;
+              }
+              if(name == "DesiredWavelengthBands")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getDesiredWavelengthBands().push_back( afrl::cmasi::WavelengthBand::get_WavelengthBand(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "DwellTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDwellTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "GroundSampleDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundSampleDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "Polygon"){
+           Polygon* o = new Polygon();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "BoundaryPoints")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getBoundaryPoints().push_back( (afrl::cmasi::Location3D*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "Rectangle"){
+           Rectangle* o = new Rectangle();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "CenterPoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setCenterPoint((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "Width")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWidth( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Height")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHeight( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Rotation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRotation( get_real32( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RemoveTasks"){
+           RemoveTasks* o = new RemoveTasks();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "TaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "ServiceStatus"){
+           ServiceStatus* o = new ServiceStatus();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "PercentComplete")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPercentComplete( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Info")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getInfo().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "StatusType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStatusType( afrl::cmasi::ServiceStatusType::get_ServiceStatusType( get_string( tmp )));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "SessionStatus"){
+           SessionStatus* o = new SessionStatus();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "State")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setState( afrl::cmasi::SimulationStatusType::get_SimulationStatusType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "StartTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "ScenarioTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setScenarioTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "RealTimeMultiple")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRealTimeMultiple( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "VehicleActionCommand"){
+           VehicleActionCommand* o = new VehicleActionCommand();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "CommandID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCommandID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleActionList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getVehicleActionList().push_back( (afrl::cmasi::VehicleAction*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Status")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStatus( afrl::cmasi::CommandStatusType::get_CommandStatusType( get_string( tmp )));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "VideoStreamAction"){
+           VideoStreamAction* o = new VideoStreamAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "VideoStreamID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVideoStreamID( get_int32( tmp ));
+                 continue;
+              }
+              if(name == "ActiveSensor")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setActiveSensor( get_int32( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "VideoStreamConfiguration"){
+           VideoStreamConfiguration* o = new VideoStreamConfiguration();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "AvailableSensorList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAvailableSensorList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PayloadKind")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadKind( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "VideoStreamState"){
+           VideoStreamState* o = new VideoStreamState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ActiveSensor")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setActiveSensor( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "AutomationResponse"){
+           AutomationResponse* o = new AutomationResponse();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "MissionCommandList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getMissionCommandList().push_back( (afrl::cmasi::MissionCommand*) oo);
+                 }
+                 continue;
+              }
+              if(name == "VehicleCommandList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getVehicleCommandList().push_back( (afrl::cmasi::VehicleActionCommand*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Info")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getInfo().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RemoveZones"){
+           RemoveZones* o = new RemoveZones();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ZoneList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getZoneList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RemoveEntities"){
+           RemoveEntities* o = new RemoveEntities();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "EntityList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEntityList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "FlightDirectorAction"){
+           FlightDirectorAction* o = new FlightDirectorAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Speed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "SpeedType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSpeedType( afrl::cmasi::SpeedType::get_SpeedType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "Heading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHeading( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Altitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "AltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "ClimbRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setClimbRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "WeatherReport"){
+           WeatherReport* o = new WeatherReport();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Area")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setArea((afrl::cmasi::AbstractZone*) oo );
+                 continue;
+              }
+              if(name == "WindSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWindSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "WindDirection")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWindDirection( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Visibility")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVisibility( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "CloudCeiling")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCloudCeiling( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "CloudCoverage")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCloudCoverage( get_real32( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "FollowPathCommand"){
+           FollowPathCommand* o = new FollowPathCommand();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "FirstWaypoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setFirstWaypoint( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "WaypointList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getWaypointList().push_back( (afrl::cmasi::PathWaypoint*) oo);
+                 }
+                 continue;
+              }
+              if(name == "StartTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "StopTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStopTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "RepeatMode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRepeatMode( afrl::cmasi::TravelMode::get_TravelMode( get_string( tmp )));
+                 continue;
+              }
+              if(name == "CommandID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCommandID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleActionList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getVehicleActionList().push_back( (afrl::cmasi::VehicleAction*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Status")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStatus( afrl::cmasi::CommandStatusType::get_CommandStatusType( get_string( tmp )));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "PathWaypoint"){
+           PathWaypoint* o = new PathWaypoint();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "PauseTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPauseTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Number")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNumber( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "NextWaypoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNextWaypoint( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Speed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "SpeedType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSpeedType( afrl::cmasi::SpeedType::get_SpeedType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "ClimbRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setClimbRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TurnType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTurnType( afrl::cmasi::TurnType::get_TurnType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "VehicleActionList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getVehicleActionList().push_back( (afrl::cmasi::VehicleAction*) oo);
+                 }
+                 continue;
+              }
+              if(name == "ContingencyWaypointA")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setContingencyWaypointA( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "ContingencyWaypointB")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setContingencyWaypointB( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTasks")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTasks().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "Latitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLatitude( get_real64( tmp ));
+                 continue;
+              }
+              if(name == "Longitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLongitude( get_real64( tmp ));
+                 continue;
+              }
+              if(name == "Altitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "AltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "StopMovementAction"){
+           StopMovementAction* o = new StopMovementAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Location")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "WaypointTransfer"){
+           WaypointTransfer* o = new WaypointTransfer();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "EntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Waypoints")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getWaypoints().push_back( (afrl::cmasi::Waypoint*) oo);
+                 }
+                 continue;
+              }
+              if(name == "TransferMode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTransferMode( afrl::cmasi::WaypointTransferMode::get_WaypointTransferMode( get_string( tmp )));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "PayloadStowAction"){
+           PayloadStowAction* o = new PayloadStowAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+
+
+         return NULL;
+        
+    }
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/CMASIXMLReader.h b/src/LMCP/afrl/cmasi/CMASIXMLReader.h
new file mode 100644
index 0000000..c5ecd8f
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/CMASIXMLReader.h
@@ -0,0 +1,45 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef CMASI_SERIESXMLREADER_H_
+#define CMASI_SERIESXMLREADER_H_
+
+#include "avtas/lmcp/Object.h"
+#include "avtas/lmcp/Node.h"
+#include "avtas/lmcp/NodeUtil.h"
+
+#include <iostream>
+
+
+using namespace avtas::lmcp;
+
+namespace afrl {
+namespace cmasi {
+
+
+class SeriesXMLReader {
+
+    /** reads an LMCP XML Storage file and returns a list of LMCPObjects */
+    public:
+
+        SeriesXMLReader(void) {}
+
+        virtual ~SeriesXMLReader(){}  
+
+        static avtas::lmcp::Object * visitType(avtas::lmcp::Node* el );
+
+};
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif 
diff --git a/src/LMCP/afrl/cmasi/CameraAction.h b/src/LMCP/afrl/cmasi/CameraAction.h
new file mode 100644
index 0000000..3a9e58d
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/CameraAction.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_CAMERAACTION_H_
+#define _AFRL_CMASI_CAMERAACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/PayloadAction.h"
+#include "afrl/cmasi/PayloadAction.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isCameraAction(avtas::lmcp::Object* obj);
+   bool isCameraAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > CameraActionDescendants();
+   
+   class CameraAction : public afrl::cmasi::PayloadAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      CameraAction(void);
+
+      // Copy Constructor
+      CameraAction(const CameraAction &that);
+
+      // Assignment Operator
+      CameraAction & operator=(const CameraAction &that);
+
+      // Destructor
+      virtual ~CameraAction(void);
+
+      // Equals overload
+      bool operator==(const CameraAction & that);
+      bool operator!=(const CameraAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual CameraAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 18; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The commanded horizontal (azimuth) field of view. (Units: degree)*/
+      float getHorizontalFieldOfView(void) const { return __HorizontalFieldOfView; }
+      CameraAction& setHorizontalFieldOfView(const float val);
+
+      /** Associated payload actions that should be performed simultaneously with the change in field of view. A frequent use case would be a gimbal pointing action. If payload ID is zero, then the gimbal on which the camera is mounted is selected. Note that this has the side-effect of steering all other payloads associated to that gimbal. (Units: None)*/
+      std::vector<afrl::cmasi::PayloadAction*> & getAssociatedActions(void) { return __AssociatedActions; }
+
+
+
+   protected:
+      /** The commanded horizontal (azimuth) field of view. */
+      float __HorizontalFieldOfView;
+      /** Associated payload actions that should be performed simultaneously with the change in field of view. A frequent use case would be a gimbal pointing action. If payload ID is zero, then the gimbal on which the camera is mounted is selected. Note that this has the side-effect of steering all other payloads associated to that gimbal. */
+      std::vector< afrl::cmasi::PayloadAction* > __AssociatedActions;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_CAMERAACTION_H_
diff --git a/src/LMCP/afrl/cmasi/CameraActionDescendants.h b/src/LMCP/afrl/cmasi/CameraActionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/CameraActionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/CameraConfiguration.h b/src/LMCP/afrl/cmasi/CameraConfiguration.h
new file mode 100644
index 0000000..200d30d
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/CameraConfiguration.h
@@ -0,0 +1,144 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_CAMERACONFIGURATION_H_
+#define _AFRL_CMASI_CAMERACONFIGURATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/PayloadConfiguration.h"
+#include "afrl/cmasi/WavelengthBand.h"
+#include "afrl/cmasi/FOVOperationMode.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isCameraConfiguration(avtas::lmcp::Object* obj);
+   bool isCameraConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > CameraConfigurationDescendants();
+   
+   class CameraConfiguration : public afrl::cmasi::PayloadConfiguration {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      CameraConfiguration(void);
+
+      // Copy Constructor
+      CameraConfiguration(const CameraConfiguration &that);
+
+      // Assignment Operator
+      CameraConfiguration & operator=(const CameraConfiguration &that);
+
+      // Destructor
+      virtual ~CameraConfiguration(void);
+
+      // Equals overload
+      bool operator==(const CameraConfiguration & that);
+      bool operator!=(const CameraConfiguration & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual CameraConfiguration* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 19; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The supported wavelength band of this camera (Units: None)*/
+      afrl::cmasi::WavelengthBand::WavelengthBand getSupportedWavelengthBand(void) const { return __SupportedWavelengthBand; }
+      CameraConfiguration& setSupportedWavelengthBand(const afrl::cmasi::WavelengthBand::WavelengthBand val);
+
+      /** The manner in which field of views are commanded: Continuous (any FOV between MinHorizontalFieldOfView and MaxHorizontalFieldOfView can be commanded), or Discrete (the only supported FOVs are listed in DiscreteHorizontalFieldOfViewList). (Units: None)*/
+      afrl::cmasi::FOVOperationMode::FOVOperationMode getFieldOfViewMode(void) const { return __FieldOfViewMode; }
+      CameraConfiguration& setFieldOfViewMode(const afrl::cmasi::FOVOperationMode::FOVOperationMode val);
+
+      /** The minimum horizontal field of view of the sensor. Only used if FieldOfViewMode is Continuous. (Units: degree)*/
+      float getMinHorizontalFieldOfView(void) const { return __MinHorizontalFieldOfView; }
+      CameraConfiguration& setMinHorizontalFieldOfView(const float val);
+
+      /** The maximum horizontal field of view of the sensor. Only used if FieldOfViewMode is Continuous. (Units: degree)*/
+      float getMaxHorizontalFieldOfView(void) const { return __MaxHorizontalFieldOfView; }
+      CameraConfiguration& setMaxHorizontalFieldOfView(const float val);
+
+      /** The horizontal field of views supported by the sensor. Only used if FieldOfViewMode is Discrete. (Units: degree)*/
+      std::vector<float> & getDiscreteHorizontalFieldOfViewList(void) { return __DiscreteHorizontalFieldOfViewList; }
+
+      /** The number of horizontal pixels in the output live-motion video stream. (Units: pixel)*/
+      uint32_t getVideoStreamHorizontalResolution(void) const { return __VideoStreamHorizontalResolution; }
+      CameraConfiguration& setVideoStreamHorizontalResolution(const uint32_t val);
+
+      /** The number of vertical pixels in the output live-motion video stream. (Units: pixel)*/
+      uint32_t getVideoStreamVerticalResolution(void) const { return __VideoStreamVerticalResolution; }
+      CameraConfiguration& setVideoStreamVerticalResolution(const uint32_t val);
+
+
+
+   protected:
+      /** The supported wavelength band of this camera */
+      afrl::cmasi::WavelengthBand::WavelengthBand __SupportedWavelengthBand;
+      /** The manner in which field of views are commanded: Continuous (any FOV between MinHorizontalFieldOfView and MaxHorizontalFieldOfView can be commanded), or Discrete (the only supported FOVs are listed in DiscreteHorizontalFieldOfViewList). */
+      afrl::cmasi::FOVOperationMode::FOVOperationMode __FieldOfViewMode;
+      /** The minimum horizontal field of view of the sensor. Only used if FieldOfViewMode is Continuous. */
+      float __MinHorizontalFieldOfView;
+      /** The maximum horizontal field of view of the sensor. Only used if FieldOfViewMode is Continuous. */
+      float __MaxHorizontalFieldOfView;
+      /** The horizontal field of views supported by the sensor. Only used if FieldOfViewMode is Discrete. */
+      std::vector< float > __DiscreteHorizontalFieldOfViewList;
+      /** The number of horizontal pixels in the output live-motion video stream. */
+      uint32_t __VideoStreamHorizontalResolution;
+      /** The number of vertical pixels in the output live-motion video stream. */
+      uint32_t __VideoStreamVerticalResolution;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_CAMERACONFIGURATION_H_
diff --git a/src/LMCP/afrl/cmasi/CameraConfigurationDescendants.h b/src/LMCP/afrl/cmasi/CameraConfigurationDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/CameraConfigurationDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/CameraState.h b/src/LMCP/afrl/cmasi/CameraState.h
new file mode 100644
index 0000000..c38b887
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/CameraState.h
@@ -0,0 +1,126 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_CAMERASTATE_H_
+#define _AFRL_CMASI_CAMERASTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/GimballedPayloadState.h"
+#include "afrl/cmasi/Location3D.h"
+#include "afrl/cmasi/Location3D.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isCameraState(avtas::lmcp::Object* obj);
+   bool isCameraState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > CameraStateDescendants();
+   
+   class CameraState : public afrl::cmasi::GimballedPayloadState {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      CameraState(void);
+
+      // Copy Constructor
+      CameraState(const CameraState &that);
+
+      // Assignment Operator
+      CameraState & operator=(const CameraState &that);
+
+      // Destructor
+      virtual ~CameraState(void);
+
+      // Equals overload
+      bool operator==(const CameraState & that);
+      bool operator!=(const CameraState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual CameraState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 21; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The current horizontal field of view (in sensor axis). (Units: degree)*/
+      float getHorizontalFieldOfView(void) const { return __HorizontalFieldOfView; }
+      CameraState& setHorizontalFieldOfView(const float val);
+
+      /** The current vertical field of view (in sensor axis). (Units: degree)*/
+      float getVerticalFieldOfView(void) const { return __VerticalFieldOfView; }
+      CameraState& setVerticalFieldOfView(const float val);
+
+      /** The current sensor footprint of the camera represented as a polygon with n-vertices. If this field contains zero items then the footprint is unavailable or was not calculated. (Units: None)*/
+      std::vector<afrl::cmasi::Location3D*> & getFootprint(void) { return __Footprint; }
+
+      /** the current location according to the intersection of a ray along the center axis of the current camera field of view with the ground. If this field is null, then the location was not computed. (Units: None)*/
+      afrl::cmasi::Location3D* const getCenterpoint(void) { return __Centerpoint; }
+      CameraState& setCenterpoint(const afrl::cmasi::Location3D* const val);
+
+
+
+   protected:
+      /** The current horizontal field of view (in sensor axis). */
+      float __HorizontalFieldOfView;
+      /** The current vertical field of view (in sensor axis). */
+      float __VerticalFieldOfView;
+      /** The current sensor footprint of the camera represented as a polygon with n-vertices. If this field contains zero items then the footprint is unavailable or was not calculated. */
+      std::vector< afrl::cmasi::Location3D* > __Footprint;
+      /** the current location according to the intersection of a ray along the center axis of the current camera field of view with the ground. If this field is null, then the location was not computed. */
+      afrl::cmasi::Location3D* __Centerpoint;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_CAMERASTATE_H_
diff --git a/src/LMCP/afrl/cmasi/CameraStateDescendants.h b/src/LMCP/afrl/cmasi/CameraStateDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/CameraStateDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/Circle.h b/src/LMCP/afrl/cmasi/Circle.h
new file mode 100644
index 0000000..65d16a3
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/Circle.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_CIRCLE_H_
+#define _AFRL_CMASI_CIRCLE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/AbstractGeometry.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isCircle(avtas::lmcp::Object* obj);
+   bool isCircle(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > CircleDescendants();
+   
+   class Circle : public afrl::cmasi::AbstractGeometry {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      Circle(void);
+
+      // Copy Constructor
+      Circle(const Circle &that);
+
+      // Assignment Operator
+      Circle & operator=(const Circle &that);
+
+      // Destructor
+      virtual ~Circle(void);
+
+      // Equals overload
+      bool operator==(const Circle & that);
+      bool operator!=(const Circle & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual Circle* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 22; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Center point of the circle (Units: None)*/
+      afrl::cmasi::Location3D* const getCenterPoint(void) { return __CenterPoint; }
+      Circle& setCenterPoint(const afrl::cmasi::Location3D* const val);
+
+      /** Radius of the circle (Units: meter)*/
+      float getRadius(void) const { return __Radius; }
+      Circle& setRadius(const float val);
+
+
+
+   protected:
+      /** Center point of the circle */
+      afrl::cmasi::Location3D* __CenterPoint;
+      /** Radius of the circle */
+      float __Radius;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_CIRCLE_H_
diff --git a/src/LMCP/afrl/cmasi/CircleDescendants.h b/src/LMCP/afrl/cmasi/CircleDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/CircleDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/CommandStatusType.h b/src/LMCP/afrl/cmasi/CommandStatusType.h
new file mode 100644
index 0000000..7e81f6e
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/CommandStatusType.h
@@ -0,0 +1,68 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_COMMANDSTATUSTYPE_H_
+#define _AFRL_CMASI_COMMANDSTATUSTYPE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace CommandStatusType {
+   enum CommandStatusType {
+       /**  Pending authorization prior to execution  */
+       Pending = 0,
+       /**  Approved for execution by the aircraft  */
+       Approved = 1,
+       /**  Currently executing by an aircraft  */
+       InProcess = 2,
+       /**  Completed execution by an aircraft  */
+       Executed = 3,
+       /**  Cancelled by an operator, aircraft, or other entity  */
+       Cancelled = 4
+
+   };
+
+   // generates a new CommandStatusType value for the passed string
+   inline CommandStatusType get_CommandStatusType(std::string str) {
+       if ( str == "Pending") return Pending;
+       if ( str == "Approved") return Approved;
+       if ( str == "InProcess") return InProcess;
+       if ( str == "Executed") return Executed;
+       if ( str == "Cancelled") return Cancelled;
+        return Pending;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(CommandStatusType e) {
+       switch(e) {
+        case Pending: return "Pending";
+        case Approved: return "Approved";
+        case InProcess: return "InProcess";
+        case Executed: return "Executed";
+        case Cancelled: return "Cancelled";
+        default: return "Pending";
+
+       }
+   }
+
+   }  // namespace CommandStatusType
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_COMMANDSTATUSTYPE_H_
diff --git a/src/LMCP/afrl/cmasi/EntityConfiguration.h b/src/LMCP/afrl/cmasi/EntityConfiguration.h
new file mode 100644
index 0000000..0bd2d49
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/EntityConfiguration.h
@@ -0,0 +1,156 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_ENTITYCONFIGURATION_H_
+#define _AFRL_CMASI_ENTITYCONFIGURATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AltitudeType.h"
+#include "afrl/cmasi/PayloadConfiguration.h"
+#include "afrl/cmasi/KeyValuePair.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isEntityConfiguration(avtas::lmcp::Object* obj);
+   bool isEntityConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > EntityConfigurationDescendants();
+   
+   class EntityConfiguration : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      EntityConfiguration(void);
+
+      // Copy Constructor
+      EntityConfiguration(const EntityConfiguration &that);
+
+      // Assignment Operator
+      EntityConfiguration & operator=(const EntityConfiguration &that);
+
+      // Destructor
+      virtual ~EntityConfiguration(void);
+
+      // Equals overload
+      bool operator==(const EntityConfiguration & that);
+      bool operator!=(const EntityConfiguration & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual EntityConfiguration* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 11; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** A unique id for this entity (Units: None)*/
+      int64_t getID(void) const { return __ID; }
+      EntityConfiguration& setID(const int64_t val);
+
+      /** the team or "side" that an entity belongs to. This can be a name of a country, a "friend" or "foe" designation, or a team name (e.g. "red team"). (Units: None)*/
+      std::string getAffiliation(void) const { return __Affiliation; }
+      EntityConfiguration& setAffiliation(const std::string val);
+
+      /** The type of this entity. The content of this field is dependent on the session. The value of this field is not specifically defined, so it is up to the simulation/session components to define a type system. For a common entity definition, see MIL STD 2525 or use DIS enumerations. (Units: None)*/
+      std::string getEntityType(void) const { return __EntityType; }
+      EntityConfiguration& setEntityType(const std::string val);
+
+      /** An optional text string for the vehicle. This is not necessarily unique, and is included for information only. ID should be used to uniquely identify entities. (Units: None)*/
+      std::string getLabel(void) const { return __Label; }
+      EntityConfiguration& setLabel(const std::string val);
+
+      /** The speed that is typically commanded for this entity (Units: meter/sec)*/
+      float getNominalSpeed(void) const { return __NominalSpeed; }
+      EntityConfiguration& setNominalSpeed(const float val);
+
+      /** The altitude that is typically commanded for this entity (Units: meter)*/
+      float getNominalAltitude(void) const { return __NominalAltitude; }
+      EntityConfiguration& setNominalAltitude(const float val);
+
+      /** Altitude type for nominal altitude (Units: None)*/
+      afrl::cmasi::AltitudeType::AltitudeType getNominalAltitudeType(void) const { return __NominalAltitudeType; }
+      EntityConfiguration& setNominalAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val);
+
+      /** A list of all payload configurations for this vehicle. Examples of payloads include: gimbaled sensors, SAR radars (not yet supported), air-launched UAVs (not yet supported), and weapons (not yet supported). (Units: None)*/
+      std::vector<afrl::cmasi::PayloadConfiguration*> & getPayloadConfigurationList(void) { return __PayloadConfigurationList; }
+
+      /** A list that maps keys to values for the inclusion of extra, custom information about this entity (Units: None)*/
+      std::vector<afrl::cmasi::KeyValuePair*> & getInfo(void) { return __Info; }
+
+
+
+   protected:
+      /** A unique id for this entity */
+      int64_t __ID;
+      /** the team or "side" that an entity belongs to. This can be a name of a country, a "friend" or "foe" designation, or a team name (e.g. "red team"). */
+      std::string __Affiliation;
+      /** The type of this entity. The content of this field is dependent on the session. The value of this field is not specifically defined, so it is up to the simulation/session components to define a type system. For a common entity definition, see MIL STD 2525 or use DIS enumerations. */
+      std::string __EntityType;
+      /** An optional text string for the vehicle. This is not necessarily unique, and is included for information only. ID should be used to uniquely identify entities. */
+      std::string __Label;
+      /** The speed that is typically commanded for this entity */
+      float __NominalSpeed;
+      /** The altitude that is typically commanded for this entity */
+      float __NominalAltitude;
+      /** Altitude type for nominal altitude */
+      afrl::cmasi::AltitudeType::AltitudeType __NominalAltitudeType;
+      /** A list of all payload configurations for this vehicle. Examples of payloads include: gimbaled sensors, SAR radars (not yet supported), air-launched UAVs (not yet supported), and weapons (not yet supported). */
+      std::vector< afrl::cmasi::PayloadConfiguration* > __PayloadConfigurationList;
+      /** A list that maps keys to values for the inclusion of extra, custom information about this entity */
+      std::vector< afrl::cmasi::KeyValuePair* > __Info;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_ENTITYCONFIGURATION_H_
diff --git a/src/LMCP/afrl/cmasi/EntityConfigurationDescendants.h b/src/LMCP/afrl/cmasi/EntityConfigurationDescendants.h
new file mode 100644
index 0000000..b130aa2
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/EntityConfigurationDescendants.h
@@ -0,0 +1,16 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/AirVehicleConfiguration.h"
+#include "afrl/impact/RadioTowerConfiguration.h"
+#include "afrl/impact/GroundVehicleConfiguration.h"
+#include "afrl/impact/SurfaceVehicleConfiguration.h"
+
diff --git a/src/LMCP/afrl/cmasi/EntityState.h b/src/LMCP/afrl/cmasi/EntityState.h
new file mode 100644
index 0000000..b3bd070
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/EntityState.h
@@ -0,0 +1,252 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_ENTITYSTATE_H_
+#define _AFRL_CMASI_ENTITYSTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+#include "afrl/cmasi/PayloadState.h"
+#include "afrl/cmasi/NavigationMode.h"
+#include "afrl/cmasi/KeyValuePair.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isEntityState(avtas::lmcp::Object* obj);
+   bool isEntityState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > EntityStateDescendants();
+   
+   class EntityState : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      EntityState(void);
+
+      // Copy Constructor
+      EntityState(const EntityState &that);
+
+      // Assignment Operator
+      EntityState & operator=(const EntityState &that);
+
+      // Destructor
+      virtual ~EntityState(void);
+
+      // Equals overload
+      bool operator==(const EntityState & that);
+      bool operator!=(const EntityState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual EntityState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 14; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** A unique ID for this entity. IDs should be greater than zero (Units: None)*/
+      int64_t getID(void) const { return __ID; }
+      EntityState& setID(const int64_t val);
+
+      /** Velocity in the body x-direction (postive out nose) (Units: meter/sec)*/
+      float getU(void) const { return __u; }
+      EntityState& setU(const float val);
+
+      /** Velocity in the body y-direction (positive out right wing) (Units: meter/sec)*/
+      float getV(void) const { return __v; }
+      EntityState& setV(const float val);
+
+      /** Velocity in the body z-direction (positve downward) (Units: meter/sec)*/
+      float getW(void) const { return __w; }
+      EntityState& setW(const float val);
+
+      /** Acceleration in the body x-direction (postive out nose) (Units: meter/sec/sec)*/
+      float getUdot(void) const { return __udot; }
+      EntityState& setUdot(const float val);
+
+      /** Acceleration in the body y-direction (positive out right wing) (Units: meter/sec/sec)*/
+      float getVdot(void) const { return __vdot; }
+      EntityState& setVdot(const float val);
+
+      /** Acceleration in the body z-direction (positve downward) (Units: meter/sec/sec)*/
+      float getWdot(void) const { return __wdot; }
+      EntityState& setWdot(const float val);
+
+      /** Angle between true North and the projection of the body x-axis in the North-East plane. (Units: degree)*/
+      float getHeading(void) const { return __Heading; }
+      EntityState& setHeading(const float val);
+
+      /** Pitch of vehicle around body y-axis (positive upwards) (Units: degree)*/
+      float getPitch(void) const { return __Pitch; }
+      EntityState& setPitch(const float val);
+
+      /** Roll angle of the vehicle around body x-axis (positive right wing down) (Units: degree)*/
+      float getRoll(void) const { return __Roll; }
+      EntityState& setRoll(const float val);
+
+      /** roll-rate of vehicle (angular velocity around body x-axis). Positive right-wing down. (Units: degree/sec)*/
+      float getP(void) const { return __p; }
+      EntityState& setP(const float val);
+
+      /** pitch rate of the vehicle (angular velocity around body y-axis). Positive nose-up.(Units: degree/sec)*/
+      float getQ(void) const { return __q; }
+      EntityState& setQ(const float val);
+
+      /** yaw rate of the vehicle (angular velocity around body z-axis). Positive nose right. (Units: degree/sec)*/
+      float getR(void) const { return __r; }
+      EntityState& setR(const float val);
+
+      /** Course/Groundtrack angle of the entity referenced to true North (Units: degrees)*/
+      float getCourse(void) const { return __Course; }
+      EntityState& setCourse(const float val);
+
+      /** Current entity ground speed (Units: m/s)*/
+      float getGroundspeed(void) const { return __Groundspeed; }
+      EntityState& setGroundspeed(const float val);
+
+      /** The perceived entity location (Units: None)*/
+      afrl::cmasi::Location3D* const getLocation(void) { return __Location; }
+      EntityState& setLocation(const afrl::cmasi::Location3D* const val);
+
+      /** The available energy remaining, expressed in terms of the percentage of maximum capacity (Units: %)*/
+      float getEnergyAvailable(void) const { return __EnergyAvailable; }
+      EntityState& setEnergyAvailable(const float val);
+
+      /** The consumption rate of available energy, expressed in terms of the percentage of maximum capacity used per second. (Units: %/sec)*/
+      float getActualEnergyRate(void) const { return __ActualEnergyRate; }
+      EntityState& setActualEnergyRate(const float val);
+
+      /** A list of states for any onboard payloads (Units: None)*/
+      std::vector<afrl::cmasi::PayloadState*> & getPayloadStateList(void) { return __PayloadStateList; }
+
+      /** The ID of the current waypoint. Only valid if the vehicle is in waypoint following mode. (Units: None)*/
+      int64_t getCurrentWaypoint(void) const { return __CurrentWaypoint; }
+      EntityState& setCurrentWaypoint(const int64_t val);
+
+      /** Current command (VehicleActionCommand or MissionCommand) being executed. A value of zero denotes no command being executed, or that a command without an set identifier (CommandID) is being executed. (Units: None)*/
+      int64_t getCurrentCommand(void) const { return __CurrentCommand; }
+      EntityState& setCurrentCommand(const int64_t val);
+
+      /** The current mode for this vehicle. (Units: None)*/
+      afrl::cmasi::NavigationMode::NavigationMode getMode(void) const { return __Mode; }
+      EntityState& setMode(const afrl::cmasi::NavigationMode::NavigationMode val);
+
+      /** Tasks that this entity is currently executing. An empty list indicates no associated tasks. The task number should coincide with the task number in the task request. For instance, if a waypoint is associated with a search task, then the task number associated with that search should be included in this list. (Units: None)*/
+      std::vector<int64_t> & getAssociatedTasks(void) { return __AssociatedTasks; }
+
+      /** time stamp of this data. Time datum is defined by the application, but unless otherwise specified is milliseconds since 1 Jan 1970 (Units: millisecond)*/
+      int64_t getTime(void) const { return __Time; }
+      EntityState& setTime(const int64_t val);
+
+      /** A list that maps keys to values for the inclusion of extra, custom information about this entity (Units: None)*/
+      std::vector<afrl::cmasi::KeyValuePair*> & getInfo(void) { return __Info; }
+
+
+
+   protected:
+      /** A unique ID for this entity. IDs should be greater than zero */
+      int64_t __ID;
+      /** Velocity in the body x-direction (postive out nose) */
+      float __u;
+      /** Velocity in the body y-direction (positive out right wing) */
+      float __v;
+      /** Velocity in the body z-direction (positve downward) */
+      float __w;
+      /** Acceleration in the body x-direction (postive out nose) */
+      float __udot;
+      /** Acceleration in the body y-direction (positive out right wing) */
+      float __vdot;
+      /** Acceleration in the body z-direction (positve downward) */
+      float __wdot;
+      /** Angle between true North and the projection of the body x-axis in the North-East plane. */
+      float __Heading;
+      /** Pitch of vehicle around body y-axis (positive upwards) */
+      float __Pitch;
+      /** Roll angle of the vehicle around body x-axis (positive right wing down) */
+      float __Roll;
+      /** roll-rate of vehicle (angular velocity around body x-axis). Positive right-wing down. */
+      float __p;
+      /** pitch rate of the vehicle (angular velocity around body y-axis). Positive nose-up.*/
+      float __q;
+      /** yaw rate of the vehicle (angular velocity around body z-axis). Positive nose right. */
+      float __r;
+      /** Course/Groundtrack angle of the entity referenced to true North */
+      float __Course;
+      /** Current entity ground speed */
+      float __Groundspeed;
+      /** The perceived entity location */
+      afrl::cmasi::Location3D* __Location;
+      /** The available energy remaining, expressed in terms of the percentage of maximum capacity */
+      float __EnergyAvailable;
+      /** The consumption rate of available energy, expressed in terms of the percentage of maximum capacity used per second. */
+      float __ActualEnergyRate;
+      /** A list of states for any onboard payloads */
+      std::vector< afrl::cmasi::PayloadState* > __PayloadStateList;
+      /** The ID of the current waypoint. Only valid if the vehicle is in waypoint following mode. */
+      int64_t __CurrentWaypoint;
+      /** Current command (VehicleActionCommand or MissionCommand) being executed. A value of zero denotes no command being executed, or that a command without an set identifier (CommandID) is being executed. */
+      int64_t __CurrentCommand;
+      /** The current mode for this vehicle. */
+      afrl::cmasi::NavigationMode::NavigationMode __Mode;
+      /** Tasks that this entity is currently executing. An empty list indicates no associated tasks. The task number should coincide with the task number in the task request. For instance, if a waypoint is associated with a search task, then the task number associated with that search should be included in this list. */
+      std::vector< int64_t > __AssociatedTasks;
+      /** time stamp of this data. Time datum is defined by the application, but unless otherwise specified is milliseconds since 1 Jan 1970 */
+      int64_t __Time;
+      /** A list that maps keys to values for the inclusion of extra, custom information about this entity */
+      std::vector< afrl::cmasi::KeyValuePair* > __Info;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_ENTITYSTATE_H_
diff --git a/src/LMCP/afrl/cmasi/EntityStateDescendants.h b/src/LMCP/afrl/cmasi/EntityStateDescendants.h
new file mode 100644
index 0000000..5a14dad
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/EntityStateDescendants.h
@@ -0,0 +1,16 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/AirVehicleState.h"
+#include "afrl/impact/RadioTowerState.h"
+#include "afrl/impact/GroundVehicleState.h"
+#include "afrl/impact/SurfaceVehicleState.h"
+
diff --git a/src/LMCP/afrl/cmasi/FOVOperationMode.h b/src/LMCP/afrl/cmasi/FOVOperationMode.h
new file mode 100644
index 0000000..b881076
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/FOVOperationMode.h
@@ -0,0 +1,56 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_FOVOPERATIONMODE_H_
+#define _AFRL_CMASI_FOVOPERATIONMODE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace FOVOperationMode {
+   enum FOVOperationMode {
+       /**  field of view can be continuously changed  */
+       Continuous = 0,
+       /**  field of view can only be set to certian, discrete values  */
+       Discrete = 1
+
+   };
+
+   // generates a new FOVOperationMode value for the passed string
+   inline FOVOperationMode get_FOVOperationMode(std::string str) {
+       if ( str == "Continuous") return Continuous;
+       if ( str == "Discrete") return Discrete;
+        return Continuous;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(FOVOperationMode e) {
+       switch(e) {
+        case Continuous: return "Continuous";
+        case Discrete: return "Discrete";
+        default: return "Continuous";
+
+       }
+   }
+
+   }  // namespace FOVOperationMode
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_FOVOPERATIONMODE_H_
diff --git a/src/LMCP/afrl/cmasi/FlightDirectorAction.h b/src/LMCP/afrl/cmasi/FlightDirectorAction.h
new file mode 100644
index 0000000..25a8c21
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/FlightDirectorAction.h
@@ -0,0 +1,138 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_FLIGHTDIRECTORACTION_H_
+#define _AFRL_CMASI_FLIGHTDIRECTORACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/NavigationAction.h"
+#include "afrl/cmasi/SpeedType.h"
+#include "afrl/cmasi/AltitudeType.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isFlightDirectorAction(avtas::lmcp::Object* obj);
+   bool isFlightDirectorAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > FlightDirectorActionDescendants();
+   
+   class FlightDirectorAction : public afrl::cmasi::NavigationAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      FlightDirectorAction(void);
+
+      // Copy Constructor
+      FlightDirectorAction(const FlightDirectorAction &that);
+
+      // Assignment Operator
+      FlightDirectorAction & operator=(const FlightDirectorAction &that);
+
+      // Destructor
+      virtual ~FlightDirectorAction(void);
+
+      // Equals overload
+      bool operator==(const FlightDirectorAction & that);
+      bool operator!=(const FlightDirectorAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual FlightDirectorAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 54; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Speed to fly (Units: meter/sec)*/
+      float getSpeed(void) const { return __Speed; }
+      FlightDirectorAction& setSpeed(const float val);
+
+      /** type of speed to fly (Units: None)*/
+      afrl::cmasi::SpeedType::SpeedType getSpeedType(void) const { return __SpeedType; }
+      FlightDirectorAction& setSpeedType(const afrl::cmasi::SpeedType::SpeedType val);
+
+      /** True heading to fly (Units: degree)*/
+      float getHeading(void) const { return __Heading; }
+      FlightDirectorAction& setHeading(const float val);
+
+      /** Altitude to maintain. (Units: meter)*/
+      float getAltitude(void) const { return __Altitude; }
+      FlightDirectorAction& setAltitude(const float val);
+
+      /** Altitude type for specified altitude (Units: None)*/
+      afrl::cmasi::AltitudeType::AltitudeType getAltitudeType(void) const { return __AltitudeType; }
+      FlightDirectorAction& setAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val);
+
+      /** target climb/descent rate for changing altitude (Units: meter/sec)*/
+      float getClimbRate(void) const { return __ClimbRate; }
+      FlightDirectorAction& setClimbRate(const float val);
+
+
+
+   protected:
+      /** Speed to fly */
+      float __Speed;
+      /** type of speed to fly */
+      afrl::cmasi::SpeedType::SpeedType __SpeedType;
+      /** True heading to fly */
+      float __Heading;
+      /** Altitude to maintain. */
+      float __Altitude;
+      /** Altitude type for specified altitude */
+      afrl::cmasi::AltitudeType::AltitudeType __AltitudeType;
+      /** target climb/descent rate for changing altitude */
+      float __ClimbRate;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_FLIGHTDIRECTORACTION_H_
diff --git a/src/LMCP/afrl/cmasi/FlightDirectorActionDescendants.h b/src/LMCP/afrl/cmasi/FlightDirectorActionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/FlightDirectorActionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/FlightProfile.h b/src/LMCP/afrl/cmasi/FlightProfile.h
new file mode 100644
index 0000000..55ec1c2
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/FlightProfile.h
@@ -0,0 +1,136 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_FLIGHTPROFILE_H_
+#define _AFRL_CMASI_FLIGHTPROFILE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isFlightProfile(avtas::lmcp::Object* obj);
+   bool isFlightProfile(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > FlightProfileDescendants();
+   
+   class FlightProfile : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      FlightProfile(void);
+
+      // Copy Constructor
+      FlightProfile(const FlightProfile &that);
+
+      // Assignment Operator
+      FlightProfile & operator=(const FlightProfile &that);
+
+      // Destructor
+      virtual ~FlightProfile(void);
+
+      // Equals overload
+      bool operator==(const FlightProfile & that);
+      bool operator!=(const FlightProfile & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual FlightProfile* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 12; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The unique name for this configuration (Units: None)*/
+      std::string getName(void) const { return __Name; }
+      FlightProfile& setName(const std::string val);
+
+      /** True Airspeed (Units: meter/sec)*/
+      float getAirspeed(void) const { return __Airspeed; }
+      FlightProfile& setAirspeed(const float val);
+
+      /** The pitch angle of the aircraft in this flight condition(assuming zero bank) (Units: degree)*/
+      float getPitchAngle(void) const { return __PitchAngle; }
+      FlightProfile& setPitchAngle(const float val);
+
+      /** Vertical speed (positive upwards) of the vehicle (Units: meter/sec)*/
+      float getVerticalSpeed(void) const { return __VerticalSpeed; }
+      FlightProfile& setVerticalSpeed(const float val);
+
+      /** The maximum angle that this vehicle will bank (Units: degree)*/
+      float getMaxBankAngle(void) const { return __MaxBankAngle; }
+      FlightProfile& setMaxBankAngle(const float val);
+
+      /** The consumption rate of available energy, expressed in terms of the percentage of maximum capacity used per second. (Units: %/sec)*/
+      float getEnergyRate(void) const { return __EnergyRate; }
+      FlightProfile& setEnergyRate(const float val);
+
+
+
+   protected:
+      /** The unique name for this configuration */
+      std::string __Name;
+      /** True Airspeed */
+      float __Airspeed;
+      /** The pitch angle of the aircraft in this flight condition(assuming zero bank) */
+      float __PitchAngle;
+      /** Vertical speed (positive upwards) of the vehicle */
+      float __VerticalSpeed;
+      /** The maximum angle that this vehicle will bank */
+      float __MaxBankAngle;
+      /** The consumption rate of available energy, expressed in terms of the percentage of maximum capacity used per second. */
+      float __EnergyRate;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_FLIGHTPROFILE_H_
diff --git a/src/LMCP/afrl/cmasi/FlightProfileDescendants.h b/src/LMCP/afrl/cmasi/FlightProfileDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/FlightProfileDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/FollowPathCommand.h b/src/LMCP/afrl/cmasi/FollowPathCommand.h
new file mode 100644
index 0000000..059a3c2
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/FollowPathCommand.h
@@ -0,0 +1,132 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_FOLLOWPATHCOMMAND_H_
+#define _AFRL_CMASI_FOLLOWPATHCOMMAND_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/VehicleActionCommand.h"
+#include "afrl/cmasi/PathWaypoint.h"
+#include "afrl/cmasi/TravelMode.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isFollowPathCommand(avtas::lmcp::Object* obj);
+   bool isFollowPathCommand(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > FollowPathCommandDescendants();
+   
+   class FollowPathCommand : public afrl::cmasi::VehicleActionCommand {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      FollowPathCommand(void);
+
+      // Copy Constructor
+      FollowPathCommand(const FollowPathCommand &that);
+
+      // Assignment Operator
+      FollowPathCommand & operator=(const FollowPathCommand &that);
+
+      // Destructor
+      virtual ~FollowPathCommand(void);
+
+      // Equals overload
+      bool operator==(const FollowPathCommand & that);
+      bool operator!=(const FollowPathCommand & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual FollowPathCommand* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 56; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The first waypoint to follow. This should correspond to the number of a waypoint in the waypoint list. If this is zero, no waypoint will be followed. (Units: None)*/
+      int64_t getFirstWaypoint(void) const { return __FirstWaypoint; }
+      FollowPathCommand& setFirstWaypoint(const int64_t val);
+
+      /** A list of waypoints to follow (Units: None)*/
+      std::vector<afrl::cmasi::PathWaypoint*> & getWaypointList(void) { return __WaypointList; }
+
+      /** Describes the start time for this action, in scenario time. If this field is zero, the action is completed immediately. (Units: milliseconds)*/
+      int64_t getStartTime(void) const { return __StartTime; }
+      FollowPathCommand& setStartTime(const int64_t val);
+
+      /** Describes the end time for this action, in scenario time. If this field is zero, it should be ignored, otherwise The entity will travel until the stop time is reached. (Units: milliseconds)*/
+      int64_t getStopTime(void) const { return __StopTime; }
+      FollowPathCommand& setStopTime(const int64_t val);
+
+      /** Describes how the entity should treat the end-of-path. Entities can complete the path once, or continuously.(Units: None)*/
+      afrl::cmasi::TravelMode::TravelMode getRepeatMode(void) const { return __RepeatMode; }
+      FollowPathCommand& setRepeatMode(const afrl::cmasi::TravelMode::TravelMode val);
+
+
+
+   protected:
+      /** The first waypoint to follow. This should correspond to the number of a waypoint in the waypoint list. If this is zero, no waypoint will be followed. */
+      int64_t __FirstWaypoint;
+      /** A list of waypoints to follow */
+      std::vector< afrl::cmasi::PathWaypoint* > __WaypointList;
+      /** Describes the start time for this action, in scenario time. If this field is zero, the action is completed immediately. */
+      int64_t __StartTime;
+      /** Describes the end time for this action, in scenario time. If this field is zero, it should be ignored, otherwise The entity will travel until the stop time is reached. */
+      int64_t __StopTime;
+      /** Describes how the entity should treat the end-of-path. Entities can complete the path once, or continuously.*/
+      afrl::cmasi::TravelMode::TravelMode __RepeatMode;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_FOLLOWPATHCOMMAND_H_
diff --git a/src/LMCP/afrl/cmasi/FollowPathCommandDescendants.h b/src/LMCP/afrl/cmasi/FollowPathCommandDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/FollowPathCommandDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/GimbalAngleAction.h b/src/LMCP/afrl/cmasi/GimbalAngleAction.h
new file mode 100644
index 0000000..5d6c84a
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimbalAngleAction.h
@@ -0,0 +1,118 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_GIMBALANGLEACTION_H_
+#define _AFRL_CMASI_GIMBALANGLEACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/PayloadAction.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isGimbalAngleAction(avtas::lmcp::Object* obj);
+   bool isGimbalAngleAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > GimbalAngleActionDescendants();
+   
+   class GimbalAngleAction : public afrl::cmasi::PayloadAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      GimbalAngleAction(void);
+
+      // Copy Constructor
+      GimbalAngleAction(const GimbalAngleAction &that);
+
+      // Assignment Operator
+      GimbalAngleAction & operator=(const GimbalAngleAction &that);
+
+      // Destructor
+      virtual ~GimbalAngleAction(void);
+
+      // Equals overload
+      bool operator==(const GimbalAngleAction & that);
+      bool operator!=(const GimbalAngleAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual GimbalAngleAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 23; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The commanded azimuth angle (0 degrees out of nose, positive clockwise). (Units: degree)*/
+      float getAzimuth(void) const { return __Azimuth; }
+      GimbalAngleAction& setAzimuth(const float val);
+
+      /** The commanded elevation angle (0 degrees horizontal, positive upwards). (Units: degree)*/
+      float getElevation(void) const { return __Elevation; }
+      GimbalAngleAction& setElevation(const float val);
+
+      /** The commanded rotation angle (0 degrees aligned with aircraft normal, positive clockwise). (Units: degree)*/
+      float getRotation(void) const { return __Rotation; }
+      GimbalAngleAction& setRotation(const float val);
+
+
+
+   protected:
+      /** The commanded azimuth angle (0 degrees out of nose, positive clockwise). */
+      float __Azimuth;
+      /** The commanded elevation angle (0 degrees horizontal, positive upwards). */
+      float __Elevation;
+      /** The commanded rotation angle (0 degrees aligned with aircraft normal, positive clockwise). */
+      float __Rotation;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_GIMBALANGLEACTION_H_
diff --git a/src/LMCP/afrl/cmasi/GimbalAngleActionDescendants.h b/src/LMCP/afrl/cmasi/GimbalAngleActionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimbalAngleActionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/GimbalConfiguration.h b/src/LMCP/afrl/cmasi/GimbalConfiguration.h
new file mode 100644
index 0000000..daf4aa0
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimbalConfiguration.h
@@ -0,0 +1,184 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_GIMBALCONFIGURATION_H_
+#define _AFRL_CMASI_GIMBALCONFIGURATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/PayloadConfiguration.h"
+#include "afrl/cmasi/GimbalPointingMode.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isGimbalConfiguration(avtas::lmcp::Object* obj);
+   bool isGimbalConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > GimbalConfigurationDescendants();
+   
+   class GimbalConfiguration : public afrl::cmasi::PayloadConfiguration {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      GimbalConfiguration(void);
+
+      // Copy Constructor
+      GimbalConfiguration(const GimbalConfiguration &that);
+
+      // Assignment Operator
+      GimbalConfiguration & operator=(const GimbalConfiguration &that);
+
+      // Destructor
+      virtual ~GimbalConfiguration(void);
+
+      // Equals overload
+      bool operator==(const GimbalConfiguration & that);
+      bool operator!=(const GimbalConfiguration & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual GimbalConfiguration* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 24; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The pointing modes supported by the gimbal (Units: None)*/
+      std::vector<afrl::cmasi::GimbalPointingMode::GimbalPointingMode> & getSupportedPointingModes(void) { return __SupportedPointingModes; }
+
+      /** Minimum azimuth that this sensor can slew in body axis (0 degrees out of nose, positive clockwise). If this is a fixed-azimuth sensor, then this should be set to the fixed azimuth value. (Units: degree)*/
+      float getMinAzimuth(void) const { return __MinAzimuth; }
+      GimbalConfiguration& setMinAzimuth(const float val);
+
+      /** Maximum azimuth that this sensor can slew in body axis (0 degrees out of nose, positive clockwise). If this is a fixed-azimuth sensor, then this should be set to the fixed azimuth value. (Units: degree)*/
+      float getMaxAzimuth(void) const { return __MaxAzimuth; }
+      GimbalConfiguration& setMaxAzimuth(const float val);
+
+      /** Determines whether there are any limits on the azimuth of the gimbal. If this is set to false, then MinAzimuth and MaxAzimuth are not used, and the gimbal is capable of continuously spinning in a 360 degree circle without hitting any stops. (Units: None)*/
+      bool getIsAzimuthClamped(void) const { return __IsAzimuthClamped; }
+      GimbalConfiguration& setIsAzimuthClamped(const bool val);
+
+      /** Minimum elevation that this sensor can slew in body axis (0 degrees horizontal, positive upwards). If this is a fixed-elevation sensor, then this should be set to the fixed elevation value. (Units: degree)*/
+      float getMinElevation(void) const { return __MinElevation; }
+      GimbalConfiguration& setMinElevation(const float val);
+
+      /** Maximum elevation that this sensor can slew in body axis (0 degrees horizontal, positive upwards). If this is a fixed-elevation sensor, then this should be set to the fixed elevation value. (Units: degree)*/
+      float getMaxElevation(void) const { return __MaxElevation; }
+      GimbalConfiguration& setMaxElevation(const float val);
+
+      /** Determines whether there are any limits on the elevation of the gimbal. If this is set to false, then MinElevation and MaxElevation are not used, and the gimbal is capable of continuously spinning in a 360 degree circle without hitting any stops. (Units: None)*/
+      bool getIsElevationClamped(void) const { return __IsElevationClamped; }
+      GimbalConfiguration& setIsElevationClamped(const bool val);
+
+      /** Minimum rotation that this sensor can slew in body axis (0 degrees aligned with aircraft normal, positive clockwise). If this is a fixed-rotation sensor, then this should be set to the fixed rotation value. (Units: degree)*/
+      float getMinRotation(void) const { return __MinRotation; }
+      GimbalConfiguration& setMinRotation(const float val);
+
+      /** Maximum rotation that this sensor can slew in body axis (0 degrees aligned with aircraft normal, positive clockwise). If this is a fixed-rotation sensor, then this should be set to the fixed rotation value. (Units: degree)*/
+      float getMaxRotation(void) const { return __MaxRotation; }
+      GimbalConfiguration& setMaxRotation(const float val);
+
+      /** Determines whether there are any limits on the rotation of the gimbal. If this is set to false, then MinRotation and MaxRotation are not used, and the gimbal is capable of continuously rotating in a 360 degree circle without hitting any stops. (Units: None)*/
+      bool getIsRotationClamped(void) const { return __IsRotationClamped; }
+      GimbalConfiguration& setIsRotationClamped(const bool val);
+
+      /** Rate of maximum horizontal slew for this gimbal. (Units: degree/sec)*/
+      float getMaxAzimuthSlewRate(void) const { return __MaxAzimuthSlewRate; }
+      GimbalConfiguration& setMaxAzimuthSlewRate(const float val);
+
+      /** Rate of maximum vertical slew for this gimbal. (Units: degree/sec)*/
+      float getMaxElevationSlewRate(void) const { return __MaxElevationSlewRate; }
+      GimbalConfiguration& setMaxElevationSlewRate(const float val);
+
+      /** Rate of maximum rotation for this gimbal. (Units: degree/sec)*/
+      float getMaxRotationRate(void) const { return __MaxRotationRate; }
+      GimbalConfiguration& setMaxRotationRate(const float val);
+
+      /** Lists the PayloadID of each sensor physically located within the gimbal and that shares the same gimbal angles. It is assumed that all sensors are boresighted. (Units: None)*/
+      std::vector<int64_t> & getContainedPayloadList(void) { return __ContainedPayloadList; }
+
+
+
+   protected:
+      /** The pointing modes supported by the gimbal */
+      std::vector< afrl::cmasi::GimbalPointingMode::GimbalPointingMode > __SupportedPointingModes;
+      /** Minimum azimuth that this sensor can slew in body axis (0 degrees out of nose, positive clockwise). If this is a fixed-azimuth sensor, then this should be set to the fixed azimuth value. */
+      float __MinAzimuth;
+      /** Maximum azimuth that this sensor can slew in body axis (0 degrees out of nose, positive clockwise). If this is a fixed-azimuth sensor, then this should be set to the fixed azimuth value. */
+      float __MaxAzimuth;
+      /** Determines whether there are any limits on the azimuth of the gimbal. If this is set to false, then MinAzimuth and MaxAzimuth are not used, and the gimbal is capable of continuously spinning in a 360 degree circle without hitting any stops. */
+      bool __IsAzimuthClamped;
+      /** Minimum elevation that this sensor can slew in body axis (0 degrees horizontal, positive upwards). If this is a fixed-elevation sensor, then this should be set to the fixed elevation value. */
+      float __MinElevation;
+      /** Maximum elevation that this sensor can slew in body axis (0 degrees horizontal, positive upwards). If this is a fixed-elevation sensor, then this should be set to the fixed elevation value. */
+      float __MaxElevation;
+      /** Determines whether there are any limits on the elevation of the gimbal. If this is set to false, then MinElevation and MaxElevation are not used, and the gimbal is capable of continuously spinning in a 360 degree circle without hitting any stops. */
+      bool __IsElevationClamped;
+      /** Minimum rotation that this sensor can slew in body axis (0 degrees aligned with aircraft normal, positive clockwise). If this is a fixed-rotation sensor, then this should be set to the fixed rotation value. */
+      float __MinRotation;
+      /** Maximum rotation that this sensor can slew in body axis (0 degrees aligned with aircraft normal, positive clockwise). If this is a fixed-rotation sensor, then this should be set to the fixed rotation value. */
+      float __MaxRotation;
+      /** Determines whether there are any limits on the rotation of the gimbal. If this is set to false, then MinRotation and MaxRotation are not used, and the gimbal is capable of continuously rotating in a 360 degree circle without hitting any stops. */
+      bool __IsRotationClamped;
+      /** Rate of maximum horizontal slew for this gimbal. */
+      float __MaxAzimuthSlewRate;
+      /** Rate of maximum vertical slew for this gimbal. */
+      float __MaxElevationSlewRate;
+      /** Rate of maximum rotation for this gimbal. */
+      float __MaxRotationRate;
+      /** Lists the PayloadID of each sensor physically located within the gimbal and that shares the same gimbal angles. It is assumed that all sensors are boresighted. */
+      std::vector< int64_t > __ContainedPayloadList;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_GIMBALCONFIGURATION_H_
diff --git a/src/LMCP/afrl/cmasi/GimbalConfigurationDescendants.h b/src/LMCP/afrl/cmasi/GimbalConfigurationDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimbalConfigurationDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/GimbalPointingMode.h b/src/LMCP/afrl/cmasi/GimbalPointingMode.h
new file mode 100644
index 0000000..c667132
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimbalPointingMode.h
@@ -0,0 +1,76 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_GIMBALPOINTINGMODE_H_
+#define _AFRL_CMASI_GIMBALPOINTINGMODE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace GimbalPointingMode {
+   enum GimbalPointingMode {
+       /**  Unknown pointing mode or unavailable  */
+       Unknown = 0,
+       /**  angles are commanded relative to the vehicle  */
+       AirVehicleRelativeAngle = 1,
+       /**  angle rates are commanded relative to the vehicle  */
+       AirVehicleRelativeSlewRate = 2,
+       /**  gimbal aimed at an inertial location  */
+       LatLonSlaved = 3,
+       /**  gimbal rates are calculated relative to the inertial coordinate system  */
+       InertialRelativeSlewRate = 4,
+       /**  gimbal continuously scans in a pre-determined pattern  */
+       Scan = 5,
+       /**  indicates that the gimbal is stowed  */
+       Stowed = 6
+
+   };
+
+   // generates a new GimbalPointingMode value for the passed string
+   inline GimbalPointingMode get_GimbalPointingMode(std::string str) {
+       if ( str == "Unknown") return Unknown;
+       if ( str == "AirVehicleRelativeAngle") return AirVehicleRelativeAngle;
+       if ( str == "AirVehicleRelativeSlewRate") return AirVehicleRelativeSlewRate;
+       if ( str == "LatLonSlaved") return LatLonSlaved;
+       if ( str == "InertialRelativeSlewRate") return InertialRelativeSlewRate;
+       if ( str == "Scan") return Scan;
+       if ( str == "Stowed") return Stowed;
+        return Unknown;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(GimbalPointingMode e) {
+       switch(e) {
+        case Unknown: return "Unknown";
+        case AirVehicleRelativeAngle: return "AirVehicleRelativeAngle";
+        case AirVehicleRelativeSlewRate: return "AirVehicleRelativeSlewRate";
+        case LatLonSlaved: return "LatLonSlaved";
+        case InertialRelativeSlewRate: return "InertialRelativeSlewRate";
+        case Scan: return "Scan";
+        case Stowed: return "Stowed";
+        default: return "Unknown";
+
+       }
+   }
+
+   }  // namespace GimbalPointingMode
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_GIMBALPOINTINGMODE_H_
diff --git a/src/LMCP/afrl/cmasi/GimbalScanAction.h b/src/LMCP/afrl/cmasi/GimbalScanAction.h
new file mode 100644
index 0000000..057f527
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimbalScanAction.h
@@ -0,0 +1,142 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_GIMBALSCANACTION_H_
+#define _AFRL_CMASI_GIMBALSCANACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/PayloadAction.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isGimbalScanAction(avtas::lmcp::Object* obj);
+   bool isGimbalScanAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > GimbalScanActionDescendants();
+   
+   class GimbalScanAction : public afrl::cmasi::PayloadAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      GimbalScanAction(void);
+
+      // Copy Constructor
+      GimbalScanAction(const GimbalScanAction &that);
+
+      // Assignment Operator
+      GimbalScanAction & operator=(const GimbalScanAction &that);
+
+      // Destructor
+      virtual ~GimbalScanAction(void);
+
+      // Equals overload
+      bool operator==(const GimbalScanAction & that);
+      bool operator!=(const GimbalScanAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual GimbalScanAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 25; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** sets the time-to-scan in the azimuthal direction. This is the time to complete one sweep through the the length of EndAzimuth - StartAzimuth. (Units: degree/second)*/
+      float getAzimuthSlewRate(void) const { return __AzimuthSlewRate; }
+      GimbalScanAction& setAzimuthSlewRate(const float val);
+
+      /** sets the time-to-scan in the elevation direction. This is the time to complete one sweep through the the length of EndElevation - StartElevation. (Units: degree/second)*/
+      float getElevationSlewRate(void) const { return __ElevationSlewRate; }
+      GimbalScanAction& setElevationSlewRate(const float val);
+
+      /** The starting azimuth for the sensor scan (boresight angle right of aircraft long axis)(Units: degree)*/
+      float getStartAzimuth(void) const { return __StartAzimuth; }
+      GimbalScanAction& setStartAzimuth(const float val);
+
+      /** The ending azimuth for the sensor scan (boresight angle right of aircraft long axis) (Units: degree)*/
+      float getEndAzimuth(void) const { return __EndAzimuth; }
+      GimbalScanAction& setEndAzimuth(const float val);
+
+      /** The starting elevation for the sensor scan (boresight angle positive from aircraft x-y plane)(Units: degree)*/
+      float getStartElevation(void) const { return __StartElevation; }
+      GimbalScanAction& setStartElevation(const float val);
+
+      /** The ending elevation for the sensor scan (boresight angle positive from aircraft x-y plane)(Units: degree)*/
+      float getEndElevation(void) const { return __EndElevation; }
+      GimbalScanAction& setEndElevation(const float val);
+
+      /** Number of sensor sweeps to perform. A zero value denotes indefinite number of sweeps. (Units: None)*/
+      uint32_t getCycles(void) const { return __Cycles; }
+      GimbalScanAction& setCycles(const uint32_t val);
+
+
+
+   protected:
+      /** sets the time-to-scan in the azimuthal direction. This is the time to complete one sweep through the the length of EndAzimuth - StartAzimuth. */
+      float __AzimuthSlewRate;
+      /** sets the time-to-scan in the elevation direction. This is the time to complete one sweep through the the length of EndElevation - StartElevation. */
+      float __ElevationSlewRate;
+      /** The starting azimuth for the sensor scan (boresight angle right of aircraft long axis)*/
+      float __StartAzimuth;
+      /** The ending azimuth for the sensor scan (boresight angle right of aircraft long axis) */
+      float __EndAzimuth;
+      /** The starting elevation for the sensor scan (boresight angle positive from aircraft x-y plane)*/
+      float __StartElevation;
+      /** The ending elevation for the sensor scan (boresight angle positive from aircraft x-y plane)*/
+      float __EndElevation;
+      /** Number of sensor sweeps to perform. A zero value denotes indefinite number of sweeps. */
+      uint32_t __Cycles;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_GIMBALSCANACTION_H_
diff --git a/src/LMCP/afrl/cmasi/GimbalScanActionDescendants.h b/src/LMCP/afrl/cmasi/GimbalScanActionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimbalScanActionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/GimbalStareAction.h b/src/LMCP/afrl/cmasi/GimbalStareAction.h
new file mode 100644
index 0000000..4bf7598
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimbalStareAction.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_GIMBALSTAREACTION_H_
+#define _AFRL_CMASI_GIMBALSTAREACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/PayloadAction.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isGimbalStareAction(avtas::lmcp::Object* obj);
+   bool isGimbalStareAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > GimbalStareActionDescendants();
+   
+   class GimbalStareAction : public afrl::cmasi::PayloadAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      GimbalStareAction(void);
+
+      // Copy Constructor
+      GimbalStareAction(const GimbalStareAction &that);
+
+      // Assignment Operator
+      GimbalStareAction & operator=(const GimbalStareAction &that);
+
+      // Destructor
+      virtual ~GimbalStareAction(void);
+
+      // Equals overload
+      bool operator==(const GimbalStareAction & that);
+      bool operator!=(const GimbalStareAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual GimbalStareAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 26; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The commanded stare point. (Units: None)*/
+      afrl::cmasi::Location3D* const getStarepoint(void) { return __Starepoint; }
+      GimbalStareAction& setStarepoint(const afrl::cmasi::Location3D* const val);
+
+      /** Duration for the stare operation. Zero denotes an indefinate stare time (Units: milliseconds)*/
+      int64_t getDuration(void) const { return __Duration; }
+      GimbalStareAction& setDuration(const int64_t val);
+
+
+
+   protected:
+      /** The commanded stare point. */
+      afrl::cmasi::Location3D* __Starepoint;
+      /** Duration for the stare operation. Zero denotes an indefinate stare time */
+      int64_t __Duration;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_GIMBALSTAREACTION_H_
diff --git a/src/LMCP/afrl/cmasi/GimbalStareActionDescendants.h b/src/LMCP/afrl/cmasi/GimbalStareActionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimbalStareActionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/GimbalState.h b/src/LMCP/afrl/cmasi/GimbalState.h
new file mode 100644
index 0000000..7004b23
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimbalState.h
@@ -0,0 +1,125 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_GIMBALSTATE_H_
+#define _AFRL_CMASI_GIMBALSTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/PayloadState.h"
+#include "afrl/cmasi/GimbalPointingMode.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isGimbalState(avtas::lmcp::Object* obj);
+   bool isGimbalState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > GimbalStateDescendants();
+   
+   class GimbalState : public afrl::cmasi::PayloadState {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      GimbalState(void);
+
+      // Copy Constructor
+      GimbalState(const GimbalState &that);
+
+      // Assignment Operator
+      GimbalState & operator=(const GimbalState &that);
+
+      // Destructor
+      virtual ~GimbalState(void);
+
+      // Equals overload
+      bool operator==(const GimbalState & that);
+      bool operator!=(const GimbalState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual GimbalState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 27; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Current pointing mode of the gimbal (Units: None)*/
+      afrl::cmasi::GimbalPointingMode::GimbalPointingMode getPointingMode(void) const { return __PointingMode; }
+      GimbalState& setPointingMode(const afrl::cmasi::GimbalPointingMode::GimbalPointingMode val);
+
+      /** Current azimuth angle of the gimbal boresight (positive from vehicle x-axis). (Units: degree)*/
+      float getAzimuth(void) const { return __Azimuth; }
+      GimbalState& setAzimuth(const float val);
+
+      /** Current elevation angle of the gimbal boresight (positive from vehicle x-y plane). (Units: degree)*/
+      float getElevation(void) const { return __Elevation; }
+      GimbalState& setElevation(const float val);
+
+      /** Current rotation angle of the gimbal boresight (0 degrees aligned with aircraft normal, positive clockwise). (Units: degree)*/
+      float getRotation(void) const { return __Rotation; }
+      GimbalState& setRotation(const float val);
+
+
+
+   protected:
+      /** Current pointing mode of the gimbal */
+      afrl::cmasi::GimbalPointingMode::GimbalPointingMode __PointingMode;
+      /** Current azimuth angle of the gimbal boresight (positive from vehicle x-axis). */
+      float __Azimuth;
+      /** Current elevation angle of the gimbal boresight (positive from vehicle x-y plane). */
+      float __Elevation;
+      /** Current rotation angle of the gimbal boresight (0 degrees aligned with aircraft normal, positive clockwise). */
+      float __Rotation;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_GIMBALSTATE_H_
diff --git a/src/LMCP/afrl/cmasi/GimbalStateDescendants.h b/src/LMCP/afrl/cmasi/GimbalStateDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimbalStateDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/GimballedPayloadState.h b/src/LMCP/afrl/cmasi/GimballedPayloadState.h
new file mode 100644
index 0000000..d189264
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimballedPayloadState.h
@@ -0,0 +1,125 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_GIMBALLEDPAYLOADSTATE_H_
+#define _AFRL_CMASI_GIMBALLEDPAYLOADSTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/PayloadState.h"
+#include "afrl/cmasi/GimbalPointingMode.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isGimballedPayloadState(avtas::lmcp::Object* obj);
+   bool isGimballedPayloadState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > GimballedPayloadStateDescendants();
+   
+   class GimballedPayloadState : public afrl::cmasi::PayloadState {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      GimballedPayloadState(void);
+
+      // Copy Constructor
+      GimballedPayloadState(const GimballedPayloadState &that);
+
+      // Assignment Operator
+      GimballedPayloadState & operator=(const GimballedPayloadState &that);
+
+      // Destructor
+      virtual ~GimballedPayloadState(void);
+
+      // Equals overload
+      bool operator==(const GimballedPayloadState & that);
+      bool operator!=(const GimballedPayloadState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual GimballedPayloadState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 20; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Current pointing mode of the gimbal to which this payload is attached(Units: None)*/
+      afrl::cmasi::GimbalPointingMode::GimbalPointingMode getPointingMode(void) const { return __PointingMode; }
+      GimballedPayloadState& setPointingMode(const afrl::cmasi::GimbalPointingMode::GimbalPointingMode val);
+
+      /** Current azimuth angle of the gimbal boresight (positive from vehicle x-axis). (Units: degree)*/
+      float getAzimuth(void) const { return __Azimuth; }
+      GimballedPayloadState& setAzimuth(const float val);
+
+      /** Current elevation angle of the gimbal boresight (positive from vehicle x-y plane). (Units: degree)*/
+      float getElevation(void) const { return __Elevation; }
+      GimballedPayloadState& setElevation(const float val);
+
+      /** Current rotation angle of the gimbal boresight (0 degrees aligned with aircraft normal, positive clockwise). (Units: degree)*/
+      float getRotation(void) const { return __Rotation; }
+      GimballedPayloadState& setRotation(const float val);
+
+
+
+   protected:
+      /** Current pointing mode of the gimbal to which this payload is attached*/
+      afrl::cmasi::GimbalPointingMode::GimbalPointingMode __PointingMode;
+      /** Current azimuth angle of the gimbal boresight (positive from vehicle x-axis). */
+      float __Azimuth;
+      /** Current elevation angle of the gimbal boresight (positive from vehicle x-y plane). */
+      float __Elevation;
+      /** Current rotation angle of the gimbal boresight (0 degrees aligned with aircraft normal, positive clockwise). */
+      float __Rotation;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_GIMBALLEDPAYLOADSTATE_H_
diff --git a/src/LMCP/afrl/cmasi/GimballedPayloadStateDescendants.h b/src/LMCP/afrl/cmasi/GimballedPayloadStateDescendants.h
new file mode 100644
index 0000000..7926dca
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GimballedPayloadStateDescendants.h
@@ -0,0 +1,13 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/CameraState.h"
+
diff --git a/src/LMCP/afrl/cmasi/GoToWaypointAction.h b/src/LMCP/afrl/cmasi/GoToWaypointAction.h
new file mode 100644
index 0000000..26b8560
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GoToWaypointAction.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_GOTOWAYPOINTACTION_H_
+#define _AFRL_CMASI_GOTOWAYPOINTACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/NavigationAction.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isGoToWaypointAction(avtas::lmcp::Object* obj);
+   bool isGoToWaypointAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > GoToWaypointActionDescendants();
+   
+   class GoToWaypointAction : public afrl::cmasi::NavigationAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      GoToWaypointAction(void);
+
+      // Copy Constructor
+      GoToWaypointAction(const GoToWaypointAction &that);
+
+      // Assignment Operator
+      GoToWaypointAction & operator=(const GoToWaypointAction &that);
+
+      // Destructor
+      virtual ~GoToWaypointAction(void);
+
+      // Equals overload
+      bool operator==(const GoToWaypointAction & that);
+      bool operator!=(const GoToWaypointAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual GoToWaypointAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 28; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Waypoint number to which the aircraft should fly. (Units: None)*/
+      int64_t getWaypointNumber(void) const { return __WaypointNumber; }
+      GoToWaypointAction& setWaypointNumber(const int64_t val);
+
+
+
+   protected:
+      /** Waypoint number to which the aircraft should fly. */
+      int64_t __WaypointNumber;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_GOTOWAYPOINTACTION_H_
diff --git a/src/LMCP/afrl/cmasi/GoToWaypointActionDescendants.h b/src/LMCP/afrl/cmasi/GoToWaypointActionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/GoToWaypointActionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/KeepInZone.h b/src/LMCP/afrl/cmasi/KeepInZone.h
new file mode 100644
index 0000000..2a8422d
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/KeepInZone.h
@@ -0,0 +1,100 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_KEEPINZONE_H_
+#define _AFRL_CMASI_KEEPINZONE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/AbstractZone.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isKeepInZone(avtas::lmcp::Object* obj);
+   bool isKeepInZone(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > KeepInZoneDescendants();
+   
+   class KeepInZone : public afrl::cmasi::AbstractZone {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      KeepInZone(void);
+
+      // Copy Constructor
+      KeepInZone(const KeepInZone &that);
+
+      // Assignment Operator
+      KeepInZone & operator=(const KeepInZone &that);
+
+      // Destructor
+      virtual ~KeepInZone(void);
+
+      // Equals overload
+      bool operator==(const KeepInZone & that);
+      bool operator!=(const KeepInZone & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual KeepInZone* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 29; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+
+
+   protected:
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_KEEPINZONE_H_
diff --git a/src/LMCP/afrl/cmasi/KeepInZoneDescendants.h b/src/LMCP/afrl/cmasi/KeepInZoneDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/KeepInZoneDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/KeepOutZone.h b/src/LMCP/afrl/cmasi/KeepOutZone.h
new file mode 100644
index 0000000..4a9dd7d
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/KeepOutZone.h
@@ -0,0 +1,115 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_KEEPOUTZONE_H_
+#define _AFRL_CMASI_KEEPOUTZONE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/AbstractZone.h"
+#include "afrl/cmasi/ZoneAvoidanceType.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isKeepOutZone(avtas::lmcp::Object* obj);
+   bool isKeepOutZone(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > KeepOutZoneDescendants();
+   
+   class KeepOutZone : public afrl::cmasi::AbstractZone {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      KeepOutZone(void);
+
+      // Copy Constructor
+      KeepOutZone(const KeepOutZone &that);
+
+      // Assignment Operator
+      KeepOutZone & operator=(const KeepOutZone &that);
+
+      // Destructor
+      virtual ~KeepOutZone(void);
+
+      // Equals overload
+      bool operator==(const KeepOutZone & that);
+      bool operator!=(const KeepOutZone & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual KeepOutZone* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 30; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The type of zone 
+      *<br/> Physical (physical boundary such as terrain or buildings) 
+      *<br/> Regulatory (fire control, flight corridor) 
+      *<br/> Acoustic Defines an area for acoustical avoidance 
+      *<br/> Threat Defines an area where a threat is present. (Units: None)*/
+      afrl::cmasi::ZoneAvoidanceType::ZoneAvoidanceType getZoneType(void) const { return __ZoneType; }
+      KeepOutZone& setZoneType(const afrl::cmasi::ZoneAvoidanceType::ZoneAvoidanceType val);
+
+
+
+   protected:
+      /** The type of zone 
+      *<br/> Physical (physical boundary such as terrain or buildings) 
+      *<br/> Regulatory (fire control, flight corridor) 
+      *<br/> Acoustic Defines an area for acoustical avoidance 
+      *<br/> Threat Defines an area where a threat is present. */
+      afrl::cmasi::ZoneAvoidanceType::ZoneAvoidanceType __ZoneType;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_KEEPOUTZONE_H_
diff --git a/src/LMCP/afrl/cmasi/KeepOutZoneDescendants.h b/src/LMCP/afrl/cmasi/KeepOutZoneDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/KeepOutZoneDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/KeyValuePair.h b/src/LMCP/afrl/cmasi/KeyValuePair.h
new file mode 100644
index 0000000..8a5adc8
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/KeyValuePair.h
@@ -0,0 +1,112 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_KEYVALUEPAIR_H_
+#define _AFRL_CMASI_KEYVALUEPAIR_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isKeyValuePair(avtas::lmcp::Object* obj);
+   bool isKeyValuePair(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > KeyValuePairDescendants();
+   
+   class KeyValuePair : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      KeyValuePair(void);
+
+      // Copy Constructor
+      KeyValuePair(const KeyValuePair &that);
+
+      // Assignment Operator
+      KeyValuePair & operator=(const KeyValuePair &that);
+
+      // Destructor
+      virtual ~KeyValuePair(void);
+
+      // Equals overload
+      bool operator==(const KeyValuePair & that);
+      bool operator!=(const KeyValuePair & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual KeyValuePair* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 2; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** A key (name) for the property (Units: None)*/
+      std::string getKey(void) const { return __Key; }
+      KeyValuePair& setKey(const std::string val);
+
+      /** A value for the property (Units: None)*/
+      std::string getValue(void) const { return __Value; }
+      KeyValuePair& setValue(const std::string val);
+
+
+
+   protected:
+      /** A key (name) for the property */
+      std::string __Key;
+      /** A value for the property */
+      std::string __Value;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_KEYVALUEPAIR_H_
diff --git a/src/LMCP/afrl/cmasi/KeyValuePairDescendants.h b/src/LMCP/afrl/cmasi/KeyValuePairDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/KeyValuePairDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/LineSearchTask.h b/src/LMCP/afrl/cmasi/LineSearchTask.h
new file mode 100644
index 0000000..14da3ca
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/LineSearchTask.h
@@ -0,0 +1,119 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_LINESEARCHTASK_H_
+#define _AFRL_CMASI_LINESEARCHTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/Location3D.h"
+#include "afrl/cmasi/Wedge.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isLineSearchTask(avtas::lmcp::Object* obj);
+   bool isLineSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > LineSearchTaskDescendants();
+   
+   class LineSearchTask : public afrl::cmasi::SearchTask {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      LineSearchTask(void);
+
+      // Copy Constructor
+      LineSearchTask(const LineSearchTask &that);
+
+      // Assignment Operator
+      LineSearchTask & operator=(const LineSearchTask &that);
+
+      // Destructor
+      virtual ~LineSearchTask(void);
+
+      // Equals overload
+      bool operator==(const LineSearchTask & that);
+      bool operator!=(const LineSearchTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual LineSearchTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 31; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Line to search (Units: None)*/
+      std::vector<afrl::cmasi::Location3D*> & getPointList(void) { return __PointList; }
+
+      /** Defines a list of acceptable look-angles for this task. See the documentation above for details. (Units: None)*/
+      std::vector<afrl::cmasi::Wedge*> & getViewAngleList(void) { return __ViewAngleList; }
+
+      /** If true, the ViewAngleList specifies inertial (North-East) angles. See documentation above. (Units: None)*/
+      bool getUseInertialViewAngles(void) const { return __UseInertialViewAngles; }
+      LineSearchTask& setUseInertialViewAngles(const bool val);
+
+
+
+   protected:
+      /** Line to search */
+      std::vector< afrl::cmasi::Location3D* > __PointList;
+      /** Defines a list of acceptable look-angles for this task. See the documentation above for details. */
+      std::vector< afrl::cmasi::Wedge* > __ViewAngleList;
+      /** If true, the ViewAngleList specifies inertial (North-East) angles. See documentation above. */
+      bool __UseInertialViewAngles;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_LINESEARCHTASK_H_
diff --git a/src/LMCP/afrl/cmasi/LineSearchTaskDescendants.h b/src/LMCP/afrl/cmasi/LineSearchTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/LineSearchTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/Location3D.h b/src/LMCP/afrl/cmasi/Location3D.h
new file mode 100644
index 0000000..8d51c60
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/Location3D.h
@@ -0,0 +1,125 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_LOCATION3D_H_
+#define _AFRL_CMASI_LOCATION3D_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AltitudeType.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isLocation3D(avtas::lmcp::Object* obj);
+   bool isLocation3D(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > Location3DDescendants();
+   
+   class Location3D : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      Location3D(void);
+
+      // Copy Constructor
+      Location3D(const Location3D &that);
+
+      // Assignment Operator
+      Location3D & operator=(const Location3D &that);
+
+      // Destructor
+      virtual ~Location3D(void);
+
+      // Equals overload
+      bool operator==(const Location3D & that);
+      bool operator!=(const Location3D & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual Location3D* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 3; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Latitude (Units: degree)*/
+      double getLatitude(void) const { return __Latitude; }
+      Location3D& setLatitude(const double val);
+
+      /** Longitude (Units: degree)*/
+      double getLongitude(void) const { return __Longitude; }
+      Location3D& setLongitude(const double val);
+
+      /** Altitude for this waypoint (Units: meter)*/
+      float getAltitude(void) const { return __Altitude; }
+      Location3D& setAltitude(const float val);
+
+      /** Altitude type for specified altitude (Units: None)*/
+      afrl::cmasi::AltitudeType::AltitudeType getAltitudeType(void) const { return __AltitudeType; }
+      Location3D& setAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val);
+
+
+
+   protected:
+      /** Latitude */
+      double __Latitude;
+      /** Longitude */
+      double __Longitude;
+      /** Altitude for this waypoint */
+      float __Altitude;
+      /** Altitude type for specified altitude */
+      afrl::cmasi::AltitudeType::AltitudeType __AltitudeType;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_LOCATION3D_H_
diff --git a/src/LMCP/afrl/cmasi/Location3DDescendants.h b/src/LMCP/afrl/cmasi/Location3DDescendants.h
new file mode 100644
index 0000000..d411dc7
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/Location3DDescendants.h
@@ -0,0 +1,14 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
diff --git a/src/LMCP/afrl/cmasi/LoiterAction.h b/src/LMCP/afrl/cmasi/LoiterAction.h
new file mode 100644
index 0000000..c13ac6d
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/LoiterAction.h
@@ -0,0 +1,151 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_LOITERACTION_H_
+#define _AFRL_CMASI_LOITERACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/NavigationAction.h"
+#include "afrl/cmasi/LoiterType.h"
+#include "afrl/cmasi/LoiterDirection.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isLoiterAction(avtas::lmcp::Object* obj);
+   bool isLoiterAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > LoiterActionDescendants();
+   
+   class LoiterAction : public afrl::cmasi::NavigationAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      LoiterAction(void);
+
+      // Copy Constructor
+      LoiterAction(const LoiterAction &that);
+
+      // Assignment Operator
+      LoiterAction & operator=(const LoiterAction &that);
+
+      // Destructor
+      virtual ~LoiterAction(void);
+
+      // Equals overload
+      bool operator==(const LoiterAction & that);
+      bool operator!=(const LoiterAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual LoiterAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 33; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The loiter shape that the vehicle should fly (Units: none)*/
+      afrl::cmasi::LoiterType::LoiterType getLoiterType(void) const { return __LoiterType; }
+      LoiterAction& setLoiterType(const afrl::cmasi::LoiterType::LoiterType val);
+
+      /** The radius for the loiter. May be used for any curvature parameter of the vehicle specific hold pattern. (Units: meter)*/
+      float getRadius(void) const { return __Radius; }
+      LoiterAction& setRadius(const float val);
+
+      /** Direction of the major axis of the vehicle specific hold pattern. For Racetracks and Figure-Eights, this is the direction of the long axis. Hovering loiters, this is direction the aircraft should face in the loiter. (Units: degree)*/
+      float getAxis(void) const { return __Axis; }
+      LoiterAction& setAxis(const float val);
+
+      /** Used in racetrack and figure-eight loiters. For figure-eight loiters, this is the length between the focii of the turn circles. For racetracks, this is the length of the straight-away. Both types have a total length of Length + 2 * Radius. For figure-eight loiters, if Length is less than 2 * radius, then this field is ignored. (Units: meter)*/
+      float getLength(void) const { return __Length; }
+      LoiterAction& setLength(const float val);
+
+      /** Direction of travel. (Units: None)*/
+      afrl::cmasi::LoiterDirection::LoiterDirection getDirection(void) const { return __Direction; }
+      LoiterAction& setDirection(const afrl::cmasi::LoiterDirection::LoiterDirection val);
+
+      /** The time to loiter at this point before continuing. A negative time value denotes perpetual orbit. (Units: milliseconds)*/
+      int64_t getDuration(void) const { return __Duration; }
+      LoiterAction& setDuration(const int64_t val);
+
+      /** Commanded True Airspeed (Units: meter/sec)*/
+      float getAirspeed(void) const { return __Airspeed; }
+      LoiterAction& setAirspeed(const float val);
+
+      /** The geometric center point of the loiter. (Units: None)*/
+      afrl::cmasi::Location3D* const getLocation(void) { return __Location; }
+      LoiterAction& setLocation(const afrl::cmasi::Location3D* const val);
+
+
+
+   protected:
+      /** The loiter shape that the vehicle should fly */
+      afrl::cmasi::LoiterType::LoiterType __LoiterType;
+      /** The radius for the loiter. May be used for any curvature parameter of the vehicle specific hold pattern. */
+      float __Radius;
+      /** Direction of the major axis of the vehicle specific hold pattern. For Racetracks and Figure-Eights, this is the direction of the long axis. Hovering loiters, this is direction the aircraft should face in the loiter. */
+      float __Axis;
+      /** Used in racetrack and figure-eight loiters. For figure-eight loiters, this is the length between the focii of the turn circles. For racetracks, this is the length of the straight-away. Both types have a total length of Length + 2 * Radius. For figure-eight loiters, if Length is less than 2 * radius, then this field is ignored. */
+      float __Length;
+      /** Direction of travel. */
+      afrl::cmasi::LoiterDirection::LoiterDirection __Direction;
+      /** The time to loiter at this point before continuing. A negative time value denotes perpetual orbit. */
+      int64_t __Duration;
+      /** Commanded True Airspeed */
+      float __Airspeed;
+      /** The geometric center point of the loiter. */
+      afrl::cmasi::Location3D* __Location;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_LOITERACTION_H_
diff --git a/src/LMCP/afrl/cmasi/LoiterActionDescendants.h b/src/LMCP/afrl/cmasi/LoiterActionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/LoiterActionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/LoiterDirection.h b/src/LMCP/afrl/cmasi/LoiterDirection.h
new file mode 100644
index 0000000..d7a1d41
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/LoiterDirection.h
@@ -0,0 +1,60 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_LOITERDIRECTION_H_
+#define _AFRL_CMASI_LOITERDIRECTION_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace LoiterDirection {
+   enum LoiterDirection {
+       /**  vehicle default  */
+       VehicleDefault = 0,
+       /**  counter-clockwise  */
+       CounterClockwise = 1,
+       /**  clockwise  */
+       Clockwise = 2
+
+   };
+
+   // generates a new LoiterDirection value for the passed string
+   inline LoiterDirection get_LoiterDirection(std::string str) {
+       if ( str == "VehicleDefault") return VehicleDefault;
+       if ( str == "CounterClockwise") return CounterClockwise;
+       if ( str == "Clockwise") return Clockwise;
+        return VehicleDefault;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(LoiterDirection e) {
+       switch(e) {
+        case VehicleDefault: return "VehicleDefault";
+        case CounterClockwise: return "CounterClockwise";
+        case Clockwise: return "Clockwise";
+        default: return "VehicleDefault";
+
+       }
+   }
+
+   }  // namespace LoiterDirection
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_LOITERDIRECTION_H_
diff --git a/src/LMCP/afrl/cmasi/LoiterTask.h b/src/LMCP/afrl/cmasi/LoiterTask.h
new file mode 100644
index 0000000..c6e4897
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/LoiterTask.h
@@ -0,0 +1,107 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_LOITERTASK_H_
+#define _AFRL_CMASI_LOITERTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/Task.h"
+#include "afrl/cmasi/LoiterAction.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isLoiterTask(avtas::lmcp::Object* obj);
+   bool isLoiterTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > LoiterTaskDescendants();
+   
+   class LoiterTask : public afrl::cmasi::Task {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      LoiterTask(void);
+
+      // Copy Constructor
+      LoiterTask(const LoiterTask &that);
+
+      // Assignment Operator
+      LoiterTask & operator=(const LoiterTask &that);
+
+      // Destructor
+      virtual ~LoiterTask(void);
+
+      // Equals overload
+      bool operator==(const LoiterTask & that);
+      bool operator!=(const LoiterTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual LoiterTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 34; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The desired loiter action to take (Units: none)*/
+      afrl::cmasi::LoiterAction* const getDesiredAction(void) { return __DesiredAction; }
+      LoiterTask& setDesiredAction(const afrl::cmasi::LoiterAction* const val);
+
+
+
+   protected:
+      /** The desired loiter action to take */
+      afrl::cmasi::LoiterAction* __DesiredAction;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_LOITERTASK_H_
diff --git a/src/LMCP/afrl/cmasi/LoiterTaskDescendants.h b/src/LMCP/afrl/cmasi/LoiterTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/LoiterTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/LoiterType.h b/src/LMCP/afrl/cmasi/LoiterType.h
new file mode 100644
index 0000000..17e3fec
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/LoiterType.h
@@ -0,0 +1,68 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_LOITERTYPE_H_
+#define _AFRL_CMASI_LOITERTYPE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace LoiterType {
+   enum LoiterType {
+       /**  vehicle default  */
+       VehicleDefault = 0,
+       /**  circular  */
+       Circular = 1,
+       /**  racetrack  */
+       Racetrack = 2,
+       /**  figure eight */
+       FigureEight = 3,
+       /**  Hovering. */
+       Hover = 4
+
+   };
+
+   // generates a new LoiterType value for the passed string
+   inline LoiterType get_LoiterType(std::string str) {
+       if ( str == "VehicleDefault") return VehicleDefault;
+       if ( str == "Circular") return Circular;
+       if ( str == "Racetrack") return Racetrack;
+       if ( str == "FigureEight") return FigureEight;
+       if ( str == "Hover") return Hover;
+        return VehicleDefault;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(LoiterType e) {
+       switch(e) {
+        case VehicleDefault: return "VehicleDefault";
+        case Circular: return "Circular";
+        case Racetrack: return "Racetrack";
+        case FigureEight: return "FigureEight";
+        case Hover: return "Hover";
+        default: return "VehicleDefault";
+
+       }
+   }
+
+   }  // namespace LoiterType
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_LOITERTYPE_H_
diff --git a/src/LMCP/afrl/cmasi/MissionCommand.h b/src/LMCP/afrl/cmasi/MissionCommand.h
new file mode 100644
index 0000000..2e4e7ee
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/MissionCommand.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_MISSIONCOMMAND_H_
+#define _AFRL_CMASI_MISSIONCOMMAND_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/VehicleActionCommand.h"
+#include "afrl/cmasi/Waypoint.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isMissionCommand(avtas::lmcp::Object* obj);
+   bool isMissionCommand(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > MissionCommandDescendants();
+   
+   class MissionCommand : public afrl::cmasi::VehicleActionCommand {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      MissionCommand(void);
+
+      // Copy Constructor
+      MissionCommand(const MissionCommand &that);
+
+      // Assignment Operator
+      MissionCommand & operator=(const MissionCommand &that);
+
+      // Destructor
+      virtual ~MissionCommand(void);
+
+      // Equals overload
+      bool operator==(const MissionCommand & that);
+      bool operator!=(const MissionCommand & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual MissionCommand* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 36; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The list of waypoints associated with this mission task. Waypoints are linked, but the waypoint list may contain waypoints that are not necessarily linked. Multiple linked routes may be sent in a single waypoint list. Waypoints are not necessarily ordered in the list. (Units: None)*/
+      std::vector<afrl::cmasi::Waypoint*> & getWaypointList(void) { return __WaypointList; }
+
+      /** ID of the first waypoint to follow. (Units: None)*/
+      int64_t getFirstWaypoint(void) const { return __FirstWaypoint; }
+      MissionCommand& setFirstWaypoint(const int64_t val);
+
+
+
+   protected:
+      /** The list of waypoints associated with this mission task. Waypoints are linked, but the waypoint list may contain waypoints that are not necessarily linked. Multiple linked routes may be sent in a single waypoint list. Waypoints are not necessarily ordered in the list. */
+      std::vector< afrl::cmasi::Waypoint* > __WaypointList;
+      /** ID of the first waypoint to follow. */
+      int64_t __FirstWaypoint;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_MISSIONCOMMAND_H_
diff --git a/src/LMCP/afrl/cmasi/MissionCommandDescendants.h b/src/LMCP/afrl/cmasi/MissionCommandDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/MissionCommandDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/MustFlyTask.h b/src/LMCP/afrl/cmasi/MustFlyTask.h
new file mode 100644
index 0000000..af00842
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/MustFlyTask.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_MUSTFLYTASK_H_
+#define _AFRL_CMASI_MUSTFLYTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/Task.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isMustFlyTask(avtas::lmcp::Object* obj);
+   bool isMustFlyTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > MustFlyTaskDescendants();
+   
+   class MustFlyTask : public afrl::cmasi::Task {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      MustFlyTask(void);
+
+      // Copy Constructor
+      MustFlyTask(const MustFlyTask &that);
+
+      // Assignment Operator
+      MustFlyTask & operator=(const MustFlyTask &that);
+
+      // Destructor
+      virtual ~MustFlyTask(void);
+
+      // Equals overload
+      bool operator==(const MustFlyTask & that);
+      bool operator!=(const MustFlyTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual MustFlyTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 37; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** point that must vehicle must fly through (Units: None)*/
+      afrl::cmasi::Location3D* const getPosition(void) { return __Position; }
+      MustFlyTask& setPosition(const afrl::cmasi::Location3D* const val);
+
+      /** Denotes whether altitude should be used in this MustFlyTask. If false, the aircraft should maintain altitude according to previous commands. (Units: None)*/
+      bool getUseAltitude(void) const { return __UseAltitude; }
+      MustFlyTask& setUseAltitude(const bool val);
+
+
+
+   protected:
+      /** point that must vehicle must fly through */
+      afrl::cmasi::Location3D* __Position;
+      /** Denotes whether altitude should be used in this MustFlyTask. If false, the aircraft should maintain altitude according to previous commands. */
+      bool __UseAltitude;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_MUSTFLYTASK_H_
diff --git a/src/LMCP/afrl/cmasi/MustFlyTaskDescendants.h b/src/LMCP/afrl/cmasi/MustFlyTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/MustFlyTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/NavigationAction.h b/src/LMCP/afrl/cmasi/NavigationAction.h
new file mode 100644
index 0000000..1ebe5a7
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/NavigationAction.h
@@ -0,0 +1,100 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_NAVIGATIONACTION_H_
+#define _AFRL_CMASI_NAVIGATIONACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/VehicleAction.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isNavigationAction(avtas::lmcp::Object* obj);
+   bool isNavigationAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > NavigationActionDescendants();
+   
+   class NavigationAction : public afrl::cmasi::VehicleAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      NavigationAction(void);
+
+      // Copy Constructor
+      NavigationAction(const NavigationAction &that);
+
+      // Assignment Operator
+      NavigationAction & operator=(const NavigationAction &that);
+
+      // Destructor
+      virtual ~NavigationAction(void);
+
+      // Equals overload
+      bool operator==(const NavigationAction & that);
+      bool operator!=(const NavigationAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual NavigationAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 32; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+
+
+   protected:
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_NAVIGATIONACTION_H_
diff --git a/src/LMCP/afrl/cmasi/NavigationActionDescendants.h b/src/LMCP/afrl/cmasi/NavigationActionDescendants.h
new file mode 100644
index 0000000..282b137
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/NavigationActionDescendants.h
@@ -0,0 +1,15 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/GoToWaypointAction.h"
+#include "afrl/cmasi/LoiterAction.h"
+#include "afrl/cmasi/FlightDirectorAction.h"
+
diff --git a/src/LMCP/afrl/cmasi/NavigationMode.h b/src/LMCP/afrl/cmasi/NavigationMode.h
new file mode 100644
index 0000000..e326918
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/NavigationMode.h
@@ -0,0 +1,72 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_NAVIGATIONMODE_H_
+#define _AFRL_CMASI_NAVIGATIONMODE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace NavigationMode {
+   enum NavigationMode {
+       /**  standard waypoint following mode  */
+       Waypoint = 0,
+       /**  loiter mode, vehicle in constant orbit  */
+       Loiter = 1,
+       /**  flight director, vehicle following specific heading and spedd commands without regard to waypoints  */
+       FlightDirector = 2,
+       /**  track target, vehicle adjusts path to maintain current target track  */
+       TargetTrack = 3,
+       /**  follow leader, vehicle path is maintained to remain in formation with a leader  */
+       FollowLeader = 4,
+       /**  lost comm, vehicle is out of comm range and should be executing lost-comm behavior  */
+       LostComm = 5
+
+   };
+
+   // generates a new NavigationMode value for the passed string
+   inline NavigationMode get_NavigationMode(std::string str) {
+       if ( str == "Waypoint") return Waypoint;
+       if ( str == "Loiter") return Loiter;
+       if ( str == "FlightDirector") return FlightDirector;
+       if ( str == "TargetTrack") return TargetTrack;
+       if ( str == "FollowLeader") return FollowLeader;
+       if ( str == "LostComm") return LostComm;
+        return Waypoint;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(NavigationMode e) {
+       switch(e) {
+        case Waypoint: return "Waypoint";
+        case Loiter: return "Loiter";
+        case FlightDirector: return "FlightDirector";
+        case TargetTrack: return "TargetTrack";
+        case FollowLeader: return "FollowLeader";
+        case LostComm: return "LostComm";
+        default: return "Waypoint";
+
+       }
+   }
+
+   }  // namespace NavigationMode
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_NAVIGATIONMODE_H_
diff --git a/src/LMCP/afrl/cmasi/OperatingRegion.h b/src/LMCP/afrl/cmasi/OperatingRegion.h
new file mode 100644
index 0000000..91c4672
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/OperatingRegion.h
@@ -0,0 +1,117 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_OPERATINGREGION_H_
+#define _AFRL_CMASI_OPERATINGREGION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isOperatingRegion(avtas::lmcp::Object* obj);
+   bool isOperatingRegion(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > OperatingRegionDescendants();
+   
+   class OperatingRegion : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      OperatingRegion(void);
+
+      // Copy Constructor
+      OperatingRegion(const OperatingRegion &that);
+
+      // Assignment Operator
+      OperatingRegion & operator=(const OperatingRegion &that);
+
+      // Destructor
+      virtual ~OperatingRegion(void);
+
+      // Equals overload
+      bool operator==(const OperatingRegion & that);
+      bool operator!=(const OperatingRegion & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual OperatingRegion* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 39; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Operating region ID (Units: None)*/
+      int64_t getID(void) const { return __ID; }
+      OperatingRegion& setID(const int64_t val);
+
+      /** Abstract Zone IDs in which the entity must remain during operation (Units: None)*/
+      std::vector<int64_t> & getKeepInAreas(void) { return __KeepInAreas; }
+
+      /** Keep Out Zone IDs that an entity must remain out of during operation (Units: None)*/
+      std::vector<int64_t> & getKeepOutAreas(void) { return __KeepOutAreas; }
+
+
+
+   protected:
+      /** Operating region ID */
+      int64_t __ID;
+      /** Abstract Zone IDs in which the entity must remain during operation */
+      std::vector< int64_t > __KeepInAreas;
+      /** Keep Out Zone IDs that an entity must remain out of during operation */
+      std::vector< int64_t > __KeepOutAreas;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_OPERATINGREGION_H_
diff --git a/src/LMCP/afrl/cmasi/OperatingRegionDescendants.h b/src/LMCP/afrl/cmasi/OperatingRegionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/OperatingRegionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/OperatorSignal.h b/src/LMCP/afrl/cmasi/OperatorSignal.h
new file mode 100644
index 0000000..860bf44
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/OperatorSignal.h
@@ -0,0 +1,107 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_OPERATORSIGNAL_H_
+#define _AFRL_CMASI_OPERATORSIGNAL_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/KeyValuePair.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isOperatorSignal(avtas::lmcp::Object* obj);
+   bool isOperatorSignal(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > OperatorSignalDescendants();
+   
+   class OperatorSignal : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      OperatorSignal(void);
+
+      // Copy Constructor
+      OperatorSignal(const OperatorSignal &that);
+
+      // Assignment Operator
+      OperatorSignal & operator=(const OperatorSignal &that);
+
+      // Destructor
+      virtual ~OperatorSignal(void);
+
+      // Equals overload
+      bool operator==(const OperatorSignal & that);
+      bool operator!=(const OperatorSignal & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual OperatorSignal* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 38; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Content of signal (e.g. button clicked) (Units: None)*/
+      std::vector<afrl::cmasi::KeyValuePair*> & getSignals(void) { return __Signals; }
+
+
+
+   protected:
+      /** Content of signal (e.g. button clicked) */
+      std::vector< afrl::cmasi::KeyValuePair* > __Signals;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_OPERATORSIGNAL_H_
diff --git a/src/LMCP/afrl/cmasi/OperatorSignalDescendants.h b/src/LMCP/afrl/cmasi/OperatorSignalDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/OperatorSignalDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/PathWaypoint.h b/src/LMCP/afrl/cmasi/PathWaypoint.h
new file mode 100644
index 0000000..7ff1407
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PathWaypoint.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_PATHWAYPOINT_H_
+#define _AFRL_CMASI_PATHWAYPOINT_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/Waypoint.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isPathWaypoint(avtas::lmcp::Object* obj);
+   bool isPathWaypoint(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > PathWaypointDescendants();
+   
+   class PathWaypoint : public afrl::cmasi::Waypoint {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      PathWaypoint(void);
+
+      // Copy Constructor
+      PathWaypoint(const PathWaypoint &that);
+
+      // Assignment Operator
+      PathWaypoint & operator=(const PathWaypoint &that);
+
+      // Destructor
+      virtual ~PathWaypoint(void);
+
+      // Equals overload
+      bool operator==(const PathWaypoint & that);
+      bool operator!=(const PathWaypoint & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual PathWaypoint* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 57; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The amount of time that an entity should pause before moving to the next waypoint. (Units: milliseconds)*/
+      int64_t getPauseTime(void) const { return __PauseTime; }
+      PathWaypoint& setPauseTime(const int64_t val);
+
+
+
+   protected:
+      /** The amount of time that an entity should pause before moving to the next waypoint. */
+      int64_t __PauseTime;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_PATHWAYPOINT_H_
diff --git a/src/LMCP/afrl/cmasi/PathWaypointDescendants.h b/src/LMCP/afrl/cmasi/PathWaypointDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PathWaypointDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/PayloadAction.h b/src/LMCP/afrl/cmasi/PayloadAction.h
new file mode 100644
index 0000000..6af5805
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PayloadAction.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_PAYLOADACTION_H_
+#define _AFRL_CMASI_PAYLOADACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/VehicleAction.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isPayloadAction(avtas::lmcp::Object* obj);
+   bool isPayloadAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > PayloadActionDescendants();
+   
+   class PayloadAction : public afrl::cmasi::VehicleAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      PayloadAction(void);
+
+      // Copy Constructor
+      PayloadAction(const PayloadAction &that);
+
+      // Assignment Operator
+      PayloadAction & operator=(const PayloadAction &that);
+
+      // Destructor
+      virtual ~PayloadAction(void);
+
+      // Equals overload
+      bool operator==(const PayloadAction & that);
+      bool operator!=(const PayloadAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual PayloadAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 4; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** A unique id for this payload item. (Units: None)*/
+      int64_t getPayloadID(void) const { return __PayloadID; }
+      PayloadAction& setPayloadID(const int64_t val);
+
+
+
+   protected:
+      /** A unique id for this payload item. */
+      int64_t __PayloadID;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_PAYLOADACTION_H_
diff --git a/src/LMCP/afrl/cmasi/PayloadActionDescendants.h b/src/LMCP/afrl/cmasi/PayloadActionDescendants.h
new file mode 100644
index 0000000..d08e31c
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PayloadActionDescendants.h
@@ -0,0 +1,16 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/CameraAction.h"
+#include "afrl/cmasi/GimbalAngleAction.h"
+#include "afrl/cmasi/GimbalScanAction.h"
+#include "afrl/cmasi/GimbalStareAction.h"
+
diff --git a/src/LMCP/afrl/cmasi/PayloadConfiguration.h b/src/LMCP/afrl/cmasi/PayloadConfiguration.h
new file mode 100644
index 0000000..812bf6d
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PayloadConfiguration.h
@@ -0,0 +1,119 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_PAYLOADCONFIGURATION_H_
+#define _AFRL_CMASI_PAYLOADCONFIGURATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/KeyValuePair.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isPayloadConfiguration(avtas::lmcp::Object* obj);
+   bool isPayloadConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > PayloadConfigurationDescendants();
+   
+   class PayloadConfiguration : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      PayloadConfiguration(void);
+
+      // Copy Constructor
+      PayloadConfiguration(const PayloadConfiguration &that);
+
+      // Assignment Operator
+      PayloadConfiguration & operator=(const PayloadConfiguration &that);
+
+      // Destructor
+      virtual ~PayloadConfiguration(void);
+
+      // Equals overload
+      bool operator==(const PayloadConfiguration & that);
+      bool operator!=(const PayloadConfiguration & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual PayloadConfiguration* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 5; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The unique id for this payload item. (Units: None)*/
+      int64_t getPayloadID(void) const { return __PayloadID; }
+      PayloadConfiguration& setPayloadID(const int64_t val);
+
+      /** A string uniquely identifying the kind of payload item (primarily to be used for debugging purposes). (Units: None)*/
+      std::string getPayloadKind(void) const { return __PayloadKind; }
+      PayloadConfiguration& setPayloadKind(const std::string val);
+
+      /** Optional parameters associated with payload configuration (Units: None)*/
+      std::vector<afrl::cmasi::KeyValuePair*> & getParameters(void) { return __Parameters; }
+
+
+
+   protected:
+      /** The unique id for this payload item. */
+      int64_t __PayloadID;
+      /** A string uniquely identifying the kind of payload item (primarily to be used for debugging purposes). */
+      std::string __PayloadKind;
+      /** Optional parameters associated with payload configuration */
+      std::vector< afrl::cmasi::KeyValuePair* > __Parameters;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_PAYLOADCONFIGURATION_H_
diff --git a/src/LMCP/afrl/cmasi/PayloadConfigurationDescendants.h b/src/LMCP/afrl/cmasi/PayloadConfigurationDescendants.h
new file mode 100644
index 0000000..741a364
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PayloadConfigurationDescendants.h
@@ -0,0 +1,18 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/CameraConfiguration.h"
+#include "afrl/cmasi/GimbalConfiguration.h"
+#include "afrl/cmasi/VideoStreamConfiguration.h"
+#include "afrl/impact/PowerConfiguration.h"
+#include "afrl/impact/RadioConfiguration.h"
+#include "afrl/impact/ImpactPayloadConfiguration.h"
+
diff --git a/src/LMCP/afrl/cmasi/PayloadState.h b/src/LMCP/afrl/cmasi/PayloadState.h
new file mode 100644
index 0000000..5f88a04
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PayloadState.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_PAYLOADSTATE_H_
+#define _AFRL_CMASI_PAYLOADSTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/KeyValuePair.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isPayloadState(avtas::lmcp::Object* obj);
+   bool isPayloadState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > PayloadStateDescendants();
+   
+   class PayloadState : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      PayloadState(void);
+
+      // Copy Constructor
+      PayloadState(const PayloadState &that);
+
+      // Assignment Operator
+      PayloadState & operator=(const PayloadState &that);
+
+      // Destructor
+      virtual ~PayloadState(void);
+
+      // Equals overload
+      bool operator==(const PayloadState & that);
+      bool operator!=(const PayloadState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual PayloadState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 6; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The unique id for this payload item. (Units: None)*/
+      int64_t getPayloadID(void) const { return __PayloadID; }
+      PayloadState& setPayloadID(const int64_t val);
+
+      /** Optional parameters associated with payload state (Units: None)*/
+      std::vector<afrl::cmasi::KeyValuePair*> & getParameters(void) { return __Parameters; }
+
+
+
+   protected:
+      /** The unique id for this payload item. */
+      int64_t __PayloadID;
+      /** Optional parameters associated with payload state */
+      std::vector< afrl::cmasi::KeyValuePair* > __Parameters;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_PAYLOADSTATE_H_
diff --git a/src/LMCP/afrl/cmasi/PayloadStateDescendants.h b/src/LMCP/afrl/cmasi/PayloadStateDescendants.h
new file mode 100644
index 0000000..648b769
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PayloadStateDescendants.h
@@ -0,0 +1,18 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/GimballedPayloadState.h"
+#include "afrl/cmasi/CameraState.h"
+#include "afrl/cmasi/GimbalState.h"
+#include "afrl/cmasi/VideoStreamState.h"
+#include "afrl/impact/RadioState.h"
+#include "afrl/impact/PowerPlantState.h"
+
diff --git a/src/LMCP/afrl/cmasi/PayloadStowAction.h b/src/LMCP/afrl/cmasi/PayloadStowAction.h
new file mode 100644
index 0000000..911afec
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PayloadStowAction.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_PAYLOADSTOWACTION_H_
+#define _AFRL_CMASI_PAYLOADSTOWACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isPayloadStowAction(avtas::lmcp::Object* obj);
+   bool isPayloadStowAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > PayloadStowActionDescendants();
+   
+   class PayloadStowAction : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      PayloadStowAction(void);
+
+      // Copy Constructor
+      PayloadStowAction(const PayloadStowAction &that);
+
+      // Assignment Operator
+      PayloadStowAction & operator=(const PayloadStowAction &that);
+
+      // Destructor
+      virtual ~PayloadStowAction(void);
+
+      // Equals overload
+      bool operator==(const PayloadStowAction & that);
+      bool operator!=(const PayloadStowAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual PayloadStowAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 60; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** payload to stow (Units: None)*/
+      int64_t getPayloadID(void) const { return __PayloadID; }
+      PayloadStowAction& setPayloadID(const int64_t val);
+
+
+
+   protected:
+      /** payload to stow */
+      int64_t __PayloadID;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_PAYLOADSTOWACTION_H_
diff --git a/src/LMCP/afrl/cmasi/PayloadStowActionDescendants.h b/src/LMCP/afrl/cmasi/PayloadStowActionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PayloadStowActionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/PointSearchTask.h b/src/LMCP/afrl/cmasi/PointSearchTask.h
new file mode 100644
index 0000000..fbbd08f
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PointSearchTask.h
@@ -0,0 +1,120 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_POINTSEARCHTASK_H_
+#define _AFRL_CMASI_POINTSEARCHTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/Location3D.h"
+#include "afrl/cmasi/Wedge.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isPointSearchTask(avtas::lmcp::Object* obj);
+   bool isPointSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > PointSearchTaskDescendants();
+   
+   class PointSearchTask : public afrl::cmasi::SearchTask {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      PointSearchTask(void);
+
+      // Copy Constructor
+      PointSearchTask(const PointSearchTask &that);
+
+      // Assignment Operator
+      PointSearchTask & operator=(const PointSearchTask &that);
+
+      // Destructor
+      virtual ~PointSearchTask(void);
+
+      // Equals overload
+      bool operator==(const PointSearchTask & that);
+      bool operator!=(const PointSearchTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual PointSearchTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 41; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Point to search (Units: None)*/
+      afrl::cmasi::Location3D* const getSearchLocation(void) { return __SearchLocation; }
+      PointSearchTask& setSearchLocation(const afrl::cmasi::Location3D* const val);
+
+      /**Minimum distance that an aircraft must maintain from the point of interest. (Units: meter)*/
+      float getStandoffDistance(void) const { return __StandoffDistance; }
+      PointSearchTask& setStandoffDistance(const float val);
+
+      /** A list of acceptable look-angles for this task. Each wedge is defined relative to true North. To be a valid look angle, a sensor must be looking from a direction within the bounds of the wedge. (Units: None)*/
+      std::vector<afrl::cmasi::Wedge*> & getViewAngleList(void) { return __ViewAngleList; }
+
+
+
+   protected:
+      /** Point to search */
+      afrl::cmasi::Location3D* __SearchLocation;
+      /**Minimum distance that an aircraft must maintain from the point of interest. */
+      float __StandoffDistance;
+      /** A list of acceptable look-angles for this task. Each wedge is defined relative to true North. To be a valid look angle, a sensor must be looking from a direction within the bounds of the wedge. */
+      std::vector< afrl::cmasi::Wedge* > __ViewAngleList;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_POINTSEARCHTASK_H_
diff --git a/src/LMCP/afrl/cmasi/PointSearchTaskDescendants.h b/src/LMCP/afrl/cmasi/PointSearchTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PointSearchTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/Polygon.h b/src/LMCP/afrl/cmasi/Polygon.h
new file mode 100644
index 0000000..6538109
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/Polygon.h
@@ -0,0 +1,107 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_POLYGON_H_
+#define _AFRL_CMASI_POLYGON_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/AbstractGeometry.h"
+#include "afrl/cmasi/Location3D.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isPolygon(avtas::lmcp::Object* obj);
+   bool isPolygon(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > PolygonDescendants();
+   
+   class Polygon : public afrl::cmasi::AbstractGeometry {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      Polygon(void);
+
+      // Copy Constructor
+      Polygon(const Polygon &that);
+
+      // Assignment Operator
+      Polygon & operator=(const Polygon &that);
+
+      // Destructor
+      virtual ~Polygon(void);
+
+      // Equals overload
+      bool operator==(const Polygon & that);
+      bool operator!=(const Polygon & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual Polygon* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 42; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Boundary points for the polygon (Units: None)*/
+      std::vector<afrl::cmasi::Location3D*> & getBoundaryPoints(void) { return __BoundaryPoints; }
+
+
+
+   protected:
+      /** Boundary points for the polygon */
+      std::vector< afrl::cmasi::Location3D* > __BoundaryPoints;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_POLYGON_H_
diff --git a/src/LMCP/afrl/cmasi/PolygonDescendants.h b/src/LMCP/afrl/cmasi/PolygonDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/PolygonDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/Rectangle.h b/src/LMCP/afrl/cmasi/Rectangle.h
new file mode 100644
index 0000000..6010dba
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/Rectangle.h
@@ -0,0 +1,125 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_RECTANGLE_H_
+#define _AFRL_CMASI_RECTANGLE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/AbstractGeometry.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isRectangle(avtas::lmcp::Object* obj);
+   bool isRectangle(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RectangleDescendants();
+   
+   class Rectangle : public afrl::cmasi::AbstractGeometry {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      Rectangle(void);
+
+      // Copy Constructor
+      Rectangle(const Rectangle &that);
+
+      // Assignment Operator
+      Rectangle & operator=(const Rectangle &that);
+
+      // Destructor
+      virtual ~Rectangle(void);
+
+      // Equals overload
+      bool operator==(const Rectangle & that);
+      bool operator!=(const Rectangle & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual Rectangle* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 43; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Center point of the rectangle. Altitude value is ignored (Units: None)*/
+      afrl::cmasi::Location3D* const getCenterPoint(void) { return __CenterPoint; }
+      Rectangle& setCenterPoint(const afrl::cmasi::Location3D* const val);
+
+      /** Width of the rectangle (Units: meter)*/
+      float getWidth(void) const { return __Width; }
+      Rectangle& setWidth(const float val);
+
+      /** Height of the rectangle (Units: meter)*/
+      float getHeight(void) const { return __Height; }
+      Rectangle& setHeight(const float val);
+
+      /** Rotation of the rectangle around the center point (positive from north axis towards east) (Units: degree)*/
+      float getRotation(void) const { return __Rotation; }
+      Rectangle& setRotation(const float val);
+
+
+
+   protected:
+      /** Center point of the rectangle. Altitude value is ignored */
+      afrl::cmasi::Location3D* __CenterPoint;
+      /** Width of the rectangle */
+      float __Width;
+      /** Height of the rectangle */
+      float __Height;
+      /** Rotation of the rectangle around the center point (positive from north axis towards east) */
+      float __Rotation;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_RECTANGLE_H_
diff --git a/src/LMCP/afrl/cmasi/RectangleDescendants.h b/src/LMCP/afrl/cmasi/RectangleDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/RectangleDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/RemoveEntities.h b/src/LMCP/afrl/cmasi/RemoveEntities.h
new file mode 100644
index 0000000..b383d6c
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/RemoveEntities.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_REMOVEENTITIES_H_
+#define _AFRL_CMASI_REMOVEENTITIES_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isRemoveEntities(avtas::lmcp::Object* obj);
+   bool isRemoveEntities(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RemoveEntitiesDescendants();
+   
+   class RemoveEntities : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RemoveEntities(void);
+
+      // Copy Constructor
+      RemoveEntities(const RemoveEntities &that);
+
+      // Assignment Operator
+      RemoveEntities & operator=(const RemoveEntities &that);
+
+      // Destructor
+      virtual ~RemoveEntities(void);
+
+      // Equals overload
+      bool operator==(const RemoveEntities & that);
+      bool operator!=(const RemoveEntities & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RemoveEntities* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 53; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** List of entities to remove (Units: None)*/
+      std::vector<int64_t> & getEntityList(void) { return __EntityList; }
+
+
+
+   protected:
+      /** List of entities to remove */
+      std::vector< int64_t > __EntityList;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_REMOVEENTITIES_H_
diff --git a/src/LMCP/afrl/cmasi/RemoveEntitiesDescendants.h b/src/LMCP/afrl/cmasi/RemoveEntitiesDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/RemoveEntitiesDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/RemoveTasks.h b/src/LMCP/afrl/cmasi/RemoveTasks.h
new file mode 100644
index 0000000..a369672
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/RemoveTasks.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_REMOVETASKS_H_
+#define _AFRL_CMASI_REMOVETASKS_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isRemoveTasks(avtas::lmcp::Object* obj);
+   bool isRemoveTasks(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RemoveTasksDescendants();
+   
+   class RemoveTasks : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RemoveTasks(void);
+
+      // Copy Constructor
+      RemoveTasks(const RemoveTasks &that);
+
+      // Assignment Operator
+      RemoveTasks & operator=(const RemoveTasks &that);
+
+      // Destructor
+      virtual ~RemoveTasks(void);
+
+      // Equals overload
+      bool operator==(const RemoveTasks & that);
+      bool operator!=(const RemoveTasks & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RemoveTasks* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 44; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /**(Units: None)*/
+      std::vector<int64_t> & getTaskList(void) { return __TaskList; }
+
+
+
+   protected:
+      /***/
+      std::vector< int64_t > __TaskList;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_REMOVETASKS_H_
diff --git a/src/LMCP/afrl/cmasi/RemoveTasksDescendants.h b/src/LMCP/afrl/cmasi/RemoveTasksDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/RemoveTasksDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/RemoveZones.h b/src/LMCP/afrl/cmasi/RemoveZones.h
new file mode 100644
index 0000000..f764865
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/RemoveZones.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_REMOVEZONES_H_
+#define _AFRL_CMASI_REMOVEZONES_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isRemoveZones(avtas::lmcp::Object* obj);
+   bool isRemoveZones(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RemoveZonesDescendants();
+   
+   class RemoveZones : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RemoveZones(void);
+
+      // Copy Constructor
+      RemoveZones(const RemoveZones &that);
+
+      // Assignment Operator
+      RemoveZones & operator=(const RemoveZones &that);
+
+      // Destructor
+      virtual ~RemoveZones(void);
+
+      // Equals overload
+      bool operator==(const RemoveZones & that);
+      bool operator!=(const RemoveZones & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RemoveZones* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 52; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** List of zones to remove (Units: None)*/
+      std::vector<int64_t> & getZoneList(void) { return __ZoneList; }
+
+
+
+   protected:
+      /** List of zones to remove */
+      std::vector< int64_t > __ZoneList;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_REMOVEZONES_H_
diff --git a/src/LMCP/afrl/cmasi/RemoveZonesDescendants.h b/src/LMCP/afrl/cmasi/RemoveZonesDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/RemoveZonesDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/SearchTask.h b/src/LMCP/afrl/cmasi/SearchTask.h
new file mode 100644
index 0000000..13fd462
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/SearchTask.h
@@ -0,0 +1,119 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_SEARCHTASK_H_
+#define _AFRL_CMASI_SEARCHTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/Task.h"
+#include "afrl/cmasi/WavelengthBand.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isSearchTask(avtas::lmcp::Object* obj);
+   bool isSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > SearchTaskDescendants();
+   
+   class SearchTask : public afrl::cmasi::Task {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      SearchTask(void);
+
+      // Copy Constructor
+      SearchTask(const SearchTask &that);
+
+      // Assignment Operator
+      SearchTask & operator=(const SearchTask &that);
+
+      // Destructor
+      virtual ~SearchTask(void);
+
+      // Equals overload
+      bool operator==(const SearchTask & that);
+      bool operator!=(const SearchTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual SearchTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 9; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The wavelength bands that should be used to complete the task. (Units: None)*/
+      std::vector<afrl::cmasi::WavelengthBand::WavelengthBand> & getDesiredWavelengthBands(void) { return __DesiredWavelengthBands; }
+
+      /** Minimum time that a sensor must look at any given point in this search task. (Units: milliseconds)*/
+      int64_t getDwellTime(void) const { return __DwellTime; }
+      SearchTask& setDwellTime(const int64_t val);
+
+      /** Average ground sample distance for locations in search area (Units: meters/pixel)*/
+      float getGroundSampleDistance(void) const { return __GroundSampleDistance; }
+      SearchTask& setGroundSampleDistance(const float val);
+
+
+
+   protected:
+      /** The wavelength bands that should be used to complete the task. */
+      std::vector< afrl::cmasi::WavelengthBand::WavelengthBand > __DesiredWavelengthBands;
+      /** Minimum time that a sensor must look at any given point in this search task. */
+      int64_t __DwellTime;
+      /** Average ground sample distance for locations in search area */
+      float __GroundSampleDistance;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_SEARCHTASK_H_
diff --git a/src/LMCP/afrl/cmasi/SearchTaskDescendants.h b/src/LMCP/afrl/cmasi/SearchTaskDescendants.h
new file mode 100644
index 0000000..d837575
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/SearchTaskDescendants.h
@@ -0,0 +1,22 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/AreaSearchTask.h"
+#include "afrl/cmasi/LineSearchTask.h"
+#include "afrl/cmasi/PointSearchTask.h"
+#include "afrl/impact/ImpactPointSearchTask.h"
+#include "afrl/impact/PatternSearchTask.h"
+#include "afrl/impact/AngledAreaSearchTask.h"
+#include "afrl/impact/ImpactLineSearchTask.h"
+#include "afrl/impact/WatchTask.h"
+#include "afrl/impact/MultiVehicleWatchTask.h"
+#include "afrl/impact/EscortTask.h"
+
diff --git a/src/LMCP/afrl/cmasi/ServiceStatus.h b/src/LMCP/afrl/cmasi/ServiceStatus.h
new file mode 100644
index 0000000..bbd510c
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/ServiceStatus.h
@@ -0,0 +1,128 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_SERVICESTATUS_H_
+#define _AFRL_CMASI_SERVICESTATUS_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/KeyValuePair.h"
+#include "afrl/cmasi/ServiceStatusType.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isServiceStatus(avtas::lmcp::Object* obj);
+   bool isServiceStatus(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > ServiceStatusDescendants();
+   
+   class ServiceStatus : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      ServiceStatus(void);
+
+      // Copy Constructor
+      ServiceStatus(const ServiceStatus &that);
+
+      // Assignment Operator
+      ServiceStatus & operator=(const ServiceStatus &that);
+
+      // Destructor
+      virtual ~ServiceStatus(void);
+
+      // Equals overload
+      bool operator==(const ServiceStatus & that);
+      bool operator!=(const ServiceStatus & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual ServiceStatus* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 45; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The estimated percentage completed for an automation process. (Units: None)*/
+      float getPercentComplete(void) const { return __PercentComplete; }
+      ServiceStatus& setPercentComplete(const float val);
+
+      /** Status from the automation service to the simulation regarding errors or conditions. (Units: None)*/
+      std::vector<afrl::cmasi::KeyValuePair*> & getInfo(void) { return __Info; }
+
+      /** Describes the type of message conveyed. 
+      *<br/> Information. Used to note normal progress updates 
+      *<br/> Warning. Notes non-fatal problem(s) in data or processing 
+      *<br/> Error. Notes fatal problem(s) 
+      *<br/> (Units: None)*/
+      afrl::cmasi::ServiceStatusType::ServiceStatusType getStatusType(void) const { return __StatusType; }
+      ServiceStatus& setStatusType(const afrl::cmasi::ServiceStatusType::ServiceStatusType val);
+
+
+
+   protected:
+      /** The estimated percentage completed for an automation process. */
+      float __PercentComplete;
+      /** Status from the automation service to the simulation regarding errors or conditions. */
+      std::vector< afrl::cmasi::KeyValuePair* > __Info;
+      /** Describes the type of message conveyed. 
+      *<br/> Information. Used to note normal progress updates 
+      *<br/> Warning. Notes non-fatal problem(s) in data or processing 
+      *<br/> Error. Notes fatal problem(s) 
+      *<br/> */
+      afrl::cmasi::ServiceStatusType::ServiceStatusType __StatusType;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_SERVICESTATUS_H_
diff --git a/src/LMCP/afrl/cmasi/ServiceStatusDescendants.h b/src/LMCP/afrl/cmasi/ServiceStatusDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/ServiceStatusDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/ServiceStatusType.h b/src/LMCP/afrl/cmasi/ServiceStatusType.h
new file mode 100644
index 0000000..72d3eba
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/ServiceStatusType.h
@@ -0,0 +1,60 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_SERVICESTATUSTYPE_H_
+#define _AFRL_CMASI_SERVICESTATUSTYPE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace ServiceStatusType {
+   enum ServiceStatusType {
+       /**  informational note from automation service  */
+       Information = 0,
+       /**  warning from automation service  */
+       Warning = 1,
+       /**  error from automation service  */
+       Error = 2
+
+   };
+
+   // generates a new ServiceStatusType value for the passed string
+   inline ServiceStatusType get_ServiceStatusType(std::string str) {
+       if ( str == "Information") return Information;
+       if ( str == "Warning") return Warning;
+       if ( str == "Error") return Error;
+        return Information;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(ServiceStatusType e) {
+       switch(e) {
+        case Information: return "Information";
+        case Warning: return "Warning";
+        case Error: return "Error";
+        default: return "Information";
+
+       }
+   }
+
+   }  // namespace ServiceStatusType
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_SERVICESTATUSTYPE_H_
diff --git a/src/LMCP/afrl/cmasi/SessionStatus.h b/src/LMCP/afrl/cmasi/SessionStatus.h
new file mode 100644
index 0000000..639a3bd
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/SessionStatus.h
@@ -0,0 +1,132 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_SESSIONSTATUS_H_
+#define _AFRL_CMASI_SESSIONSTATUS_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/SimulationStatusType.h"
+#include "afrl/cmasi/KeyValuePair.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isSessionStatus(avtas::lmcp::Object* obj);
+   bool isSessionStatus(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > SessionStatusDescendants();
+   
+   class SessionStatus : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      SessionStatus(void);
+
+      // Copy Constructor
+      SessionStatus(const SessionStatus &that);
+
+      // Assignment Operator
+      SessionStatus & operator=(const SessionStatus &that);
+
+      // Destructor
+      virtual ~SessionStatus(void);
+
+      // Equals overload
+      bool operator==(const SessionStatus & that);
+      bool operator!=(const SessionStatus & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual SessionStatus* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 46; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The current state of the session (Units: None)*/
+      afrl::cmasi::SimulationStatusType::SimulationStatusType getState(void) const { return __State; }
+      SessionStatus& setState(const afrl::cmasi::SimulationStatusType::SimulationStatusType val);
+
+      /** The simulation or scenario start time. This is absolute time in milliseconds since epoch (1 Jan 1970 00:00 GMT). If this field is zero, then no start time is specfied and each sim component is to use the first receipt of this Struct with a SimStatus of "Running" as the start time. (Units: millisecond)*/
+      int64_t getStartTime(void) const { return __StartTime; }
+      SessionStatus& setStartTime(const int64_t val);
+
+      /** The current time in scenario time . This is the internal time for the simulation, not the absolute time since epoch, as in "StartTime". The internal simualation time is based on the start time and the real-time muiltiple, which can change throughout the simulation. (Units: millisecond)*/
+      int64_t getScenarioTime(void) const { return __ScenarioTime; }
+      SessionStatus& setScenarioTime(const int64_t val);
+
+      /** The ratio of simulation time to real time. Values greater than 1.0 denote faster than real-time. Values less than 0.0 have no meaning. (Units: None)*/
+      float getRealTimeMultiple(void) const { return __RealTimeMultiple; }
+      SessionStatus& setRealTimeMultiple(const float val);
+
+      /** A field to store command-line style parameters used to initialize or modify an execution. (Units: None)*/
+      std::vector<afrl::cmasi::KeyValuePair*> & getParameters(void) { return __Parameters; }
+
+
+
+   protected:
+      /** The current state of the session */
+      afrl::cmasi::SimulationStatusType::SimulationStatusType __State;
+      /** The simulation or scenario start time. This is absolute time in milliseconds since epoch (1 Jan 1970 00:00 GMT). If this field is zero, then no start time is specfied and each sim component is to use the first receipt of this Struct with a SimStatus of "Running" as the start time. */
+      int64_t __StartTime;
+      /** The current time in scenario time . This is the internal time for the simulation, not the absolute time since epoch, as in "StartTime". The internal simualation time is based on the start time and the real-time muiltiple, which can change throughout the simulation. */
+      int64_t __ScenarioTime;
+      /** The ratio of simulation time to real time. Values greater than 1.0 denote faster than real-time. Values less than 0.0 have no meaning. */
+      float __RealTimeMultiple;
+      /** A field to store command-line style parameters used to initialize or modify an execution. */
+      std::vector< afrl::cmasi::KeyValuePair* > __Parameters;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_SESSIONSTATUS_H_
diff --git a/src/LMCP/afrl/cmasi/SessionStatusDescendants.h b/src/LMCP/afrl/cmasi/SessionStatusDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/SessionStatusDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/SimulationStatusType.h b/src/LMCP/afrl/cmasi/SimulationStatusType.h
new file mode 100644
index 0000000..8030c6a
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/SimulationStatusType.h
@@ -0,0 +1,64 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_SIMULATIONSTATUSTYPE_H_
+#define _AFRL_CMASI_SIMULATIONSTATUSTYPE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace SimulationStatusType {
+   enum SimulationStatusType {
+       /**  simulation is stopped  */
+       Stopped = 0,
+       /**  simulation is running  */
+       Running = 1,
+       /**  simulation paused  */
+       Paused = 2,
+       /**  simulation is reset  */
+       Reset = 3
+
+   };
+
+   // generates a new SimulationStatusType value for the passed string
+   inline SimulationStatusType get_SimulationStatusType(std::string str) {
+       if ( str == "Stopped") return Stopped;
+       if ( str == "Running") return Running;
+       if ( str == "Paused") return Paused;
+       if ( str == "Reset") return Reset;
+        return Stopped;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(SimulationStatusType e) {
+       switch(e) {
+        case Stopped: return "Stopped";
+        case Running: return "Running";
+        case Paused: return "Paused";
+        case Reset: return "Reset";
+        default: return "Stopped";
+
+       }
+   }
+
+   }  // namespace SimulationStatusType
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_SIMULATIONSTATUSTYPE_H_
diff --git a/src/LMCP/afrl/cmasi/SpeedType.h b/src/LMCP/afrl/cmasi/SpeedType.h
new file mode 100644
index 0000000..8c0af4c
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/SpeedType.h
@@ -0,0 +1,56 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_SPEEDTYPE_H_
+#define _AFRL_CMASI_SPEEDTYPE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace SpeedType {
+   enum SpeedType {
+       /**  airspeed  */
+       Airspeed = 0,
+       /**  groundspeed  */
+       Groundspeed = 1
+
+   };
+
+   // generates a new SpeedType value for the passed string
+   inline SpeedType get_SpeedType(std::string str) {
+       if ( str == "Airspeed") return Airspeed;
+       if ( str == "Groundspeed") return Groundspeed;
+        return Airspeed;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(SpeedType e) {
+       switch(e) {
+        case Airspeed: return "Airspeed";
+        case Groundspeed: return "Groundspeed";
+        default: return "Airspeed";
+
+       }
+   }
+
+   }  // namespace SpeedType
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_SPEEDTYPE_H_
diff --git a/src/LMCP/afrl/cmasi/StopMovementAction.h b/src/LMCP/afrl/cmasi/StopMovementAction.h
new file mode 100644
index 0000000..eeeb4d5
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/StopMovementAction.h
@@ -0,0 +1,107 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_STOPMOVEMENTACTION_H_
+#define _AFRL_CMASI_STOPMOVEMENTACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/VehicleAction.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isStopMovementAction(avtas::lmcp::Object* obj);
+   bool isStopMovementAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > StopMovementActionDescendants();
+   
+   class StopMovementAction : public afrl::cmasi::VehicleAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      StopMovementAction(void);
+
+      // Copy Constructor
+      StopMovementAction(const StopMovementAction &that);
+
+      // Assignment Operator
+      StopMovementAction & operator=(const StopMovementAction &that);
+
+      // Destructor
+      virtual ~StopMovementAction(void);
+
+      // Equals overload
+      bool operator==(const StopMovementAction & that);
+      bool operator!=(const StopMovementAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual StopMovementAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 58; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** A location at which the entity should stop. If this is null, the entity will stop immediately. (Units: None)*/
+      afrl::cmasi::Location3D* const getLocation(void) { return __Location; }
+      StopMovementAction& setLocation(const afrl::cmasi::Location3D* const val);
+
+
+
+   protected:
+      /** A location at which the entity should stop. If this is null, the entity will stop immediately. */
+      afrl::cmasi::Location3D* __Location;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_STOPMOVEMENTACTION_H_
diff --git a/src/LMCP/afrl/cmasi/StopMovementActionDescendants.h b/src/LMCP/afrl/cmasi/StopMovementActionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/StopMovementActionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/Task.h b/src/LMCP/afrl/cmasi/Task.h
new file mode 100644
index 0000000..4f7fb8f
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/Task.h
@@ -0,0 +1,142 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_TASK_H_
+#define _AFRL_CMASI_TASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/KeyValuePair.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isTask(avtas::lmcp::Object* obj);
+   bool isTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskDescendants();
+   
+   class Task : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      Task(void);
+
+      // Copy Constructor
+      Task(const Task &that);
+
+      // Assignment Operator
+      Task & operator=(const Task &that);
+
+      // Destructor
+      virtual ~Task(void);
+
+      // Equals overload
+      bool operator==(const Task & that);
+      bool operator!=(const Task & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual Task* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 8; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** A unique identifier for this task. (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      Task& setTaskID(const int64_t val);
+
+      /** An optional text string for the task. This is not necesarily unique, and is included for information only. TaskID should be used to uniquely identify tasks. (Units: None)*/
+      std::string getLabel(void) const { return __Label; }
+      Task& setLabel(const std::string val);
+
+      /** A list of entity IDs that are eligible to accomplish this task. If the list is empty, then it is assumed all entities are eligible. (Units: None)*/
+      std::vector<int64_t> & getEligibleEntities(void) { return __EligibleEntities; }
+
+      /** If a task is to be repeatedly done, this field indicates how often. A value of zero means the task is complete on the first pass. (Units: sec)*/
+      float getRevisitRate(void) const { return __RevisitRate; }
+      Task& setRevisitRate(const float val);
+
+      /** An optional text string for automation service task parameters. (Units: None)*/
+      std::vector<afrl::cmasi::KeyValuePair*> & getParameters(void) { return __Parameters; }
+
+      /** The priority value for this task. Priority is a relative value of this task compared to other tasks in the scenario. This field should be limited to the range[0..100], 100 being the highest level of priority. The exact interpretation priority may vary depending on algorithm implementation. (Units: None)*/
+      uint8_t getPriority(void) const { return __Priority; }
+      Task& setPriority(const uint8_t val);
+
+      /** Indicates whether this task <i><b>must</b></i> be executed as part of a mission plan. (Units: None)*/
+      bool getRequired(void) const { return __Required; }
+      Task& setRequired(const bool val);
+
+
+
+   protected:
+      /** A unique identifier for this task. */
+      int64_t __TaskID;
+      /** An optional text string for the task. This is not necesarily unique, and is included for information only. TaskID should be used to uniquely identify tasks. */
+      std::string __Label;
+      /** A list of entity IDs that are eligible to accomplish this task. If the list is empty, then it is assumed all entities are eligible. */
+      std::vector< int64_t > __EligibleEntities;
+      /** If a task is to be repeatedly done, this field indicates how often. A value of zero means the task is complete on the first pass. */
+      float __RevisitRate;
+      /** An optional text string for automation service task parameters. */
+      std::vector< afrl::cmasi::KeyValuePair* > __Parameters;
+      /** The priority value for this task. Priority is a relative value of this task compared to other tasks in the scenario. This field should be limited to the range[0..100], 100 being the highest level of priority. The exact interpretation priority may vary depending on algorithm implementation. */
+      uint8_t __Priority;
+      /** Indicates whether this task <i><b>must</b></i> be executed as part of a mission plan. */
+      bool __Required;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_TASK_H_
diff --git a/src/LMCP/afrl/cmasi/TaskDescendants.h b/src/LMCP/afrl/cmasi/TaskDescendants.h
new file mode 100644
index 0000000..6dfb201
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/TaskDescendants.h
@@ -0,0 +1,30 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "uxas/messages/task/AssignmentCoordinatorTask.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/AreaSearchTask.h"
+#include "afrl/cmasi/LineSearchTask.h"
+#include "afrl/cmasi/PointSearchTask.h"
+#include "afrl/impact/ImpactPointSearchTask.h"
+#include "afrl/impact/PatternSearchTask.h"
+#include "afrl/impact/AngledAreaSearchTask.h"
+#include "afrl/impact/ImpactLineSearchTask.h"
+#include "afrl/impact/WatchTask.h"
+#include "afrl/impact/MultiVehicleWatchTask.h"
+#include "afrl/impact/EscortTask.h"
+#include "afrl/cmasi/LoiterTask.h"
+#include "afrl/cmasi/MustFlyTask.h"
+#include "afrl/impact/CommRelayTask.h"
+#include "afrl/impact/CordonTask.h"
+#include "afrl/impact/BlockadeTask.h"
+#include "afrl/cmasi/perceive/TrackEntityTask.h"
+
diff --git a/src/LMCP/afrl/cmasi/TravelMode.h b/src/LMCP/afrl/cmasi/TravelMode.h
new file mode 100644
index 0000000..31f10b7
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/TravelMode.h
@@ -0,0 +1,60 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_TRAVELMODE_H_
+#define _AFRL_CMASI_TRAVELMODE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace TravelMode {
+   enum TravelMode {
+       /**  A path is traversed from beginning to end, then the entity stops  */
+       SinglePass = 0,
+       /**  Upon reaching the end of a route, the entity travels the waypoint list in reverse-direction.  */
+       ReverseCourse = 1,
+       /**  Upon reaching the end of a route, the entity travels to the first point and repeats the route.  */
+       Loop = 2
+
+   };
+
+   // generates a new TravelMode value for the passed string
+   inline TravelMode get_TravelMode(std::string str) {
+       if ( str == "SinglePass") return SinglePass;
+       if ( str == "ReverseCourse") return ReverseCourse;
+       if ( str == "Loop") return Loop;
+        return SinglePass;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(TravelMode e) {
+       switch(e) {
+        case SinglePass: return "SinglePass";
+        case ReverseCourse: return "ReverseCourse";
+        case Loop: return "Loop";
+        default: return "SinglePass";
+
+       }
+   }
+
+   }  // namespace TravelMode
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_TRAVELMODE_H_
diff --git a/src/LMCP/afrl/cmasi/TurnType.h b/src/LMCP/afrl/cmasi/TurnType.h
new file mode 100644
index 0000000..b82b45d
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/TurnType.h
@@ -0,0 +1,56 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_TURNTYPE_H_
+#define _AFRL_CMASI_TURNTYPE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace TurnType {
+   enum TurnType {
+       /**  turn short, return to track  */
+       TurnShort = 0,
+       /**  fly over, return to track  */
+       FlyOver = 1
+
+   };
+
+   // generates a new TurnType value for the passed string
+   inline TurnType get_TurnType(std::string str) {
+       if ( str == "TurnShort") return TurnShort;
+       if ( str == "FlyOver") return FlyOver;
+        return TurnShort;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(TurnType e) {
+       switch(e) {
+        case TurnShort: return "TurnShort";
+        case FlyOver: return "FlyOver";
+        default: return "TurnShort";
+
+       }
+   }
+
+   }  // namespace TurnType
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_TURNTYPE_H_
diff --git a/src/LMCP/afrl/cmasi/VehicleAction.h b/src/LMCP/afrl/cmasi/VehicleAction.h
new file mode 100644
index 0000000..fd82e6d
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/VehicleAction.h
@@ -0,0 +1,108 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_VEHICLEACTION_H_
+#define _AFRL_CMASI_VEHICLEACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isVehicleAction(avtas::lmcp::Object* obj);
+   bool isVehicleAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > VehicleActionDescendants();
+   
+   class VehicleAction : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      VehicleAction(void);
+
+      // Copy Constructor
+      VehicleAction(const VehicleAction &that);
+
+      // Assignment Operator
+      VehicleAction & operator=(const VehicleAction &that);
+
+      // Destructor
+      virtual ~VehicleAction(void);
+
+      // Equals overload
+      bool operator==(const VehicleAction & that);
+      bool operator!=(const VehicleAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual VehicleAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 7; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** A list of tasks that are associated with this action. A length of zero denotes no associated tasks. This field is for analysis purposes. The automation service should associate a list of tasks with each action to enable analysis of the allocation of tasks to vehicles.
+      *<br/> (Units: None)*/
+      std::vector<int64_t> & getAssociatedTaskList(void) { return __AssociatedTaskList; }
+
+
+
+   protected:
+      /** A list of tasks that are associated with this action. A length of zero denotes no associated tasks. This field is for analysis purposes. The automation service should associate a list of tasks with each action to enable analysis of the allocation of tasks to vehicles.
+      *<br/> */
+      std::vector< int64_t > __AssociatedTaskList;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_VEHICLEACTION_H_
diff --git a/src/LMCP/afrl/cmasi/VehicleActionCommand.h b/src/LMCP/afrl/cmasi/VehicleActionCommand.h
new file mode 100644
index 0000000..a4890cb
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/VehicleActionCommand.h
@@ -0,0 +1,126 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_VEHICLEACTIONCOMMAND_H_
+#define _AFRL_CMASI_VEHICLEACTIONCOMMAND_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/VehicleAction.h"
+#include "afrl/cmasi/CommandStatusType.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isVehicleActionCommand(avtas::lmcp::Object* obj);
+   bool isVehicleActionCommand(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > VehicleActionCommandDescendants();
+   
+   class VehicleActionCommand : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      VehicleActionCommand(void);
+
+      // Copy Constructor
+      VehicleActionCommand(const VehicleActionCommand &that);
+
+      // Assignment Operator
+      VehicleActionCommand & operator=(const VehicleActionCommand &that);
+
+      // Destructor
+      virtual ~VehicleActionCommand(void);
+
+      // Equals overload
+      bool operator==(const VehicleActionCommand & that);
+      bool operator!=(const VehicleActionCommand & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual VehicleActionCommand* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 47; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** A unique id for this command. automation services should issue new ids with every new command (Units: None)*/
+      int64_t getCommandID(void) const { return __CommandID; }
+      VehicleActionCommand& setCommandID(const int64_t val);
+
+      /** The id of the vehicle for this command. (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      VehicleActionCommand& setVehicleID(const int64_t val);
+
+      /** a set of actions to be performed immediately by the vehicle. (Units: None)*/
+      std::vector<afrl::cmasi::VehicleAction*> & getVehicleActionList(void) { return __VehicleActionList; }
+
+      /** Denotes the current execution status of this command. (Units: None)*/
+      afrl::cmasi::CommandStatusType::CommandStatusType getStatus(void) const { return __Status; }
+      VehicleActionCommand& setStatus(const afrl::cmasi::CommandStatusType::CommandStatusType val);
+
+
+
+   protected:
+      /** A unique id for this command. automation services should issue new ids with every new command */
+      int64_t __CommandID;
+      /** The id of the vehicle for this command. */
+      int64_t __VehicleID;
+      /** a set of actions to be performed immediately by the vehicle. */
+      std::vector< afrl::cmasi::VehicleAction* > __VehicleActionList;
+      /** Denotes the current execution status of this command. */
+      afrl::cmasi::CommandStatusType::CommandStatusType __Status;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_VEHICLEACTIONCOMMAND_H_
diff --git a/src/LMCP/afrl/cmasi/VehicleActionCommandDescendants.h b/src/LMCP/afrl/cmasi/VehicleActionCommandDescendants.h
new file mode 100644
index 0000000..af4e013
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/VehicleActionCommandDescendants.h
@@ -0,0 +1,14 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/MissionCommand.h"
+#include "afrl/cmasi/FollowPathCommand.h"
+
diff --git a/src/LMCP/afrl/cmasi/VehicleActionDescendants.h b/src/LMCP/afrl/cmasi/VehicleActionDescendants.h
new file mode 100644
index 0000000..75ed2ed
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/VehicleActionDescendants.h
@@ -0,0 +1,25 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/PayloadAction.h"
+#include "afrl/cmasi/CameraAction.h"
+#include "afrl/cmasi/GimbalAngleAction.h"
+#include "afrl/cmasi/GimbalScanAction.h"
+#include "afrl/cmasi/GimbalStareAction.h"
+#include "afrl/cmasi/NavigationAction.h"
+#include "afrl/cmasi/GoToWaypointAction.h"
+#include "afrl/cmasi/LoiterAction.h"
+#include "afrl/cmasi/FlightDirectorAction.h"
+#include "afrl/cmasi/VideoStreamAction.h"
+#include "afrl/cmasi/StopMovementAction.h"
+#include "afrl/impact/DeployImpactPayload.h"
+#include "afrl/cmasi/perceive/TrackEntityAction.h"
+
diff --git a/src/LMCP/afrl/cmasi/VideoStreamAction.h b/src/LMCP/afrl/cmasi/VideoStreamAction.h
new file mode 100644
index 0000000..2354be4
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/VideoStreamAction.h
@@ -0,0 +1,112 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_VIDEOSTREAMACTION_H_
+#define _AFRL_CMASI_VIDEOSTREAMACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/VehicleAction.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isVideoStreamAction(avtas::lmcp::Object* obj);
+   bool isVideoStreamAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > VideoStreamActionDescendants();
+   
+   class VideoStreamAction : public afrl::cmasi::VehicleAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      VideoStreamAction(void);
+
+      // Copy Constructor
+      VideoStreamAction(const VideoStreamAction &that);
+
+      // Assignment Operator
+      VideoStreamAction & operator=(const VideoStreamAction &that);
+
+      // Destructor
+      virtual ~VideoStreamAction(void);
+
+      // Equals overload
+      bool operator==(const VideoStreamAction & that);
+      bool operator!=(const VideoStreamAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual VideoStreamAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 48; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** A unique id for the video stream. (Units: None)*/
+      int32_t getVideoStreamID(void) const { return __VideoStreamID; }
+      VideoStreamAction& setVideoStreamID(const int32_t val);
+
+      /** The PayloadID of the sensor which should be activated on this video stream. (Units: None)*/
+      int32_t getActiveSensor(void) const { return __ActiveSensor; }
+      VideoStreamAction& setActiveSensor(const int32_t val);
+
+
+
+   protected:
+      /** A unique id for the video stream. */
+      int32_t __VideoStreamID;
+      /** The PayloadID of the sensor which should be activated on this video stream. */
+      int32_t __ActiveSensor;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_VIDEOSTREAMACTION_H_
diff --git a/src/LMCP/afrl/cmasi/VideoStreamActionDescendants.h b/src/LMCP/afrl/cmasi/VideoStreamActionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/VideoStreamActionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/VideoStreamConfiguration.h b/src/LMCP/afrl/cmasi/VideoStreamConfiguration.h
new file mode 100644
index 0000000..6a31733
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/VideoStreamConfiguration.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_VIDEOSTREAMCONFIGURATION_H_
+#define _AFRL_CMASI_VIDEOSTREAMCONFIGURATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/PayloadConfiguration.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isVideoStreamConfiguration(avtas::lmcp::Object* obj);
+   bool isVideoStreamConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > VideoStreamConfigurationDescendants();
+   
+   class VideoStreamConfiguration : public afrl::cmasi::PayloadConfiguration {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      VideoStreamConfiguration(void);
+
+      // Copy Constructor
+      VideoStreamConfiguration(const VideoStreamConfiguration &that);
+
+      // Assignment Operator
+      VideoStreamConfiguration & operator=(const VideoStreamConfiguration &that);
+
+      // Destructor
+      virtual ~VideoStreamConfiguration(void);
+
+      // Equals overload
+      bool operator==(const VideoStreamConfiguration & that);
+      bool operator!=(const VideoStreamConfiguration & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual VideoStreamConfiguration* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 49; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** List the PayloadID of each sensor that is multiplexed into this stream. The {@link VideoStreamAction} message selects which of these sensors is currently active on the stream. (Units: None)*/
+      std::vector<int64_t> & getAvailableSensorList(void) { return __AvailableSensorList; }
+
+
+
+   protected:
+      /** List the PayloadID of each sensor that is multiplexed into this stream. The {@link VideoStreamAction} message selects which of these sensors is currently active on the stream. */
+      std::vector< int64_t > __AvailableSensorList;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_VIDEOSTREAMCONFIGURATION_H_
diff --git a/src/LMCP/afrl/cmasi/VideoStreamConfigurationDescendants.h b/src/LMCP/afrl/cmasi/VideoStreamConfigurationDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/VideoStreamConfigurationDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/VideoStreamState.h b/src/LMCP/afrl/cmasi/VideoStreamState.h
new file mode 100644
index 0000000..c9cad82
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/VideoStreamState.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_VIDEOSTREAMSTATE_H_
+#define _AFRL_CMASI_VIDEOSTREAMSTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/PayloadState.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isVideoStreamState(avtas::lmcp::Object* obj);
+   bool isVideoStreamState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > VideoStreamStateDescendants();
+   
+   class VideoStreamState : public afrl::cmasi::PayloadState {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      VideoStreamState(void);
+
+      // Copy Constructor
+      VideoStreamState(const VideoStreamState &that);
+
+      // Assignment Operator
+      VideoStreamState & operator=(const VideoStreamState &that);
+
+      // Destructor
+      virtual ~VideoStreamState(void);
+
+      // Equals overload
+      bool operator==(const VideoStreamState & that);
+      bool operator!=(const VideoStreamState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual VideoStreamState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 50; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The PayloadID of the sensor which is active on this video stream.. (Units: None)*/
+      int64_t getActiveSensor(void) const { return __ActiveSensor; }
+      VideoStreamState& setActiveSensor(const int64_t val);
+
+
+
+   protected:
+      /** The PayloadID of the sensor which is active on this video stream.. */
+      int64_t __ActiveSensor;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_VIDEOSTREAMSTATE_H_
diff --git a/src/LMCP/afrl/cmasi/VideoStreamStateDescendants.h b/src/LMCP/afrl/cmasi/VideoStreamStateDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/VideoStreamStateDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/WavelengthBand.h b/src/LMCP/afrl/cmasi/WavelengthBand.h
new file mode 100644
index 0000000..5b016c2
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/WavelengthBand.h
@@ -0,0 +1,72 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_WAVELENGTHBAND_H_
+#define _AFRL_CMASI_WAVELENGTHBAND_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace WavelengthBand {
+   enum WavelengthBand {
+       /**  used in cases when wavelength is not applicable  */
+       AllAny = 0,
+       /**  Electro-optical.  Visible spectrum  */
+       EO = 1,
+       /**  Long-wave Infrared  */
+       LWIR = 2,
+       /**  Short-wave infrared  */
+       SWIR = 3,
+       /**  mid-wave infrared  */
+       MWIR = 4,
+       /**  Other or undefined wavelength band  */
+       Other = 5
+
+   };
+
+   // generates a new WavelengthBand value for the passed string
+   inline WavelengthBand get_WavelengthBand(std::string str) {
+       if ( str == "AllAny") return AllAny;
+       if ( str == "EO") return EO;
+       if ( str == "LWIR") return LWIR;
+       if ( str == "SWIR") return SWIR;
+       if ( str == "MWIR") return MWIR;
+       if ( str == "Other") return Other;
+        return AllAny;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(WavelengthBand e) {
+       switch(e) {
+        case AllAny: return "AllAny";
+        case EO: return "EO";
+        case LWIR: return "LWIR";
+        case SWIR: return "SWIR";
+        case MWIR: return "MWIR";
+        case Other: return "Other";
+        default: return "AllAny";
+
+       }
+   }
+
+   }  // namespace WavelengthBand
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_WAVELENGTHBAND_H_
diff --git a/src/LMCP/afrl/cmasi/Waypoint.h b/src/LMCP/afrl/cmasi/Waypoint.h
new file mode 100644
index 0000000..5e46d70
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/Waypoint.h
@@ -0,0 +1,162 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_WAYPOINT_H_
+#define _AFRL_CMASI_WAYPOINT_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "afrl/cmasi/Location3D.h"
+#include "afrl/cmasi/SpeedType.h"
+#include "afrl/cmasi/TurnType.h"
+#include "afrl/cmasi/VehicleAction.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isWaypoint(avtas::lmcp::Object* obj);
+   bool isWaypoint(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > WaypointDescendants();
+   
+   class Waypoint : public afrl::cmasi::Location3D {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      Waypoint(void);
+
+      // Copy Constructor
+      Waypoint(const Waypoint &that);
+
+      // Assignment Operator
+      Waypoint & operator=(const Waypoint &that);
+
+      // Destructor
+      virtual ~Waypoint(void);
+
+      // Equals overload
+      bool operator==(const Waypoint & that);
+      bool operator!=(const Waypoint & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual Waypoint* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 35; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** A unique waypoint number (Units: None)*/
+      int64_t getNumber(void) const { return __Number; }
+      Waypoint& setNumber(const int64_t val);
+
+      /** The index of the next waypoint in the list. Consecutively numbered waypoints are <b>not</b> considered linked, the link must be explicitly stated in this field. (Units: None)*/
+      int64_t getNextWaypoint(void) const { return __NextWaypoint; }
+      Waypoint& setNextWaypoint(const int64_t val);
+
+      /** Commanded speed for this waypoint. See SpeedType for defintion of this field. (Units: meter/sec)*/
+      float getSpeed(void) const { return __Speed; }
+      Waypoint& setSpeed(const float val);
+
+      /** Type of commanded speed (Units: None)*/
+      afrl::cmasi::SpeedType::SpeedType getSpeedType(void) const { return __SpeedType; }
+      Waypoint& setSpeedType(const afrl::cmasi::SpeedType::SpeedType val);
+
+      /** The commanded climb rate. Positive values upwards. For surface (ground and sea) entities, this value is ignored. (Units: meter/sec)*/
+      float getClimbRate(void) const { return __ClimbRate; }
+      Waypoint& setClimbRate(const float val);
+
+      /** The type of turn to execute (Units: None)*/
+      afrl::cmasi::TurnType::TurnType getTurnType(void) const { return __TurnType; }
+      Waypoint& setTurnType(const afrl::cmasi::TurnType::TurnType val);
+
+      /** A list of actions to perform at this waypoint (Units: None)*/
+      std::vector<afrl::cmasi::VehicleAction*> & getVehicleActionList(void) { return __VehicleActionList; }
+
+      /** A waypoint for contingency (e.g. lost-comm, alternate mission) operations. A value of zero denotes that no contingency point is specified. (Units: None)*/
+      int64_t getContingencyWaypointA(void) const { return __ContingencyWaypointA; }
+      Waypoint& setContingencyWaypointA(const int64_t val);
+
+      /** A waypoint for contingency (e.g. lost-comm, alternate mission) operations. A value of zero denotes that no contingency point is specified. (Units: None)*/
+      int64_t getContingencyWaypointB(void) const { return __ContingencyWaypointB; }
+      Waypoint& setContingencyWaypointB(const int64_t val);
+
+      /** A list of tasks that are associated with this waypoint. A length of zero denotes no associated tasks. This field is for analysis purposes. The automation service should associate a list of tasks with each waypoint to enable analysis of the allocation of tasks to vehicles. (Units: None)*/
+      std::vector<int64_t> & getAssociatedTasks(void) { return __AssociatedTasks; }
+
+
+
+   protected:
+      /** A unique waypoint number */
+      int64_t __Number;
+      /** The index of the next waypoint in the list. Consecutively numbered waypoints are <b>not</b> considered linked, the link must be explicitly stated in this field. */
+      int64_t __NextWaypoint;
+      /** Commanded speed for this waypoint. See SpeedType for defintion of this field. */
+      float __Speed;
+      /** Type of commanded speed */
+      afrl::cmasi::SpeedType::SpeedType __SpeedType;
+      /** The commanded climb rate. Positive values upwards. For surface (ground and sea) entities, this value is ignored. */
+      float __ClimbRate;
+      /** The type of turn to execute */
+      afrl::cmasi::TurnType::TurnType __TurnType;
+      /** A list of actions to perform at this waypoint */
+      std::vector< afrl::cmasi::VehicleAction* > __VehicleActionList;
+      /** A waypoint for contingency (e.g. lost-comm, alternate mission) operations. A value of zero denotes that no contingency point is specified. */
+      int64_t __ContingencyWaypointA;
+      /** A waypoint for contingency (e.g. lost-comm, alternate mission) operations. A value of zero denotes that no contingency point is specified. */
+      int64_t __ContingencyWaypointB;
+      /** A list of tasks that are associated with this waypoint. A length of zero denotes no associated tasks. This field is for analysis purposes. The automation service should associate a list of tasks with each waypoint to enable analysis of the allocation of tasks to vehicles. */
+      std::vector< int64_t > __AssociatedTasks;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_WAYPOINT_H_
diff --git a/src/LMCP/afrl/cmasi/WaypointDescendants.h b/src/LMCP/afrl/cmasi/WaypointDescendants.h
new file mode 100644
index 0000000..e0c9373
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/WaypointDescendants.h
@@ -0,0 +1,13 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/PathWaypoint.h"
+
diff --git a/src/LMCP/afrl/cmasi/WaypointTransfer.h b/src/LMCP/afrl/cmasi/WaypointTransfer.h
new file mode 100644
index 0000000..fe8968b
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/WaypointTransfer.h
@@ -0,0 +1,120 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_WAYPOINTTRANSFER_H_
+#define _AFRL_CMASI_WAYPOINTTRANSFER_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/WaypointTransferMode.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isWaypointTransfer(avtas::lmcp::Object* obj);
+   bool isWaypointTransfer(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > WaypointTransferDescendants();
+   
+   class WaypointTransfer : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      WaypointTransfer(void);
+
+      // Copy Constructor
+      WaypointTransfer(const WaypointTransfer &that);
+
+      // Assignment Operator
+      WaypointTransfer & operator=(const WaypointTransfer &that);
+
+      // Destructor
+      virtual ~WaypointTransfer(void);
+
+      // Equals overload
+      bool operator==(const WaypointTransfer & that);
+      bool operator!=(const WaypointTransfer & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual WaypointTransfer* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 59; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** ID of the entity assoicated with the waypoints (Units: None)*/
+      int64_t getEntityID(void) const { return __EntityID; }
+      WaypointTransfer& setEntityID(const int64_t val);
+
+      /** A list of wayppoints to transfer. This may be empty if the transfer type is "RequestWaypoints" or "ClearWaypoints" (Units: None)*/
+      std::vector<afrl::cmasi::Waypoint*> & getWaypoints(void) { return __Waypoints; }
+
+      /** describes the transfer action to take (Units: None)*/
+      afrl::cmasi::WaypointTransferMode::WaypointTransferMode getTransferMode(void) const { return __TransferMode; }
+      WaypointTransfer& setTransferMode(const afrl::cmasi::WaypointTransferMode::WaypointTransferMode val);
+
+
+
+   protected:
+      /** ID of the entity assoicated with the waypoints */
+      int64_t __EntityID;
+      /** A list of wayppoints to transfer. This may be empty if the transfer type is "RequestWaypoints" or "ClearWaypoints" */
+      std::vector< afrl::cmasi::Waypoint* > __Waypoints;
+      /** describes the transfer action to take */
+      afrl::cmasi::WaypointTransferMode::WaypointTransferMode __TransferMode;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_WAYPOINTTRANSFER_H_
diff --git a/src/LMCP/afrl/cmasi/WaypointTransferDescendants.h b/src/LMCP/afrl/cmasi/WaypointTransferDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/WaypointTransferDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/WaypointTransferMode.h b/src/LMCP/afrl/cmasi/WaypointTransferMode.h
new file mode 100644
index 0000000..76aba0e
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/WaypointTransferMode.h
@@ -0,0 +1,64 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_WAYPOINTTRANSFERMODE_H_
+#define _AFRL_CMASI_WAYPOINTTRANSFERMODE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace WaypointTransferMode {
+   enum WaypointTransferMode {
+       /**  Requests download of waypoints from the aircraft  */
+       RequestWaypoints = 0,
+       /**  Adds waypoints to the aircraft.  Waypoints with the same number are overwritten  */
+       AddWaypoints = 1,
+       /**  Commands the aircraft to clear its waypoints  */
+       ClearWaypoints = 2,
+       /**  Reports waypoints that are curretly in the aircraft computer  */
+       ReportWaypoints = 3
+
+   };
+
+   // generates a new WaypointTransferMode value for the passed string
+   inline WaypointTransferMode get_WaypointTransferMode(std::string str) {
+       if ( str == "RequestWaypoints") return RequestWaypoints;
+       if ( str == "AddWaypoints") return AddWaypoints;
+       if ( str == "ClearWaypoints") return ClearWaypoints;
+       if ( str == "ReportWaypoints") return ReportWaypoints;
+        return RequestWaypoints;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(WaypointTransferMode e) {
+       switch(e) {
+        case RequestWaypoints: return "RequestWaypoints";
+        case AddWaypoints: return "AddWaypoints";
+        case ClearWaypoints: return "ClearWaypoints";
+        case ReportWaypoints: return "ReportWaypoints";
+        default: return "RequestWaypoints";
+
+       }
+   }
+
+   }  // namespace WaypointTransferMode
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_WAYPOINTTRANSFERMODE_H_
diff --git a/src/LMCP/afrl/cmasi/WeatherReport.h b/src/LMCP/afrl/cmasi/WeatherReport.h
new file mode 100644
index 0000000..6d50897
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/WeatherReport.h
@@ -0,0 +1,137 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_WEATHERREPORT_H_
+#define _AFRL_CMASI_WEATHERREPORT_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AbstractZone.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isWeatherReport(avtas::lmcp::Object* obj);
+   bool isWeatherReport(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > WeatherReportDescendants();
+   
+   class WeatherReport : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      WeatherReport(void);
+
+      // Copy Constructor
+      WeatherReport(const WeatherReport &that);
+
+      // Assignment Operator
+      WeatherReport & operator=(const WeatherReport &that);
+
+      // Destructor
+      virtual ~WeatherReport(void);
+
+      // Equals overload
+      bool operator==(const WeatherReport & that);
+      bool operator!=(const WeatherReport & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual WeatherReport* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 55; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** The area for which this report pertains. If this is null, then the report pertains to the entire area. (Units: None)*/
+      afrl::cmasi::AbstractZone* const getArea(void) { return __Area; }
+      WeatherReport& setArea(const afrl::cmasi::AbstractZone* const val);
+
+      /** Windspeed value for this area (Units: meter/sec)*/
+      float getWindSpeed(void) const { return __WindSpeed; }
+      WeatherReport& setWindSpeed(const float val);
+
+      /** Wind direction. Direction is the true heading from which the wind is blowing. (Units: degree)*/
+      float getWindDirection(void) const { return __WindDirection; }
+      WeatherReport& setWindDirection(const float val);
+
+      /** Visibility, according to the <a href="http://en.wikipedia.org/wiki/Visibility">ICAO definition</a>. (Units: meter)*/
+      float getVisibility(void) const { return __Visibility; }
+      WeatherReport& setVisibility(const float val);
+
+      /** Height of the bottom of a cloud layer, in MSL altitude. If there is more than one cloud layer, create WeatherReports for each zone that contains a cloud layer. A value of "0" denotes free-of-clouds (Units: meter)*/
+      float getCloudCeiling(void) const { return __CloudCeiling; }
+      WeatherReport& setCloudCeiling(const float val);
+
+      /** Amount of cloud coverage for the given cloud layer. Values should be 0..1, 0 denoting free-of-clouds, and 1 denoting overcast. (Units: None)*/
+      float getCloudCoverage(void) const { return __CloudCoverage; }
+      WeatherReport& setCloudCoverage(const float val);
+
+
+
+   protected:
+      /** The area for which this report pertains. If this is null, then the report pertains to the entire area. */
+      afrl::cmasi::AbstractZone* __Area;
+      /** Windspeed value for this area */
+      float __WindSpeed;
+      /** Wind direction. Direction is the true heading from which the wind is blowing. */
+      float __WindDirection;
+      /** Visibility, according to the <a href="http://en.wikipedia.org/wiki/Visibility">ICAO definition</a>. */
+      float __Visibility;
+      /** Height of the bottom of a cloud layer, in MSL altitude. If there is more than one cloud layer, create WeatherReports for each zone that contains a cloud layer. A value of "0" denotes free-of-clouds */
+      float __CloudCeiling;
+      /** Amount of cloud coverage for the given cloud layer. Values should be 0..1, 0 denoting free-of-clouds, and 1 denoting overcast. */
+      float __CloudCoverage;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_WEATHERREPORT_H_
diff --git a/src/LMCP/afrl/cmasi/WeatherReportDescendants.h b/src/LMCP/afrl/cmasi/WeatherReportDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/WeatherReportDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/Wedge.h b/src/LMCP/afrl/cmasi/Wedge.h
new file mode 100644
index 0000000..87b4505
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/Wedge.h
@@ -0,0 +1,124 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_WEDGE_H_
+#define _AFRL_CMASI_WEDGE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "CMASIEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   bool isWedge(avtas::lmcp::Object* obj);
+   bool isWedge(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > WedgeDescendants();
+   
+   class Wedge : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      Wedge(void);
+
+      // Copy Constructor
+      Wedge(const Wedge &that);
+
+      // Assignment Operator
+      Wedge & operator=(const Wedge &that);
+
+      // Destructor
+      virtual ~Wedge(void);
+
+      // Equals overload
+      bool operator==(const Wedge & that);
+      bool operator!=(const Wedge & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual Wedge* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 16; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("CMASI"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 4849604199710720000LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Azimuthal centerline of the wedge. (Units: degree)*/
+      float getAzimuthCenterline(void) const { return __AzimuthCenterline; }
+      Wedge& setAzimuthCenterline(const float val);
+
+      /** Vertical centerline of the wedge. (Units: degree)*/
+      float getVerticalCenterline(void) const { return __VerticalCenterline; }
+      Wedge& setVerticalCenterline(const float val);
+
+      /** Azimuthal angular extent of the wedge. The extent is centered around the centerline. A value of zero denotes that this wedge is defined as a single angle. (Units: degree)*/
+      float getAzimuthExtent(void) const { return __AzimuthExtent; }
+      Wedge& setAzimuthExtent(const float val);
+
+      /** Vertical angular extent of the wedge. The extent is centered around the centerline. A value of zero denotes that this wedge is defined as a single angle. (Units: degree)*/
+      float getVerticalExtent(void) const { return __VerticalExtent; }
+      Wedge& setVerticalExtent(const float val);
+
+
+
+   protected:
+      /** Azimuthal centerline of the wedge. */
+      float __AzimuthCenterline;
+      /** Vertical centerline of the wedge. */
+      float __VerticalCenterline;
+      /** Azimuthal angular extent of the wedge. The extent is centered around the centerline. A value of zero denotes that this wedge is defined as a single angle. */
+      float __AzimuthExtent;
+      /** Vertical angular extent of the wedge. The extent is centered around the centerline. A value of zero denotes that this wedge is defined as a single angle. */
+      float __VerticalExtent;
+
+   };
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_WEDGE_H_
diff --git a/src/LMCP/afrl/cmasi/WedgeDescendants.h b/src/LMCP/afrl/cmasi/WedgeDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/WedgeDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/ZoneAvoidanceType.h b/src/LMCP/afrl/cmasi/ZoneAvoidanceType.h
new file mode 100644
index 0000000..0f2b7f2
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/ZoneAvoidanceType.h
@@ -0,0 +1,68 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_ZONEAVOIDANCETYPE_H_
+#define _AFRL_CMASI_ZONEAVOIDANCETYPE_H_
+
+#include <string>
+
+namespace afrl {
+namespace cmasi {
+
+
+
+   namespace ZoneAvoidanceType {
+   enum ZoneAvoidanceType {
+       /**  zone corresponds to a physical boundary (e.g. terrain, buildings)  */
+       Physical = 1,
+       /**  zone corresponds to a regulatory boundary (e.g. flight control corridor)  */
+       Regulatory = 2,
+       /**  zone corresponds to an area that is sensitive to acoustic intrusion  */
+       Acoustic = 3,
+       /**  zone contains a threat */
+       Threat = 4,
+       /**  zone defines an area that is sensitive to visual detection.  The threshold of visual detection                is not defined by this standard. */
+       Visual = 5
+
+   };
+
+   // generates a new ZoneAvoidanceType value for the passed string
+   inline ZoneAvoidanceType get_ZoneAvoidanceType(std::string str) {
+       if ( str == "Physical") return Physical;
+       if ( str == "Regulatory") return Regulatory;
+       if ( str == "Acoustic") return Acoustic;
+       if ( str == "Threat") return Threat;
+       if ( str == "Visual") return Visual;
+        return Physical;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(ZoneAvoidanceType e) {
+       switch(e) {
+        case Physical: return "Physical";
+        case Regulatory: return "Regulatory";
+        case Acoustic: return "Acoustic";
+        case Threat: return "Threat";
+        case Visual: return "Visual";
+        default: return "Physical";
+
+       }
+   }
+
+   }  // namespace ZoneAvoidanceType
+
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_ZONEAVOIDANCETYPE_H_
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiAbstractGeometry.cpp b/src/LMCP/afrl/cmasi/afrlcmasiAbstractGeometry.cpp
new file mode 100644
index 0000000..b5a830b
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiAbstractGeometry.cpp
@@ -0,0 +1,151 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/AbstractGeometry.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AbstractGeometry::Subscription = "afrl.cmasi.AbstractGeometry";
+   const std::string AbstractGeometry::TypeName = "AbstractGeometry";
+   
+   bool isAbstractGeometry(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 1) return false;
+      return true;
+   }
+   
+   bool isAbstractGeometry(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 1) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AbstractGeometryDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.Circle");
+       descendants.push_back("afrl.cmasi.Polygon");
+       descendants.push_back("afrl.cmasi.Rectangle");
+
+       return descendants;
+   }
+   
+   AbstractGeometry::AbstractGeometry(void) : avtas::lmcp::Object()
+   {
+
+   }
+     
+   AbstractGeometry::AbstractGeometry(const AbstractGeometry &that) : avtas::lmcp::Object(that)
+   {
+
+   }
+   
+   AbstractGeometry & AbstractGeometry::operator=(const AbstractGeometry &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+
+      }
+      return *this;
+   }
+
+   AbstractGeometry* AbstractGeometry::clone() const
+   {
+        return new AbstractGeometry(*this);
+   }
+   
+   AbstractGeometry::~AbstractGeometry(void)
+   {
+
+   }
+  
+   void AbstractGeometry::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+
+   }
+   
+   void AbstractGeometry::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+
+   }
+
+   uint32_t AbstractGeometry::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+
+      return size;
+   }
+
+   std::string AbstractGeometry::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AbstractGeometry ) {\n";
+      indent = std::string((++depth)*3, ' ');
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AbstractGeometry::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AbstractGeometry Series=\"CMASI\">\n";
+      str << ws << "</AbstractGeometry>\n";
+
+      return str.str();
+   }
+
+   bool AbstractGeometry::operator==(const AbstractGeometry & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      return true;
+
+   }
+
+   bool AbstractGeometry::operator!=(const AbstractGeometry & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiAbstractZone.cpp b/src/LMCP/afrl/cmasi/afrlcmasiAbstractZone.cpp
new file mode 100644
index 0000000..6d085b2
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiAbstractZone.cpp
@@ -0,0 +1,368 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/AbstractZone.h"
+#include "afrl/cmasi/Circle.h"
+#include "afrl/cmasi/Polygon.h"
+#include "afrl/cmasi/Rectangle.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AbstractZone::Subscription = "afrl.cmasi.AbstractZone";
+   const std::string AbstractZone::TypeName = "AbstractZone";
+   
+   bool isAbstractZone(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 10) return false;
+      return true;
+   }
+   
+   bool isAbstractZone(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 10) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AbstractZoneDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.KeepInZone");
+       descendants.push_back("afrl.cmasi.KeepOutZone");
+       descendants.push_back("afrl.impact.WaterZone");
+
+       return descendants;
+   }
+   
+   AbstractZone::AbstractZone(void) : avtas::lmcp::Object()
+   {
+      __ZoneID = 0LL;
+      __MinAltitude = 0.f;
+      __MinAltitudeType = afrl::cmasi::AltitudeType::AGL;
+      __MaxAltitude = 0.f;
+      __MaxAltitudeType = afrl::cmasi::AltitudeType::MSL;
+      __StartTime = 0LL;
+      __EndTime = 0LL;
+      __Padding = 0.f;
+      __Label = std::string("");
+      __Boundary = new afrl::cmasi::AbstractGeometry();
+
+   }
+     
+   AbstractZone::AbstractZone(const AbstractZone &that) : avtas::lmcp::Object(that)
+   {
+        __ZoneID = that.__ZoneID;
+        __MinAltitude = that.__MinAltitude;
+        __MinAltitudeType = that.__MinAltitudeType;
+        __MaxAltitude = that.__MaxAltitude;
+        __MaxAltitudeType = that.__MaxAltitudeType;
+        __AffectedAircraft.clear();
+        for (size_t i=0; i< that.__AffectedAircraft.size(); i++)
+        {
+           __AffectedAircraft.push_back( that.__AffectedAircraft[i]);
+        }
+        __StartTime = that.__StartTime;
+        __EndTime = that.__EndTime;
+        __Padding = that.__Padding;
+        __Label = that.__Label;
+        __Boundary = that.__Boundary == nullptr ? nullptr : that.__Boundary->clone();
+
+   }
+   
+   AbstractZone & AbstractZone::operator=(const AbstractZone &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__Boundary != nullptr) delete __Boundary;
+
+         __ZoneID = that.__ZoneID;
+         __MinAltitude = that.__MinAltitude;
+         __MinAltitudeType = that.__MinAltitudeType;
+         __MaxAltitude = that.__MaxAltitude;
+         __MaxAltitudeType = that.__MaxAltitudeType;
+         __AffectedAircraft.clear();
+         for (size_t i=0; i< that.__AffectedAircraft.size(); i++)
+         {
+            __AffectedAircraft.push_back( that.__AffectedAircraft[i]);
+         }
+         __StartTime = that.__StartTime;
+         __EndTime = that.__EndTime;
+         __Padding = that.__Padding;
+         __Label = that.__Label;
+         __Boundary = that.__Boundary == nullptr ? nullptr : that.__Boundary->clone();
+
+      }
+      return *this;
+   }
+
+   AbstractZone* AbstractZone::clone() const
+   {
+        return new AbstractZone(*this);
+   }
+   
+   AbstractZone::~AbstractZone(void)
+   {
+      if (__Boundary != nullptr) delete __Boundary;
+
+   }
+  
+   void AbstractZone::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ZoneID);
+      buf.putFloat(__MinAltitude);
+      buf.putInt( (int32_t) __MinAltitudeType);
+      buf.putFloat(__MaxAltitude);
+      buf.putInt( (int32_t) __MaxAltitudeType);
+      buf.putUShort( static_cast<uint16_t>(__AffectedAircraft.size()));
+      for (size_t i=0; i<__AffectedAircraft.size(); i++)
+      {
+         buf.putLong(__AffectedAircraft[i]);
+      }
+      buf.putLong(__StartTime);
+      buf.putLong(__EndTime);
+      buf.putFloat(__Padding);
+      buf.putString(__Label);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Boundary, buf);
+
+   }
+   
+   void AbstractZone::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ZoneID = buf.getLong();
+      __MinAltitude = buf.getFloat();
+      __MinAltitudeType = (afrl::cmasi::AltitudeType::AltitudeType) buf.getInt();
+      __MaxAltitude = buf.getFloat();
+      __MaxAltitudeType = (afrl::cmasi::AltitudeType::AltitudeType) buf.getInt();
+      __AffectedAircraft.clear();
+      uint16_t __AffectedAircraft_length = buf.getUShort();
+      for (uint32_t i=0; i< __AffectedAircraft_length; i++)
+      {
+         __AffectedAircraft.push_back(buf.getLong() );
+      }
+      __StartTime = buf.getLong();
+      __EndTime = buf.getLong();
+      __Padding = buf.getFloat();
+      __Label = buf.getString();
+      {
+         if (__Boundary != nullptr) delete __Boundary;
+         __Boundary = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Boundary = (afrl::cmasi::AbstractGeometry*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Boundary != nullptr) __Boundary->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t AbstractZone::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::AltitudeType::AltitudeType);
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::AltitudeType::AltitudeType);
+      size += 2 + sizeof(int64_t) * __AffectedAircraft.size();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += 2 + __Label.length();
+      size += (__Boundary != nullptr ? __Boundary->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string AbstractZone::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AbstractZone ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ZoneID (int64_t) = " << __ZoneID << "\n";
+      oss << indent << "MinAltitude (float) = " << __MinAltitude << "\n";
+      oss << indent << "MinAltitudeType (AltitudeType) = " << __MinAltitudeType << "\n";
+      oss << indent << "MaxAltitude (float) = " << __MaxAltitude << "\n";
+      oss << indent << "MaxAltitudeType (AltitudeType) = " << __MaxAltitudeType << "\n";
+      oss << indent << "AffectedAircraft (int64 [ " << __AffectedAircraft.size() << ", var ])\n";
+      oss << indent << "StartTime (int64_t) = " << __StartTime << "\n";
+      oss << indent << "EndTime (int64_t) = " << __EndTime << "\n";
+      oss << indent << "Padding (float) = " << __Padding << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "Boundary (AbstractGeometry)";
+      if (__Boundary == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AbstractZone::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AbstractZone Series=\"CMASI\">\n";
+      str << ws << "   <ZoneID>" << __ZoneID << "</ZoneID>\n";
+      str << ws << "   <MinAltitude>" << __MinAltitude << "</MinAltitude>\n";
+      str << ws << "   <MinAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__MinAltitudeType) << "</MinAltitudeType>\n";
+      str << ws << "   <MaxAltitude>" << __MaxAltitude << "</MaxAltitude>\n";
+      str << ws << "   <MaxAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__MaxAltitudeType) << "</MaxAltitudeType>\n";
+      str << ws << "   <AffectedAircraft>\n";
+      for (size_t i=0; i<__AffectedAircraft.size(); i++)
+      {
+         str << ws << "   <int64>" << __AffectedAircraft[i] << "</int64>\n";
+      }
+      str << ws << "   </AffectedAircraft>\n";
+      str << ws << "   <StartTime>" << __StartTime << "</StartTime>\n";
+      str << ws << "   <EndTime>" << __EndTime << "</EndTime>\n";
+      str << ws << "   <Padding>" << __Padding << "</Padding>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      if (__Boundary != nullptr)
+      {
+         str << ws << "   <Boundary>";
+         str << "\n" + __Boundary->toXML(depth + 1) + ws + "   ";
+         str << "</Boundary>\n";
+      }
+      str << ws << "</AbstractZone>\n";
+
+      return str.str();
+   }
+
+   bool AbstractZone::operator==(const AbstractZone & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ZoneID != that.__ZoneID) return false;
+      if(__MinAltitude != that.__MinAltitude) return false;
+      if(__MinAltitudeType != that.__MinAltitudeType) return false;
+      if(__MaxAltitude != that.__MaxAltitude) return false;
+      if(__MaxAltitudeType != that.__MaxAltitudeType) return false;
+      if(__AffectedAircraft.size() != that.__AffectedAircraft.size()) return false;
+      for (size_t i=0; i<__AffectedAircraft.size(); i++)
+      {
+         if(__AffectedAircraft[i] != that.__AffectedAircraft[i]) return false;
+      }
+      if(__StartTime != that.__StartTime) return false;
+      if(__EndTime != that.__EndTime) return false;
+      if(__Padding != that.__Padding) return false;
+      if(__Label != that.__Label) return false;
+      if(__Boundary && that.__Boundary)
+      {
+         if(__Boundary->getSeriesNameAsLong() != that.__Boundary->getSeriesNameAsLong()) return false;
+         if(__Boundary->getSeriesVersion() != that.__Boundary->getSeriesVersion()) return false;
+         if(__Boundary->getLmcpType() != that.__Boundary->getLmcpType()) return false;
+         if( *(__Boundary) != *(that.__Boundary) ) return false;
+      }
+      else if(__Boundary != that.__Boundary) return false;
+      return true;
+
+   }
+
+   bool AbstractZone::operator!=(const AbstractZone & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   AbstractZone& AbstractZone::setZoneID(const int64_t val)
+   {
+      __ZoneID = val;
+      return *this;
+   }
+
+   AbstractZone& AbstractZone::setMinAltitude(const float val)
+   {
+      __MinAltitude = val;
+      return *this;
+   }
+
+   AbstractZone& AbstractZone::setMinAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val)
+   {
+      __MinAltitudeType = val;
+      return *this;
+   }
+
+   AbstractZone& AbstractZone::setMaxAltitude(const float val)
+   {
+      __MaxAltitude = val;
+      return *this;
+   }
+
+   AbstractZone& AbstractZone::setMaxAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val)
+   {
+      __MaxAltitudeType = val;
+      return *this;
+   }
+
+
+   AbstractZone& AbstractZone::setStartTime(const int64_t val)
+   {
+      __StartTime = val;
+      return *this;
+   }
+
+   AbstractZone& AbstractZone::setEndTime(const int64_t val)
+   {
+      __EndTime = val;
+      return *this;
+   }
+
+   AbstractZone& AbstractZone::setPadding(const float val)
+   {
+      __Padding = val;
+      return *this;
+   }
+
+   AbstractZone& AbstractZone::setLabel(const std::string val)
+   {
+      __Label = val;
+      return *this;
+   }
+
+   AbstractZone& AbstractZone::setBoundary(const afrl::cmasi::AbstractGeometry* const val)
+   {
+      if (__Boundary != nullptr) { delete __Boundary; __Boundary = nullptr; }
+      if (val != nullptr) { __Boundary = const_cast< afrl::cmasi::AbstractGeometry* > (val); }
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiAirVehicleConfiguration.cpp b/src/LMCP/afrl/cmasi/afrlcmasiAirVehicleConfiguration.cpp
new file mode 100644
index 0000000..664f013
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiAirVehicleConfiguration.cpp
@@ -0,0 +1,452 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/AirVehicleConfiguration.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AirVehicleConfiguration::Subscription = "afrl.cmasi.AirVehicleConfiguration";
+   const std::string AirVehicleConfiguration::TypeName = "AirVehicleConfiguration";
+   
+   bool isAirVehicleConfiguration(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 13) return false;
+      return true;
+   }
+   
+   bool isAirVehicleConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 13) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AirVehicleConfigurationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   AirVehicleConfiguration::AirVehicleConfiguration(void) : afrl::cmasi::EntityConfiguration()
+   {
+      __MinimumSpeed = 0.f;
+      __MaximumSpeed = 0.f;
+      __NominalFlightProfile = new afrl::cmasi::FlightProfile();
+      __MinimumAltitude = 0.f;
+      __MinAltitudeType = afrl::cmasi::AltitudeType::AGL;
+      __MaximumAltitude = 1000000.f;
+      __MaxAltitudeType = afrl::cmasi::AltitudeType::MSL;
+
+   }
+     
+   AirVehicleConfiguration::AirVehicleConfiguration(const AirVehicleConfiguration &that) : afrl::cmasi::EntityConfiguration(that)
+   {
+        __MinimumSpeed = that.__MinimumSpeed;
+        __MaximumSpeed = that.__MaximumSpeed;
+        __NominalFlightProfile = that.__NominalFlightProfile == nullptr ? nullptr : that.__NominalFlightProfile->clone();
+        __AlternateFlightProfiles.clear();
+        for (size_t i=0; i< that.__AlternateFlightProfiles.size(); i++)
+        {
+           __AlternateFlightProfiles.push_back( that.__AlternateFlightProfiles[i] == nullptr ? nullptr : that.__AlternateFlightProfiles[i]->clone());
+        }
+        __AvailableLoiterTypes.clear();
+        for (size_t i=0; i< that.__AvailableLoiterTypes.size(); i++)
+        {
+           __AvailableLoiterTypes.push_back( that.__AvailableLoiterTypes[i]);
+        }
+        __AvailableTurnTypes.clear();
+        for (size_t i=0; i< that.__AvailableTurnTypes.size(); i++)
+        {
+           __AvailableTurnTypes.push_back( that.__AvailableTurnTypes[i]);
+        }
+        __MinimumAltitude = that.__MinimumAltitude;
+        __MinAltitudeType = that.__MinAltitudeType;
+        __MaximumAltitude = that.__MaximumAltitude;
+        __MaxAltitudeType = that.__MaxAltitudeType;
+
+   }
+   
+   AirVehicleConfiguration & AirVehicleConfiguration::operator=(const AirVehicleConfiguration &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::EntityConfiguration::operator=(that);
+         if (__NominalFlightProfile != nullptr) delete __NominalFlightProfile;
+         for (size_t i=0; i<__AlternateFlightProfiles.size(); i++)
+         {
+            if (__AlternateFlightProfiles[i] != nullptr) delete __AlternateFlightProfiles[i];
+         }
+
+         __MinimumSpeed = that.__MinimumSpeed;
+         __MaximumSpeed = that.__MaximumSpeed;
+         __NominalFlightProfile = that.__NominalFlightProfile == nullptr ? nullptr : that.__NominalFlightProfile->clone();
+         __AlternateFlightProfiles.clear();
+         for (size_t i=0; i< that.__AlternateFlightProfiles.size(); i++)
+         {
+            __AlternateFlightProfiles.push_back( that.__AlternateFlightProfiles[i] == nullptr ? nullptr : that.__AlternateFlightProfiles[i]->clone());
+         }
+         __AvailableLoiterTypes.clear();
+         for (size_t i=0; i< that.__AvailableLoiterTypes.size(); i++)
+         {
+            __AvailableLoiterTypes.push_back( that.__AvailableLoiterTypes[i]);
+         }
+         __AvailableTurnTypes.clear();
+         for (size_t i=0; i< that.__AvailableTurnTypes.size(); i++)
+         {
+            __AvailableTurnTypes.push_back( that.__AvailableTurnTypes[i]);
+         }
+         __MinimumAltitude = that.__MinimumAltitude;
+         __MinAltitudeType = that.__MinAltitudeType;
+         __MaximumAltitude = that.__MaximumAltitude;
+         __MaxAltitudeType = that.__MaxAltitudeType;
+
+      }
+      return *this;
+   }
+
+   AirVehicleConfiguration* AirVehicleConfiguration::clone() const
+   {
+        return new AirVehicleConfiguration(*this);
+   }
+   
+   AirVehicleConfiguration::~AirVehicleConfiguration(void)
+   {
+      if (__NominalFlightProfile != nullptr) delete __NominalFlightProfile;
+      for (size_t i=0; i<__AlternateFlightProfiles.size(); i++)
+      {
+         if (__AlternateFlightProfiles[i] != nullptr) delete __AlternateFlightProfiles[i];
+      }
+
+   }
+  
+   void AirVehicleConfiguration::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::EntityConfiguration::pack(buf);
+      // Copy the class into the buffer
+      buf.putFloat(__MinimumSpeed);
+      buf.putFloat(__MaximumSpeed);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __NominalFlightProfile, buf);
+      buf.putUShort( static_cast<uint16_t>(__AlternateFlightProfiles.size()));
+      for (size_t i=0; i<__AlternateFlightProfiles.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __AlternateFlightProfiles[i], buf);
+      }
+      buf.putUShort( static_cast<uint16_t>(__AvailableLoiterTypes.size()));
+      for (size_t i=0; i<__AvailableLoiterTypes.size(); i++)
+      {
+         buf.putInt( (int32_t) __AvailableLoiterTypes[i]);
+      }
+      buf.putUShort( static_cast<uint16_t>(__AvailableTurnTypes.size()));
+      for (size_t i=0; i<__AvailableTurnTypes.size(); i++)
+      {
+         buf.putInt( (int32_t) __AvailableTurnTypes[i]);
+      }
+      buf.putFloat(__MinimumAltitude);
+      buf.putInt( (int32_t) __MinAltitudeType);
+      buf.putFloat(__MaximumAltitude);
+      buf.putInt( (int32_t) __MaxAltitudeType);
+
+   }
+   
+   void AirVehicleConfiguration::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::EntityConfiguration::unpack(buf);
+      // Copy the buffer into the class
+      __MinimumSpeed = buf.getFloat();
+      __MaximumSpeed = buf.getFloat();
+      {
+         if (__NominalFlightProfile != nullptr) delete __NominalFlightProfile;
+         __NominalFlightProfile = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __NominalFlightProfile = (afrl::cmasi::FlightProfile*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__NominalFlightProfile != nullptr) __NominalFlightProfile->unpack(buf);
+         }
+      }
+      for (size_t i=0; i<__AlternateFlightProfiles.size(); i++)
+      {
+         if (__AlternateFlightProfiles[i] != nullptr)
+            delete __AlternateFlightProfiles[i];
+      }
+      __AlternateFlightProfiles.clear();
+      uint16_t __AlternateFlightProfiles_length = buf.getUShort();
+      for (uint32_t i=0; i< __AlternateFlightProfiles_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::FlightProfile* e = (afrl::cmasi::FlightProfile*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __AlternateFlightProfiles.push_back(e);
+         }
+      }
+      __AvailableLoiterTypes.clear();
+      uint16_t __AvailableLoiterTypes_length = buf.getUShort();
+      for (uint32_t i=0; i< __AvailableLoiterTypes_length; i++)
+      {
+         __AvailableLoiterTypes.push_back( (afrl::cmasi::LoiterType::LoiterType) buf.getInt() );
+      }
+      __AvailableTurnTypes.clear();
+      uint16_t __AvailableTurnTypes_length = buf.getUShort();
+      for (uint32_t i=0; i< __AvailableTurnTypes_length; i++)
+      {
+         __AvailableTurnTypes.push_back( (afrl::cmasi::TurnType::TurnType) buf.getInt() );
+      }
+      __MinimumAltitude = buf.getFloat();
+      __MinAltitudeType = (afrl::cmasi::AltitudeType::AltitudeType) buf.getInt();
+      __MaximumAltitude = buf.getFloat();
+      __MaxAltitudeType = (afrl::cmasi::AltitudeType::AltitudeType) buf.getInt();
+
+   }
+
+   uint32_t AirVehicleConfiguration::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::EntityConfiguration::calculatePackedSize();
+      size += sizeof(float);
+      size += sizeof(float);
+      size += (__NominalFlightProfile != nullptr ? __NominalFlightProfile->calculatePackedSize() + 15 : 1);
+      size += 2;
+      for (size_t i=0; i<__AlternateFlightProfiles.size(); i++)
+      {
+         if (__AlternateFlightProfiles[i] != nullptr)
+         {
+            size += __AlternateFlightProfiles[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += 2 + sizeof(afrl::cmasi::LoiterType::LoiterType) * __AvailableLoiterTypes.size();
+      size += 2 + sizeof(afrl::cmasi::TurnType::TurnType) * __AvailableTurnTypes.size();
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::AltitudeType::AltitudeType);
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::AltitudeType::AltitudeType);
+
+      return size;
+   }
+
+   std::string AirVehicleConfiguration::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AirVehicleConfiguration ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ID (int64_t) = " << __ID << "\n";
+      oss << indent << "Affiliation (std::string) = " << __Affiliation << "\n";
+      oss << indent << "EntityType (std::string) = " << __EntityType << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "NominalSpeed (float) = " << __NominalSpeed << "\n";
+      oss << indent << "NominalAltitude (float) = " << __NominalAltitude << "\n";
+      oss << indent << "NominalAltitudeType (AltitudeType) = " << __NominalAltitudeType << "\n";
+      oss << indent << "PayloadConfigurationList (PayloadConfiguration [ " << __PayloadConfigurationList.size() << ", var ])\n";
+      oss << indent << "Info (KeyValuePair [ " << __Info.size() << ", var ])\n";
+
+      oss << indent << "MinimumSpeed (float) = " << __MinimumSpeed << "\n";
+      oss << indent << "MaximumSpeed (float) = " << __MaximumSpeed << "\n";
+      oss << indent << "NominalFlightProfile (FlightProfile)";
+      if (__NominalFlightProfile == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "AlternateFlightProfiles (FlightProfile [ " << __AlternateFlightProfiles.size() << ", var ])\n";
+      oss << indent << "AvailableLoiterTypes (LoiterType [ " << __AvailableLoiterTypes.size() << ", var ])\n";
+      oss << indent << "AvailableTurnTypes (TurnType [ " << __AvailableTurnTypes.size() << ", var ])\n";
+      oss << indent << "MinimumAltitude (float) = " << __MinimumAltitude << "\n";
+      oss << indent << "MinAltitudeType (AltitudeType) = " << __MinAltitudeType << "\n";
+      oss << indent << "MaximumAltitude (float) = " << __MaximumAltitude << "\n";
+      oss << indent << "MaxAltitudeType (AltitudeType) = " << __MaxAltitudeType << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AirVehicleConfiguration::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AirVehicleConfiguration Series=\"CMASI\">\n";
+      str << ws << "   <MinimumSpeed>" << __MinimumSpeed << "</MinimumSpeed>\n";
+      str << ws << "   <MaximumSpeed>" << __MaximumSpeed << "</MaximumSpeed>\n";
+      if (__NominalFlightProfile != nullptr)
+      {
+         str << ws << "   <NominalFlightProfile>";
+         str << "\n" + __NominalFlightProfile->toXML(depth + 1) + ws + "   ";
+         str << "</NominalFlightProfile>\n";
+      }
+      str << ws << "   <AlternateFlightProfiles>\n";
+      for (size_t i=0; i<__AlternateFlightProfiles.size(); i++)
+      {
+         str << (__AlternateFlightProfiles[i] == nullptr ? ( ws + "   <null/>\n") : (__AlternateFlightProfiles[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </AlternateFlightProfiles>\n";
+      str << ws << "   <AvailableLoiterTypes>\n";
+      for (size_t i=0; i<__AvailableLoiterTypes.size(); i++)
+      {
+         str << ws << "   <LoiterType>" << afrl::cmasi::LoiterType::get_string(__AvailableLoiterTypes[i]) << "</LoiterType>\n";
+      }
+      str << ws << "   </AvailableLoiterTypes>\n";
+      str << ws << "   <AvailableTurnTypes>\n";
+      for (size_t i=0; i<__AvailableTurnTypes.size(); i++)
+      {
+         str << ws << "   <TurnType>" << afrl::cmasi::TurnType::get_string(__AvailableTurnTypes[i]) << "</TurnType>\n";
+      }
+      str << ws << "   </AvailableTurnTypes>\n";
+      str << ws << "   <MinimumAltitude>" << __MinimumAltitude << "</MinimumAltitude>\n";
+      str << ws << "   <MinAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__MinAltitudeType) << "</MinAltitudeType>\n";
+      str << ws << "   <MaximumAltitude>" << __MaximumAltitude << "</MaximumAltitude>\n";
+      str << ws << "   <MaxAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__MaxAltitudeType) << "</MaxAltitudeType>\n";
+      str << ws << "   <ID>" << __ID << "</ID>\n";
+      str << ws << "   <Affiliation>" << __Affiliation << "</Affiliation>\n";
+      str << ws << "   <EntityType>" << __EntityType << "</EntityType>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <NominalSpeed>" << __NominalSpeed << "</NominalSpeed>\n";
+      str << ws << "   <NominalAltitude>" << __NominalAltitude << "</NominalAltitude>\n";
+      str << ws << "   <NominalAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__NominalAltitudeType) << "</NominalAltitudeType>\n";
+      str << ws << "   <PayloadConfigurationList>\n";
+      for (size_t i=0; i<__PayloadConfigurationList.size(); i++)
+      {
+         str << (__PayloadConfigurationList[i] == nullptr ? ( ws + "   <null/>\n") : (__PayloadConfigurationList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PayloadConfigurationList>\n";
+      str << ws << "   <Info>\n";
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         str << (__Info[i] == nullptr ? ( ws + "   <null/>\n") : (__Info[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Info>\n";
+      str << ws << "</AirVehicleConfiguration>\n";
+
+      return str.str();
+   }
+
+   bool AirVehicleConfiguration::operator==(const AirVehicleConfiguration & that)
+   {
+      if( afrl::cmasi::EntityConfiguration::operator!=(that) )
+      {
+          return false;
+      }
+      if(__MinimumSpeed != that.__MinimumSpeed) return false;
+      if(__MaximumSpeed != that.__MaximumSpeed) return false;
+      if(__NominalFlightProfile && that.__NominalFlightProfile)
+      {
+         if(__NominalFlightProfile->getSeriesNameAsLong() != that.__NominalFlightProfile->getSeriesNameAsLong()) return false;
+         if(__NominalFlightProfile->getSeriesVersion() != that.__NominalFlightProfile->getSeriesVersion()) return false;
+         if(__NominalFlightProfile->getLmcpType() != that.__NominalFlightProfile->getLmcpType()) return false;
+         if( *(__NominalFlightProfile) != *(that.__NominalFlightProfile) ) return false;
+      }
+      else if(__NominalFlightProfile != that.__NominalFlightProfile) return false;
+      if(__AlternateFlightProfiles.size() != that.__AlternateFlightProfiles.size()) return false;
+      for (size_t i=0; i<__AlternateFlightProfiles.size(); i++)
+      {
+         if(__AlternateFlightProfiles[i] && that.__AlternateFlightProfiles[i])
+         {
+            if(__AlternateFlightProfiles[i]->getSeriesNameAsLong() != that.__AlternateFlightProfiles[i]->getSeriesNameAsLong()) return false;
+            if(__AlternateFlightProfiles[i]->getSeriesVersion() != that.__AlternateFlightProfiles[i]->getSeriesVersion()) return false;
+            if(__AlternateFlightProfiles[i]->getLmcpType() != that.__AlternateFlightProfiles[i]->getLmcpType()) return false;
+            if( *(__AlternateFlightProfiles[i]) != *(that.__AlternateFlightProfiles[i]) ) return false;
+         }
+         else if(__AlternateFlightProfiles[i] != that.__AlternateFlightProfiles[i]) return false;
+      }
+      if(__AvailableLoiterTypes.size() != that.__AvailableLoiterTypes.size()) return false;
+      for (size_t i=0; i<__AvailableLoiterTypes.size(); i++)
+      {
+         if(__AvailableLoiterTypes[i] != that.__AvailableLoiterTypes[i]) return false;
+      }
+      if(__AvailableTurnTypes.size() != that.__AvailableTurnTypes.size()) return false;
+      for (size_t i=0; i<__AvailableTurnTypes.size(); i++)
+      {
+         if(__AvailableTurnTypes[i] != that.__AvailableTurnTypes[i]) return false;
+      }
+      if(__MinimumAltitude != that.__MinimumAltitude) return false;
+      if(__MinAltitudeType != that.__MinAltitudeType) return false;
+      if(__MaximumAltitude != that.__MaximumAltitude) return false;
+      if(__MaxAltitudeType != that.__MaxAltitudeType) return false;
+      return true;
+
+   }
+
+   bool AirVehicleConfiguration::operator!=(const AirVehicleConfiguration & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   AirVehicleConfiguration& AirVehicleConfiguration::setMinimumSpeed(const float val)
+   {
+      __MinimumSpeed = val;
+      return *this;
+   }
+
+   AirVehicleConfiguration& AirVehicleConfiguration::setMaximumSpeed(const float val)
+   {
+      __MaximumSpeed = val;
+      return *this;
+   }
+
+   AirVehicleConfiguration& AirVehicleConfiguration::setNominalFlightProfile(const afrl::cmasi::FlightProfile* const val)
+   {
+      if (__NominalFlightProfile != nullptr) { delete __NominalFlightProfile; __NominalFlightProfile = nullptr; }
+      if (val != nullptr) { __NominalFlightProfile = const_cast< afrl::cmasi::FlightProfile* > (val); }
+      return *this;
+   }
+
+
+
+
+   AirVehicleConfiguration& AirVehicleConfiguration::setMinimumAltitude(const float val)
+   {
+      __MinimumAltitude = val;
+      return *this;
+   }
+
+   AirVehicleConfiguration& AirVehicleConfiguration::setMinAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val)
+   {
+      __MinAltitudeType = val;
+      return *this;
+   }
+
+   AirVehicleConfiguration& AirVehicleConfiguration::setMaximumAltitude(const float val)
+   {
+      __MaximumAltitude = val;
+      return *this;
+   }
+
+   AirVehicleConfiguration& AirVehicleConfiguration::setMaxAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val)
+   {
+      __MaxAltitudeType = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiAirVehicleState.cpp b/src/LMCP/afrl/cmasi/afrlcmasiAirVehicleState.cpp
new file mode 100644
index 0000000..7868e8b
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiAirVehicleState.cpp
@@ -0,0 +1,282 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/AirVehicleState.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AirVehicleState::Subscription = "afrl.cmasi.AirVehicleState";
+   const std::string AirVehicleState::TypeName = "AirVehicleState";
+   
+   bool isAirVehicleState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 15) return false;
+      return true;
+   }
+   
+   bool isAirVehicleState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 15) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AirVehicleStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   AirVehicleState::AirVehicleState(void) : afrl::cmasi::EntityState()
+   {
+      __Airspeed = 0.f;
+      __VerticalSpeed = 0.f;
+      __WindSpeed = 0.f;
+      __WindDirection = 0.f;
+
+   }
+     
+   AirVehicleState::AirVehicleState(const AirVehicleState &that) : afrl::cmasi::EntityState(that)
+   {
+        __Airspeed = that.__Airspeed;
+        __VerticalSpeed = that.__VerticalSpeed;
+        __WindSpeed = that.__WindSpeed;
+        __WindDirection = that.__WindDirection;
+
+   }
+   
+   AirVehicleState & AirVehicleState::operator=(const AirVehicleState &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::EntityState::operator=(that);
+
+         __Airspeed = that.__Airspeed;
+         __VerticalSpeed = that.__VerticalSpeed;
+         __WindSpeed = that.__WindSpeed;
+         __WindDirection = that.__WindDirection;
+
+      }
+      return *this;
+   }
+
+   AirVehicleState* AirVehicleState::clone() const
+   {
+        return new AirVehicleState(*this);
+   }
+   
+   AirVehicleState::~AirVehicleState(void)
+   {
+
+   }
+  
+   void AirVehicleState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::EntityState::pack(buf);
+      // Copy the class into the buffer
+      buf.putFloat(__Airspeed);
+      buf.putFloat(__VerticalSpeed);
+      buf.putFloat(__WindSpeed);
+      buf.putFloat(__WindDirection);
+
+   }
+   
+   void AirVehicleState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::EntityState::unpack(buf);
+      // Copy the buffer into the class
+      __Airspeed = buf.getFloat();
+      __VerticalSpeed = buf.getFloat();
+      __WindSpeed = buf.getFloat();
+      __WindDirection = buf.getFloat();
+
+   }
+
+   uint32_t AirVehicleState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::EntityState::calculatePackedSize();
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string AirVehicleState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AirVehicleState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ID (int64_t) = " << __ID << "\n";
+      oss << indent << "u (float) = " << __u << "\n";
+      oss << indent << "v (float) = " << __v << "\n";
+      oss << indent << "w (float) = " << __w << "\n";
+      oss << indent << "udot (float) = " << __udot << "\n";
+      oss << indent << "vdot (float) = " << __vdot << "\n";
+      oss << indent << "wdot (float) = " << __wdot << "\n";
+      oss << indent << "Heading (float) = " << __Heading << "\n";
+      oss << indent << "Pitch (float) = " << __Pitch << "\n";
+      oss << indent << "Roll (float) = " << __Roll << "\n";
+      oss << indent << "p (float) = " << __p << "\n";
+      oss << indent << "q (float) = " << __q << "\n";
+      oss << indent << "r (float) = " << __r << "\n";
+      oss << indent << "Course (float) = " << __Course << "\n";
+      oss << indent << "Groundspeed (float) = " << __Groundspeed << "\n";
+      oss << indent << "Location (Location3D)";
+      if (__Location == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "EnergyAvailable (float) = " << __EnergyAvailable << "\n";
+      oss << indent << "ActualEnergyRate (float) = " << __ActualEnergyRate << "\n";
+      oss << indent << "PayloadStateList (PayloadState [ " << __PayloadStateList.size() << ", var ])\n";
+      oss << indent << "CurrentWaypoint (int64_t) = " << __CurrentWaypoint << "\n";
+      oss << indent << "CurrentCommand (int64_t) = " << __CurrentCommand << "\n";
+      oss << indent << "Mode (NavigationMode) = " << __Mode << "\n";
+      oss << indent << "AssociatedTasks (int64 [ " << __AssociatedTasks.size() << ", var ])\n";
+      oss << indent << "Time (int64_t) = " << __Time << "\n";
+      oss << indent << "Info (KeyValuePair [ " << __Info.size() << ", var ])\n";
+
+      oss << indent << "Airspeed (float) = " << __Airspeed << "\n";
+      oss << indent << "VerticalSpeed (float) = " << __VerticalSpeed << "\n";
+      oss << indent << "WindSpeed (float) = " << __WindSpeed << "\n";
+      oss << indent << "WindDirection (float) = " << __WindDirection << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AirVehicleState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AirVehicleState Series=\"CMASI\">\n";
+      str << ws << "   <Airspeed>" << __Airspeed << "</Airspeed>\n";
+      str << ws << "   <VerticalSpeed>" << __VerticalSpeed << "</VerticalSpeed>\n";
+      str << ws << "   <WindSpeed>" << __WindSpeed << "</WindSpeed>\n";
+      str << ws << "   <WindDirection>" << __WindDirection << "</WindDirection>\n";
+      str << ws << "   <ID>" << __ID << "</ID>\n";
+      str << ws << "   <u>" << __u << "</u>\n";
+      str << ws << "   <v>" << __v << "</v>\n";
+      str << ws << "   <w>" << __w << "</w>\n";
+      str << ws << "   <udot>" << __udot << "</udot>\n";
+      str << ws << "   <vdot>" << __vdot << "</vdot>\n";
+      str << ws << "   <wdot>" << __wdot << "</wdot>\n";
+      str << ws << "   <Heading>" << __Heading << "</Heading>\n";
+      str << ws << "   <Pitch>" << __Pitch << "</Pitch>\n";
+      str << ws << "   <Roll>" << __Roll << "</Roll>\n";
+      str << ws << "   <p>" << __p << "</p>\n";
+      str << ws << "   <q>" << __q << "</q>\n";
+      str << ws << "   <r>" << __r << "</r>\n";
+      str << ws << "   <Course>" << __Course << "</Course>\n";
+      str << ws << "   <Groundspeed>" << __Groundspeed << "</Groundspeed>\n";
+      if (__Location != nullptr)
+      {
+         str << ws << "   <Location>";
+         str << "\n" + __Location->toXML(depth + 1) + ws + "   ";
+         str << "</Location>\n";
+      }
+      str << ws << "   <EnergyAvailable>" << __EnergyAvailable << "</EnergyAvailable>\n";
+      str << ws << "   <ActualEnergyRate>" << __ActualEnergyRate << "</ActualEnergyRate>\n";
+      str << ws << "   <PayloadStateList>\n";
+      for (size_t i=0; i<__PayloadStateList.size(); i++)
+      {
+         str << (__PayloadStateList[i] == nullptr ? ( ws + "   <null/>\n") : (__PayloadStateList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PayloadStateList>\n";
+      str << ws << "   <CurrentWaypoint>" << __CurrentWaypoint << "</CurrentWaypoint>\n";
+      str << ws << "   <CurrentCommand>" << __CurrentCommand << "</CurrentCommand>\n";
+      str << ws << "   <Mode>" << afrl::cmasi::NavigationMode::get_string(__Mode) << "</Mode>\n";
+      str << ws << "   <AssociatedTasks>\n";
+      for (size_t i=0; i<__AssociatedTasks.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTasks[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTasks>\n";
+      str << ws << "   <Time>" << __Time << "</Time>\n";
+      str << ws << "   <Info>\n";
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         str << (__Info[i] == nullptr ? ( ws + "   <null/>\n") : (__Info[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Info>\n";
+      str << ws << "</AirVehicleState>\n";
+
+      return str.str();
+   }
+
+   bool AirVehicleState::operator==(const AirVehicleState & that)
+   {
+      if( afrl::cmasi::EntityState::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Airspeed != that.__Airspeed) return false;
+      if(__VerticalSpeed != that.__VerticalSpeed) return false;
+      if(__WindSpeed != that.__WindSpeed) return false;
+      if(__WindDirection != that.__WindDirection) return false;
+      return true;
+
+   }
+
+   bool AirVehicleState::operator!=(const AirVehicleState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   AirVehicleState& AirVehicleState::setAirspeed(const float val)
+   {
+      __Airspeed = val;
+      return *this;
+   }
+
+   AirVehicleState& AirVehicleState::setVerticalSpeed(const float val)
+   {
+      __VerticalSpeed = val;
+      return *this;
+   }
+
+   AirVehicleState& AirVehicleState::setWindSpeed(const float val)
+   {
+      __WindSpeed = val;
+      return *this;
+   }
+
+   AirVehicleState& AirVehicleState::setWindDirection(const float val)
+   {
+      __WindDirection = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiAreaSearchTask.cpp b/src/LMCP/afrl/cmasi/afrlcmasiAreaSearchTask.cpp
new file mode 100644
index 0000000..51d67dd
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiAreaSearchTask.cpp
@@ -0,0 +1,303 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/AreaSearchTask.h"
+#include "afrl/cmasi/Circle.h"
+#include "afrl/cmasi/Polygon.h"
+#include "afrl/cmasi/Rectangle.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AreaSearchTask::Subscription = "afrl.cmasi.AreaSearchTask";
+   const std::string AreaSearchTask::TypeName = "AreaSearchTask";
+   
+   bool isAreaSearchTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 17) return false;
+      return true;
+   }
+   
+   bool isAreaSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 17) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AreaSearchTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   AreaSearchTask::AreaSearchTask(void) : afrl::cmasi::SearchTask()
+   {
+      __SearchArea = new afrl::cmasi::AbstractGeometry();
+
+   }
+     
+   AreaSearchTask::AreaSearchTask(const AreaSearchTask &that) : afrl::cmasi::SearchTask(that)
+   {
+        __SearchArea = that.__SearchArea == nullptr ? nullptr : that.__SearchArea->clone();
+        __ViewAngleList.clear();
+        for (size_t i=0; i< that.__ViewAngleList.size(); i++)
+        {
+           __ViewAngleList.push_back( that.__ViewAngleList[i] == nullptr ? nullptr : that.__ViewAngleList[i]->clone());
+        }
+
+   }
+   
+   AreaSearchTask & AreaSearchTask::operator=(const AreaSearchTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::SearchTask::operator=(that);
+         if (__SearchArea != nullptr) delete __SearchArea;
+         for (size_t i=0; i<__ViewAngleList.size(); i++)
+         {
+            if (__ViewAngleList[i] != nullptr) delete __ViewAngleList[i];
+         }
+
+         __SearchArea = that.__SearchArea == nullptr ? nullptr : that.__SearchArea->clone();
+         __ViewAngleList.clear();
+         for (size_t i=0; i< that.__ViewAngleList.size(); i++)
+         {
+            __ViewAngleList.push_back( that.__ViewAngleList[i] == nullptr ? nullptr : that.__ViewAngleList[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   AreaSearchTask* AreaSearchTask::clone() const
+   {
+        return new AreaSearchTask(*this);
+   }
+   
+   AreaSearchTask::~AreaSearchTask(void)
+   {
+      if (__SearchArea != nullptr) delete __SearchArea;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr) delete __ViewAngleList[i];
+      }
+
+   }
+  
+   void AreaSearchTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::SearchTask::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __SearchArea, buf);
+      buf.putUShort( static_cast<uint16_t>(__ViewAngleList.size()));
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __ViewAngleList[i], buf);
+      }
+
+   }
+   
+   void AreaSearchTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::SearchTask::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__SearchArea != nullptr) delete __SearchArea;
+         __SearchArea = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __SearchArea = (afrl::cmasi::AbstractGeometry*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__SearchArea != nullptr) __SearchArea->unpack(buf);
+         }
+      }
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr)
+            delete __ViewAngleList[i];
+      }
+      __ViewAngleList.clear();
+      uint16_t __ViewAngleList_length = buf.getUShort();
+      for (uint32_t i=0; i< __ViewAngleList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Wedge* e = (afrl::cmasi::Wedge*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __ViewAngleList.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t AreaSearchTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::SearchTask::calculatePackedSize();
+      size += (__SearchArea != nullptr ? __SearchArea->calculatePackedSize() + 15 : 1);
+      size += 2;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr)
+         {
+            size += __ViewAngleList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string AreaSearchTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AreaSearchTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "DesiredWavelengthBands (WavelengthBand [ " << __DesiredWavelengthBands.size() << ", var ])\n";
+      oss << indent << "DwellTime (int64_t) = " << __DwellTime << "\n";
+      oss << indent << "GroundSampleDistance (float) = " << __GroundSampleDistance << "\n";
+
+      oss << indent << "SearchArea (AbstractGeometry)";
+      if (__SearchArea == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "ViewAngleList (Wedge [ " << __ViewAngleList.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AreaSearchTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AreaSearchTask Series=\"CMASI\">\n";
+      if (__SearchArea != nullptr)
+      {
+         str << ws << "   <SearchArea>";
+         str << "\n" + __SearchArea->toXML(depth + 1) + ws + "   ";
+         str << "</SearchArea>\n";
+      }
+      str << ws << "   <ViewAngleList>\n";
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         str << (__ViewAngleList[i] == nullptr ? ( ws + "   <null/>\n") : (__ViewAngleList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </ViewAngleList>\n";
+      str << ws << "   <DesiredWavelengthBands>\n";
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         str << ws << "   <WavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__DesiredWavelengthBands[i]) << "</WavelengthBand>\n";
+      }
+      str << ws << "   </DesiredWavelengthBands>\n";
+      str << ws << "   <DwellTime>" << __DwellTime << "</DwellTime>\n";
+      str << ws << "   <GroundSampleDistance>" << __GroundSampleDistance << "</GroundSampleDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</AreaSearchTask>\n";
+
+      return str.str();
+   }
+
+   bool AreaSearchTask::operator==(const AreaSearchTask & that)
+   {
+      if( afrl::cmasi::SearchTask::operator!=(that) )
+      {
+          return false;
+      }
+      if(__SearchArea && that.__SearchArea)
+      {
+         if(__SearchArea->getSeriesNameAsLong() != that.__SearchArea->getSeriesNameAsLong()) return false;
+         if(__SearchArea->getSeriesVersion() != that.__SearchArea->getSeriesVersion()) return false;
+         if(__SearchArea->getLmcpType() != that.__SearchArea->getLmcpType()) return false;
+         if( *(__SearchArea) != *(that.__SearchArea) ) return false;
+      }
+      else if(__SearchArea != that.__SearchArea) return false;
+      if(__ViewAngleList.size() != that.__ViewAngleList.size()) return false;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if(__ViewAngleList[i] && that.__ViewAngleList[i])
+         {
+            if(__ViewAngleList[i]->getSeriesNameAsLong() != that.__ViewAngleList[i]->getSeriesNameAsLong()) return false;
+            if(__ViewAngleList[i]->getSeriesVersion() != that.__ViewAngleList[i]->getSeriesVersion()) return false;
+            if(__ViewAngleList[i]->getLmcpType() != that.__ViewAngleList[i]->getLmcpType()) return false;
+            if( *(__ViewAngleList[i]) != *(that.__ViewAngleList[i]) ) return false;
+         }
+         else if(__ViewAngleList[i] != that.__ViewAngleList[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool AreaSearchTask::operator!=(const AreaSearchTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   AreaSearchTask& AreaSearchTask::setSearchArea(const afrl::cmasi::AbstractGeometry* const val)
+   {
+      if (__SearchArea != nullptr) { delete __SearchArea; __SearchArea = nullptr; }
+      if (val != nullptr) { __SearchArea = const_cast< afrl::cmasi::AbstractGeometry* > (val); }
+      return *this;
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiAutomationRequest.cpp b/src/LMCP/afrl/cmasi/afrlcmasiAutomationRequest.cpp
new file mode 100644
index 0000000..79f87f4
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiAutomationRequest.cpp
@@ -0,0 +1,263 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/AutomationRequest.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AutomationRequest::Subscription = "afrl.cmasi.AutomationRequest";
+   const std::string AutomationRequest::TypeName = "AutomationRequest";
+   
+   bool isAutomationRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 40) return false;
+      return true;
+   }
+   
+   bool isAutomationRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 40) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AutomationRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   AutomationRequest::AutomationRequest(void) : avtas::lmcp::Object()
+   {
+      __TaskRelationships = std::string("");
+      __OperatingRegion = 0LL;
+      __RedoAllTasks = false;
+
+   }
+     
+   AutomationRequest::AutomationRequest(const AutomationRequest &that) : avtas::lmcp::Object(that)
+   {
+        __EntityList.clear();
+        for (size_t i=0; i< that.__EntityList.size(); i++)
+        {
+           __EntityList.push_back( that.__EntityList[i]);
+        }
+        __TaskList.clear();
+        for (size_t i=0; i< that.__TaskList.size(); i++)
+        {
+           __TaskList.push_back( that.__TaskList[i]);
+        }
+        __TaskRelationships = that.__TaskRelationships;
+        __OperatingRegion = that.__OperatingRegion;
+        __RedoAllTasks = that.__RedoAllTasks;
+
+   }
+   
+   AutomationRequest & AutomationRequest::operator=(const AutomationRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __EntityList.clear();
+         for (size_t i=0; i< that.__EntityList.size(); i++)
+         {
+            __EntityList.push_back( that.__EntityList[i]);
+         }
+         __TaskList.clear();
+         for (size_t i=0; i< that.__TaskList.size(); i++)
+         {
+            __TaskList.push_back( that.__TaskList[i]);
+         }
+         __TaskRelationships = that.__TaskRelationships;
+         __OperatingRegion = that.__OperatingRegion;
+         __RedoAllTasks = that.__RedoAllTasks;
+
+      }
+      return *this;
+   }
+
+   AutomationRequest* AutomationRequest::clone() const
+   {
+        return new AutomationRequest(*this);
+   }
+   
+   AutomationRequest::~AutomationRequest(void)
+   {
+
+   }
+  
+   void AutomationRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__EntityList.size()));
+      for (size_t i=0; i<__EntityList.size(); i++)
+      {
+         buf.putLong(__EntityList[i]);
+      }
+      buf.putUShort( static_cast<uint16_t>(__TaskList.size()));
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         buf.putLong(__TaskList[i]);
+      }
+      buf.putString(__TaskRelationships);
+      buf.putLong(__OperatingRegion);
+      buf.putBool(__RedoAllTasks);
+
+   }
+   
+   void AutomationRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __EntityList.clear();
+      uint16_t __EntityList_length = buf.getUShort();
+      for (uint32_t i=0; i< __EntityList_length; i++)
+      {
+         __EntityList.push_back(buf.getLong() );
+      }
+      __TaskList.clear();
+      uint16_t __TaskList_length = buf.getUShort();
+      for (uint32_t i=0; i< __TaskList_length; i++)
+      {
+         __TaskList.push_back(buf.getLong() );
+      }
+      __TaskRelationships = buf.getString();
+      __OperatingRegion = buf.getLong();
+      __RedoAllTasks = buf.getBool();
+
+   }
+
+   uint32_t AutomationRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2 + sizeof(int64_t) * __EntityList.size();
+      size += 2 + sizeof(int64_t) * __TaskList.size();
+      size += 2 + __TaskRelationships.length();
+      size += sizeof(int64_t);
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string AutomationRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AutomationRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "EntityList (int64 [ " << __EntityList.size() << ", var ])\n";
+      oss << indent << "TaskList (int64 [ " << __TaskList.size() << ", var ])\n";
+      oss << indent << "TaskRelationships (std::string) = " << __TaskRelationships << "\n";
+      oss << indent << "OperatingRegion (int64_t) = " << __OperatingRegion << "\n";
+      oss << indent << "RedoAllTasks (bool) = " << __RedoAllTasks << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AutomationRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AutomationRequest Series=\"CMASI\">\n";
+      str << ws << "   <EntityList>\n";
+      for (size_t i=0; i<__EntityList.size(); i++)
+      {
+         str << ws << "   <int64>" << __EntityList[i] << "</int64>\n";
+      }
+      str << ws << "   </EntityList>\n";
+      str << ws << "   <TaskList>\n";
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __TaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </TaskList>\n";
+      str << ws << "   <TaskRelationships>" << __TaskRelationships << "</TaskRelationships>\n";
+      str << ws << "   <OperatingRegion>" << __OperatingRegion << "</OperatingRegion>\n";
+      str << ws << "   <RedoAllTasks>" << (__RedoAllTasks ? "true" : "false") << "</RedoAllTasks>\n";
+      str << ws << "</AutomationRequest>\n";
+
+      return str.str();
+   }
+
+   bool AutomationRequest::operator==(const AutomationRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__EntityList.size() != that.__EntityList.size()) return false;
+      for (size_t i=0; i<__EntityList.size(); i++)
+      {
+         if(__EntityList[i] != that.__EntityList[i]) return false;
+      }
+      if(__TaskList.size() != that.__TaskList.size()) return false;
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         if(__TaskList[i] != that.__TaskList[i]) return false;
+      }
+      if(__TaskRelationships != that.__TaskRelationships) return false;
+      if(__OperatingRegion != that.__OperatingRegion) return false;
+      if(__RedoAllTasks != that.__RedoAllTasks) return false;
+      return true;
+
+   }
+
+   bool AutomationRequest::operator!=(const AutomationRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+   AutomationRequest& AutomationRequest::setTaskRelationships(const std::string val)
+   {
+      __TaskRelationships = val;
+      return *this;
+   }
+
+   AutomationRequest& AutomationRequest::setOperatingRegion(const int64_t val)
+   {
+      __OperatingRegion = val;
+      return *this;
+   }
+
+   AutomationRequest& AutomationRequest::setRedoAllTasks(const bool val)
+   {
+      __RedoAllTasks = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiAutomationResponse.cpp b/src/LMCP/afrl/cmasi/afrlcmasiAutomationResponse.cpp
new file mode 100644
index 0000000..1cb48ff
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiAutomationResponse.cpp
@@ -0,0 +1,363 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/AutomationResponse.h"
+#include "afrl/cmasi/MissionCommand.h"
+#include "afrl/cmasi/FollowPathCommand.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AutomationResponse::Subscription = "afrl.cmasi.AutomationResponse";
+   const std::string AutomationResponse::TypeName = "AutomationResponse";
+   
+   bool isAutomationResponse(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 51) return false;
+      return true;
+   }
+   
+   bool isAutomationResponse(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 51) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AutomationResponseDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   AutomationResponse::AutomationResponse(void) : avtas::lmcp::Object()
+   {
+
+   }
+     
+   AutomationResponse::AutomationResponse(const AutomationResponse &that) : avtas::lmcp::Object(that)
+   {
+        __MissionCommandList.clear();
+        for (size_t i=0; i< that.__MissionCommandList.size(); i++)
+        {
+           __MissionCommandList.push_back( that.__MissionCommandList[i] == nullptr ? nullptr : that.__MissionCommandList[i]->clone());
+        }
+        __VehicleCommandList.clear();
+        for (size_t i=0; i< that.__VehicleCommandList.size(); i++)
+        {
+           __VehicleCommandList.push_back( that.__VehicleCommandList[i] == nullptr ? nullptr : that.__VehicleCommandList[i]->clone());
+        }
+        __Info.clear();
+        for (size_t i=0; i< that.__Info.size(); i++)
+        {
+           __Info.push_back( that.__Info[i] == nullptr ? nullptr : that.__Info[i]->clone());
+        }
+
+   }
+   
+   AutomationResponse & AutomationResponse::operator=(const AutomationResponse &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__MissionCommandList.size(); i++)
+         {
+            if (__MissionCommandList[i] != nullptr) delete __MissionCommandList[i];
+         }
+         for (size_t i=0; i<__VehicleCommandList.size(); i++)
+         {
+            if (__VehicleCommandList[i] != nullptr) delete __VehicleCommandList[i];
+         }
+         for (size_t i=0; i<__Info.size(); i++)
+         {
+            if (__Info[i] != nullptr) delete __Info[i];
+         }
+
+         __MissionCommandList.clear();
+         for (size_t i=0; i< that.__MissionCommandList.size(); i++)
+         {
+            __MissionCommandList.push_back( that.__MissionCommandList[i] == nullptr ? nullptr : that.__MissionCommandList[i]->clone());
+         }
+         __VehicleCommandList.clear();
+         for (size_t i=0; i< that.__VehicleCommandList.size(); i++)
+         {
+            __VehicleCommandList.push_back( that.__VehicleCommandList[i] == nullptr ? nullptr : that.__VehicleCommandList[i]->clone());
+         }
+         __Info.clear();
+         for (size_t i=0; i< that.__Info.size(); i++)
+         {
+            __Info.push_back( that.__Info[i] == nullptr ? nullptr : that.__Info[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   AutomationResponse* AutomationResponse::clone() const
+   {
+        return new AutomationResponse(*this);
+   }
+   
+   AutomationResponse::~AutomationResponse(void)
+   {
+      for (size_t i=0; i<__MissionCommandList.size(); i++)
+      {
+         if (__MissionCommandList[i] != nullptr) delete __MissionCommandList[i];
+      }
+      for (size_t i=0; i<__VehicleCommandList.size(); i++)
+      {
+         if (__VehicleCommandList[i] != nullptr) delete __VehicleCommandList[i];
+      }
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if (__Info[i] != nullptr) delete __Info[i];
+      }
+
+   }
+  
+   void AutomationResponse::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__MissionCommandList.size()));
+      for (size_t i=0; i<__MissionCommandList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __MissionCommandList[i], buf);
+      }
+      buf.putUShort( static_cast<uint16_t>(__VehicleCommandList.size()));
+      for (size_t i=0; i<__VehicleCommandList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __VehicleCommandList[i], buf);
+      }
+      buf.putUShort( static_cast<uint16_t>(__Info.size()));
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Info[i], buf);
+      }
+
+   }
+   
+   void AutomationResponse::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      for (size_t i=0; i<__MissionCommandList.size(); i++)
+      {
+         if (__MissionCommandList[i] != nullptr)
+            delete __MissionCommandList[i];
+      }
+      __MissionCommandList.clear();
+      uint16_t __MissionCommandList_length = buf.getUShort();
+      for (uint32_t i=0; i< __MissionCommandList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::MissionCommand* e = (afrl::cmasi::MissionCommand*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __MissionCommandList.push_back(e);
+         }
+      }
+      for (size_t i=0; i<__VehicleCommandList.size(); i++)
+      {
+         if (__VehicleCommandList[i] != nullptr)
+            delete __VehicleCommandList[i];
+      }
+      __VehicleCommandList.clear();
+      uint16_t __VehicleCommandList_length = buf.getUShort();
+      for (uint32_t i=0; i< __VehicleCommandList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::VehicleActionCommand* e = (afrl::cmasi::VehicleActionCommand*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __VehicleCommandList.push_back(e);
+         }
+      }
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if (__Info[i] != nullptr)
+            delete __Info[i];
+      }
+      __Info.clear();
+      uint16_t __Info_length = buf.getUShort();
+      for (uint32_t i=0; i< __Info_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::KeyValuePair* e = (afrl::cmasi::KeyValuePair*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Info.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t AutomationResponse::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2;
+      for (size_t i=0; i<__MissionCommandList.size(); i++)
+      {
+         if (__MissionCommandList[i] != nullptr)
+         {
+            size += __MissionCommandList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += 2;
+      for (size_t i=0; i<__VehicleCommandList.size(); i++)
+      {
+         if (__VehicleCommandList[i] != nullptr)
+         {
+            size += __VehicleCommandList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += 2;
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if (__Info[i] != nullptr)
+         {
+            size += __Info[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string AutomationResponse::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AutomationResponse ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "MissionCommandList (MissionCommand [ " << __MissionCommandList.size() << ", var ])\n";
+      oss << indent << "VehicleCommandList (VehicleActionCommand [ " << __VehicleCommandList.size() << ", var ])\n";
+      oss << indent << "Info (KeyValuePair [ " << __Info.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AutomationResponse::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AutomationResponse Series=\"CMASI\">\n";
+      str << ws << "   <MissionCommandList>\n";
+      for (size_t i=0; i<__MissionCommandList.size(); i++)
+      {
+         str << (__MissionCommandList[i] == nullptr ? ( ws + "   <null/>\n") : (__MissionCommandList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </MissionCommandList>\n";
+      str << ws << "   <VehicleCommandList>\n";
+      for (size_t i=0; i<__VehicleCommandList.size(); i++)
+      {
+         str << (__VehicleCommandList[i] == nullptr ? ( ws + "   <null/>\n") : (__VehicleCommandList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </VehicleCommandList>\n";
+      str << ws << "   <Info>\n";
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         str << (__Info[i] == nullptr ? ( ws + "   <null/>\n") : (__Info[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Info>\n";
+      str << ws << "</AutomationResponse>\n";
+
+      return str.str();
+   }
+
+   bool AutomationResponse::operator==(const AutomationResponse & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__MissionCommandList.size() != that.__MissionCommandList.size()) return false;
+      for (size_t i=0; i<__MissionCommandList.size(); i++)
+      {
+         if(__MissionCommandList[i] && that.__MissionCommandList[i])
+         {
+            if(__MissionCommandList[i]->getSeriesNameAsLong() != that.__MissionCommandList[i]->getSeriesNameAsLong()) return false;
+            if(__MissionCommandList[i]->getSeriesVersion() != that.__MissionCommandList[i]->getSeriesVersion()) return false;
+            if(__MissionCommandList[i]->getLmcpType() != that.__MissionCommandList[i]->getLmcpType()) return false;
+            if( *(__MissionCommandList[i]) != *(that.__MissionCommandList[i]) ) return false;
+         }
+         else if(__MissionCommandList[i] != that.__MissionCommandList[i]) return false;
+      }
+      if(__VehicleCommandList.size() != that.__VehicleCommandList.size()) return false;
+      for (size_t i=0; i<__VehicleCommandList.size(); i++)
+      {
+         if(__VehicleCommandList[i] && that.__VehicleCommandList[i])
+         {
+            if(__VehicleCommandList[i]->getSeriesNameAsLong() != that.__VehicleCommandList[i]->getSeriesNameAsLong()) return false;
+            if(__VehicleCommandList[i]->getSeriesVersion() != that.__VehicleCommandList[i]->getSeriesVersion()) return false;
+            if(__VehicleCommandList[i]->getLmcpType() != that.__VehicleCommandList[i]->getLmcpType()) return false;
+            if( *(__VehicleCommandList[i]) != *(that.__VehicleCommandList[i]) ) return false;
+         }
+         else if(__VehicleCommandList[i] != that.__VehicleCommandList[i]) return false;
+      }
+      if(__Info.size() != that.__Info.size()) return false;
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if(__Info[i] && that.__Info[i])
+         {
+            if(__Info[i]->getSeriesNameAsLong() != that.__Info[i]->getSeriesNameAsLong()) return false;
+            if(__Info[i]->getSeriesVersion() != that.__Info[i]->getSeriesVersion()) return false;
+            if(__Info[i]->getLmcpType() != that.__Info[i]->getLmcpType()) return false;
+            if( *(__Info[i]) != *(that.__Info[i]) ) return false;
+         }
+         else if(__Info[i] != that.__Info[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool AutomationResponse::operator!=(const AutomationResponse & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiCameraAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiCameraAction.cpp
new file mode 100644
index 0000000..56240a9
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiCameraAction.cpp
@@ -0,0 +1,249 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/CameraAction.h"
+#include "afrl/cmasi/CameraAction.h"
+#include "afrl/cmasi/GimbalAngleAction.h"
+#include "afrl/cmasi/GimbalScanAction.h"
+#include "afrl/cmasi/GimbalStareAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string CameraAction::Subscription = "afrl.cmasi.CameraAction";
+   const std::string CameraAction::TypeName = "CameraAction";
+   
+   bool isCameraAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 18) return false;
+      return true;
+   }
+   
+   bool isCameraAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 18) return false;
+      return true;
+   }
+   
+   std::vector< std::string > CameraActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   CameraAction::CameraAction(void) : afrl::cmasi::PayloadAction()
+   {
+      __HorizontalFieldOfView = 0.f;
+
+   }
+     
+   CameraAction::CameraAction(const CameraAction &that) : afrl::cmasi::PayloadAction(that)
+   {
+        __HorizontalFieldOfView = that.__HorizontalFieldOfView;
+        __AssociatedActions.clear();
+        for (size_t i=0; i< that.__AssociatedActions.size(); i++)
+        {
+           __AssociatedActions.push_back( that.__AssociatedActions[i] == nullptr ? nullptr : that.__AssociatedActions[i]->clone());
+        }
+
+   }
+   
+   CameraAction & CameraAction::operator=(const CameraAction &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadAction::operator=(that);
+         for (size_t i=0; i<__AssociatedActions.size(); i++)
+         {
+            if (__AssociatedActions[i] != nullptr) delete __AssociatedActions[i];
+         }
+
+         __HorizontalFieldOfView = that.__HorizontalFieldOfView;
+         __AssociatedActions.clear();
+         for (size_t i=0; i< that.__AssociatedActions.size(); i++)
+         {
+            __AssociatedActions.push_back( that.__AssociatedActions[i] == nullptr ? nullptr : that.__AssociatedActions[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   CameraAction* CameraAction::clone() const
+   {
+        return new CameraAction(*this);
+   }
+   
+   CameraAction::~CameraAction(void)
+   {
+      for (size_t i=0; i<__AssociatedActions.size(); i++)
+      {
+         if (__AssociatedActions[i] != nullptr) delete __AssociatedActions[i];
+      }
+
+   }
+  
+   void CameraAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadAction::pack(buf);
+      // Copy the class into the buffer
+      buf.putFloat(__HorizontalFieldOfView);
+      buf.putUShort( static_cast<uint16_t>(__AssociatedActions.size()));
+      for (size_t i=0; i<__AssociatedActions.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __AssociatedActions[i], buf);
+      }
+
+   }
+   
+   void CameraAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadAction::unpack(buf);
+      // Copy the buffer into the class
+      __HorizontalFieldOfView = buf.getFloat();
+      for (size_t i=0; i<__AssociatedActions.size(); i++)
+      {
+         if (__AssociatedActions[i] != nullptr)
+            delete __AssociatedActions[i];
+      }
+      __AssociatedActions.clear();
+      uint16_t __AssociatedActions_length = buf.getUShort();
+      for (uint32_t i=0; i< __AssociatedActions_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::PayloadAction* e = (afrl::cmasi::PayloadAction*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __AssociatedActions.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t CameraAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadAction::calculatePackedSize();
+      size += sizeof(float);
+      size += 2;
+      for (size_t i=0; i<__AssociatedActions.size(); i++)
+      {
+         if (__AssociatedActions[i] != nullptr)
+         {
+            size += __AssociatedActions[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string CameraAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( CameraAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+
+      oss << indent << "HorizontalFieldOfView (float) = " << __HorizontalFieldOfView << "\n";
+      oss << indent << "AssociatedActions (PayloadAction [ " << __AssociatedActions.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string CameraAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<CameraAction Series=\"CMASI\">\n";
+      str << ws << "   <HorizontalFieldOfView>" << __HorizontalFieldOfView << "</HorizontalFieldOfView>\n";
+      str << ws << "   <AssociatedActions>\n";
+      for (size_t i=0; i<__AssociatedActions.size(); i++)
+      {
+         str << (__AssociatedActions[i] == nullptr ? ( ws + "   <null/>\n") : (__AssociatedActions[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </AssociatedActions>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</CameraAction>\n";
+
+      return str.str();
+   }
+
+   bool CameraAction::operator==(const CameraAction & that)
+   {
+      if( afrl::cmasi::PayloadAction::operator!=(that) )
+      {
+          return false;
+      }
+      if(__HorizontalFieldOfView != that.__HorizontalFieldOfView) return false;
+      if(__AssociatedActions.size() != that.__AssociatedActions.size()) return false;
+      for (size_t i=0; i<__AssociatedActions.size(); i++)
+      {
+         if(__AssociatedActions[i] && that.__AssociatedActions[i])
+         {
+            if(__AssociatedActions[i]->getSeriesNameAsLong() != that.__AssociatedActions[i]->getSeriesNameAsLong()) return false;
+            if(__AssociatedActions[i]->getSeriesVersion() != that.__AssociatedActions[i]->getSeriesVersion()) return false;
+            if(__AssociatedActions[i]->getLmcpType() != that.__AssociatedActions[i]->getLmcpType()) return false;
+            if( *(__AssociatedActions[i]) != *(that.__AssociatedActions[i]) ) return false;
+         }
+         else if(__AssociatedActions[i] != that.__AssociatedActions[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool CameraAction::operator!=(const CameraAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   CameraAction& CameraAction::setHorizontalFieldOfView(const float val)
+   {
+      __HorizontalFieldOfView = val;
+      return *this;
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiCameraConfiguration.cpp b/src/LMCP/afrl/cmasi/afrlcmasiCameraConfiguration.cpp
new file mode 100644
index 0000000..8b98599
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiCameraConfiguration.cpp
@@ -0,0 +1,285 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/CameraConfiguration.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string CameraConfiguration::Subscription = "afrl.cmasi.CameraConfiguration";
+   const std::string CameraConfiguration::TypeName = "CameraConfiguration";
+   
+   bool isCameraConfiguration(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 19) return false;
+      return true;
+   }
+   
+   bool isCameraConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 19) return false;
+      return true;
+   }
+   
+   std::vector< std::string > CameraConfigurationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   CameraConfiguration::CameraConfiguration(void) : afrl::cmasi::PayloadConfiguration()
+   {
+      __SupportedWavelengthBand = afrl::cmasi::WavelengthBand::EO;
+      __FieldOfViewMode = afrl::cmasi::FOVOperationMode::Continuous;
+      __MinHorizontalFieldOfView = 0.f;
+      __MaxHorizontalFieldOfView = 0.f;
+      __VideoStreamHorizontalResolution = 0;
+      __VideoStreamVerticalResolution = 0;
+
+   }
+     
+   CameraConfiguration::CameraConfiguration(const CameraConfiguration &that) : afrl::cmasi::PayloadConfiguration(that)
+   {
+        __SupportedWavelengthBand = that.__SupportedWavelengthBand;
+        __FieldOfViewMode = that.__FieldOfViewMode;
+        __MinHorizontalFieldOfView = that.__MinHorizontalFieldOfView;
+        __MaxHorizontalFieldOfView = that.__MaxHorizontalFieldOfView;
+        __DiscreteHorizontalFieldOfViewList.clear();
+        for (size_t i=0; i< that.__DiscreteHorizontalFieldOfViewList.size(); i++)
+        {
+           __DiscreteHorizontalFieldOfViewList.push_back( that.__DiscreteHorizontalFieldOfViewList[i]);
+        }
+        __VideoStreamHorizontalResolution = that.__VideoStreamHorizontalResolution;
+        __VideoStreamVerticalResolution = that.__VideoStreamVerticalResolution;
+
+   }
+   
+   CameraConfiguration & CameraConfiguration::operator=(const CameraConfiguration &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadConfiguration::operator=(that);
+
+         __SupportedWavelengthBand = that.__SupportedWavelengthBand;
+         __FieldOfViewMode = that.__FieldOfViewMode;
+         __MinHorizontalFieldOfView = that.__MinHorizontalFieldOfView;
+         __MaxHorizontalFieldOfView = that.__MaxHorizontalFieldOfView;
+         __DiscreteHorizontalFieldOfViewList.clear();
+         for (size_t i=0; i< that.__DiscreteHorizontalFieldOfViewList.size(); i++)
+         {
+            __DiscreteHorizontalFieldOfViewList.push_back( that.__DiscreteHorizontalFieldOfViewList[i]);
+         }
+         __VideoStreamHorizontalResolution = that.__VideoStreamHorizontalResolution;
+         __VideoStreamVerticalResolution = that.__VideoStreamVerticalResolution;
+
+      }
+      return *this;
+   }
+
+   CameraConfiguration* CameraConfiguration::clone() const
+   {
+        return new CameraConfiguration(*this);
+   }
+   
+   CameraConfiguration::~CameraConfiguration(void)
+   {
+
+   }
+  
+   void CameraConfiguration::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadConfiguration::pack(buf);
+      // Copy the class into the buffer
+      buf.putInt( (int32_t) __SupportedWavelengthBand);
+      buf.putInt( (int32_t) __FieldOfViewMode);
+      buf.putFloat(__MinHorizontalFieldOfView);
+      buf.putFloat(__MaxHorizontalFieldOfView);
+      buf.putUShort( static_cast<uint16_t>(__DiscreteHorizontalFieldOfViewList.size()));
+      for (size_t i=0; i<__DiscreteHorizontalFieldOfViewList.size(); i++)
+      {
+         buf.putFloat(__DiscreteHorizontalFieldOfViewList[i]);
+      }
+      buf.putUInt(__VideoStreamHorizontalResolution);
+      buf.putUInt(__VideoStreamVerticalResolution);
+
+   }
+   
+   void CameraConfiguration::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadConfiguration::unpack(buf);
+      // Copy the buffer into the class
+      __SupportedWavelengthBand = (afrl::cmasi::WavelengthBand::WavelengthBand) buf.getInt();
+      __FieldOfViewMode = (afrl::cmasi::FOVOperationMode::FOVOperationMode) buf.getInt();
+      __MinHorizontalFieldOfView = buf.getFloat();
+      __MaxHorizontalFieldOfView = buf.getFloat();
+      __DiscreteHorizontalFieldOfViewList.clear();
+      uint16_t __DiscreteHorizontalFieldOfViewList_length = buf.getUShort();
+      for (uint32_t i=0; i< __DiscreteHorizontalFieldOfViewList_length; i++)
+      {
+         __DiscreteHorizontalFieldOfViewList.push_back(buf.getFloat() );
+      }
+      __VideoStreamHorizontalResolution = buf.getUInt();
+      __VideoStreamVerticalResolution = buf.getUInt();
+
+   }
+
+   uint32_t CameraConfiguration::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadConfiguration::calculatePackedSize();
+      size += sizeof(afrl::cmasi::WavelengthBand::WavelengthBand);
+      size += sizeof(afrl::cmasi::FOVOperationMode::FOVOperationMode);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += 2 + sizeof(float) * __DiscreteHorizontalFieldOfViewList.size();
+      size += sizeof(uint32_t);
+      size += sizeof(uint32_t);
+
+      return size;
+   }
+
+   std::string CameraConfiguration::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( CameraConfiguration ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "PayloadKind (std::string) = " << __PayloadKind << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      oss << indent << "SupportedWavelengthBand (WavelengthBand) = " << __SupportedWavelengthBand << "\n";
+      oss << indent << "FieldOfViewMode (FOVOperationMode) = " << __FieldOfViewMode << "\n";
+      oss << indent << "MinHorizontalFieldOfView (float) = " << __MinHorizontalFieldOfView << "\n";
+      oss << indent << "MaxHorizontalFieldOfView (float) = " << __MaxHorizontalFieldOfView << "\n";
+      oss << indent << "DiscreteHorizontalFieldOfViewList (real32 [ " << __DiscreteHorizontalFieldOfViewList.size() << ", var ])\n";
+      oss << indent << "VideoStreamHorizontalResolution (uint32_t) = " << __VideoStreamHorizontalResolution << "\n";
+      oss << indent << "VideoStreamVerticalResolution (uint32_t) = " << __VideoStreamVerticalResolution << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string CameraConfiguration::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<CameraConfiguration Series=\"CMASI\">\n";
+      str << ws << "   <SupportedWavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__SupportedWavelengthBand) << "</SupportedWavelengthBand>\n";
+      str << ws << "   <FieldOfViewMode>" << afrl::cmasi::FOVOperationMode::get_string(__FieldOfViewMode) << "</FieldOfViewMode>\n";
+      str << ws << "   <MinHorizontalFieldOfView>" << __MinHorizontalFieldOfView << "</MinHorizontalFieldOfView>\n";
+      str << ws << "   <MaxHorizontalFieldOfView>" << __MaxHorizontalFieldOfView << "</MaxHorizontalFieldOfView>\n";
+      str << ws << "   <DiscreteHorizontalFieldOfViewList>\n";
+      for (size_t i=0; i<__DiscreteHorizontalFieldOfViewList.size(); i++)
+      {
+         str << ws << "   <real32>" << __DiscreteHorizontalFieldOfViewList[i] << "</real32>\n";
+      }
+      str << ws << "   </DiscreteHorizontalFieldOfViewList>\n";
+      str << ws << "   <VideoStreamHorizontalResolution>" << __VideoStreamHorizontalResolution << "</VideoStreamHorizontalResolution>\n";
+      str << ws << "   <VideoStreamVerticalResolution>" << __VideoStreamVerticalResolution << "</VideoStreamVerticalResolution>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <PayloadKind>" << __PayloadKind << "</PayloadKind>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</CameraConfiguration>\n";
+
+      return str.str();
+   }
+
+   bool CameraConfiguration::operator==(const CameraConfiguration & that)
+   {
+      if( afrl::cmasi::PayloadConfiguration::operator!=(that) )
+      {
+          return false;
+      }
+      if(__SupportedWavelengthBand != that.__SupportedWavelengthBand) return false;
+      if(__FieldOfViewMode != that.__FieldOfViewMode) return false;
+      if(__MinHorizontalFieldOfView != that.__MinHorizontalFieldOfView) return false;
+      if(__MaxHorizontalFieldOfView != that.__MaxHorizontalFieldOfView) return false;
+      if(__DiscreteHorizontalFieldOfViewList.size() != that.__DiscreteHorizontalFieldOfViewList.size()) return false;
+      for (size_t i=0; i<__DiscreteHorizontalFieldOfViewList.size(); i++)
+      {
+         if(__DiscreteHorizontalFieldOfViewList[i] != that.__DiscreteHorizontalFieldOfViewList[i]) return false;
+      }
+      if(__VideoStreamHorizontalResolution != that.__VideoStreamHorizontalResolution) return false;
+      if(__VideoStreamVerticalResolution != that.__VideoStreamVerticalResolution) return false;
+      return true;
+
+   }
+
+   bool CameraConfiguration::operator!=(const CameraConfiguration & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   CameraConfiguration& CameraConfiguration::setSupportedWavelengthBand(const afrl::cmasi::WavelengthBand::WavelengthBand val)
+   {
+      __SupportedWavelengthBand = val;
+      return *this;
+   }
+
+   CameraConfiguration& CameraConfiguration::setFieldOfViewMode(const afrl::cmasi::FOVOperationMode::FOVOperationMode val)
+   {
+      __FieldOfViewMode = val;
+      return *this;
+   }
+
+   CameraConfiguration& CameraConfiguration::setMinHorizontalFieldOfView(const float val)
+   {
+      __MinHorizontalFieldOfView = val;
+      return *this;
+   }
+
+   CameraConfiguration& CameraConfiguration::setMaxHorizontalFieldOfView(const float val)
+   {
+      __MaxHorizontalFieldOfView = val;
+      return *this;
+   }
+
+
+   CameraConfiguration& CameraConfiguration::setVideoStreamHorizontalResolution(const uint32_t val)
+   {
+      __VideoStreamHorizontalResolution = val;
+      return *this;
+   }
+
+   CameraConfiguration& CameraConfiguration::setVideoStreamVerticalResolution(const uint32_t val)
+   {
+      __VideoStreamVerticalResolution = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiCameraState.cpp b/src/LMCP/afrl/cmasi/afrlcmasiCameraState.cpp
new file mode 100644
index 0000000..6a67348
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiCameraState.cpp
@@ -0,0 +1,316 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/CameraState.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string CameraState::Subscription = "afrl.cmasi.CameraState";
+   const std::string CameraState::TypeName = "CameraState";
+   
+   bool isCameraState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 21) return false;
+      return true;
+   }
+   
+   bool isCameraState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 21) return false;
+      return true;
+   }
+   
+   std::vector< std::string > CameraStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   CameraState::CameraState(void) : afrl::cmasi::GimballedPayloadState()
+   {
+      __HorizontalFieldOfView = 0.f;
+      __VerticalFieldOfView = 0.f;
+      __Centerpoint = nullptr;
+
+   }
+     
+   CameraState::CameraState(const CameraState &that) : afrl::cmasi::GimballedPayloadState(that)
+   {
+        __HorizontalFieldOfView = that.__HorizontalFieldOfView;
+        __VerticalFieldOfView = that.__VerticalFieldOfView;
+        __Footprint.clear();
+        for (size_t i=0; i< that.__Footprint.size(); i++)
+        {
+           __Footprint.push_back( that.__Footprint[i] == nullptr ? nullptr : that.__Footprint[i]->clone());
+        }
+        __Centerpoint = that.__Centerpoint == nullptr ? nullptr : that.__Centerpoint->clone();
+
+   }
+   
+   CameraState & CameraState::operator=(const CameraState &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::GimballedPayloadState::operator=(that);
+         for (size_t i=0; i<__Footprint.size(); i++)
+         {
+            if (__Footprint[i] != nullptr) delete __Footprint[i];
+         }
+         if (__Centerpoint != nullptr) delete __Centerpoint;
+
+         __HorizontalFieldOfView = that.__HorizontalFieldOfView;
+         __VerticalFieldOfView = that.__VerticalFieldOfView;
+         __Footprint.clear();
+         for (size_t i=0; i< that.__Footprint.size(); i++)
+         {
+            __Footprint.push_back( that.__Footprint[i] == nullptr ? nullptr : that.__Footprint[i]->clone());
+         }
+         __Centerpoint = that.__Centerpoint == nullptr ? nullptr : that.__Centerpoint->clone();
+
+      }
+      return *this;
+   }
+
+   CameraState* CameraState::clone() const
+   {
+        return new CameraState(*this);
+   }
+   
+   CameraState::~CameraState(void)
+   {
+      for (size_t i=0; i<__Footprint.size(); i++)
+      {
+         if (__Footprint[i] != nullptr) delete __Footprint[i];
+      }
+      if (__Centerpoint != nullptr) delete __Centerpoint;
+
+   }
+  
+   void CameraState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::GimballedPayloadState::pack(buf);
+      // Copy the class into the buffer
+      buf.putFloat(__HorizontalFieldOfView);
+      buf.putFloat(__VerticalFieldOfView);
+      buf.putUShort( static_cast<uint16_t>(__Footprint.size()));
+      for (size_t i=0; i<__Footprint.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Footprint[i], buf);
+      }
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Centerpoint, buf);
+
+   }
+   
+   void CameraState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::GimballedPayloadState::unpack(buf);
+      // Copy the buffer into the class
+      __HorizontalFieldOfView = buf.getFloat();
+      __VerticalFieldOfView = buf.getFloat();
+      for (size_t i=0; i<__Footprint.size(); i++)
+      {
+         if (__Footprint[i] != nullptr)
+            delete __Footprint[i];
+      }
+      __Footprint.clear();
+      uint16_t __Footprint_length = buf.getUShort();
+      for (uint32_t i=0; i< __Footprint_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Location3D* e = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Footprint.push_back(e);
+         }
+      }
+      {
+         if (__Centerpoint != nullptr) delete __Centerpoint;
+         __Centerpoint = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Centerpoint = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Centerpoint != nullptr) __Centerpoint->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t CameraState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::GimballedPayloadState::calculatePackedSize();
+      size += sizeof(float);
+      size += sizeof(float);
+      size += 2;
+      for (size_t i=0; i<__Footprint.size(); i++)
+      {
+         if (__Footprint[i] != nullptr)
+         {
+            size += __Footprint[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += (__Centerpoint != nullptr ? __Centerpoint->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string CameraState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( CameraState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      oss << indent << "PointingMode (GimbalPointingMode) = " << __PointingMode << "\n";
+      oss << indent << "Azimuth (float) = " << __Azimuth << "\n";
+      oss << indent << "Elevation (float) = " << __Elevation << "\n";
+      oss << indent << "Rotation (float) = " << __Rotation << "\n";
+
+      oss << indent << "HorizontalFieldOfView (float) = " << __HorizontalFieldOfView << "\n";
+      oss << indent << "VerticalFieldOfView (float) = " << __VerticalFieldOfView << "\n";
+      oss << indent << "Footprint (Location3D [ " << __Footprint.size() << ", var ])\n";
+      oss << indent << "Centerpoint (Location3D)";
+      if (__Centerpoint == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string CameraState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<CameraState Series=\"CMASI\">\n";
+      str << ws << "   <HorizontalFieldOfView>" << __HorizontalFieldOfView << "</HorizontalFieldOfView>\n";
+      str << ws << "   <VerticalFieldOfView>" << __VerticalFieldOfView << "</VerticalFieldOfView>\n";
+      str << ws << "   <Footprint>\n";
+      for (size_t i=0; i<__Footprint.size(); i++)
+      {
+         str << (__Footprint[i] == nullptr ? ( ws + "   <null/>\n") : (__Footprint[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Footprint>\n";
+      if (__Centerpoint != nullptr)
+      {
+         str << ws << "   <Centerpoint>";
+         str << "\n" + __Centerpoint->toXML(depth + 1) + ws + "   ";
+         str << "</Centerpoint>\n";
+      }
+      str << ws << "   <PointingMode>" << afrl::cmasi::GimbalPointingMode::get_string(__PointingMode) << "</PointingMode>\n";
+      str << ws << "   <Azimuth>" << __Azimuth << "</Azimuth>\n";
+      str << ws << "   <Elevation>" << __Elevation << "</Elevation>\n";
+      str << ws << "   <Rotation>" << __Rotation << "</Rotation>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</CameraState>\n";
+
+      return str.str();
+   }
+
+   bool CameraState::operator==(const CameraState & that)
+   {
+      if( afrl::cmasi::GimballedPayloadState::operator!=(that) )
+      {
+          return false;
+      }
+      if(__HorizontalFieldOfView != that.__HorizontalFieldOfView) return false;
+      if(__VerticalFieldOfView != that.__VerticalFieldOfView) return false;
+      if(__Footprint.size() != that.__Footprint.size()) return false;
+      for (size_t i=0; i<__Footprint.size(); i++)
+      {
+         if(__Footprint[i] && that.__Footprint[i])
+         {
+            if(__Footprint[i]->getSeriesNameAsLong() != that.__Footprint[i]->getSeriesNameAsLong()) return false;
+            if(__Footprint[i]->getSeriesVersion() != that.__Footprint[i]->getSeriesVersion()) return false;
+            if(__Footprint[i]->getLmcpType() != that.__Footprint[i]->getLmcpType()) return false;
+            if( *(__Footprint[i]) != *(that.__Footprint[i]) ) return false;
+         }
+         else if(__Footprint[i] != that.__Footprint[i]) return false;
+      }
+      if(__Centerpoint && that.__Centerpoint)
+      {
+         if(__Centerpoint->getSeriesNameAsLong() != that.__Centerpoint->getSeriesNameAsLong()) return false;
+         if(__Centerpoint->getSeriesVersion() != that.__Centerpoint->getSeriesVersion()) return false;
+         if(__Centerpoint->getLmcpType() != that.__Centerpoint->getLmcpType()) return false;
+         if( *(__Centerpoint) != *(that.__Centerpoint) ) return false;
+      }
+      else if(__Centerpoint != that.__Centerpoint) return false;
+      return true;
+
+   }
+
+   bool CameraState::operator!=(const CameraState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   CameraState& CameraState::setHorizontalFieldOfView(const float val)
+   {
+      __HorizontalFieldOfView = val;
+      return *this;
+   }
+
+   CameraState& CameraState::setVerticalFieldOfView(const float val)
+   {
+      __VerticalFieldOfView = val;
+      return *this;
+   }
+
+
+   CameraState& CameraState::setCenterpoint(const afrl::cmasi::Location3D* const val)
+   {
+      if (__Centerpoint != nullptr) { delete __Centerpoint; __Centerpoint = nullptr; }
+      if (val != nullptr) { __Centerpoint = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiCircle.cpp b/src/LMCP/afrl/cmasi/afrlcmasiCircle.cpp
new file mode 100644
index 0000000..8d156e0
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiCircle.cpp
@@ -0,0 +1,210 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/Circle.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string Circle::Subscription = "afrl.cmasi.Circle";
+   const std::string Circle::TypeName = "Circle";
+   
+   bool isCircle(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 22) return false;
+      return true;
+   }
+   
+   bool isCircle(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 22) return false;
+      return true;
+   }
+   
+   std::vector< std::string > CircleDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   Circle::Circle(void) : afrl::cmasi::AbstractGeometry()
+   {
+      __CenterPoint = new afrl::cmasi::Location3D();
+      __Radius = 0.f;
+
+   }
+     
+   Circle::Circle(const Circle &that) : afrl::cmasi::AbstractGeometry(that)
+   {
+        __CenterPoint = that.__CenterPoint == nullptr ? nullptr : that.__CenterPoint->clone();
+        __Radius = that.__Radius;
+
+   }
+   
+   Circle & Circle::operator=(const Circle &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::AbstractGeometry::operator=(that);
+         if (__CenterPoint != nullptr) delete __CenterPoint;
+
+         __CenterPoint = that.__CenterPoint == nullptr ? nullptr : that.__CenterPoint->clone();
+         __Radius = that.__Radius;
+
+      }
+      return *this;
+   }
+
+   Circle* Circle::clone() const
+   {
+        return new Circle(*this);
+   }
+   
+   Circle::~Circle(void)
+   {
+      if (__CenterPoint != nullptr) delete __CenterPoint;
+
+   }
+  
+   void Circle::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::AbstractGeometry::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __CenterPoint, buf);
+      buf.putFloat(__Radius);
+
+   }
+   
+   void Circle::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::AbstractGeometry::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__CenterPoint != nullptr) delete __CenterPoint;
+         __CenterPoint = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __CenterPoint = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__CenterPoint != nullptr) __CenterPoint->unpack(buf);
+         }
+      }
+      __Radius = buf.getFloat();
+
+   }
+
+   uint32_t Circle::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::AbstractGeometry::calculatePackedSize();
+      size += (__CenterPoint != nullptr ? __CenterPoint->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string Circle::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( Circle ) {\n";
+      indent = std::string((++depth)*3, ' ');
+
+      oss << indent << "CenterPoint (Location3D)";
+      if (__CenterPoint == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "Radius (float) = " << __Radius << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string Circle::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<Circle Series=\"CMASI\">\n";
+      if (__CenterPoint != nullptr)
+      {
+         str << ws << "   <CenterPoint>";
+         str << "\n" + __CenterPoint->toXML(depth + 1) + ws + "   ";
+         str << "</CenterPoint>\n";
+      }
+      str << ws << "   <Radius>" << __Radius << "</Radius>\n";
+      str << ws << "</Circle>\n";
+
+      return str.str();
+   }
+
+   bool Circle::operator==(const Circle & that)
+   {
+      if( afrl::cmasi::AbstractGeometry::operator!=(that) )
+      {
+          return false;
+      }
+      if(__CenterPoint && that.__CenterPoint)
+      {
+         if(__CenterPoint->getSeriesNameAsLong() != that.__CenterPoint->getSeriesNameAsLong()) return false;
+         if(__CenterPoint->getSeriesVersion() != that.__CenterPoint->getSeriesVersion()) return false;
+         if(__CenterPoint->getLmcpType() != that.__CenterPoint->getLmcpType()) return false;
+         if( *(__CenterPoint) != *(that.__CenterPoint) ) return false;
+      }
+      else if(__CenterPoint != that.__CenterPoint) return false;
+      if(__Radius != that.__Radius) return false;
+      return true;
+
+   }
+
+   bool Circle::operator!=(const Circle & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   Circle& Circle::setCenterPoint(const afrl::cmasi::Location3D* const val)
+   {
+      if (__CenterPoint != nullptr) { delete __CenterPoint; __CenterPoint = nullptr; }
+      if (val != nullptr) { __CenterPoint = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   Circle& Circle::setRadius(const float val)
+   {
+      __Radius = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiEntityConfiguration.cpp b/src/LMCP/afrl/cmasi/afrlcmasiEntityConfiguration.cpp
new file mode 100644
index 0000000..58cda3f
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiEntityConfiguration.cpp
@@ -0,0 +1,402 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/EntityConfiguration.h"
+#include "afrl/cmasi/CameraConfiguration.h"
+#include "afrl/cmasi/GimbalConfiguration.h"
+#include "afrl/cmasi/VideoStreamConfiguration.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string EntityConfiguration::Subscription = "afrl.cmasi.EntityConfiguration";
+   const std::string EntityConfiguration::TypeName = "EntityConfiguration";
+   
+   bool isEntityConfiguration(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 11) return false;
+      return true;
+   }
+   
+   bool isEntityConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 11) return false;
+      return true;
+   }
+   
+   std::vector< std::string > EntityConfigurationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.AirVehicleConfiguration");
+       descendants.push_back("afrl.impact.RadioTowerConfiguration");
+       descendants.push_back("afrl.impact.GroundVehicleConfiguration");
+       descendants.push_back("afrl.impact.SurfaceVehicleConfiguration");
+
+       return descendants;
+   }
+   
+   EntityConfiguration::EntityConfiguration(void) : avtas::lmcp::Object()
+   {
+      __ID = 0LL;
+      __Affiliation = std::string("Unknown");
+      __EntityType = std::string("");
+      __Label = std::string("");
+      __NominalSpeed = 0.f;
+      __NominalAltitude = 0.0f;
+      __NominalAltitudeType = afrl::cmasi::AltitudeType::AGL;
+
+   }
+     
+   EntityConfiguration::EntityConfiguration(const EntityConfiguration &that) : avtas::lmcp::Object(that)
+   {
+        __ID = that.__ID;
+        __Affiliation = that.__Affiliation;
+        __EntityType = that.__EntityType;
+        __Label = that.__Label;
+        __NominalSpeed = that.__NominalSpeed;
+        __NominalAltitude = that.__NominalAltitude;
+        __NominalAltitudeType = that.__NominalAltitudeType;
+        __PayloadConfigurationList.clear();
+        for (size_t i=0; i< that.__PayloadConfigurationList.size(); i++)
+        {
+           __PayloadConfigurationList.push_back( that.__PayloadConfigurationList[i] == nullptr ? nullptr : that.__PayloadConfigurationList[i]->clone());
+        }
+        __Info.clear();
+        for (size_t i=0; i< that.__Info.size(); i++)
+        {
+           __Info.push_back( that.__Info[i] == nullptr ? nullptr : that.__Info[i]->clone());
+        }
+
+   }
+   
+   EntityConfiguration & EntityConfiguration::operator=(const EntityConfiguration &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__PayloadConfigurationList.size(); i++)
+         {
+            if (__PayloadConfigurationList[i] != nullptr) delete __PayloadConfigurationList[i];
+         }
+         for (size_t i=0; i<__Info.size(); i++)
+         {
+            if (__Info[i] != nullptr) delete __Info[i];
+         }
+
+         __ID = that.__ID;
+         __Affiliation = that.__Affiliation;
+         __EntityType = that.__EntityType;
+         __Label = that.__Label;
+         __NominalSpeed = that.__NominalSpeed;
+         __NominalAltitude = that.__NominalAltitude;
+         __NominalAltitudeType = that.__NominalAltitudeType;
+         __PayloadConfigurationList.clear();
+         for (size_t i=0; i< that.__PayloadConfigurationList.size(); i++)
+         {
+            __PayloadConfigurationList.push_back( that.__PayloadConfigurationList[i] == nullptr ? nullptr : that.__PayloadConfigurationList[i]->clone());
+         }
+         __Info.clear();
+         for (size_t i=0; i< that.__Info.size(); i++)
+         {
+            __Info.push_back( that.__Info[i] == nullptr ? nullptr : that.__Info[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   EntityConfiguration* EntityConfiguration::clone() const
+   {
+        return new EntityConfiguration(*this);
+   }
+   
+   EntityConfiguration::~EntityConfiguration(void)
+   {
+      for (size_t i=0; i<__PayloadConfigurationList.size(); i++)
+      {
+         if (__PayloadConfigurationList[i] != nullptr) delete __PayloadConfigurationList[i];
+      }
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if (__Info[i] != nullptr) delete __Info[i];
+      }
+
+   }
+  
+   void EntityConfiguration::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ID);
+      buf.putString(__Affiliation);
+      buf.putString(__EntityType);
+      buf.putString(__Label);
+      buf.putFloat(__NominalSpeed);
+      buf.putFloat(__NominalAltitude);
+      buf.putInt( (int32_t) __NominalAltitudeType);
+      buf.putUShort( static_cast<uint16_t>(__PayloadConfigurationList.size()));
+      for (size_t i=0; i<__PayloadConfigurationList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __PayloadConfigurationList[i], buf);
+      }
+      buf.putUShort( static_cast<uint16_t>(__Info.size()));
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Info[i], buf);
+      }
+
+   }
+   
+   void EntityConfiguration::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ID = buf.getLong();
+      __Affiliation = buf.getString();
+      __EntityType = buf.getString();
+      __Label = buf.getString();
+      __NominalSpeed = buf.getFloat();
+      __NominalAltitude = buf.getFloat();
+      __NominalAltitudeType = (afrl::cmasi::AltitudeType::AltitudeType) buf.getInt();
+      for (size_t i=0; i<__PayloadConfigurationList.size(); i++)
+      {
+         if (__PayloadConfigurationList[i] != nullptr)
+            delete __PayloadConfigurationList[i];
+      }
+      __PayloadConfigurationList.clear();
+      uint16_t __PayloadConfigurationList_length = buf.getUShort();
+      for (uint32_t i=0; i< __PayloadConfigurationList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::PayloadConfiguration* e = (afrl::cmasi::PayloadConfiguration*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __PayloadConfigurationList.push_back(e);
+         }
+      }
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if (__Info[i] != nullptr)
+            delete __Info[i];
+      }
+      __Info.clear();
+      uint16_t __Info_length = buf.getUShort();
+      for (uint32_t i=0; i< __Info_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::KeyValuePair* e = (afrl::cmasi::KeyValuePair*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Info.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t EntityConfiguration::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2 + __Affiliation.length();
+      size += 2 + __EntityType.length();
+      size += 2 + __Label.length();
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::AltitudeType::AltitudeType);
+      size += 2;
+      for (size_t i=0; i<__PayloadConfigurationList.size(); i++)
+      {
+         if (__PayloadConfigurationList[i] != nullptr)
+         {
+            size += __PayloadConfigurationList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += 2;
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if (__Info[i] != nullptr)
+         {
+            size += __Info[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string EntityConfiguration::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( EntityConfiguration ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ID (int64_t) = " << __ID << "\n";
+      oss << indent << "Affiliation (std::string) = " << __Affiliation << "\n";
+      oss << indent << "EntityType (std::string) = " << __EntityType << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "NominalSpeed (float) = " << __NominalSpeed << "\n";
+      oss << indent << "NominalAltitude (float) = " << __NominalAltitude << "\n";
+      oss << indent << "NominalAltitudeType (AltitudeType) = " << __NominalAltitudeType << "\n";
+      oss << indent << "PayloadConfigurationList (PayloadConfiguration [ " << __PayloadConfigurationList.size() << ", var ])\n";
+      oss << indent << "Info (KeyValuePair [ " << __Info.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string EntityConfiguration::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<EntityConfiguration Series=\"CMASI\">\n";
+      str << ws << "   <ID>" << __ID << "</ID>\n";
+      str << ws << "   <Affiliation>" << __Affiliation << "</Affiliation>\n";
+      str << ws << "   <EntityType>" << __EntityType << "</EntityType>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <NominalSpeed>" << __NominalSpeed << "</NominalSpeed>\n";
+      str << ws << "   <NominalAltitude>" << __NominalAltitude << "</NominalAltitude>\n";
+      str << ws << "   <NominalAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__NominalAltitudeType) << "</NominalAltitudeType>\n";
+      str << ws << "   <PayloadConfigurationList>\n";
+      for (size_t i=0; i<__PayloadConfigurationList.size(); i++)
+      {
+         str << (__PayloadConfigurationList[i] == nullptr ? ( ws + "   <null/>\n") : (__PayloadConfigurationList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PayloadConfigurationList>\n";
+      str << ws << "   <Info>\n";
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         str << (__Info[i] == nullptr ? ( ws + "   <null/>\n") : (__Info[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Info>\n";
+      str << ws << "</EntityConfiguration>\n";
+
+      return str.str();
+   }
+
+   bool EntityConfiguration::operator==(const EntityConfiguration & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ID != that.__ID) return false;
+      if(__Affiliation != that.__Affiliation) return false;
+      if(__EntityType != that.__EntityType) return false;
+      if(__Label != that.__Label) return false;
+      if(__NominalSpeed != that.__NominalSpeed) return false;
+      if(__NominalAltitude != that.__NominalAltitude) return false;
+      if(__NominalAltitudeType != that.__NominalAltitudeType) return false;
+      if(__PayloadConfigurationList.size() != that.__PayloadConfigurationList.size()) return false;
+      for (size_t i=0; i<__PayloadConfigurationList.size(); i++)
+      {
+         if(__PayloadConfigurationList[i] && that.__PayloadConfigurationList[i])
+         {
+            if(__PayloadConfigurationList[i]->getSeriesNameAsLong() != that.__PayloadConfigurationList[i]->getSeriesNameAsLong()) return false;
+            if(__PayloadConfigurationList[i]->getSeriesVersion() != that.__PayloadConfigurationList[i]->getSeriesVersion()) return false;
+            if(__PayloadConfigurationList[i]->getLmcpType() != that.__PayloadConfigurationList[i]->getLmcpType()) return false;
+            if( *(__PayloadConfigurationList[i]) != *(that.__PayloadConfigurationList[i]) ) return false;
+         }
+         else if(__PayloadConfigurationList[i] != that.__PayloadConfigurationList[i]) return false;
+      }
+      if(__Info.size() != that.__Info.size()) return false;
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if(__Info[i] && that.__Info[i])
+         {
+            if(__Info[i]->getSeriesNameAsLong() != that.__Info[i]->getSeriesNameAsLong()) return false;
+            if(__Info[i]->getSeriesVersion() != that.__Info[i]->getSeriesVersion()) return false;
+            if(__Info[i]->getLmcpType() != that.__Info[i]->getLmcpType()) return false;
+            if( *(__Info[i]) != *(that.__Info[i]) ) return false;
+         }
+         else if(__Info[i] != that.__Info[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool EntityConfiguration::operator!=(const EntityConfiguration & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   EntityConfiguration& EntityConfiguration::setID(const int64_t val)
+   {
+      __ID = val;
+      return *this;
+   }
+
+   EntityConfiguration& EntityConfiguration::setAffiliation(const std::string val)
+   {
+      __Affiliation = val;
+      return *this;
+   }
+
+   EntityConfiguration& EntityConfiguration::setEntityType(const std::string val)
+   {
+      __EntityType = val;
+      return *this;
+   }
+
+   EntityConfiguration& EntityConfiguration::setLabel(const std::string val)
+   {
+      __Label = val;
+      return *this;
+   }
+
+   EntityConfiguration& EntityConfiguration::setNominalSpeed(const float val)
+   {
+      __NominalSpeed = val;
+      return *this;
+   }
+
+   EntityConfiguration& EntityConfiguration::setNominalAltitude(const float val)
+   {
+      __NominalAltitude = val;
+      return *this;
+   }
+
+   EntityConfiguration& EntityConfiguration::setNominalAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val)
+   {
+      __NominalAltitudeType = val;
+      return *this;
+   }
+
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiEntityState.cpp b/src/LMCP/afrl/cmasi/afrlcmasiEntityState.cpp
new file mode 100644
index 0000000..174fa2b
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiEntityState.cpp
@@ -0,0 +1,694 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/EntityState.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+#include "afrl/cmasi/GimballedPayloadState.h"
+#include "afrl/cmasi/CameraState.h"
+#include "afrl/cmasi/GimbalState.h"
+#include "afrl/cmasi/VideoStreamState.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string EntityState::Subscription = "afrl.cmasi.EntityState";
+   const std::string EntityState::TypeName = "EntityState";
+   
+   bool isEntityState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 14) return false;
+      return true;
+   }
+   
+   bool isEntityState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 14) return false;
+      return true;
+   }
+   
+   std::vector< std::string > EntityStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.AirVehicleState");
+       descendants.push_back("afrl.impact.RadioTowerState");
+       descendants.push_back("afrl.impact.GroundVehicleState");
+       descendants.push_back("afrl.impact.SurfaceVehicleState");
+
+       return descendants;
+   }
+   
+   EntityState::EntityState(void) : avtas::lmcp::Object()
+   {
+      __ID = 0LL;
+      __u = 0.f;
+      __v = 0.f;
+      __w = 0.f;
+      __udot = 0.f;
+      __vdot = 0.f;
+      __wdot = 0.f;
+      __Heading = 0.f;
+      __Pitch = 0.f;
+      __Roll = 0.f;
+      __p = 0.f;
+      __q = 0.f;
+      __r = 0.f;
+      __Course = 0.f;
+      __Groundspeed = 0.f;
+      __Location = new afrl::cmasi::Location3D();
+      __EnergyAvailable = 0.f;
+      __ActualEnergyRate = 0.f;
+      __CurrentWaypoint = 0LL;
+      __CurrentCommand = 0LL;
+      __Mode = afrl::cmasi::NavigationMode::Waypoint;
+      __Time = 0LL;
+
+   }
+     
+   EntityState::EntityState(const EntityState &that) : avtas::lmcp::Object(that)
+   {
+        __ID = that.__ID;
+        __u = that.__u;
+        __v = that.__v;
+        __w = that.__w;
+        __udot = that.__udot;
+        __vdot = that.__vdot;
+        __wdot = that.__wdot;
+        __Heading = that.__Heading;
+        __Pitch = that.__Pitch;
+        __Roll = that.__Roll;
+        __p = that.__p;
+        __q = that.__q;
+        __r = that.__r;
+        __Course = that.__Course;
+        __Groundspeed = that.__Groundspeed;
+        __Location = that.__Location == nullptr ? nullptr : that.__Location->clone();
+        __EnergyAvailable = that.__EnergyAvailable;
+        __ActualEnergyRate = that.__ActualEnergyRate;
+        __PayloadStateList.clear();
+        for (size_t i=0; i< that.__PayloadStateList.size(); i++)
+        {
+           __PayloadStateList.push_back( that.__PayloadStateList[i] == nullptr ? nullptr : that.__PayloadStateList[i]->clone());
+        }
+        __CurrentWaypoint = that.__CurrentWaypoint;
+        __CurrentCommand = that.__CurrentCommand;
+        __Mode = that.__Mode;
+        __AssociatedTasks.clear();
+        for (size_t i=0; i< that.__AssociatedTasks.size(); i++)
+        {
+           __AssociatedTasks.push_back( that.__AssociatedTasks[i]);
+        }
+        __Time = that.__Time;
+        __Info.clear();
+        for (size_t i=0; i< that.__Info.size(); i++)
+        {
+           __Info.push_back( that.__Info[i] == nullptr ? nullptr : that.__Info[i]->clone());
+        }
+
+   }
+   
+   EntityState & EntityState::operator=(const EntityState &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__Location != nullptr) delete __Location;
+         for (size_t i=0; i<__PayloadStateList.size(); i++)
+         {
+            if (__PayloadStateList[i] != nullptr) delete __PayloadStateList[i];
+         }
+         for (size_t i=0; i<__Info.size(); i++)
+         {
+            if (__Info[i] != nullptr) delete __Info[i];
+         }
+
+         __ID = that.__ID;
+         __u = that.__u;
+         __v = that.__v;
+         __w = that.__w;
+         __udot = that.__udot;
+         __vdot = that.__vdot;
+         __wdot = that.__wdot;
+         __Heading = that.__Heading;
+         __Pitch = that.__Pitch;
+         __Roll = that.__Roll;
+         __p = that.__p;
+         __q = that.__q;
+         __r = that.__r;
+         __Course = that.__Course;
+         __Groundspeed = that.__Groundspeed;
+         __Location = that.__Location == nullptr ? nullptr : that.__Location->clone();
+         __EnergyAvailable = that.__EnergyAvailable;
+         __ActualEnergyRate = that.__ActualEnergyRate;
+         __PayloadStateList.clear();
+         for (size_t i=0; i< that.__PayloadStateList.size(); i++)
+         {
+            __PayloadStateList.push_back( that.__PayloadStateList[i] == nullptr ? nullptr : that.__PayloadStateList[i]->clone());
+         }
+         __CurrentWaypoint = that.__CurrentWaypoint;
+         __CurrentCommand = that.__CurrentCommand;
+         __Mode = that.__Mode;
+         __AssociatedTasks.clear();
+         for (size_t i=0; i< that.__AssociatedTasks.size(); i++)
+         {
+            __AssociatedTasks.push_back( that.__AssociatedTasks[i]);
+         }
+         __Time = that.__Time;
+         __Info.clear();
+         for (size_t i=0; i< that.__Info.size(); i++)
+         {
+            __Info.push_back( that.__Info[i] == nullptr ? nullptr : that.__Info[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   EntityState* EntityState::clone() const
+   {
+        return new EntityState(*this);
+   }
+   
+   EntityState::~EntityState(void)
+   {
+      if (__Location != nullptr) delete __Location;
+      for (size_t i=0; i<__PayloadStateList.size(); i++)
+      {
+         if (__PayloadStateList[i] != nullptr) delete __PayloadStateList[i];
+      }
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if (__Info[i] != nullptr) delete __Info[i];
+      }
+
+   }
+  
+   void EntityState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ID);
+      buf.putFloat(__u);
+      buf.putFloat(__v);
+      buf.putFloat(__w);
+      buf.putFloat(__udot);
+      buf.putFloat(__vdot);
+      buf.putFloat(__wdot);
+      buf.putFloat(__Heading);
+      buf.putFloat(__Pitch);
+      buf.putFloat(__Roll);
+      buf.putFloat(__p);
+      buf.putFloat(__q);
+      buf.putFloat(__r);
+      buf.putFloat(__Course);
+      buf.putFloat(__Groundspeed);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Location, buf);
+      buf.putFloat(__EnergyAvailable);
+      buf.putFloat(__ActualEnergyRate);
+      buf.putUShort( static_cast<uint16_t>(__PayloadStateList.size()));
+      for (size_t i=0; i<__PayloadStateList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __PayloadStateList[i], buf);
+      }
+      buf.putLong(__CurrentWaypoint);
+      buf.putLong(__CurrentCommand);
+      buf.putInt( (int32_t) __Mode);
+      buf.putUShort( static_cast<uint16_t>(__AssociatedTasks.size()));
+      for (size_t i=0; i<__AssociatedTasks.size(); i++)
+      {
+         buf.putLong(__AssociatedTasks[i]);
+      }
+      buf.putLong(__Time);
+      buf.putUShort( static_cast<uint16_t>(__Info.size()));
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Info[i], buf);
+      }
+
+   }
+   
+   void EntityState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ID = buf.getLong();
+      __u = buf.getFloat();
+      __v = buf.getFloat();
+      __w = buf.getFloat();
+      __udot = buf.getFloat();
+      __vdot = buf.getFloat();
+      __wdot = buf.getFloat();
+      __Heading = buf.getFloat();
+      __Pitch = buf.getFloat();
+      __Roll = buf.getFloat();
+      __p = buf.getFloat();
+      __q = buf.getFloat();
+      __r = buf.getFloat();
+      __Course = buf.getFloat();
+      __Groundspeed = buf.getFloat();
+      {
+         if (__Location != nullptr) delete __Location;
+         __Location = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Location = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Location != nullptr) __Location->unpack(buf);
+         }
+      }
+      __EnergyAvailable = buf.getFloat();
+      __ActualEnergyRate = buf.getFloat();
+      for (size_t i=0; i<__PayloadStateList.size(); i++)
+      {
+         if (__PayloadStateList[i] != nullptr)
+            delete __PayloadStateList[i];
+      }
+      __PayloadStateList.clear();
+      uint16_t __PayloadStateList_length = buf.getUShort();
+      for (uint32_t i=0; i< __PayloadStateList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::PayloadState* e = (afrl::cmasi::PayloadState*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __PayloadStateList.push_back(e);
+         }
+      }
+      __CurrentWaypoint = buf.getLong();
+      __CurrentCommand = buf.getLong();
+      __Mode = (afrl::cmasi::NavigationMode::NavigationMode) buf.getInt();
+      __AssociatedTasks.clear();
+      uint16_t __AssociatedTasks_length = buf.getUShort();
+      for (uint32_t i=0; i< __AssociatedTasks_length; i++)
+      {
+         __AssociatedTasks.push_back(buf.getLong() );
+      }
+      __Time = buf.getLong();
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if (__Info[i] != nullptr)
+            delete __Info[i];
+      }
+      __Info.clear();
+      uint16_t __Info_length = buf.getUShort();
+      for (uint32_t i=0; i< __Info_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::KeyValuePair* e = (afrl::cmasi::KeyValuePair*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Info.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t EntityState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += (__Location != nullptr ? __Location->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += 2;
+      for (size_t i=0; i<__PayloadStateList.size(); i++)
+      {
+         if (__PayloadStateList[i] != nullptr)
+         {
+            size += __PayloadStateList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(afrl::cmasi::NavigationMode::NavigationMode);
+      size += 2 + sizeof(int64_t) * __AssociatedTasks.size();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if (__Info[i] != nullptr)
+         {
+            size += __Info[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string EntityState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( EntityState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ID (int64_t) = " << __ID << "\n";
+      oss << indent << "u (float) = " << __u << "\n";
+      oss << indent << "v (float) = " << __v << "\n";
+      oss << indent << "w (float) = " << __w << "\n";
+      oss << indent << "udot (float) = " << __udot << "\n";
+      oss << indent << "vdot (float) = " << __vdot << "\n";
+      oss << indent << "wdot (float) = " << __wdot << "\n";
+      oss << indent << "Heading (float) = " << __Heading << "\n";
+      oss << indent << "Pitch (float) = " << __Pitch << "\n";
+      oss << indent << "Roll (float) = " << __Roll << "\n";
+      oss << indent << "p (float) = " << __p << "\n";
+      oss << indent << "q (float) = " << __q << "\n";
+      oss << indent << "r (float) = " << __r << "\n";
+      oss << indent << "Course (float) = " << __Course << "\n";
+      oss << indent << "Groundspeed (float) = " << __Groundspeed << "\n";
+      oss << indent << "Location (Location3D)";
+      if (__Location == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "EnergyAvailable (float) = " << __EnergyAvailable << "\n";
+      oss << indent << "ActualEnergyRate (float) = " << __ActualEnergyRate << "\n";
+      oss << indent << "PayloadStateList (PayloadState [ " << __PayloadStateList.size() << ", var ])\n";
+      oss << indent << "CurrentWaypoint (int64_t) = " << __CurrentWaypoint << "\n";
+      oss << indent << "CurrentCommand (int64_t) = " << __CurrentCommand << "\n";
+      oss << indent << "Mode (NavigationMode) = " << __Mode << "\n";
+      oss << indent << "AssociatedTasks (int64 [ " << __AssociatedTasks.size() << ", var ])\n";
+      oss << indent << "Time (int64_t) = " << __Time << "\n";
+      oss << indent << "Info (KeyValuePair [ " << __Info.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string EntityState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<EntityState Series=\"CMASI\">\n";
+      str << ws << "   <ID>" << __ID << "</ID>\n";
+      str << ws << "   <u>" << __u << "</u>\n";
+      str << ws << "   <v>" << __v << "</v>\n";
+      str << ws << "   <w>" << __w << "</w>\n";
+      str << ws << "   <udot>" << __udot << "</udot>\n";
+      str << ws << "   <vdot>" << __vdot << "</vdot>\n";
+      str << ws << "   <wdot>" << __wdot << "</wdot>\n";
+      str << ws << "   <Heading>" << __Heading << "</Heading>\n";
+      str << ws << "   <Pitch>" << __Pitch << "</Pitch>\n";
+      str << ws << "   <Roll>" << __Roll << "</Roll>\n";
+      str << ws << "   <p>" << __p << "</p>\n";
+      str << ws << "   <q>" << __q << "</q>\n";
+      str << ws << "   <r>" << __r << "</r>\n";
+      str << ws << "   <Course>" << __Course << "</Course>\n";
+      str << ws << "   <Groundspeed>" << __Groundspeed << "</Groundspeed>\n";
+      if (__Location != nullptr)
+      {
+         str << ws << "   <Location>";
+         str << "\n" + __Location->toXML(depth + 1) + ws + "   ";
+         str << "</Location>\n";
+      }
+      str << ws << "   <EnergyAvailable>" << __EnergyAvailable << "</EnergyAvailable>\n";
+      str << ws << "   <ActualEnergyRate>" << __ActualEnergyRate << "</ActualEnergyRate>\n";
+      str << ws << "   <PayloadStateList>\n";
+      for (size_t i=0; i<__PayloadStateList.size(); i++)
+      {
+         str << (__PayloadStateList[i] == nullptr ? ( ws + "   <null/>\n") : (__PayloadStateList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PayloadStateList>\n";
+      str << ws << "   <CurrentWaypoint>" << __CurrentWaypoint << "</CurrentWaypoint>\n";
+      str << ws << "   <CurrentCommand>" << __CurrentCommand << "</CurrentCommand>\n";
+      str << ws << "   <Mode>" << afrl::cmasi::NavigationMode::get_string(__Mode) << "</Mode>\n";
+      str << ws << "   <AssociatedTasks>\n";
+      for (size_t i=0; i<__AssociatedTasks.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTasks[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTasks>\n";
+      str << ws << "   <Time>" << __Time << "</Time>\n";
+      str << ws << "   <Info>\n";
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         str << (__Info[i] == nullptr ? ( ws + "   <null/>\n") : (__Info[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Info>\n";
+      str << ws << "</EntityState>\n";
+
+      return str.str();
+   }
+
+   bool EntityState::operator==(const EntityState & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ID != that.__ID) return false;
+      if(__u != that.__u) return false;
+      if(__v != that.__v) return false;
+      if(__w != that.__w) return false;
+      if(__udot != that.__udot) return false;
+      if(__vdot != that.__vdot) return false;
+      if(__wdot != that.__wdot) return false;
+      if(__Heading != that.__Heading) return false;
+      if(__Pitch != that.__Pitch) return false;
+      if(__Roll != that.__Roll) return false;
+      if(__p != that.__p) return false;
+      if(__q != that.__q) return false;
+      if(__r != that.__r) return false;
+      if(__Course != that.__Course) return false;
+      if(__Groundspeed != that.__Groundspeed) return false;
+      if(__Location && that.__Location)
+      {
+         if(__Location->getSeriesNameAsLong() != that.__Location->getSeriesNameAsLong()) return false;
+         if(__Location->getSeriesVersion() != that.__Location->getSeriesVersion()) return false;
+         if(__Location->getLmcpType() != that.__Location->getLmcpType()) return false;
+         if( *(__Location) != *(that.__Location) ) return false;
+      }
+      else if(__Location != that.__Location) return false;
+      if(__EnergyAvailable != that.__EnergyAvailable) return false;
+      if(__ActualEnergyRate != that.__ActualEnergyRate) return false;
+      if(__PayloadStateList.size() != that.__PayloadStateList.size()) return false;
+      for (size_t i=0; i<__PayloadStateList.size(); i++)
+      {
+         if(__PayloadStateList[i] && that.__PayloadStateList[i])
+         {
+            if(__PayloadStateList[i]->getSeriesNameAsLong() != that.__PayloadStateList[i]->getSeriesNameAsLong()) return false;
+            if(__PayloadStateList[i]->getSeriesVersion() != that.__PayloadStateList[i]->getSeriesVersion()) return false;
+            if(__PayloadStateList[i]->getLmcpType() != that.__PayloadStateList[i]->getLmcpType()) return false;
+            if( *(__PayloadStateList[i]) != *(that.__PayloadStateList[i]) ) return false;
+         }
+         else if(__PayloadStateList[i] != that.__PayloadStateList[i]) return false;
+      }
+      if(__CurrentWaypoint != that.__CurrentWaypoint) return false;
+      if(__CurrentCommand != that.__CurrentCommand) return false;
+      if(__Mode != that.__Mode) return false;
+      if(__AssociatedTasks.size() != that.__AssociatedTasks.size()) return false;
+      for (size_t i=0; i<__AssociatedTasks.size(); i++)
+      {
+         if(__AssociatedTasks[i] != that.__AssociatedTasks[i]) return false;
+      }
+      if(__Time != that.__Time) return false;
+      if(__Info.size() != that.__Info.size()) return false;
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if(__Info[i] && that.__Info[i])
+         {
+            if(__Info[i]->getSeriesNameAsLong() != that.__Info[i]->getSeriesNameAsLong()) return false;
+            if(__Info[i]->getSeriesVersion() != that.__Info[i]->getSeriesVersion()) return false;
+            if(__Info[i]->getLmcpType() != that.__Info[i]->getLmcpType()) return false;
+            if( *(__Info[i]) != *(that.__Info[i]) ) return false;
+         }
+         else if(__Info[i] != that.__Info[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool EntityState::operator!=(const EntityState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   EntityState& EntityState::setID(const int64_t val)
+   {
+      __ID = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setU(const float val)
+   {
+      __u = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setV(const float val)
+   {
+      __v = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setW(const float val)
+   {
+      __w = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setUdot(const float val)
+   {
+      __udot = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setVdot(const float val)
+   {
+      __vdot = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setWdot(const float val)
+   {
+      __wdot = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setHeading(const float val)
+   {
+      __Heading = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setPitch(const float val)
+   {
+      __Pitch = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setRoll(const float val)
+   {
+      __Roll = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setP(const float val)
+   {
+      __p = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setQ(const float val)
+   {
+      __q = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setR(const float val)
+   {
+      __r = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setCourse(const float val)
+   {
+      __Course = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setGroundspeed(const float val)
+   {
+      __Groundspeed = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__Location != nullptr) { delete __Location; __Location = nullptr; }
+      if (val != nullptr) { __Location = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   EntityState& EntityState::setEnergyAvailable(const float val)
+   {
+      __EnergyAvailable = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setActualEnergyRate(const float val)
+   {
+      __ActualEnergyRate = val;
+      return *this;
+   }
+
+
+   EntityState& EntityState::setCurrentWaypoint(const int64_t val)
+   {
+      __CurrentWaypoint = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setCurrentCommand(const int64_t val)
+   {
+      __CurrentCommand = val;
+      return *this;
+   }
+
+   EntityState& EntityState::setMode(const afrl::cmasi::NavigationMode::NavigationMode val)
+   {
+      __Mode = val;
+      return *this;
+   }
+
+
+   EntityState& EntityState::setTime(const int64_t val)
+   {
+      __Time = val;
+      return *this;
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiFlightDirectorAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiFlightDirectorAction.cpp
new file mode 100644
index 0000000..0a9606a
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiFlightDirectorAction.cpp
@@ -0,0 +1,247 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/FlightDirectorAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string FlightDirectorAction::Subscription = "afrl.cmasi.FlightDirectorAction";
+   const std::string FlightDirectorAction::TypeName = "FlightDirectorAction";
+   
+   bool isFlightDirectorAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 54) return false;
+      return true;
+   }
+   
+   bool isFlightDirectorAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 54) return false;
+      return true;
+   }
+   
+   std::vector< std::string > FlightDirectorActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   FlightDirectorAction::FlightDirectorAction(void) : afrl::cmasi::NavigationAction()
+   {
+      __Speed = 0.f;
+      __SpeedType = afrl::cmasi::SpeedType::Airspeed;
+      __Heading = 0.f;
+      __Altitude = 0.f;
+      __AltitudeType = afrl::cmasi::AltitudeType::MSL;
+      __ClimbRate = 0.f;
+
+   }
+     
+   FlightDirectorAction::FlightDirectorAction(const FlightDirectorAction &that) : afrl::cmasi::NavigationAction(that)
+   {
+        __Speed = that.__Speed;
+        __SpeedType = that.__SpeedType;
+        __Heading = that.__Heading;
+        __Altitude = that.__Altitude;
+        __AltitudeType = that.__AltitudeType;
+        __ClimbRate = that.__ClimbRate;
+
+   }
+   
+   FlightDirectorAction & FlightDirectorAction::operator=(const FlightDirectorAction &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::NavigationAction::operator=(that);
+
+         __Speed = that.__Speed;
+         __SpeedType = that.__SpeedType;
+         __Heading = that.__Heading;
+         __Altitude = that.__Altitude;
+         __AltitudeType = that.__AltitudeType;
+         __ClimbRate = that.__ClimbRate;
+
+      }
+      return *this;
+   }
+
+   FlightDirectorAction* FlightDirectorAction::clone() const
+   {
+        return new FlightDirectorAction(*this);
+   }
+   
+   FlightDirectorAction::~FlightDirectorAction(void)
+   {
+
+   }
+  
+   void FlightDirectorAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::NavigationAction::pack(buf);
+      // Copy the class into the buffer
+      buf.putFloat(__Speed);
+      buf.putInt( (int32_t) __SpeedType);
+      buf.putFloat(__Heading);
+      buf.putFloat(__Altitude);
+      buf.putInt( (int32_t) __AltitudeType);
+      buf.putFloat(__ClimbRate);
+
+   }
+   
+   void FlightDirectorAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::NavigationAction::unpack(buf);
+      // Copy the buffer into the class
+      __Speed = buf.getFloat();
+      __SpeedType = (afrl::cmasi::SpeedType::SpeedType) buf.getInt();
+      __Heading = buf.getFloat();
+      __Altitude = buf.getFloat();
+      __AltitudeType = (afrl::cmasi::AltitudeType::AltitudeType) buf.getInt();
+      __ClimbRate = buf.getFloat();
+
+   }
+
+   uint32_t FlightDirectorAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::NavigationAction::calculatePackedSize();
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::SpeedType::SpeedType);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::AltitudeType::AltitudeType);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string FlightDirectorAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( FlightDirectorAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+
+      oss << indent << "Speed (float) = " << __Speed << "\n";
+      oss << indent << "SpeedType (SpeedType) = " << __SpeedType << "\n";
+      oss << indent << "Heading (float) = " << __Heading << "\n";
+      oss << indent << "Altitude (float) = " << __Altitude << "\n";
+      oss << indent << "AltitudeType (AltitudeType) = " << __AltitudeType << "\n";
+      oss << indent << "ClimbRate (float) = " << __ClimbRate << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string FlightDirectorAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<FlightDirectorAction Series=\"CMASI\">\n";
+      str << ws << "   <Speed>" << __Speed << "</Speed>\n";
+      str << ws << "   <SpeedType>" << afrl::cmasi::SpeedType::get_string(__SpeedType) << "</SpeedType>\n";
+      str << ws << "   <Heading>" << __Heading << "</Heading>\n";
+      str << ws << "   <Altitude>" << __Altitude << "</Altitude>\n";
+      str << ws << "   <AltitudeType>" << afrl::cmasi::AltitudeType::get_string(__AltitudeType) << "</AltitudeType>\n";
+      str << ws << "   <ClimbRate>" << __ClimbRate << "</ClimbRate>\n";
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</FlightDirectorAction>\n";
+
+      return str.str();
+   }
+
+   bool FlightDirectorAction::operator==(const FlightDirectorAction & that)
+   {
+      if( afrl::cmasi::NavigationAction::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Speed != that.__Speed) return false;
+      if(__SpeedType != that.__SpeedType) return false;
+      if(__Heading != that.__Heading) return false;
+      if(__Altitude != that.__Altitude) return false;
+      if(__AltitudeType != that.__AltitudeType) return false;
+      if(__ClimbRate != that.__ClimbRate) return false;
+      return true;
+
+   }
+
+   bool FlightDirectorAction::operator!=(const FlightDirectorAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   FlightDirectorAction& FlightDirectorAction::setSpeed(const float val)
+   {
+      __Speed = val;
+      return *this;
+   }
+
+   FlightDirectorAction& FlightDirectorAction::setSpeedType(const afrl::cmasi::SpeedType::SpeedType val)
+   {
+      __SpeedType = val;
+      return *this;
+   }
+
+   FlightDirectorAction& FlightDirectorAction::setHeading(const float val)
+   {
+      __Heading = val;
+      return *this;
+   }
+
+   FlightDirectorAction& FlightDirectorAction::setAltitude(const float val)
+   {
+      __Altitude = val;
+      return *this;
+   }
+
+   FlightDirectorAction& FlightDirectorAction::setAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val)
+   {
+      __AltitudeType = val;
+      return *this;
+   }
+
+   FlightDirectorAction& FlightDirectorAction::setClimbRate(const float val)
+   {
+      __ClimbRate = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiFlightProfile.cpp b/src/LMCP/afrl/cmasi/afrlcmasiFlightProfile.cpp
new file mode 100644
index 0000000..8bd11fd
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiFlightProfile.cpp
@@ -0,0 +1,238 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/FlightProfile.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string FlightProfile::Subscription = "afrl.cmasi.FlightProfile";
+   const std::string FlightProfile::TypeName = "FlightProfile";
+   
+   bool isFlightProfile(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 12) return false;
+      return true;
+   }
+   
+   bool isFlightProfile(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 12) return false;
+      return true;
+   }
+   
+   std::vector< std::string > FlightProfileDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   FlightProfile::FlightProfile(void) : avtas::lmcp::Object()
+   {
+      __Name = std::string("");
+      __Airspeed = 0.f;
+      __PitchAngle = 0.f;
+      __VerticalSpeed = 0.f;
+      __MaxBankAngle = 0.f;
+      __EnergyRate = 0.f;
+
+   }
+     
+   FlightProfile::FlightProfile(const FlightProfile &that) : avtas::lmcp::Object(that)
+   {
+        __Name = that.__Name;
+        __Airspeed = that.__Airspeed;
+        __PitchAngle = that.__PitchAngle;
+        __VerticalSpeed = that.__VerticalSpeed;
+        __MaxBankAngle = that.__MaxBankAngle;
+        __EnergyRate = that.__EnergyRate;
+
+   }
+   
+   FlightProfile & FlightProfile::operator=(const FlightProfile &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __Name = that.__Name;
+         __Airspeed = that.__Airspeed;
+         __PitchAngle = that.__PitchAngle;
+         __VerticalSpeed = that.__VerticalSpeed;
+         __MaxBankAngle = that.__MaxBankAngle;
+         __EnergyRate = that.__EnergyRate;
+
+      }
+      return *this;
+   }
+
+   FlightProfile* FlightProfile::clone() const
+   {
+        return new FlightProfile(*this);
+   }
+   
+   FlightProfile::~FlightProfile(void)
+   {
+
+   }
+  
+   void FlightProfile::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putString(__Name);
+      buf.putFloat(__Airspeed);
+      buf.putFloat(__PitchAngle);
+      buf.putFloat(__VerticalSpeed);
+      buf.putFloat(__MaxBankAngle);
+      buf.putFloat(__EnergyRate);
+
+   }
+   
+   void FlightProfile::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __Name = buf.getString();
+      __Airspeed = buf.getFloat();
+      __PitchAngle = buf.getFloat();
+      __VerticalSpeed = buf.getFloat();
+      __MaxBankAngle = buf.getFloat();
+      __EnergyRate = buf.getFloat();
+
+   }
+
+   uint32_t FlightProfile::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2 + __Name.length();
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string FlightProfile::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( FlightProfile ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "Name (std::string) = " << __Name << "\n";
+      oss << indent << "Airspeed (float) = " << __Airspeed << "\n";
+      oss << indent << "PitchAngle (float) = " << __PitchAngle << "\n";
+      oss << indent << "VerticalSpeed (float) = " << __VerticalSpeed << "\n";
+      oss << indent << "MaxBankAngle (float) = " << __MaxBankAngle << "\n";
+      oss << indent << "EnergyRate (float) = " << __EnergyRate << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string FlightProfile::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<FlightProfile Series=\"CMASI\">\n";
+      str << ws << "   <Name>" << __Name << "</Name>\n";
+      str << ws << "   <Airspeed>" << __Airspeed << "</Airspeed>\n";
+      str << ws << "   <PitchAngle>" << __PitchAngle << "</PitchAngle>\n";
+      str << ws << "   <VerticalSpeed>" << __VerticalSpeed << "</VerticalSpeed>\n";
+      str << ws << "   <MaxBankAngle>" << __MaxBankAngle << "</MaxBankAngle>\n";
+      str << ws << "   <EnergyRate>" << __EnergyRate << "</EnergyRate>\n";
+      str << ws << "</FlightProfile>\n";
+
+      return str.str();
+   }
+
+   bool FlightProfile::operator==(const FlightProfile & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Name != that.__Name) return false;
+      if(__Airspeed != that.__Airspeed) return false;
+      if(__PitchAngle != that.__PitchAngle) return false;
+      if(__VerticalSpeed != that.__VerticalSpeed) return false;
+      if(__MaxBankAngle != that.__MaxBankAngle) return false;
+      if(__EnergyRate != that.__EnergyRate) return false;
+      return true;
+
+   }
+
+   bool FlightProfile::operator!=(const FlightProfile & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   FlightProfile& FlightProfile::setName(const std::string val)
+   {
+      __Name = val;
+      return *this;
+   }
+
+   FlightProfile& FlightProfile::setAirspeed(const float val)
+   {
+      __Airspeed = val;
+      return *this;
+   }
+
+   FlightProfile& FlightProfile::setPitchAngle(const float val)
+   {
+      __PitchAngle = val;
+      return *this;
+   }
+
+   FlightProfile& FlightProfile::setVerticalSpeed(const float val)
+   {
+      __VerticalSpeed = val;
+      return *this;
+   }
+
+   FlightProfile& FlightProfile::setMaxBankAngle(const float val)
+   {
+      __MaxBankAngle = val;
+      return *this;
+   }
+
+   FlightProfile& FlightProfile::setEnergyRate(const float val)
+   {
+      __EnergyRate = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiFollowPathCommand.cpp b/src/LMCP/afrl/cmasi/afrlcmasiFollowPathCommand.cpp
new file mode 100644
index 0000000..7248882
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiFollowPathCommand.cpp
@@ -0,0 +1,293 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/FollowPathCommand.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string FollowPathCommand::Subscription = "afrl.cmasi.FollowPathCommand";
+   const std::string FollowPathCommand::TypeName = "FollowPathCommand";
+   
+   bool isFollowPathCommand(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 56) return false;
+      return true;
+   }
+   
+   bool isFollowPathCommand(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 56) return false;
+      return true;
+   }
+   
+   std::vector< std::string > FollowPathCommandDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   FollowPathCommand::FollowPathCommand(void) : afrl::cmasi::VehicleActionCommand()
+   {
+      __FirstWaypoint = 0LL;
+      __StartTime = 0LL;
+      __StopTime = 0LL;
+      __RepeatMode = afrl::cmasi::TravelMode::SinglePass;
+
+   }
+     
+   FollowPathCommand::FollowPathCommand(const FollowPathCommand &that) : afrl::cmasi::VehicleActionCommand(that)
+   {
+        __FirstWaypoint = that.__FirstWaypoint;
+        __WaypointList.clear();
+        for (size_t i=0; i< that.__WaypointList.size(); i++)
+        {
+           __WaypointList.push_back( that.__WaypointList[i] == nullptr ? nullptr : that.__WaypointList[i]->clone());
+        }
+        __StartTime = that.__StartTime;
+        __StopTime = that.__StopTime;
+        __RepeatMode = that.__RepeatMode;
+
+   }
+   
+   FollowPathCommand & FollowPathCommand::operator=(const FollowPathCommand &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::VehicleActionCommand::operator=(that);
+         for (size_t i=0; i<__WaypointList.size(); i++)
+         {
+            if (__WaypointList[i] != nullptr) delete __WaypointList[i];
+         }
+
+         __FirstWaypoint = that.__FirstWaypoint;
+         __WaypointList.clear();
+         for (size_t i=0; i< that.__WaypointList.size(); i++)
+         {
+            __WaypointList.push_back( that.__WaypointList[i] == nullptr ? nullptr : that.__WaypointList[i]->clone());
+         }
+         __StartTime = that.__StartTime;
+         __StopTime = that.__StopTime;
+         __RepeatMode = that.__RepeatMode;
+
+      }
+      return *this;
+   }
+
+   FollowPathCommand* FollowPathCommand::clone() const
+   {
+        return new FollowPathCommand(*this);
+   }
+   
+   FollowPathCommand::~FollowPathCommand(void)
+   {
+      for (size_t i=0; i<__WaypointList.size(); i++)
+      {
+         if (__WaypointList[i] != nullptr) delete __WaypointList[i];
+      }
+
+   }
+  
+   void FollowPathCommand::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::VehicleActionCommand::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__FirstWaypoint);
+      buf.putUShort( static_cast<uint16_t>(__WaypointList.size()));
+      for (size_t i=0; i<__WaypointList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __WaypointList[i], buf);
+      }
+      buf.putLong(__StartTime);
+      buf.putLong(__StopTime);
+      buf.putInt( (int32_t) __RepeatMode);
+
+   }
+   
+   void FollowPathCommand::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::VehicleActionCommand::unpack(buf);
+      // Copy the buffer into the class
+      __FirstWaypoint = buf.getLong();
+      for (size_t i=0; i<__WaypointList.size(); i++)
+      {
+         if (__WaypointList[i] != nullptr)
+            delete __WaypointList[i];
+      }
+      __WaypointList.clear();
+      uint16_t __WaypointList_length = buf.getUShort();
+      for (uint32_t i=0; i< __WaypointList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::PathWaypoint* e = (afrl::cmasi::PathWaypoint*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __WaypointList.push_back(e);
+         }
+      }
+      __StartTime = buf.getLong();
+      __StopTime = buf.getLong();
+      __RepeatMode = (afrl::cmasi::TravelMode::TravelMode) buf.getInt();
+
+   }
+
+   uint32_t FollowPathCommand::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::VehicleActionCommand::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__WaypointList.size(); i++)
+      {
+         if (__WaypointList[i] != nullptr)
+         {
+            size += __WaypointList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(afrl::cmasi::TravelMode::TravelMode);
+
+      return size;
+   }
+
+   std::string FollowPathCommand::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( FollowPathCommand ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "CommandID (int64_t) = " << __CommandID << "\n";
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "VehicleActionList (VehicleAction [ " << __VehicleActionList.size() << ", var ])\n";
+      oss << indent << "Status (CommandStatusType) = " << __Status << "\n";
+
+      oss << indent << "FirstWaypoint (int64_t) = " << __FirstWaypoint << "\n";
+      oss << indent << "WaypointList (PathWaypoint [ " << __WaypointList.size() << ", var ])\n";
+      oss << indent << "StartTime (int64_t) = " << __StartTime << "\n";
+      oss << indent << "StopTime (int64_t) = " << __StopTime << "\n";
+      oss << indent << "RepeatMode (TravelMode) = " << __RepeatMode << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string FollowPathCommand::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<FollowPathCommand Series=\"CMASI\">\n";
+      str << ws << "   <FirstWaypoint>" << __FirstWaypoint << "</FirstWaypoint>\n";
+      str << ws << "   <WaypointList>\n";
+      for (size_t i=0; i<__WaypointList.size(); i++)
+      {
+         str << (__WaypointList[i] == nullptr ? ( ws + "   <null/>\n") : (__WaypointList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </WaypointList>\n";
+      str << ws << "   <StartTime>" << __StartTime << "</StartTime>\n";
+      str << ws << "   <StopTime>" << __StopTime << "</StopTime>\n";
+      str << ws << "   <RepeatMode>" << afrl::cmasi::TravelMode::get_string(__RepeatMode) << "</RepeatMode>\n";
+      str << ws << "   <CommandID>" << __CommandID << "</CommandID>\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <VehicleActionList>\n";
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         str << (__VehicleActionList[i] == nullptr ? ( ws + "   <null/>\n") : (__VehicleActionList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </VehicleActionList>\n";
+      str << ws << "   <Status>" << afrl::cmasi::CommandStatusType::get_string(__Status) << "</Status>\n";
+      str << ws << "</FollowPathCommand>\n";
+
+      return str.str();
+   }
+
+   bool FollowPathCommand::operator==(const FollowPathCommand & that)
+   {
+      if( afrl::cmasi::VehicleActionCommand::operator!=(that) )
+      {
+          return false;
+      }
+      if(__FirstWaypoint != that.__FirstWaypoint) return false;
+      if(__WaypointList.size() != that.__WaypointList.size()) return false;
+      for (size_t i=0; i<__WaypointList.size(); i++)
+      {
+         if(__WaypointList[i] && that.__WaypointList[i])
+         {
+            if(__WaypointList[i]->getSeriesNameAsLong() != that.__WaypointList[i]->getSeriesNameAsLong()) return false;
+            if(__WaypointList[i]->getSeriesVersion() != that.__WaypointList[i]->getSeriesVersion()) return false;
+            if(__WaypointList[i]->getLmcpType() != that.__WaypointList[i]->getLmcpType()) return false;
+            if( *(__WaypointList[i]) != *(that.__WaypointList[i]) ) return false;
+         }
+         else if(__WaypointList[i] != that.__WaypointList[i]) return false;
+      }
+      if(__StartTime != that.__StartTime) return false;
+      if(__StopTime != that.__StopTime) return false;
+      if(__RepeatMode != that.__RepeatMode) return false;
+      return true;
+
+   }
+
+   bool FollowPathCommand::operator!=(const FollowPathCommand & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   FollowPathCommand& FollowPathCommand::setFirstWaypoint(const int64_t val)
+   {
+      __FirstWaypoint = val;
+      return *this;
+   }
+
+
+   FollowPathCommand& FollowPathCommand::setStartTime(const int64_t val)
+   {
+      __StartTime = val;
+      return *this;
+   }
+
+   FollowPathCommand& FollowPathCommand::setStopTime(const int64_t val)
+   {
+      __StopTime = val;
+      return *this;
+   }
+
+   FollowPathCommand& FollowPathCommand::setRepeatMode(const afrl::cmasi::TravelMode::TravelMode val)
+   {
+      __RepeatMode = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiGimbalAngleAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiGimbalAngleAction.cpp
new file mode 100644
index 0000000..a655ff6
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiGimbalAngleAction.cpp
@@ -0,0 +1,204 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/GimbalAngleAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string GimbalAngleAction::Subscription = "afrl.cmasi.GimbalAngleAction";
+   const std::string GimbalAngleAction::TypeName = "GimbalAngleAction";
+   
+   bool isGimbalAngleAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 23) return false;
+      return true;
+   }
+   
+   bool isGimbalAngleAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 23) return false;
+      return true;
+   }
+   
+   std::vector< std::string > GimbalAngleActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   GimbalAngleAction::GimbalAngleAction(void) : afrl::cmasi::PayloadAction()
+   {
+      __Azimuth = 0.f;
+      __Elevation = 0.f;
+      __Rotation = 0.f;
+
+   }
+     
+   GimbalAngleAction::GimbalAngleAction(const GimbalAngleAction &that) : afrl::cmasi::PayloadAction(that)
+   {
+        __Azimuth = that.__Azimuth;
+        __Elevation = that.__Elevation;
+        __Rotation = that.__Rotation;
+
+   }
+   
+   GimbalAngleAction & GimbalAngleAction::operator=(const GimbalAngleAction &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadAction::operator=(that);
+
+         __Azimuth = that.__Azimuth;
+         __Elevation = that.__Elevation;
+         __Rotation = that.__Rotation;
+
+      }
+      return *this;
+   }
+
+   GimbalAngleAction* GimbalAngleAction::clone() const
+   {
+        return new GimbalAngleAction(*this);
+   }
+   
+   GimbalAngleAction::~GimbalAngleAction(void)
+   {
+
+   }
+  
+   void GimbalAngleAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadAction::pack(buf);
+      // Copy the class into the buffer
+      buf.putFloat(__Azimuth);
+      buf.putFloat(__Elevation);
+      buf.putFloat(__Rotation);
+
+   }
+   
+   void GimbalAngleAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadAction::unpack(buf);
+      // Copy the buffer into the class
+      __Azimuth = buf.getFloat();
+      __Elevation = buf.getFloat();
+      __Rotation = buf.getFloat();
+
+   }
+
+   uint32_t GimbalAngleAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadAction::calculatePackedSize();
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string GimbalAngleAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( GimbalAngleAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+
+      oss << indent << "Azimuth (float) = " << __Azimuth << "\n";
+      oss << indent << "Elevation (float) = " << __Elevation << "\n";
+      oss << indent << "Rotation (float) = " << __Rotation << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string GimbalAngleAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<GimbalAngleAction Series=\"CMASI\">\n";
+      str << ws << "   <Azimuth>" << __Azimuth << "</Azimuth>\n";
+      str << ws << "   <Elevation>" << __Elevation << "</Elevation>\n";
+      str << ws << "   <Rotation>" << __Rotation << "</Rotation>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</GimbalAngleAction>\n";
+
+      return str.str();
+   }
+
+   bool GimbalAngleAction::operator==(const GimbalAngleAction & that)
+   {
+      if( afrl::cmasi::PayloadAction::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Azimuth != that.__Azimuth) return false;
+      if(__Elevation != that.__Elevation) return false;
+      if(__Rotation != that.__Rotation) return false;
+      return true;
+
+   }
+
+   bool GimbalAngleAction::operator!=(const GimbalAngleAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   GimbalAngleAction& GimbalAngleAction::setAzimuth(const float val)
+   {
+      __Azimuth = val;
+      return *this;
+   }
+
+   GimbalAngleAction& GimbalAngleAction::setElevation(const float val)
+   {
+      __Elevation = val;
+      return *this;
+   }
+
+   GimbalAngleAction& GimbalAngleAction::setRotation(const float val)
+   {
+      __Rotation = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiGimbalConfiguration.cpp b/src/LMCP/afrl/cmasi/afrlcmasiGimbalConfiguration.cpp
new file mode 100644
index 0000000..8084e1d
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiGimbalConfiguration.cpp
@@ -0,0 +1,410 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/GimbalConfiguration.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string GimbalConfiguration::Subscription = "afrl.cmasi.GimbalConfiguration";
+   const std::string GimbalConfiguration::TypeName = "GimbalConfiguration";
+   
+   bool isGimbalConfiguration(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 24) return false;
+      return true;
+   }
+   
+   bool isGimbalConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 24) return false;
+      return true;
+   }
+   
+   std::vector< std::string > GimbalConfigurationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   GimbalConfiguration::GimbalConfiguration(void) : afrl::cmasi::PayloadConfiguration()
+   {
+      __MinAzimuth = -180.f;
+      __MaxAzimuth = 180.f;
+      __IsAzimuthClamped = false;
+      __MinElevation = -180.f;
+      __MaxElevation = 180.f;
+      __IsElevationClamped = false;
+      __MinRotation = 0.f;
+      __MaxRotation = 0.f;
+      __IsRotationClamped = true;
+      __MaxAzimuthSlewRate = 0.f;
+      __MaxElevationSlewRate = 0.f;
+      __MaxRotationRate = 0.f;
+
+   }
+     
+   GimbalConfiguration::GimbalConfiguration(const GimbalConfiguration &that) : afrl::cmasi::PayloadConfiguration(that)
+   {
+        __SupportedPointingModes.clear();
+        for (size_t i=0; i< that.__SupportedPointingModes.size(); i++)
+        {
+           __SupportedPointingModes.push_back( that.__SupportedPointingModes[i]);
+        }
+        __MinAzimuth = that.__MinAzimuth;
+        __MaxAzimuth = that.__MaxAzimuth;
+        __IsAzimuthClamped = that.__IsAzimuthClamped;
+        __MinElevation = that.__MinElevation;
+        __MaxElevation = that.__MaxElevation;
+        __IsElevationClamped = that.__IsElevationClamped;
+        __MinRotation = that.__MinRotation;
+        __MaxRotation = that.__MaxRotation;
+        __IsRotationClamped = that.__IsRotationClamped;
+        __MaxAzimuthSlewRate = that.__MaxAzimuthSlewRate;
+        __MaxElevationSlewRate = that.__MaxElevationSlewRate;
+        __MaxRotationRate = that.__MaxRotationRate;
+        __ContainedPayloadList.clear();
+        for (size_t i=0; i< that.__ContainedPayloadList.size(); i++)
+        {
+           __ContainedPayloadList.push_back( that.__ContainedPayloadList[i]);
+        }
+
+   }
+   
+   GimbalConfiguration & GimbalConfiguration::operator=(const GimbalConfiguration &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadConfiguration::operator=(that);
+
+         __SupportedPointingModes.clear();
+         for (size_t i=0; i< that.__SupportedPointingModes.size(); i++)
+         {
+            __SupportedPointingModes.push_back( that.__SupportedPointingModes[i]);
+         }
+         __MinAzimuth = that.__MinAzimuth;
+         __MaxAzimuth = that.__MaxAzimuth;
+         __IsAzimuthClamped = that.__IsAzimuthClamped;
+         __MinElevation = that.__MinElevation;
+         __MaxElevation = that.__MaxElevation;
+         __IsElevationClamped = that.__IsElevationClamped;
+         __MinRotation = that.__MinRotation;
+         __MaxRotation = that.__MaxRotation;
+         __IsRotationClamped = that.__IsRotationClamped;
+         __MaxAzimuthSlewRate = that.__MaxAzimuthSlewRate;
+         __MaxElevationSlewRate = that.__MaxElevationSlewRate;
+         __MaxRotationRate = that.__MaxRotationRate;
+         __ContainedPayloadList.clear();
+         for (size_t i=0; i< that.__ContainedPayloadList.size(); i++)
+         {
+            __ContainedPayloadList.push_back( that.__ContainedPayloadList[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   GimbalConfiguration* GimbalConfiguration::clone() const
+   {
+        return new GimbalConfiguration(*this);
+   }
+   
+   GimbalConfiguration::~GimbalConfiguration(void)
+   {
+
+   }
+  
+   void GimbalConfiguration::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadConfiguration::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__SupportedPointingModes.size()));
+      for (size_t i=0; i<__SupportedPointingModes.size(); i++)
+      {
+         buf.putInt( (int32_t) __SupportedPointingModes[i]);
+      }
+      buf.putFloat(__MinAzimuth);
+      buf.putFloat(__MaxAzimuth);
+      buf.putBool(__IsAzimuthClamped);
+      buf.putFloat(__MinElevation);
+      buf.putFloat(__MaxElevation);
+      buf.putBool(__IsElevationClamped);
+      buf.putFloat(__MinRotation);
+      buf.putFloat(__MaxRotation);
+      buf.putBool(__IsRotationClamped);
+      buf.putFloat(__MaxAzimuthSlewRate);
+      buf.putFloat(__MaxElevationSlewRate);
+      buf.putFloat(__MaxRotationRate);
+      buf.putUShort( static_cast<uint16_t>(__ContainedPayloadList.size()));
+      for (size_t i=0; i<__ContainedPayloadList.size(); i++)
+      {
+         buf.putLong(__ContainedPayloadList[i]);
+      }
+
+   }
+   
+   void GimbalConfiguration::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadConfiguration::unpack(buf);
+      // Copy the buffer into the class
+      __SupportedPointingModes.clear();
+      uint16_t __SupportedPointingModes_length = buf.getUShort();
+      for (uint32_t i=0; i< __SupportedPointingModes_length; i++)
+      {
+         __SupportedPointingModes.push_back( (afrl::cmasi::GimbalPointingMode::GimbalPointingMode) buf.getInt() );
+      }
+      __MinAzimuth = buf.getFloat();
+      __MaxAzimuth = buf.getFloat();
+      __IsAzimuthClamped = buf.getBool();
+      __MinElevation = buf.getFloat();
+      __MaxElevation = buf.getFloat();
+      __IsElevationClamped = buf.getBool();
+      __MinRotation = buf.getFloat();
+      __MaxRotation = buf.getFloat();
+      __IsRotationClamped = buf.getBool();
+      __MaxAzimuthSlewRate = buf.getFloat();
+      __MaxElevationSlewRate = buf.getFloat();
+      __MaxRotationRate = buf.getFloat();
+      __ContainedPayloadList.clear();
+      uint16_t __ContainedPayloadList_length = buf.getUShort();
+      for (uint32_t i=0; i< __ContainedPayloadList_length; i++)
+      {
+         __ContainedPayloadList.push_back(buf.getLong() );
+      }
+
+   }
+
+   uint32_t GimbalConfiguration::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadConfiguration::calculatePackedSize();
+      size += 2 + sizeof(afrl::cmasi::GimbalPointingMode::GimbalPointingMode) * __SupportedPointingModes.size();
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(bool);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(bool);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(bool);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += 2 + sizeof(int64_t) * __ContainedPayloadList.size();
+
+      return size;
+   }
+
+   std::string GimbalConfiguration::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( GimbalConfiguration ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "PayloadKind (std::string) = " << __PayloadKind << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      oss << indent << "SupportedPointingModes (GimbalPointingMode [ " << __SupportedPointingModes.size() << ", var ])\n";
+      oss << indent << "MinAzimuth (float) = " << __MinAzimuth << "\n";
+      oss << indent << "MaxAzimuth (float) = " << __MaxAzimuth << "\n";
+      oss << indent << "IsAzimuthClamped (bool) = " << __IsAzimuthClamped << "\n";
+      oss << indent << "MinElevation (float) = " << __MinElevation << "\n";
+      oss << indent << "MaxElevation (float) = " << __MaxElevation << "\n";
+      oss << indent << "IsElevationClamped (bool) = " << __IsElevationClamped << "\n";
+      oss << indent << "MinRotation (float) = " << __MinRotation << "\n";
+      oss << indent << "MaxRotation (float) = " << __MaxRotation << "\n";
+      oss << indent << "IsRotationClamped (bool) = " << __IsRotationClamped << "\n";
+      oss << indent << "MaxAzimuthSlewRate (float) = " << __MaxAzimuthSlewRate << "\n";
+      oss << indent << "MaxElevationSlewRate (float) = " << __MaxElevationSlewRate << "\n";
+      oss << indent << "MaxRotationRate (float) = " << __MaxRotationRate << "\n";
+      oss << indent << "ContainedPayloadList (int64 [ " << __ContainedPayloadList.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string GimbalConfiguration::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<GimbalConfiguration Series=\"CMASI\">\n";
+      str << ws << "   <SupportedPointingModes>\n";
+      for (size_t i=0; i<__SupportedPointingModes.size(); i++)
+      {
+         str << ws << "   <GimbalPointingMode>" << afrl::cmasi::GimbalPointingMode::get_string(__SupportedPointingModes[i]) << "</GimbalPointingMode>\n";
+      }
+      str << ws << "   </SupportedPointingModes>\n";
+      str << ws << "   <MinAzimuth>" << __MinAzimuth << "</MinAzimuth>\n";
+      str << ws << "   <MaxAzimuth>" << __MaxAzimuth << "</MaxAzimuth>\n";
+      str << ws << "   <IsAzimuthClamped>" << (__IsAzimuthClamped ? "true" : "false") << "</IsAzimuthClamped>\n";
+      str << ws << "   <MinElevation>" << __MinElevation << "</MinElevation>\n";
+      str << ws << "   <MaxElevation>" << __MaxElevation << "</MaxElevation>\n";
+      str << ws << "   <IsElevationClamped>" << (__IsElevationClamped ? "true" : "false") << "</IsElevationClamped>\n";
+      str << ws << "   <MinRotation>" << __MinRotation << "</MinRotation>\n";
+      str << ws << "   <MaxRotation>" << __MaxRotation << "</MaxRotation>\n";
+      str << ws << "   <IsRotationClamped>" << (__IsRotationClamped ? "true" : "false") << "</IsRotationClamped>\n";
+      str << ws << "   <MaxAzimuthSlewRate>" << __MaxAzimuthSlewRate << "</MaxAzimuthSlewRate>\n";
+      str << ws << "   <MaxElevationSlewRate>" << __MaxElevationSlewRate << "</MaxElevationSlewRate>\n";
+      str << ws << "   <MaxRotationRate>" << __MaxRotationRate << "</MaxRotationRate>\n";
+      str << ws << "   <ContainedPayloadList>\n";
+      for (size_t i=0; i<__ContainedPayloadList.size(); i++)
+      {
+         str << ws << "   <int64>" << __ContainedPayloadList[i] << "</int64>\n";
+      }
+      str << ws << "   </ContainedPayloadList>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <PayloadKind>" << __PayloadKind << "</PayloadKind>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</GimbalConfiguration>\n";
+
+      return str.str();
+   }
+
+   bool GimbalConfiguration::operator==(const GimbalConfiguration & that)
+   {
+      if( afrl::cmasi::PayloadConfiguration::operator!=(that) )
+      {
+          return false;
+      }
+      if(__SupportedPointingModes.size() != that.__SupportedPointingModes.size()) return false;
+      for (size_t i=0; i<__SupportedPointingModes.size(); i++)
+      {
+         if(__SupportedPointingModes[i] != that.__SupportedPointingModes[i]) return false;
+      }
+      if(__MinAzimuth != that.__MinAzimuth) return false;
+      if(__MaxAzimuth != that.__MaxAzimuth) return false;
+      if(__IsAzimuthClamped != that.__IsAzimuthClamped) return false;
+      if(__MinElevation != that.__MinElevation) return false;
+      if(__MaxElevation != that.__MaxElevation) return false;
+      if(__IsElevationClamped != that.__IsElevationClamped) return false;
+      if(__MinRotation != that.__MinRotation) return false;
+      if(__MaxRotation != that.__MaxRotation) return false;
+      if(__IsRotationClamped != that.__IsRotationClamped) return false;
+      if(__MaxAzimuthSlewRate != that.__MaxAzimuthSlewRate) return false;
+      if(__MaxElevationSlewRate != that.__MaxElevationSlewRate) return false;
+      if(__MaxRotationRate != that.__MaxRotationRate) return false;
+      if(__ContainedPayloadList.size() != that.__ContainedPayloadList.size()) return false;
+      for (size_t i=0; i<__ContainedPayloadList.size(); i++)
+      {
+         if(__ContainedPayloadList[i] != that.__ContainedPayloadList[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool GimbalConfiguration::operator!=(const GimbalConfiguration & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+   GimbalConfiguration& GimbalConfiguration::setMinAzimuth(const float val)
+   {
+      __MinAzimuth = val;
+      return *this;
+   }
+
+   GimbalConfiguration& GimbalConfiguration::setMaxAzimuth(const float val)
+   {
+      __MaxAzimuth = val;
+      return *this;
+   }
+
+   GimbalConfiguration& GimbalConfiguration::setIsAzimuthClamped(const bool val)
+   {
+      __IsAzimuthClamped = val;
+      return *this;
+   }
+
+   GimbalConfiguration& GimbalConfiguration::setMinElevation(const float val)
+   {
+      __MinElevation = val;
+      return *this;
+   }
+
+   GimbalConfiguration& GimbalConfiguration::setMaxElevation(const float val)
+   {
+      __MaxElevation = val;
+      return *this;
+   }
+
+   GimbalConfiguration& GimbalConfiguration::setIsElevationClamped(const bool val)
+   {
+      __IsElevationClamped = val;
+      return *this;
+   }
+
+   GimbalConfiguration& GimbalConfiguration::setMinRotation(const float val)
+   {
+      __MinRotation = val;
+      return *this;
+   }
+
+   GimbalConfiguration& GimbalConfiguration::setMaxRotation(const float val)
+   {
+      __MaxRotation = val;
+      return *this;
+   }
+
+   GimbalConfiguration& GimbalConfiguration::setIsRotationClamped(const bool val)
+   {
+      __IsRotationClamped = val;
+      return *this;
+   }
+
+   GimbalConfiguration& GimbalConfiguration::setMaxAzimuthSlewRate(const float val)
+   {
+      __MaxAzimuthSlewRate = val;
+      return *this;
+   }
+
+   GimbalConfiguration& GimbalConfiguration::setMaxElevationSlewRate(const float val)
+   {
+      __MaxElevationSlewRate = val;
+      return *this;
+   }
+
+   GimbalConfiguration& GimbalConfiguration::setMaxRotationRate(const float val)
+   {
+      __MaxRotationRate = val;
+      return *this;
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiGimbalScanAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiGimbalScanAction.cpp
new file mode 100644
index 0000000..8b3324c
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiGimbalScanAction.cpp
@@ -0,0 +1,264 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/GimbalScanAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string GimbalScanAction::Subscription = "afrl.cmasi.GimbalScanAction";
+   const std::string GimbalScanAction::TypeName = "GimbalScanAction";
+   
+   bool isGimbalScanAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 25) return false;
+      return true;
+   }
+   
+   bool isGimbalScanAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 25) return false;
+      return true;
+   }
+   
+   std::vector< std::string > GimbalScanActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   GimbalScanAction::GimbalScanAction(void) : afrl::cmasi::PayloadAction()
+   {
+      __AzimuthSlewRate = 0.f;
+      __ElevationSlewRate = 0.f;
+      __StartAzimuth = 0.f;
+      __EndAzimuth = 0.f;
+      __StartElevation = 0.f;
+      __EndElevation = 0.f;
+      __Cycles = 0;
+
+   }
+     
+   GimbalScanAction::GimbalScanAction(const GimbalScanAction &that) : afrl::cmasi::PayloadAction(that)
+   {
+        __AzimuthSlewRate = that.__AzimuthSlewRate;
+        __ElevationSlewRate = that.__ElevationSlewRate;
+        __StartAzimuth = that.__StartAzimuth;
+        __EndAzimuth = that.__EndAzimuth;
+        __StartElevation = that.__StartElevation;
+        __EndElevation = that.__EndElevation;
+        __Cycles = that.__Cycles;
+
+   }
+   
+   GimbalScanAction & GimbalScanAction::operator=(const GimbalScanAction &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadAction::operator=(that);
+
+         __AzimuthSlewRate = that.__AzimuthSlewRate;
+         __ElevationSlewRate = that.__ElevationSlewRate;
+         __StartAzimuth = that.__StartAzimuth;
+         __EndAzimuth = that.__EndAzimuth;
+         __StartElevation = that.__StartElevation;
+         __EndElevation = that.__EndElevation;
+         __Cycles = that.__Cycles;
+
+      }
+      return *this;
+   }
+
+   GimbalScanAction* GimbalScanAction::clone() const
+   {
+        return new GimbalScanAction(*this);
+   }
+   
+   GimbalScanAction::~GimbalScanAction(void)
+   {
+
+   }
+  
+   void GimbalScanAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadAction::pack(buf);
+      // Copy the class into the buffer
+      buf.putFloat(__AzimuthSlewRate);
+      buf.putFloat(__ElevationSlewRate);
+      buf.putFloat(__StartAzimuth);
+      buf.putFloat(__EndAzimuth);
+      buf.putFloat(__StartElevation);
+      buf.putFloat(__EndElevation);
+      buf.putUInt(__Cycles);
+
+   }
+   
+   void GimbalScanAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadAction::unpack(buf);
+      // Copy the buffer into the class
+      __AzimuthSlewRate = buf.getFloat();
+      __ElevationSlewRate = buf.getFloat();
+      __StartAzimuth = buf.getFloat();
+      __EndAzimuth = buf.getFloat();
+      __StartElevation = buf.getFloat();
+      __EndElevation = buf.getFloat();
+      __Cycles = buf.getUInt();
+
+   }
+
+   uint32_t GimbalScanAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadAction::calculatePackedSize();
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(uint32_t);
+
+      return size;
+   }
+
+   std::string GimbalScanAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( GimbalScanAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+
+      oss << indent << "AzimuthSlewRate (float) = " << __AzimuthSlewRate << "\n";
+      oss << indent << "ElevationSlewRate (float) = " << __ElevationSlewRate << "\n";
+      oss << indent << "StartAzimuth (float) = " << __StartAzimuth << "\n";
+      oss << indent << "EndAzimuth (float) = " << __EndAzimuth << "\n";
+      oss << indent << "StartElevation (float) = " << __StartElevation << "\n";
+      oss << indent << "EndElevation (float) = " << __EndElevation << "\n";
+      oss << indent << "Cycles (uint32_t) = " << __Cycles << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string GimbalScanAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<GimbalScanAction Series=\"CMASI\">\n";
+      str << ws << "   <AzimuthSlewRate>" << __AzimuthSlewRate << "</AzimuthSlewRate>\n";
+      str << ws << "   <ElevationSlewRate>" << __ElevationSlewRate << "</ElevationSlewRate>\n";
+      str << ws << "   <StartAzimuth>" << __StartAzimuth << "</StartAzimuth>\n";
+      str << ws << "   <EndAzimuth>" << __EndAzimuth << "</EndAzimuth>\n";
+      str << ws << "   <StartElevation>" << __StartElevation << "</StartElevation>\n";
+      str << ws << "   <EndElevation>" << __EndElevation << "</EndElevation>\n";
+      str << ws << "   <Cycles>" << __Cycles << "</Cycles>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</GimbalScanAction>\n";
+
+      return str.str();
+   }
+
+   bool GimbalScanAction::operator==(const GimbalScanAction & that)
+   {
+      if( afrl::cmasi::PayloadAction::operator!=(that) )
+      {
+          return false;
+      }
+      if(__AzimuthSlewRate != that.__AzimuthSlewRate) return false;
+      if(__ElevationSlewRate != that.__ElevationSlewRate) return false;
+      if(__StartAzimuth != that.__StartAzimuth) return false;
+      if(__EndAzimuth != that.__EndAzimuth) return false;
+      if(__StartElevation != that.__StartElevation) return false;
+      if(__EndElevation != that.__EndElevation) return false;
+      if(__Cycles != that.__Cycles) return false;
+      return true;
+
+   }
+
+   bool GimbalScanAction::operator!=(const GimbalScanAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   GimbalScanAction& GimbalScanAction::setAzimuthSlewRate(const float val)
+   {
+      __AzimuthSlewRate = val;
+      return *this;
+   }
+
+   GimbalScanAction& GimbalScanAction::setElevationSlewRate(const float val)
+   {
+      __ElevationSlewRate = val;
+      return *this;
+   }
+
+   GimbalScanAction& GimbalScanAction::setStartAzimuth(const float val)
+   {
+      __StartAzimuth = val;
+      return *this;
+   }
+
+   GimbalScanAction& GimbalScanAction::setEndAzimuth(const float val)
+   {
+      __EndAzimuth = val;
+      return *this;
+   }
+
+   GimbalScanAction& GimbalScanAction::setStartElevation(const float val)
+   {
+      __StartElevation = val;
+      return *this;
+   }
+
+   GimbalScanAction& GimbalScanAction::setEndElevation(const float val)
+   {
+      __EndElevation = val;
+      return *this;
+   }
+
+   GimbalScanAction& GimbalScanAction::setCycles(const uint32_t val)
+   {
+      __Cycles = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiGimbalStareAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiGimbalStareAction.cpp
new file mode 100644
index 0000000..dc38594
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiGimbalStareAction.cpp
@@ -0,0 +1,220 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/GimbalStareAction.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string GimbalStareAction::Subscription = "afrl.cmasi.GimbalStareAction";
+   const std::string GimbalStareAction::TypeName = "GimbalStareAction";
+   
+   bool isGimbalStareAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 26) return false;
+      return true;
+   }
+   
+   bool isGimbalStareAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 26) return false;
+      return true;
+   }
+   
+   std::vector< std::string > GimbalStareActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   GimbalStareAction::GimbalStareAction(void) : afrl::cmasi::PayloadAction()
+   {
+      __Starepoint = new afrl::cmasi::Location3D();
+      __Duration = 0LL;
+
+   }
+     
+   GimbalStareAction::GimbalStareAction(const GimbalStareAction &that) : afrl::cmasi::PayloadAction(that)
+   {
+        __Starepoint = that.__Starepoint == nullptr ? nullptr : that.__Starepoint->clone();
+        __Duration = that.__Duration;
+
+   }
+   
+   GimbalStareAction & GimbalStareAction::operator=(const GimbalStareAction &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadAction::operator=(that);
+         if (__Starepoint != nullptr) delete __Starepoint;
+
+         __Starepoint = that.__Starepoint == nullptr ? nullptr : that.__Starepoint->clone();
+         __Duration = that.__Duration;
+
+      }
+      return *this;
+   }
+
+   GimbalStareAction* GimbalStareAction::clone() const
+   {
+        return new GimbalStareAction(*this);
+   }
+   
+   GimbalStareAction::~GimbalStareAction(void)
+   {
+      if (__Starepoint != nullptr) delete __Starepoint;
+
+   }
+  
+   void GimbalStareAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadAction::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Starepoint, buf);
+      buf.putLong(__Duration);
+
+   }
+   
+   void GimbalStareAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadAction::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__Starepoint != nullptr) delete __Starepoint;
+         __Starepoint = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Starepoint = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Starepoint != nullptr) __Starepoint->unpack(buf);
+         }
+      }
+      __Duration = buf.getLong();
+
+   }
+
+   uint32_t GimbalStareAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadAction::calculatePackedSize();
+      size += (__Starepoint != nullptr ? __Starepoint->calculatePackedSize() + 15 : 1);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string GimbalStareAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( GimbalStareAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+
+      oss << indent << "Starepoint (Location3D)";
+      if (__Starepoint == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "Duration (int64_t) = " << __Duration << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string GimbalStareAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<GimbalStareAction Series=\"CMASI\">\n";
+      if (__Starepoint != nullptr)
+      {
+         str << ws << "   <Starepoint>";
+         str << "\n" + __Starepoint->toXML(depth + 1) + ws + "   ";
+         str << "</Starepoint>\n";
+      }
+      str << ws << "   <Duration>" << __Duration << "</Duration>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</GimbalStareAction>\n";
+
+      return str.str();
+   }
+
+   bool GimbalStareAction::operator==(const GimbalStareAction & that)
+   {
+      if( afrl::cmasi::PayloadAction::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Starepoint && that.__Starepoint)
+      {
+         if(__Starepoint->getSeriesNameAsLong() != that.__Starepoint->getSeriesNameAsLong()) return false;
+         if(__Starepoint->getSeriesVersion() != that.__Starepoint->getSeriesVersion()) return false;
+         if(__Starepoint->getLmcpType() != that.__Starepoint->getLmcpType()) return false;
+         if( *(__Starepoint) != *(that.__Starepoint) ) return false;
+      }
+      else if(__Starepoint != that.__Starepoint) return false;
+      if(__Duration != that.__Duration) return false;
+      return true;
+
+   }
+
+   bool GimbalStareAction::operator!=(const GimbalStareAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   GimbalStareAction& GimbalStareAction::setStarepoint(const afrl::cmasi::Location3D* const val)
+   {
+      if (__Starepoint != nullptr) { delete __Starepoint; __Starepoint = nullptr; }
+      if (val != nullptr) { __Starepoint = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   GimbalStareAction& GimbalStareAction::setDuration(const int64_t val)
+   {
+      __Duration = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiGimbalState.cpp b/src/LMCP/afrl/cmasi/afrlcmasiGimbalState.cpp
new file mode 100644
index 0000000..b239344
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiGimbalState.cpp
@@ -0,0 +1,218 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/GimbalState.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string GimbalState::Subscription = "afrl.cmasi.GimbalState";
+   const std::string GimbalState::TypeName = "GimbalState";
+   
+   bool isGimbalState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 27) return false;
+      return true;
+   }
+   
+   bool isGimbalState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 27) return false;
+      return true;
+   }
+   
+   std::vector< std::string > GimbalStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   GimbalState::GimbalState(void) : afrl::cmasi::PayloadState()
+   {
+      __PointingMode = afrl::cmasi::GimbalPointingMode::Unknown;
+      __Azimuth = 0.f;
+      __Elevation = 0.f;
+      __Rotation = 0.f;
+
+   }
+     
+   GimbalState::GimbalState(const GimbalState &that) : afrl::cmasi::PayloadState(that)
+   {
+        __PointingMode = that.__PointingMode;
+        __Azimuth = that.__Azimuth;
+        __Elevation = that.__Elevation;
+        __Rotation = that.__Rotation;
+
+   }
+   
+   GimbalState & GimbalState::operator=(const GimbalState &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadState::operator=(that);
+
+         __PointingMode = that.__PointingMode;
+         __Azimuth = that.__Azimuth;
+         __Elevation = that.__Elevation;
+         __Rotation = that.__Rotation;
+
+      }
+      return *this;
+   }
+
+   GimbalState* GimbalState::clone() const
+   {
+        return new GimbalState(*this);
+   }
+   
+   GimbalState::~GimbalState(void)
+   {
+
+   }
+  
+   void GimbalState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadState::pack(buf);
+      // Copy the class into the buffer
+      buf.putInt( (int32_t) __PointingMode);
+      buf.putFloat(__Azimuth);
+      buf.putFloat(__Elevation);
+      buf.putFloat(__Rotation);
+
+   }
+   
+   void GimbalState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadState::unpack(buf);
+      // Copy the buffer into the class
+      __PointingMode = (afrl::cmasi::GimbalPointingMode::GimbalPointingMode) buf.getInt();
+      __Azimuth = buf.getFloat();
+      __Elevation = buf.getFloat();
+      __Rotation = buf.getFloat();
+
+   }
+
+   uint32_t GimbalState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadState::calculatePackedSize();
+      size += sizeof(afrl::cmasi::GimbalPointingMode::GimbalPointingMode);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string GimbalState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( GimbalState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      oss << indent << "PointingMode (GimbalPointingMode) = " << __PointingMode << "\n";
+      oss << indent << "Azimuth (float) = " << __Azimuth << "\n";
+      oss << indent << "Elevation (float) = " << __Elevation << "\n";
+      oss << indent << "Rotation (float) = " << __Rotation << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string GimbalState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<GimbalState Series=\"CMASI\">\n";
+      str << ws << "   <PointingMode>" << afrl::cmasi::GimbalPointingMode::get_string(__PointingMode) << "</PointingMode>\n";
+      str << ws << "   <Azimuth>" << __Azimuth << "</Azimuth>\n";
+      str << ws << "   <Elevation>" << __Elevation << "</Elevation>\n";
+      str << ws << "   <Rotation>" << __Rotation << "</Rotation>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</GimbalState>\n";
+
+      return str.str();
+   }
+
+   bool GimbalState::operator==(const GimbalState & that)
+   {
+      if( afrl::cmasi::PayloadState::operator!=(that) )
+      {
+          return false;
+      }
+      if(__PointingMode != that.__PointingMode) return false;
+      if(__Azimuth != that.__Azimuth) return false;
+      if(__Elevation != that.__Elevation) return false;
+      if(__Rotation != that.__Rotation) return false;
+      return true;
+
+   }
+
+   bool GimbalState::operator!=(const GimbalState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   GimbalState& GimbalState::setPointingMode(const afrl::cmasi::GimbalPointingMode::GimbalPointingMode val)
+   {
+      __PointingMode = val;
+      return *this;
+   }
+
+   GimbalState& GimbalState::setAzimuth(const float val)
+   {
+      __Azimuth = val;
+      return *this;
+   }
+
+   GimbalState& GimbalState::setElevation(const float val)
+   {
+      __Elevation = val;
+      return *this;
+   }
+
+   GimbalState& GimbalState::setRotation(const float val)
+   {
+      __Rotation = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiGimballedPayloadState.cpp b/src/LMCP/afrl/cmasi/afrlcmasiGimballedPayloadState.cpp
new file mode 100644
index 0000000..0bffd75
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiGimballedPayloadState.cpp
@@ -0,0 +1,219 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/GimballedPayloadState.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string GimballedPayloadState::Subscription = "afrl.cmasi.GimballedPayloadState";
+   const std::string GimballedPayloadState::TypeName = "GimballedPayloadState";
+   
+   bool isGimballedPayloadState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 20) return false;
+      return true;
+   }
+   
+   bool isGimballedPayloadState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 20) return false;
+      return true;
+   }
+   
+   std::vector< std::string > GimballedPayloadStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.CameraState");
+
+       return descendants;
+   }
+   
+   GimballedPayloadState::GimballedPayloadState(void) : afrl::cmasi::PayloadState()
+   {
+      __PointingMode = afrl::cmasi::GimbalPointingMode::Unknown;
+      __Azimuth = 0.f;
+      __Elevation = 0.f;
+      __Rotation = 0.f;
+
+   }
+     
+   GimballedPayloadState::GimballedPayloadState(const GimballedPayloadState &that) : afrl::cmasi::PayloadState(that)
+   {
+        __PointingMode = that.__PointingMode;
+        __Azimuth = that.__Azimuth;
+        __Elevation = that.__Elevation;
+        __Rotation = that.__Rotation;
+
+   }
+   
+   GimballedPayloadState & GimballedPayloadState::operator=(const GimballedPayloadState &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadState::operator=(that);
+
+         __PointingMode = that.__PointingMode;
+         __Azimuth = that.__Azimuth;
+         __Elevation = that.__Elevation;
+         __Rotation = that.__Rotation;
+
+      }
+      return *this;
+   }
+
+   GimballedPayloadState* GimballedPayloadState::clone() const
+   {
+        return new GimballedPayloadState(*this);
+   }
+   
+   GimballedPayloadState::~GimballedPayloadState(void)
+   {
+
+   }
+  
+   void GimballedPayloadState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadState::pack(buf);
+      // Copy the class into the buffer
+      buf.putInt( (int32_t) __PointingMode);
+      buf.putFloat(__Azimuth);
+      buf.putFloat(__Elevation);
+      buf.putFloat(__Rotation);
+
+   }
+   
+   void GimballedPayloadState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadState::unpack(buf);
+      // Copy the buffer into the class
+      __PointingMode = (afrl::cmasi::GimbalPointingMode::GimbalPointingMode) buf.getInt();
+      __Azimuth = buf.getFloat();
+      __Elevation = buf.getFloat();
+      __Rotation = buf.getFloat();
+
+   }
+
+   uint32_t GimballedPayloadState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadState::calculatePackedSize();
+      size += sizeof(afrl::cmasi::GimbalPointingMode::GimbalPointingMode);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string GimballedPayloadState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( GimballedPayloadState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      oss << indent << "PointingMode (GimbalPointingMode) = " << __PointingMode << "\n";
+      oss << indent << "Azimuth (float) = " << __Azimuth << "\n";
+      oss << indent << "Elevation (float) = " << __Elevation << "\n";
+      oss << indent << "Rotation (float) = " << __Rotation << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string GimballedPayloadState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<GimballedPayloadState Series=\"CMASI\">\n";
+      str << ws << "   <PointingMode>" << afrl::cmasi::GimbalPointingMode::get_string(__PointingMode) << "</PointingMode>\n";
+      str << ws << "   <Azimuth>" << __Azimuth << "</Azimuth>\n";
+      str << ws << "   <Elevation>" << __Elevation << "</Elevation>\n";
+      str << ws << "   <Rotation>" << __Rotation << "</Rotation>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</GimballedPayloadState>\n";
+
+      return str.str();
+   }
+
+   bool GimballedPayloadState::operator==(const GimballedPayloadState & that)
+   {
+      if( afrl::cmasi::PayloadState::operator!=(that) )
+      {
+          return false;
+      }
+      if(__PointingMode != that.__PointingMode) return false;
+      if(__Azimuth != that.__Azimuth) return false;
+      if(__Elevation != that.__Elevation) return false;
+      if(__Rotation != that.__Rotation) return false;
+      return true;
+
+   }
+
+   bool GimballedPayloadState::operator!=(const GimballedPayloadState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   GimballedPayloadState& GimballedPayloadState::setPointingMode(const afrl::cmasi::GimbalPointingMode::GimbalPointingMode val)
+   {
+      __PointingMode = val;
+      return *this;
+   }
+
+   GimballedPayloadState& GimballedPayloadState::setAzimuth(const float val)
+   {
+      __Azimuth = val;
+      return *this;
+   }
+
+   GimballedPayloadState& GimballedPayloadState::setElevation(const float val)
+   {
+      __Elevation = val;
+      return *this;
+   }
+
+   GimballedPayloadState& GimballedPayloadState::setRotation(const float val)
+   {
+      __Rotation = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiGoToWaypointAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiGoToWaypointAction.cpp
new file mode 100644
index 0000000..bde2ad8
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiGoToWaypointAction.cpp
@@ -0,0 +1,172 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/GoToWaypointAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string GoToWaypointAction::Subscription = "afrl.cmasi.GoToWaypointAction";
+   const std::string GoToWaypointAction::TypeName = "GoToWaypointAction";
+   
+   bool isGoToWaypointAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 28) return false;
+      return true;
+   }
+   
+   bool isGoToWaypointAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 28) return false;
+      return true;
+   }
+   
+   std::vector< std::string > GoToWaypointActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   GoToWaypointAction::GoToWaypointAction(void) : afrl::cmasi::NavigationAction()
+   {
+      __WaypointNumber = 0LL;
+
+   }
+     
+   GoToWaypointAction::GoToWaypointAction(const GoToWaypointAction &that) : afrl::cmasi::NavigationAction(that)
+   {
+        __WaypointNumber = that.__WaypointNumber;
+
+   }
+   
+   GoToWaypointAction & GoToWaypointAction::operator=(const GoToWaypointAction &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::NavigationAction::operator=(that);
+
+         __WaypointNumber = that.__WaypointNumber;
+
+      }
+      return *this;
+   }
+
+   GoToWaypointAction* GoToWaypointAction::clone() const
+   {
+        return new GoToWaypointAction(*this);
+   }
+   
+   GoToWaypointAction::~GoToWaypointAction(void)
+   {
+
+   }
+  
+   void GoToWaypointAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::NavigationAction::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__WaypointNumber);
+
+   }
+   
+   void GoToWaypointAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::NavigationAction::unpack(buf);
+      // Copy the buffer into the class
+      __WaypointNumber = buf.getLong();
+
+   }
+
+   uint32_t GoToWaypointAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::NavigationAction::calculatePackedSize();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string GoToWaypointAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( GoToWaypointAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+
+      oss << indent << "WaypointNumber (int64_t) = " << __WaypointNumber << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string GoToWaypointAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<GoToWaypointAction Series=\"CMASI\">\n";
+      str << ws << "   <WaypointNumber>" << __WaypointNumber << "</WaypointNumber>\n";
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</GoToWaypointAction>\n";
+
+      return str.str();
+   }
+
+   bool GoToWaypointAction::operator==(const GoToWaypointAction & that)
+   {
+      if( afrl::cmasi::NavigationAction::operator!=(that) )
+      {
+          return false;
+      }
+      if(__WaypointNumber != that.__WaypointNumber) return false;
+      return true;
+
+   }
+
+   bool GoToWaypointAction::operator!=(const GoToWaypointAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   GoToWaypointAction& GoToWaypointAction::setWaypointNumber(const int64_t val)
+   {
+      __WaypointNumber = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiKeepInZone.cpp b/src/LMCP/afrl/cmasi/afrlcmasiKeepInZone.cpp
new file mode 100644
index 0000000..e60c725
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiKeepInZone.cpp
@@ -0,0 +1,184 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/KeepInZone.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string KeepInZone::Subscription = "afrl.cmasi.KeepInZone";
+   const std::string KeepInZone::TypeName = "KeepInZone";
+   
+   bool isKeepInZone(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 29) return false;
+      return true;
+   }
+   
+   bool isKeepInZone(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 29) return false;
+      return true;
+   }
+   
+   std::vector< std::string > KeepInZoneDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   KeepInZone::KeepInZone(void) : afrl::cmasi::AbstractZone()
+   {
+
+   }
+     
+   KeepInZone::KeepInZone(const KeepInZone &that) : afrl::cmasi::AbstractZone(that)
+   {
+
+   }
+   
+   KeepInZone & KeepInZone::operator=(const KeepInZone &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::AbstractZone::operator=(that);
+
+
+      }
+      return *this;
+   }
+
+   KeepInZone* KeepInZone::clone() const
+   {
+        return new KeepInZone(*this);
+   }
+   
+   KeepInZone::~KeepInZone(void)
+   {
+
+   }
+  
+   void KeepInZone::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::AbstractZone::pack(buf);
+      // Copy the class into the buffer
+
+   }
+   
+   void KeepInZone::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::AbstractZone::unpack(buf);
+      // Copy the buffer into the class
+
+   }
+
+   uint32_t KeepInZone::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::AbstractZone::calculatePackedSize();
+
+      return size;
+   }
+
+   std::string KeepInZone::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( KeepInZone ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ZoneID (int64_t) = " << __ZoneID << "\n";
+      oss << indent << "MinAltitude (float) = " << __MinAltitude << "\n";
+      oss << indent << "MinAltitudeType (AltitudeType) = " << __MinAltitudeType << "\n";
+      oss << indent << "MaxAltitude (float) = " << __MaxAltitude << "\n";
+      oss << indent << "MaxAltitudeType (AltitudeType) = " << __MaxAltitudeType << "\n";
+      oss << indent << "AffectedAircraft (int64 [ " << __AffectedAircraft.size() << ", var ])\n";
+      oss << indent << "StartTime (int64_t) = " << __StartTime << "\n";
+      oss << indent << "EndTime (int64_t) = " << __EndTime << "\n";
+      oss << indent << "Padding (float) = " << __Padding << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "Boundary (AbstractGeometry)";
+      if (__Boundary == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string KeepInZone::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<KeepInZone Series=\"CMASI\">\n";
+      str << ws << "   <ZoneID>" << __ZoneID << "</ZoneID>\n";
+      str << ws << "   <MinAltitude>" << __MinAltitude << "</MinAltitude>\n";
+      str << ws << "   <MinAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__MinAltitudeType) << "</MinAltitudeType>\n";
+      str << ws << "   <MaxAltitude>" << __MaxAltitude << "</MaxAltitude>\n";
+      str << ws << "   <MaxAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__MaxAltitudeType) << "</MaxAltitudeType>\n";
+      str << ws << "   <AffectedAircraft>\n";
+      for (size_t i=0; i<__AffectedAircraft.size(); i++)
+      {
+         str << ws << "   <int64>" << __AffectedAircraft[i] << "</int64>\n";
+      }
+      str << ws << "   </AffectedAircraft>\n";
+      str << ws << "   <StartTime>" << __StartTime << "</StartTime>\n";
+      str << ws << "   <EndTime>" << __EndTime << "</EndTime>\n";
+      str << ws << "   <Padding>" << __Padding << "</Padding>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      if (__Boundary != nullptr)
+      {
+         str << ws << "   <Boundary>";
+         str << "\n" + __Boundary->toXML(depth + 1) + ws + "   ";
+         str << "</Boundary>\n";
+      }
+      str << ws << "</KeepInZone>\n";
+
+      return str.str();
+   }
+
+   bool KeepInZone::operator==(const KeepInZone & that)
+   {
+      if( afrl::cmasi::AbstractZone::operator!=(that) )
+      {
+          return false;
+      }
+      return true;
+
+   }
+
+   bool KeepInZone::operator!=(const KeepInZone & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiKeepOutZone.cpp b/src/LMCP/afrl/cmasi/afrlcmasiKeepOutZone.cpp
new file mode 100644
index 0000000..55bdbae
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiKeepOutZone.cpp
@@ -0,0 +1,199 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/KeepOutZone.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string KeepOutZone::Subscription = "afrl.cmasi.KeepOutZone";
+   const std::string KeepOutZone::TypeName = "KeepOutZone";
+   
+   bool isKeepOutZone(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 30) return false;
+      return true;
+   }
+   
+   bool isKeepOutZone(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 30) return false;
+      return true;
+   }
+   
+   std::vector< std::string > KeepOutZoneDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   KeepOutZone::KeepOutZone(void) : afrl::cmasi::AbstractZone()
+   {
+      __ZoneType = afrl::cmasi::ZoneAvoidanceType::Physical;
+
+   }
+     
+   KeepOutZone::KeepOutZone(const KeepOutZone &that) : afrl::cmasi::AbstractZone(that)
+   {
+        __ZoneType = that.__ZoneType;
+
+   }
+   
+   KeepOutZone & KeepOutZone::operator=(const KeepOutZone &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::AbstractZone::operator=(that);
+
+         __ZoneType = that.__ZoneType;
+
+      }
+      return *this;
+   }
+
+   KeepOutZone* KeepOutZone::clone() const
+   {
+        return new KeepOutZone(*this);
+   }
+   
+   KeepOutZone::~KeepOutZone(void)
+   {
+
+   }
+  
+   void KeepOutZone::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::AbstractZone::pack(buf);
+      // Copy the class into the buffer
+      buf.putInt( (int32_t) __ZoneType);
+
+   }
+   
+   void KeepOutZone::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::AbstractZone::unpack(buf);
+      // Copy the buffer into the class
+      __ZoneType = (afrl::cmasi::ZoneAvoidanceType::ZoneAvoidanceType) buf.getInt();
+
+   }
+
+   uint32_t KeepOutZone::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::AbstractZone::calculatePackedSize();
+      size += sizeof(afrl::cmasi::ZoneAvoidanceType::ZoneAvoidanceType);
+
+      return size;
+   }
+
+   std::string KeepOutZone::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( KeepOutZone ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ZoneID (int64_t) = " << __ZoneID << "\n";
+      oss << indent << "MinAltitude (float) = " << __MinAltitude << "\n";
+      oss << indent << "MinAltitudeType (AltitudeType) = " << __MinAltitudeType << "\n";
+      oss << indent << "MaxAltitude (float) = " << __MaxAltitude << "\n";
+      oss << indent << "MaxAltitudeType (AltitudeType) = " << __MaxAltitudeType << "\n";
+      oss << indent << "AffectedAircraft (int64 [ " << __AffectedAircraft.size() << ", var ])\n";
+      oss << indent << "StartTime (int64_t) = " << __StartTime << "\n";
+      oss << indent << "EndTime (int64_t) = " << __EndTime << "\n";
+      oss << indent << "Padding (float) = " << __Padding << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "Boundary (AbstractGeometry)";
+      if (__Boundary == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      oss << indent << "ZoneType (ZoneAvoidanceType) = " << __ZoneType << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string KeepOutZone::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<KeepOutZone Series=\"CMASI\">\n";
+      str << ws << "   <ZoneType>" << afrl::cmasi::ZoneAvoidanceType::get_string(__ZoneType) << "</ZoneType>\n";
+      str << ws << "   <ZoneID>" << __ZoneID << "</ZoneID>\n";
+      str << ws << "   <MinAltitude>" << __MinAltitude << "</MinAltitude>\n";
+      str << ws << "   <MinAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__MinAltitudeType) << "</MinAltitudeType>\n";
+      str << ws << "   <MaxAltitude>" << __MaxAltitude << "</MaxAltitude>\n";
+      str << ws << "   <MaxAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__MaxAltitudeType) << "</MaxAltitudeType>\n";
+      str << ws << "   <AffectedAircraft>\n";
+      for (size_t i=0; i<__AffectedAircraft.size(); i++)
+      {
+         str << ws << "   <int64>" << __AffectedAircraft[i] << "</int64>\n";
+      }
+      str << ws << "   </AffectedAircraft>\n";
+      str << ws << "   <StartTime>" << __StartTime << "</StartTime>\n";
+      str << ws << "   <EndTime>" << __EndTime << "</EndTime>\n";
+      str << ws << "   <Padding>" << __Padding << "</Padding>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      if (__Boundary != nullptr)
+      {
+         str << ws << "   <Boundary>";
+         str << "\n" + __Boundary->toXML(depth + 1) + ws + "   ";
+         str << "</Boundary>\n";
+      }
+      str << ws << "</KeepOutZone>\n";
+
+      return str.str();
+   }
+
+   bool KeepOutZone::operator==(const KeepOutZone & that)
+   {
+      if( afrl::cmasi::AbstractZone::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ZoneType != that.__ZoneType) return false;
+      return true;
+
+   }
+
+   bool KeepOutZone::operator!=(const KeepOutZone & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   KeepOutZone& KeepOutZone::setZoneType(const afrl::cmasi::ZoneAvoidanceType::ZoneAvoidanceType val)
+   {
+      __ZoneType = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiKeyValuePair.cpp b/src/LMCP/afrl/cmasi/afrlcmasiKeyValuePair.cpp
new file mode 100644
index 0000000..b6bf0b6
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiKeyValuePair.cpp
@@ -0,0 +1,178 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/KeyValuePair.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string KeyValuePair::Subscription = "afrl.cmasi.KeyValuePair";
+   const std::string KeyValuePair::TypeName = "KeyValuePair";
+   
+   bool isKeyValuePair(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 2) return false;
+      return true;
+   }
+   
+   bool isKeyValuePair(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 2) return false;
+      return true;
+   }
+   
+   std::vector< std::string > KeyValuePairDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   KeyValuePair::KeyValuePair(void) : avtas::lmcp::Object()
+   {
+      __Key = std::string("");
+      __Value = std::string("");
+
+   }
+     
+   KeyValuePair::KeyValuePair(const KeyValuePair &that) : avtas::lmcp::Object(that)
+   {
+        __Key = that.__Key;
+        __Value = that.__Value;
+
+   }
+   
+   KeyValuePair & KeyValuePair::operator=(const KeyValuePair &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __Key = that.__Key;
+         __Value = that.__Value;
+
+      }
+      return *this;
+   }
+
+   KeyValuePair* KeyValuePair::clone() const
+   {
+        return new KeyValuePair(*this);
+   }
+   
+   KeyValuePair::~KeyValuePair(void)
+   {
+
+   }
+  
+   void KeyValuePair::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putString(__Key);
+      buf.putString(__Value);
+
+   }
+   
+   void KeyValuePair::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __Key = buf.getString();
+      __Value = buf.getString();
+
+   }
+
+   uint32_t KeyValuePair::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2 + __Key.length();
+      size += 2 + __Value.length();
+
+      return size;
+   }
+
+   std::string KeyValuePair::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( KeyValuePair ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "Key (std::string) = " << __Key << "\n";
+      oss << indent << "Value (std::string) = " << __Value << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string KeyValuePair::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<KeyValuePair Series=\"CMASI\">\n";
+      str << ws << "   <Key>" << __Key << "</Key>\n";
+      str << ws << "   <Value>" << __Value << "</Value>\n";
+      str << ws << "</KeyValuePair>\n";
+
+      return str.str();
+   }
+
+   bool KeyValuePair::operator==(const KeyValuePair & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Key != that.__Key) return false;
+      if(__Value != that.__Value) return false;
+      return true;
+
+   }
+
+   bool KeyValuePair::operator!=(const KeyValuePair & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   KeyValuePair& KeyValuePair::setKey(const std::string val)
+   {
+      __Key = val;
+      return *this;
+   }
+
+   KeyValuePair& KeyValuePair::setValue(const std::string val)
+   {
+      __Value = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiLineSearchTask.cpp b/src/LMCP/afrl/cmasi/afrlcmasiLineSearchTask.cpp
new file mode 100644
index 0000000..6d79984
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiLineSearchTask.cpp
@@ -0,0 +1,344 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/LineSearchTask.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string LineSearchTask::Subscription = "afrl.cmasi.LineSearchTask";
+   const std::string LineSearchTask::TypeName = "LineSearchTask";
+   
+   bool isLineSearchTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 31) return false;
+      return true;
+   }
+   
+   bool isLineSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 31) return false;
+      return true;
+   }
+   
+   std::vector< std::string > LineSearchTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   LineSearchTask::LineSearchTask(void) : afrl::cmasi::SearchTask()
+   {
+      __UseInertialViewAngles = false;
+
+   }
+     
+   LineSearchTask::LineSearchTask(const LineSearchTask &that) : afrl::cmasi::SearchTask(that)
+   {
+        __PointList.clear();
+        for (size_t i=0; i< that.__PointList.size(); i++)
+        {
+           __PointList.push_back( that.__PointList[i] == nullptr ? nullptr : that.__PointList[i]->clone());
+        }
+        __ViewAngleList.clear();
+        for (size_t i=0; i< that.__ViewAngleList.size(); i++)
+        {
+           __ViewAngleList.push_back( that.__ViewAngleList[i] == nullptr ? nullptr : that.__ViewAngleList[i]->clone());
+        }
+        __UseInertialViewAngles = that.__UseInertialViewAngles;
+
+   }
+   
+   LineSearchTask & LineSearchTask::operator=(const LineSearchTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::SearchTask::operator=(that);
+         for (size_t i=0; i<__PointList.size(); i++)
+         {
+            if (__PointList[i] != nullptr) delete __PointList[i];
+         }
+         for (size_t i=0; i<__ViewAngleList.size(); i++)
+         {
+            if (__ViewAngleList[i] != nullptr) delete __ViewAngleList[i];
+         }
+
+         __PointList.clear();
+         for (size_t i=0; i< that.__PointList.size(); i++)
+         {
+            __PointList.push_back( that.__PointList[i] == nullptr ? nullptr : that.__PointList[i]->clone());
+         }
+         __ViewAngleList.clear();
+         for (size_t i=0; i< that.__ViewAngleList.size(); i++)
+         {
+            __ViewAngleList.push_back( that.__ViewAngleList[i] == nullptr ? nullptr : that.__ViewAngleList[i]->clone());
+         }
+         __UseInertialViewAngles = that.__UseInertialViewAngles;
+
+      }
+      return *this;
+   }
+
+   LineSearchTask* LineSearchTask::clone() const
+   {
+        return new LineSearchTask(*this);
+   }
+   
+   LineSearchTask::~LineSearchTask(void)
+   {
+      for (size_t i=0; i<__PointList.size(); i++)
+      {
+         if (__PointList[i] != nullptr) delete __PointList[i];
+      }
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr) delete __ViewAngleList[i];
+      }
+
+   }
+  
+   void LineSearchTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::SearchTask::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__PointList.size()));
+      for (size_t i=0; i<__PointList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __PointList[i], buf);
+      }
+      buf.putUShort( static_cast<uint16_t>(__ViewAngleList.size()));
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __ViewAngleList[i], buf);
+      }
+      buf.putBool(__UseInertialViewAngles);
+
+   }
+   
+   void LineSearchTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::SearchTask::unpack(buf);
+      // Copy the buffer into the class
+      for (size_t i=0; i<__PointList.size(); i++)
+      {
+         if (__PointList[i] != nullptr)
+            delete __PointList[i];
+      }
+      __PointList.clear();
+      uint16_t __PointList_length = buf.getUShort();
+      for (uint32_t i=0; i< __PointList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Location3D* e = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __PointList.push_back(e);
+         }
+      }
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr)
+            delete __ViewAngleList[i];
+      }
+      __ViewAngleList.clear();
+      uint16_t __ViewAngleList_length = buf.getUShort();
+      for (uint32_t i=0; i< __ViewAngleList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Wedge* e = (afrl::cmasi::Wedge*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __ViewAngleList.push_back(e);
+         }
+      }
+      __UseInertialViewAngles = buf.getBool();
+
+   }
+
+   uint32_t LineSearchTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::SearchTask::calculatePackedSize();
+      size += 2;
+      for (size_t i=0; i<__PointList.size(); i++)
+      {
+         if (__PointList[i] != nullptr)
+         {
+            size += __PointList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += 2;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr)
+         {
+            size += __ViewAngleList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string LineSearchTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( LineSearchTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "DesiredWavelengthBands (WavelengthBand [ " << __DesiredWavelengthBands.size() << ", var ])\n";
+      oss << indent << "DwellTime (int64_t) = " << __DwellTime << "\n";
+      oss << indent << "GroundSampleDistance (float) = " << __GroundSampleDistance << "\n";
+
+      oss << indent << "PointList (Location3D [ " << __PointList.size() << ", var ])\n";
+      oss << indent << "ViewAngleList (Wedge [ " << __ViewAngleList.size() << ", var ])\n";
+      oss << indent << "UseInertialViewAngles (bool) = " << __UseInertialViewAngles << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string LineSearchTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<LineSearchTask Series=\"CMASI\">\n";
+      str << ws << "   <PointList>\n";
+      for (size_t i=0; i<__PointList.size(); i++)
+      {
+         str << (__PointList[i] == nullptr ? ( ws + "   <null/>\n") : (__PointList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PointList>\n";
+      str << ws << "   <ViewAngleList>\n";
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         str << (__ViewAngleList[i] == nullptr ? ( ws + "   <null/>\n") : (__ViewAngleList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </ViewAngleList>\n";
+      str << ws << "   <UseInertialViewAngles>" << (__UseInertialViewAngles ? "true" : "false") << "</UseInertialViewAngles>\n";
+      str << ws << "   <DesiredWavelengthBands>\n";
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         str << ws << "   <WavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__DesiredWavelengthBands[i]) << "</WavelengthBand>\n";
+      }
+      str << ws << "   </DesiredWavelengthBands>\n";
+      str << ws << "   <DwellTime>" << __DwellTime << "</DwellTime>\n";
+      str << ws << "   <GroundSampleDistance>" << __GroundSampleDistance << "</GroundSampleDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</LineSearchTask>\n";
+
+      return str.str();
+   }
+
+   bool LineSearchTask::operator==(const LineSearchTask & that)
+   {
+      if( afrl::cmasi::SearchTask::operator!=(that) )
+      {
+          return false;
+      }
+      if(__PointList.size() != that.__PointList.size()) return false;
+      for (size_t i=0; i<__PointList.size(); i++)
+      {
+         if(__PointList[i] && that.__PointList[i])
+         {
+            if(__PointList[i]->getSeriesNameAsLong() != that.__PointList[i]->getSeriesNameAsLong()) return false;
+            if(__PointList[i]->getSeriesVersion() != that.__PointList[i]->getSeriesVersion()) return false;
+            if(__PointList[i]->getLmcpType() != that.__PointList[i]->getLmcpType()) return false;
+            if( *(__PointList[i]) != *(that.__PointList[i]) ) return false;
+         }
+         else if(__PointList[i] != that.__PointList[i]) return false;
+      }
+      if(__ViewAngleList.size() != that.__ViewAngleList.size()) return false;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if(__ViewAngleList[i] && that.__ViewAngleList[i])
+         {
+            if(__ViewAngleList[i]->getSeriesNameAsLong() != that.__ViewAngleList[i]->getSeriesNameAsLong()) return false;
+            if(__ViewAngleList[i]->getSeriesVersion() != that.__ViewAngleList[i]->getSeriesVersion()) return false;
+            if(__ViewAngleList[i]->getLmcpType() != that.__ViewAngleList[i]->getLmcpType()) return false;
+            if( *(__ViewAngleList[i]) != *(that.__ViewAngleList[i]) ) return false;
+         }
+         else if(__ViewAngleList[i] != that.__ViewAngleList[i]) return false;
+      }
+      if(__UseInertialViewAngles != that.__UseInertialViewAngles) return false;
+      return true;
+
+   }
+
+   bool LineSearchTask::operator!=(const LineSearchTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+   LineSearchTask& LineSearchTask::setUseInertialViewAngles(const bool val)
+   {
+      __UseInertialViewAngles = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiLocation3D.cpp b/src/LMCP/afrl/cmasi/afrlcmasiLocation3D.cpp
new file mode 100644
index 0000000..8a8279e
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiLocation3D.cpp
@@ -0,0 +1,210 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/Location3D.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string Location3D::Subscription = "afrl.cmasi.Location3D";
+   const std::string Location3D::TypeName = "Location3D";
+   
+   bool isLocation3D(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 3) return false;
+      return true;
+   }
+   
+   bool isLocation3D(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 3) return false;
+      return true;
+   }
+   
+   std::vector< std::string > Location3DDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.Waypoint");
+       descendants.push_back("afrl.cmasi.PathWaypoint");
+
+       return descendants;
+   }
+   
+   Location3D::Location3D(void) : avtas::lmcp::Object()
+   {
+      __Latitude = 0;
+      __Longitude = 0;
+      __Altitude = 0.f;
+      __AltitudeType = afrl::cmasi::AltitudeType::MSL;
+
+   }
+     
+   Location3D::Location3D(const Location3D &that) : avtas::lmcp::Object(that)
+   {
+        __Latitude = that.__Latitude;
+        __Longitude = that.__Longitude;
+        __Altitude = that.__Altitude;
+        __AltitudeType = that.__AltitudeType;
+
+   }
+   
+   Location3D & Location3D::operator=(const Location3D &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __Latitude = that.__Latitude;
+         __Longitude = that.__Longitude;
+         __Altitude = that.__Altitude;
+         __AltitudeType = that.__AltitudeType;
+
+      }
+      return *this;
+   }
+
+   Location3D* Location3D::clone() const
+   {
+        return new Location3D(*this);
+   }
+   
+   Location3D::~Location3D(void)
+   {
+
+   }
+  
+   void Location3D::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putDouble(__Latitude);
+      buf.putDouble(__Longitude);
+      buf.putFloat(__Altitude);
+      buf.putInt( (int32_t) __AltitudeType);
+
+   }
+   
+   void Location3D::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __Latitude = buf.getDouble();
+      __Longitude = buf.getDouble();
+      __Altitude = buf.getFloat();
+      __AltitudeType = (afrl::cmasi::AltitudeType::AltitudeType) buf.getInt();
+
+   }
+
+   uint32_t Location3D::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(double);
+      size += sizeof(double);
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::AltitudeType::AltitudeType);
+
+      return size;
+   }
+
+   std::string Location3D::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( Location3D ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "Latitude (double) = " << __Latitude << "\n";
+      oss << indent << "Longitude (double) = " << __Longitude << "\n";
+      oss << indent << "Altitude (float) = " << __Altitude << "\n";
+      oss << indent << "AltitudeType (AltitudeType) = " << __AltitudeType << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string Location3D::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<Location3D Series=\"CMASI\">\n";
+      str << ws << "   <Latitude>" << __Latitude << "</Latitude>\n";
+      str << ws << "   <Longitude>" << __Longitude << "</Longitude>\n";
+      str << ws << "   <Altitude>" << __Altitude << "</Altitude>\n";
+      str << ws << "   <AltitudeType>" << afrl::cmasi::AltitudeType::get_string(__AltitudeType) << "</AltitudeType>\n";
+      str << ws << "</Location3D>\n";
+
+      return str.str();
+   }
+
+   bool Location3D::operator==(const Location3D & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Latitude != that.__Latitude) return false;
+      if(__Longitude != that.__Longitude) return false;
+      if(__Altitude != that.__Altitude) return false;
+      if(__AltitudeType != that.__AltitudeType) return false;
+      return true;
+
+   }
+
+   bool Location3D::operator!=(const Location3D & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   Location3D& Location3D::setLatitude(const double val)
+   {
+      __Latitude = val;
+      return *this;
+   }
+
+   Location3D& Location3D::setLongitude(const double val)
+   {
+      __Longitude = val;
+      return *this;
+   }
+
+   Location3D& Location3D::setAltitude(const float val)
+   {
+      __Altitude = val;
+      return *this;
+   }
+
+   Location3D& Location3D::setAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val)
+   {
+      __AltitudeType = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiLoiterAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiLoiterAction.cpp
new file mode 100644
index 0000000..5e97440
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiLoiterAction.cpp
@@ -0,0 +1,308 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/LoiterAction.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string LoiterAction::Subscription = "afrl.cmasi.LoiterAction";
+   const std::string LoiterAction::TypeName = "LoiterAction";
+   
+   bool isLoiterAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 33) return false;
+      return true;
+   }
+   
+   bool isLoiterAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 33) return false;
+      return true;
+   }
+   
+   std::vector< std::string > LoiterActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   LoiterAction::LoiterAction(void) : afrl::cmasi::NavigationAction()
+   {
+      __LoiterType = afrl::cmasi::LoiterType::VehicleDefault;
+      __Radius = 0.f;
+      __Axis = 0.f;
+      __Length = 0.f;
+      __Direction = afrl::cmasi::LoiterDirection::VehicleDefault;
+      __Duration = 0LL;
+      __Airspeed = 0.f;
+      __Location = new afrl::cmasi::Location3D();
+
+   }
+     
+   LoiterAction::LoiterAction(const LoiterAction &that) : afrl::cmasi::NavigationAction(that)
+   {
+        __LoiterType = that.__LoiterType;
+        __Radius = that.__Radius;
+        __Axis = that.__Axis;
+        __Length = that.__Length;
+        __Direction = that.__Direction;
+        __Duration = that.__Duration;
+        __Airspeed = that.__Airspeed;
+        __Location = that.__Location == nullptr ? nullptr : that.__Location->clone();
+
+   }
+   
+   LoiterAction & LoiterAction::operator=(const LoiterAction &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::NavigationAction::operator=(that);
+         if (__Location != nullptr) delete __Location;
+
+         __LoiterType = that.__LoiterType;
+         __Radius = that.__Radius;
+         __Axis = that.__Axis;
+         __Length = that.__Length;
+         __Direction = that.__Direction;
+         __Duration = that.__Duration;
+         __Airspeed = that.__Airspeed;
+         __Location = that.__Location == nullptr ? nullptr : that.__Location->clone();
+
+      }
+      return *this;
+   }
+
+   LoiterAction* LoiterAction::clone() const
+   {
+        return new LoiterAction(*this);
+   }
+   
+   LoiterAction::~LoiterAction(void)
+   {
+      if (__Location != nullptr) delete __Location;
+
+   }
+  
+   void LoiterAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::NavigationAction::pack(buf);
+      // Copy the class into the buffer
+      buf.putInt( (int32_t) __LoiterType);
+      buf.putFloat(__Radius);
+      buf.putFloat(__Axis);
+      buf.putFloat(__Length);
+      buf.putInt( (int32_t) __Direction);
+      buf.putLong(__Duration);
+      buf.putFloat(__Airspeed);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Location, buf);
+
+   }
+   
+   void LoiterAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::NavigationAction::unpack(buf);
+      // Copy the buffer into the class
+      __LoiterType = (afrl::cmasi::LoiterType::LoiterType) buf.getInt();
+      __Radius = buf.getFloat();
+      __Axis = buf.getFloat();
+      __Length = buf.getFloat();
+      __Direction = (afrl::cmasi::LoiterDirection::LoiterDirection) buf.getInt();
+      __Duration = buf.getLong();
+      __Airspeed = buf.getFloat();
+      {
+         if (__Location != nullptr) delete __Location;
+         __Location = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Location = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Location != nullptr) __Location->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t LoiterAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::NavigationAction::calculatePackedSize();
+      size += sizeof(afrl::cmasi::LoiterType::LoiterType);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::LoiterDirection::LoiterDirection);
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += (__Location != nullptr ? __Location->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string LoiterAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( LoiterAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+
+      oss << indent << "LoiterType (LoiterType) = " << __LoiterType << "\n";
+      oss << indent << "Radius (float) = " << __Radius << "\n";
+      oss << indent << "Axis (float) = " << __Axis << "\n";
+      oss << indent << "Length (float) = " << __Length << "\n";
+      oss << indent << "Direction (LoiterDirection) = " << __Direction << "\n";
+      oss << indent << "Duration (int64_t) = " << __Duration << "\n";
+      oss << indent << "Airspeed (float) = " << __Airspeed << "\n";
+      oss << indent << "Location (Location3D)";
+      if (__Location == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string LoiterAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<LoiterAction Series=\"CMASI\">\n";
+      str << ws << "   <LoiterType>" << afrl::cmasi::LoiterType::get_string(__LoiterType) << "</LoiterType>\n";
+      str << ws << "   <Radius>" << __Radius << "</Radius>\n";
+      str << ws << "   <Axis>" << __Axis << "</Axis>\n";
+      str << ws << "   <Length>" << __Length << "</Length>\n";
+      str << ws << "   <Direction>" << afrl::cmasi::LoiterDirection::get_string(__Direction) << "</Direction>\n";
+      str << ws << "   <Duration>" << __Duration << "</Duration>\n";
+      str << ws << "   <Airspeed>" << __Airspeed << "</Airspeed>\n";
+      if (__Location != nullptr)
+      {
+         str << ws << "   <Location>";
+         str << "\n" + __Location->toXML(depth + 1) + ws + "   ";
+         str << "</Location>\n";
+      }
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</LoiterAction>\n";
+
+      return str.str();
+   }
+
+   bool LoiterAction::operator==(const LoiterAction & that)
+   {
+      if( afrl::cmasi::NavigationAction::operator!=(that) )
+      {
+          return false;
+      }
+      if(__LoiterType != that.__LoiterType) return false;
+      if(__Radius != that.__Radius) return false;
+      if(__Axis != that.__Axis) return false;
+      if(__Length != that.__Length) return false;
+      if(__Direction != that.__Direction) return false;
+      if(__Duration != that.__Duration) return false;
+      if(__Airspeed != that.__Airspeed) return false;
+      if(__Location && that.__Location)
+      {
+         if(__Location->getSeriesNameAsLong() != that.__Location->getSeriesNameAsLong()) return false;
+         if(__Location->getSeriesVersion() != that.__Location->getSeriesVersion()) return false;
+         if(__Location->getLmcpType() != that.__Location->getLmcpType()) return false;
+         if( *(__Location) != *(that.__Location) ) return false;
+      }
+      else if(__Location != that.__Location) return false;
+      return true;
+
+   }
+
+   bool LoiterAction::operator!=(const LoiterAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   LoiterAction& LoiterAction::setLoiterType(const afrl::cmasi::LoiterType::LoiterType val)
+   {
+      __LoiterType = val;
+      return *this;
+   }
+
+   LoiterAction& LoiterAction::setRadius(const float val)
+   {
+      __Radius = val;
+      return *this;
+   }
+
+   LoiterAction& LoiterAction::setAxis(const float val)
+   {
+      __Axis = val;
+      return *this;
+   }
+
+   LoiterAction& LoiterAction::setLength(const float val)
+   {
+      __Length = val;
+      return *this;
+   }
+
+   LoiterAction& LoiterAction::setDirection(const afrl::cmasi::LoiterDirection::LoiterDirection val)
+   {
+      __Direction = val;
+      return *this;
+   }
+
+   LoiterAction& LoiterAction::setDuration(const int64_t val)
+   {
+      __Duration = val;
+      return *this;
+   }
+
+   LoiterAction& LoiterAction::setAirspeed(const float val)
+   {
+      __Airspeed = val;
+      return *this;
+   }
+
+   LoiterAction& LoiterAction::setLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__Location != nullptr) { delete __Location; __Location = nullptr; }
+      if (val != nullptr) { __Location = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiLoiterTask.cpp b/src/LMCP/afrl/cmasi/afrlcmasiLoiterTask.cpp
new file mode 100644
index 0000000..d52cc0b
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiLoiterTask.cpp
@@ -0,0 +1,217 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/LoiterTask.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string LoiterTask::Subscription = "afrl.cmasi.LoiterTask";
+   const std::string LoiterTask::TypeName = "LoiterTask";
+   
+   bool isLoiterTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 34) return false;
+      return true;
+   }
+   
+   bool isLoiterTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 34) return false;
+      return true;
+   }
+   
+   std::vector< std::string > LoiterTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   LoiterTask::LoiterTask(void) : afrl::cmasi::Task()
+   {
+      __DesiredAction = new afrl::cmasi::LoiterAction();
+
+   }
+     
+   LoiterTask::LoiterTask(const LoiterTask &that) : afrl::cmasi::Task(that)
+   {
+        __DesiredAction = that.__DesiredAction == nullptr ? nullptr : that.__DesiredAction->clone();
+
+   }
+   
+   LoiterTask & LoiterTask::operator=(const LoiterTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::Task::operator=(that);
+         if (__DesiredAction != nullptr) delete __DesiredAction;
+
+         __DesiredAction = that.__DesiredAction == nullptr ? nullptr : that.__DesiredAction->clone();
+
+      }
+      return *this;
+   }
+
+   LoiterTask* LoiterTask::clone() const
+   {
+        return new LoiterTask(*this);
+   }
+   
+   LoiterTask::~LoiterTask(void)
+   {
+      if (__DesiredAction != nullptr) delete __DesiredAction;
+
+   }
+  
+   void LoiterTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::Task::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __DesiredAction, buf);
+
+   }
+   
+   void LoiterTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::Task::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__DesiredAction != nullptr) delete __DesiredAction;
+         __DesiredAction = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __DesiredAction = (afrl::cmasi::LoiterAction*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__DesiredAction != nullptr) __DesiredAction->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t LoiterTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::Task::calculatePackedSize();
+      size += (__DesiredAction != nullptr ? __DesiredAction->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string LoiterTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( LoiterTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "DesiredAction (LoiterAction)";
+      if (__DesiredAction == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string LoiterTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<LoiterTask Series=\"CMASI\">\n";
+      if (__DesiredAction != nullptr)
+      {
+         str << ws << "   <DesiredAction>";
+         str << "\n" + __DesiredAction->toXML(depth + 1) + ws + "   ";
+         str << "</DesiredAction>\n";
+      }
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</LoiterTask>\n";
+
+      return str.str();
+   }
+
+   bool LoiterTask::operator==(const LoiterTask & that)
+   {
+      if( afrl::cmasi::Task::operator!=(that) )
+      {
+          return false;
+      }
+      if(__DesiredAction && that.__DesiredAction)
+      {
+         if(__DesiredAction->getSeriesNameAsLong() != that.__DesiredAction->getSeriesNameAsLong()) return false;
+         if(__DesiredAction->getSeriesVersion() != that.__DesiredAction->getSeriesVersion()) return false;
+         if(__DesiredAction->getLmcpType() != that.__DesiredAction->getLmcpType()) return false;
+         if( *(__DesiredAction) != *(that.__DesiredAction) ) return false;
+      }
+      else if(__DesiredAction != that.__DesiredAction) return false;
+      return true;
+
+   }
+
+   bool LoiterTask::operator!=(const LoiterTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   LoiterTask& LoiterTask::setDesiredAction(const afrl::cmasi::LoiterAction* const val)
+   {
+      if (__DesiredAction != nullptr) { delete __DesiredAction; __DesiredAction = nullptr; }
+      if (val != nullptr) { __DesiredAction = const_cast< afrl::cmasi::LoiterAction* > (val); }
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiMissionCommand.cpp b/src/LMCP/afrl/cmasi/afrlcmasiMissionCommand.cpp
new file mode 100644
index 0000000..b615afe
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiMissionCommand.cpp
@@ -0,0 +1,249 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/MissionCommand.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string MissionCommand::Subscription = "afrl.cmasi.MissionCommand";
+   const std::string MissionCommand::TypeName = "MissionCommand";
+   
+   bool isMissionCommand(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 36) return false;
+      return true;
+   }
+   
+   bool isMissionCommand(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 36) return false;
+      return true;
+   }
+   
+   std::vector< std::string > MissionCommandDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   MissionCommand::MissionCommand(void) : afrl::cmasi::VehicleActionCommand()
+   {
+      __FirstWaypoint = 0LL;
+
+   }
+     
+   MissionCommand::MissionCommand(const MissionCommand &that) : afrl::cmasi::VehicleActionCommand(that)
+   {
+        __WaypointList.clear();
+        for (size_t i=0; i< that.__WaypointList.size(); i++)
+        {
+           __WaypointList.push_back( that.__WaypointList[i] == nullptr ? nullptr : that.__WaypointList[i]->clone());
+        }
+        __FirstWaypoint = that.__FirstWaypoint;
+
+   }
+   
+   MissionCommand & MissionCommand::operator=(const MissionCommand &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::VehicleActionCommand::operator=(that);
+         for (size_t i=0; i<__WaypointList.size(); i++)
+         {
+            if (__WaypointList[i] != nullptr) delete __WaypointList[i];
+         }
+
+         __WaypointList.clear();
+         for (size_t i=0; i< that.__WaypointList.size(); i++)
+         {
+            __WaypointList.push_back( that.__WaypointList[i] == nullptr ? nullptr : that.__WaypointList[i]->clone());
+         }
+         __FirstWaypoint = that.__FirstWaypoint;
+
+      }
+      return *this;
+   }
+
+   MissionCommand* MissionCommand::clone() const
+   {
+        return new MissionCommand(*this);
+   }
+   
+   MissionCommand::~MissionCommand(void)
+   {
+      for (size_t i=0; i<__WaypointList.size(); i++)
+      {
+         if (__WaypointList[i] != nullptr) delete __WaypointList[i];
+      }
+
+   }
+  
+   void MissionCommand::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::VehicleActionCommand::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__WaypointList.size()));
+      for (size_t i=0; i<__WaypointList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __WaypointList[i], buf);
+      }
+      buf.putLong(__FirstWaypoint);
+
+   }
+   
+   void MissionCommand::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::VehicleActionCommand::unpack(buf);
+      // Copy the buffer into the class
+      for (size_t i=0; i<__WaypointList.size(); i++)
+      {
+         if (__WaypointList[i] != nullptr)
+            delete __WaypointList[i];
+      }
+      __WaypointList.clear();
+      uint16_t __WaypointList_length = buf.getUShort();
+      for (uint32_t i=0; i< __WaypointList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Waypoint* e = (afrl::cmasi::Waypoint*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __WaypointList.push_back(e);
+         }
+      }
+      __FirstWaypoint = buf.getLong();
+
+   }
+
+   uint32_t MissionCommand::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::VehicleActionCommand::calculatePackedSize();
+      size += 2;
+      for (size_t i=0; i<__WaypointList.size(); i++)
+      {
+         if (__WaypointList[i] != nullptr)
+         {
+            size += __WaypointList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string MissionCommand::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( MissionCommand ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "CommandID (int64_t) = " << __CommandID << "\n";
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "VehicleActionList (VehicleAction [ " << __VehicleActionList.size() << ", var ])\n";
+      oss << indent << "Status (CommandStatusType) = " << __Status << "\n";
+
+      oss << indent << "WaypointList (Waypoint [ " << __WaypointList.size() << ", var ])\n";
+      oss << indent << "FirstWaypoint (int64_t) = " << __FirstWaypoint << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string MissionCommand::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<MissionCommand Series=\"CMASI\">\n";
+      str << ws << "   <WaypointList>\n";
+      for (size_t i=0; i<__WaypointList.size(); i++)
+      {
+         str << (__WaypointList[i] == nullptr ? ( ws + "   <null/>\n") : (__WaypointList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </WaypointList>\n";
+      str << ws << "   <FirstWaypoint>" << __FirstWaypoint << "</FirstWaypoint>\n";
+      str << ws << "   <CommandID>" << __CommandID << "</CommandID>\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <VehicleActionList>\n";
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         str << (__VehicleActionList[i] == nullptr ? ( ws + "   <null/>\n") : (__VehicleActionList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </VehicleActionList>\n";
+      str << ws << "   <Status>" << afrl::cmasi::CommandStatusType::get_string(__Status) << "</Status>\n";
+      str << ws << "</MissionCommand>\n";
+
+      return str.str();
+   }
+
+   bool MissionCommand::operator==(const MissionCommand & that)
+   {
+      if( afrl::cmasi::VehicleActionCommand::operator!=(that) )
+      {
+          return false;
+      }
+      if(__WaypointList.size() != that.__WaypointList.size()) return false;
+      for (size_t i=0; i<__WaypointList.size(); i++)
+      {
+         if(__WaypointList[i] && that.__WaypointList[i])
+         {
+            if(__WaypointList[i]->getSeriesNameAsLong() != that.__WaypointList[i]->getSeriesNameAsLong()) return false;
+            if(__WaypointList[i]->getSeriesVersion() != that.__WaypointList[i]->getSeriesVersion()) return false;
+            if(__WaypointList[i]->getLmcpType() != that.__WaypointList[i]->getLmcpType()) return false;
+            if( *(__WaypointList[i]) != *(that.__WaypointList[i]) ) return false;
+         }
+         else if(__WaypointList[i] != that.__WaypointList[i]) return false;
+      }
+      if(__FirstWaypoint != that.__FirstWaypoint) return false;
+      return true;
+
+   }
+
+   bool MissionCommand::operator!=(const MissionCommand & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+   MissionCommand& MissionCommand::setFirstWaypoint(const int64_t val)
+   {
+      __FirstWaypoint = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiMustFlyTask.cpp b/src/LMCP/afrl/cmasi/afrlcmasiMustFlyTask.cpp
new file mode 100644
index 0000000..551f10f
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiMustFlyTask.cpp
@@ -0,0 +1,234 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/MustFlyTask.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string MustFlyTask::Subscription = "afrl.cmasi.MustFlyTask";
+   const std::string MustFlyTask::TypeName = "MustFlyTask";
+   
+   bool isMustFlyTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 37) return false;
+      return true;
+   }
+   
+   bool isMustFlyTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 37) return false;
+      return true;
+   }
+   
+   std::vector< std::string > MustFlyTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   MustFlyTask::MustFlyTask(void) : afrl::cmasi::Task()
+   {
+      __Position = new afrl::cmasi::Location3D();
+      __UseAltitude = true;
+
+   }
+     
+   MustFlyTask::MustFlyTask(const MustFlyTask &that) : afrl::cmasi::Task(that)
+   {
+        __Position = that.__Position == nullptr ? nullptr : that.__Position->clone();
+        __UseAltitude = that.__UseAltitude;
+
+   }
+   
+   MustFlyTask & MustFlyTask::operator=(const MustFlyTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::Task::operator=(that);
+         if (__Position != nullptr) delete __Position;
+
+         __Position = that.__Position == nullptr ? nullptr : that.__Position->clone();
+         __UseAltitude = that.__UseAltitude;
+
+      }
+      return *this;
+   }
+
+   MustFlyTask* MustFlyTask::clone() const
+   {
+        return new MustFlyTask(*this);
+   }
+   
+   MustFlyTask::~MustFlyTask(void)
+   {
+      if (__Position != nullptr) delete __Position;
+
+   }
+  
+   void MustFlyTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::Task::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Position, buf);
+      buf.putBool(__UseAltitude);
+
+   }
+   
+   void MustFlyTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::Task::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__Position != nullptr) delete __Position;
+         __Position = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Position = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Position != nullptr) __Position->unpack(buf);
+         }
+      }
+      __UseAltitude = buf.getBool();
+
+   }
+
+   uint32_t MustFlyTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::Task::calculatePackedSize();
+      size += (__Position != nullptr ? __Position->calculatePackedSize() + 15 : 1);
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string MustFlyTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( MustFlyTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "Position (Location3D)";
+      if (__Position == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "UseAltitude (bool) = " << __UseAltitude << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string MustFlyTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<MustFlyTask Series=\"CMASI\">\n";
+      if (__Position != nullptr)
+      {
+         str << ws << "   <Position>";
+         str << "\n" + __Position->toXML(depth + 1) + ws + "   ";
+         str << "</Position>\n";
+      }
+      str << ws << "   <UseAltitude>" << (__UseAltitude ? "true" : "false") << "</UseAltitude>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</MustFlyTask>\n";
+
+      return str.str();
+   }
+
+   bool MustFlyTask::operator==(const MustFlyTask & that)
+   {
+      if( afrl::cmasi::Task::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Position && that.__Position)
+      {
+         if(__Position->getSeriesNameAsLong() != that.__Position->getSeriesNameAsLong()) return false;
+         if(__Position->getSeriesVersion() != that.__Position->getSeriesVersion()) return false;
+         if(__Position->getLmcpType() != that.__Position->getLmcpType()) return false;
+         if( *(__Position) != *(that.__Position) ) return false;
+      }
+      else if(__Position != that.__Position) return false;
+      if(__UseAltitude != that.__UseAltitude) return false;
+      return true;
+
+   }
+
+   bool MustFlyTask::operator!=(const MustFlyTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   MustFlyTask& MustFlyTask::setPosition(const afrl::cmasi::Location3D* const val)
+   {
+      if (__Position != nullptr) { delete __Position; __Position = nullptr; }
+      if (val != nullptr) { __Position = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   MustFlyTask& MustFlyTask::setUseAltitude(const bool val)
+   {
+      __UseAltitude = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiNavigationAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiNavigationAction.cpp
new file mode 100644
index 0000000..d442314
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiNavigationAction.cpp
@@ -0,0 +1,159 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/NavigationAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string NavigationAction::Subscription = "afrl.cmasi.NavigationAction";
+   const std::string NavigationAction::TypeName = "NavigationAction";
+   
+   bool isNavigationAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 32) return false;
+      return true;
+   }
+   
+   bool isNavigationAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 32) return false;
+      return true;
+   }
+   
+   std::vector< std::string > NavigationActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.GoToWaypointAction");
+       descendants.push_back("afrl.cmasi.LoiterAction");
+       descendants.push_back("afrl.cmasi.FlightDirectorAction");
+
+       return descendants;
+   }
+   
+   NavigationAction::NavigationAction(void) : afrl::cmasi::VehicleAction()
+   {
+
+   }
+     
+   NavigationAction::NavigationAction(const NavigationAction &that) : afrl::cmasi::VehicleAction(that)
+   {
+
+   }
+   
+   NavigationAction & NavigationAction::operator=(const NavigationAction &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::VehicleAction::operator=(that);
+
+
+      }
+      return *this;
+   }
+
+   NavigationAction* NavigationAction::clone() const
+   {
+        return new NavigationAction(*this);
+   }
+   
+   NavigationAction::~NavigationAction(void)
+   {
+
+   }
+  
+   void NavigationAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::VehicleAction::pack(buf);
+      // Copy the class into the buffer
+
+   }
+   
+   void NavigationAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::VehicleAction::unpack(buf);
+      // Copy the buffer into the class
+
+   }
+
+   uint32_t NavigationAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::VehicleAction::calculatePackedSize();
+
+      return size;
+   }
+
+   std::string NavigationAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( NavigationAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string NavigationAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<NavigationAction Series=\"CMASI\">\n";
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</NavigationAction>\n";
+
+      return str.str();
+   }
+
+   bool NavigationAction::operator==(const NavigationAction & that)
+   {
+      if( afrl::cmasi::VehicleAction::operator!=(that) )
+      {
+          return false;
+      }
+      return true;
+
+   }
+
+   bool NavigationAction::operator!=(const NavigationAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiOperatingRegion.cpp b/src/LMCP/afrl/cmasi/afrlcmasiOperatingRegion.cpp
new file mode 100644
index 0000000..5d407d2
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiOperatingRegion.cpp
@@ -0,0 +1,233 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/OperatingRegion.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string OperatingRegion::Subscription = "afrl.cmasi.OperatingRegion";
+   const std::string OperatingRegion::TypeName = "OperatingRegion";
+   
+   bool isOperatingRegion(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 39) return false;
+      return true;
+   }
+   
+   bool isOperatingRegion(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 39) return false;
+      return true;
+   }
+   
+   std::vector< std::string > OperatingRegionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   OperatingRegion::OperatingRegion(void) : avtas::lmcp::Object()
+   {
+      __ID = 0LL;
+
+   }
+     
+   OperatingRegion::OperatingRegion(const OperatingRegion &that) : avtas::lmcp::Object(that)
+   {
+        __ID = that.__ID;
+        __KeepInAreas.clear();
+        for (size_t i=0; i< that.__KeepInAreas.size(); i++)
+        {
+           __KeepInAreas.push_back( that.__KeepInAreas[i]);
+        }
+        __KeepOutAreas.clear();
+        for (size_t i=0; i< that.__KeepOutAreas.size(); i++)
+        {
+           __KeepOutAreas.push_back( that.__KeepOutAreas[i]);
+        }
+
+   }
+   
+   OperatingRegion & OperatingRegion::operator=(const OperatingRegion &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __ID = that.__ID;
+         __KeepInAreas.clear();
+         for (size_t i=0; i< that.__KeepInAreas.size(); i++)
+         {
+            __KeepInAreas.push_back( that.__KeepInAreas[i]);
+         }
+         __KeepOutAreas.clear();
+         for (size_t i=0; i< that.__KeepOutAreas.size(); i++)
+         {
+            __KeepOutAreas.push_back( that.__KeepOutAreas[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   OperatingRegion* OperatingRegion::clone() const
+   {
+        return new OperatingRegion(*this);
+   }
+   
+   OperatingRegion::~OperatingRegion(void)
+   {
+
+   }
+  
+   void OperatingRegion::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ID);
+      buf.putUShort( static_cast<uint16_t>(__KeepInAreas.size()));
+      for (size_t i=0; i<__KeepInAreas.size(); i++)
+      {
+         buf.putLong(__KeepInAreas[i]);
+      }
+      buf.putUShort( static_cast<uint16_t>(__KeepOutAreas.size()));
+      for (size_t i=0; i<__KeepOutAreas.size(); i++)
+      {
+         buf.putLong(__KeepOutAreas[i]);
+      }
+
+   }
+   
+   void OperatingRegion::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ID = buf.getLong();
+      __KeepInAreas.clear();
+      uint16_t __KeepInAreas_length = buf.getUShort();
+      for (uint32_t i=0; i< __KeepInAreas_length; i++)
+      {
+         __KeepInAreas.push_back(buf.getLong() );
+      }
+      __KeepOutAreas.clear();
+      uint16_t __KeepOutAreas_length = buf.getUShort();
+      for (uint32_t i=0; i< __KeepOutAreas_length; i++)
+      {
+         __KeepOutAreas.push_back(buf.getLong() );
+      }
+
+   }
+
+   uint32_t OperatingRegion::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2 + sizeof(int64_t) * __KeepInAreas.size();
+      size += 2 + sizeof(int64_t) * __KeepOutAreas.size();
+
+      return size;
+   }
+
+   std::string OperatingRegion::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( OperatingRegion ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ID (int64_t) = " << __ID << "\n";
+      oss << indent << "KeepInAreas (int64 [ " << __KeepInAreas.size() << ", var ])\n";
+      oss << indent << "KeepOutAreas (int64 [ " << __KeepOutAreas.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string OperatingRegion::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<OperatingRegion Series=\"CMASI\">\n";
+      str << ws << "   <ID>" << __ID << "</ID>\n";
+      str << ws << "   <KeepInAreas>\n";
+      for (size_t i=0; i<__KeepInAreas.size(); i++)
+      {
+         str << ws << "   <int64>" << __KeepInAreas[i] << "</int64>\n";
+      }
+      str << ws << "   </KeepInAreas>\n";
+      str << ws << "   <KeepOutAreas>\n";
+      for (size_t i=0; i<__KeepOutAreas.size(); i++)
+      {
+         str << ws << "   <int64>" << __KeepOutAreas[i] << "</int64>\n";
+      }
+      str << ws << "   </KeepOutAreas>\n";
+      str << ws << "</OperatingRegion>\n";
+
+      return str.str();
+   }
+
+   bool OperatingRegion::operator==(const OperatingRegion & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ID != that.__ID) return false;
+      if(__KeepInAreas.size() != that.__KeepInAreas.size()) return false;
+      for (size_t i=0; i<__KeepInAreas.size(); i++)
+      {
+         if(__KeepInAreas[i] != that.__KeepInAreas[i]) return false;
+      }
+      if(__KeepOutAreas.size() != that.__KeepOutAreas.size()) return false;
+      for (size_t i=0; i<__KeepOutAreas.size(); i++)
+      {
+         if(__KeepOutAreas[i] != that.__KeepOutAreas[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool OperatingRegion::operator!=(const OperatingRegion & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   OperatingRegion& OperatingRegion::setID(const int64_t val)
+   {
+      __ID = val;
+      return *this;
+   }
+
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiOperatorSignal.cpp b/src/LMCP/afrl/cmasi/afrlcmasiOperatorSignal.cpp
new file mode 100644
index 0000000..a98aca9
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiOperatorSignal.cpp
@@ -0,0 +1,219 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/OperatorSignal.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string OperatorSignal::Subscription = "afrl.cmasi.OperatorSignal";
+   const std::string OperatorSignal::TypeName = "OperatorSignal";
+   
+   bool isOperatorSignal(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 38) return false;
+      return true;
+   }
+   
+   bool isOperatorSignal(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 38) return false;
+      return true;
+   }
+   
+   std::vector< std::string > OperatorSignalDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   OperatorSignal::OperatorSignal(void) : avtas::lmcp::Object()
+   {
+
+   }
+     
+   OperatorSignal::OperatorSignal(const OperatorSignal &that) : avtas::lmcp::Object(that)
+   {
+        __Signals.clear();
+        for (size_t i=0; i< that.__Signals.size(); i++)
+        {
+           __Signals.push_back( that.__Signals[i] == nullptr ? nullptr : that.__Signals[i]->clone());
+        }
+
+   }
+   
+   OperatorSignal & OperatorSignal::operator=(const OperatorSignal &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Signals.size(); i++)
+         {
+            if (__Signals[i] != nullptr) delete __Signals[i];
+         }
+
+         __Signals.clear();
+         for (size_t i=0; i< that.__Signals.size(); i++)
+         {
+            __Signals.push_back( that.__Signals[i] == nullptr ? nullptr : that.__Signals[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   OperatorSignal* OperatorSignal::clone() const
+   {
+        return new OperatorSignal(*this);
+   }
+   
+   OperatorSignal::~OperatorSignal(void)
+   {
+      for (size_t i=0; i<__Signals.size(); i++)
+      {
+         if (__Signals[i] != nullptr) delete __Signals[i];
+      }
+
+   }
+  
+   void OperatorSignal::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__Signals.size()));
+      for (size_t i=0; i<__Signals.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Signals[i], buf);
+      }
+
+   }
+   
+   void OperatorSignal::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      for (size_t i=0; i<__Signals.size(); i++)
+      {
+         if (__Signals[i] != nullptr)
+            delete __Signals[i];
+      }
+      __Signals.clear();
+      uint16_t __Signals_length = buf.getUShort();
+      for (uint32_t i=0; i< __Signals_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::KeyValuePair* e = (afrl::cmasi::KeyValuePair*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Signals.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t OperatorSignal::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2;
+      for (size_t i=0; i<__Signals.size(); i++)
+      {
+         if (__Signals[i] != nullptr)
+         {
+            size += __Signals[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string OperatorSignal::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( OperatorSignal ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "Signals (KeyValuePair [ " << __Signals.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string OperatorSignal::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<OperatorSignal Series=\"CMASI\">\n";
+      str << ws << "   <Signals>\n";
+      for (size_t i=0; i<__Signals.size(); i++)
+      {
+         str << (__Signals[i] == nullptr ? ( ws + "   <null/>\n") : (__Signals[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Signals>\n";
+      str << ws << "</OperatorSignal>\n";
+
+      return str.str();
+   }
+
+   bool OperatorSignal::operator==(const OperatorSignal & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Signals.size() != that.__Signals.size()) return false;
+      for (size_t i=0; i<__Signals.size(); i++)
+      {
+         if(__Signals[i] && that.__Signals[i])
+         {
+            if(__Signals[i]->getSeriesNameAsLong() != that.__Signals[i]->getSeriesNameAsLong()) return false;
+            if(__Signals[i]->getSeriesVersion() != that.__Signals[i]->getSeriesVersion()) return false;
+            if(__Signals[i]->getLmcpType() != that.__Signals[i]->getLmcpType()) return false;
+            if( *(__Signals[i]) != *(that.__Signals[i]) ) return false;
+         }
+         else if(__Signals[i] != that.__Signals[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool OperatorSignal::operator!=(const OperatorSignal & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiPathWaypoint.cpp b/src/LMCP/afrl/cmasi/afrlcmasiPathWaypoint.cpp
new file mode 100644
index 0000000..c17c26a
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiPathWaypoint.cpp
@@ -0,0 +1,203 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string PathWaypoint::Subscription = "afrl.cmasi.PathWaypoint";
+   const std::string PathWaypoint::TypeName = "PathWaypoint";
+   
+   bool isPathWaypoint(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 57) return false;
+      return true;
+   }
+   
+   bool isPathWaypoint(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 57) return false;
+      return true;
+   }
+   
+   std::vector< std::string > PathWaypointDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   PathWaypoint::PathWaypoint(void) : afrl::cmasi::Waypoint()
+   {
+      __PauseTime = 0LL;
+
+   }
+     
+   PathWaypoint::PathWaypoint(const PathWaypoint &that) : afrl::cmasi::Waypoint(that)
+   {
+        __PauseTime = that.__PauseTime;
+
+   }
+   
+   PathWaypoint & PathWaypoint::operator=(const PathWaypoint &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::Waypoint::operator=(that);
+
+         __PauseTime = that.__PauseTime;
+
+      }
+      return *this;
+   }
+
+   PathWaypoint* PathWaypoint::clone() const
+   {
+        return new PathWaypoint(*this);
+   }
+   
+   PathWaypoint::~PathWaypoint(void)
+   {
+
+   }
+  
+   void PathWaypoint::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::Waypoint::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__PauseTime);
+
+   }
+   
+   void PathWaypoint::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::Waypoint::unpack(buf);
+      // Copy the buffer into the class
+      __PauseTime = buf.getLong();
+
+   }
+
+   uint32_t PathWaypoint::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::Waypoint::calculatePackedSize();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string PathWaypoint::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( PathWaypoint ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "Latitude (double) = " << __Latitude << "\n";
+      oss << indent << "Longitude (double) = " << __Longitude << "\n";
+      oss << indent << "Altitude (float) = " << __Altitude << "\n";
+      oss << indent << "AltitudeType (AltitudeType) = " << __AltitudeType << "\n";
+
+      oss << indent << "Number (int64_t) = " << __Number << "\n";
+      oss << indent << "NextWaypoint (int64_t) = " << __NextWaypoint << "\n";
+      oss << indent << "Speed (float) = " << __Speed << "\n";
+      oss << indent << "SpeedType (SpeedType) = " << __SpeedType << "\n";
+      oss << indent << "ClimbRate (float) = " << __ClimbRate << "\n";
+      oss << indent << "TurnType (TurnType) = " << __TurnType << "\n";
+      oss << indent << "VehicleActionList (VehicleAction [ " << __VehicleActionList.size() << ", var ])\n";
+      oss << indent << "ContingencyWaypointA (int64_t) = " << __ContingencyWaypointA << "\n";
+      oss << indent << "ContingencyWaypointB (int64_t) = " << __ContingencyWaypointB << "\n";
+      oss << indent << "AssociatedTasks (int64 [ " << __AssociatedTasks.size() << ", var ])\n";
+
+      oss << indent << "PauseTime (int64_t) = " << __PauseTime << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string PathWaypoint::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<PathWaypoint Series=\"CMASI\">\n";
+      str << ws << "   <PauseTime>" << __PauseTime << "</PauseTime>\n";
+      str << ws << "   <Number>" << __Number << "</Number>\n";
+      str << ws << "   <NextWaypoint>" << __NextWaypoint << "</NextWaypoint>\n";
+      str << ws << "   <Speed>" << __Speed << "</Speed>\n";
+      str << ws << "   <SpeedType>" << afrl::cmasi::SpeedType::get_string(__SpeedType) << "</SpeedType>\n";
+      str << ws << "   <ClimbRate>" << __ClimbRate << "</ClimbRate>\n";
+      str << ws << "   <TurnType>" << afrl::cmasi::TurnType::get_string(__TurnType) << "</TurnType>\n";
+      str << ws << "   <VehicleActionList>\n";
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         str << (__VehicleActionList[i] == nullptr ? ( ws + "   <null/>\n") : (__VehicleActionList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </VehicleActionList>\n";
+      str << ws << "   <ContingencyWaypointA>" << __ContingencyWaypointA << "</ContingencyWaypointA>\n";
+      str << ws << "   <ContingencyWaypointB>" << __ContingencyWaypointB << "</ContingencyWaypointB>\n";
+      str << ws << "   <AssociatedTasks>\n";
+      for (size_t i=0; i<__AssociatedTasks.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTasks[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTasks>\n";
+      str << ws << "   <Latitude>" << __Latitude << "</Latitude>\n";
+      str << ws << "   <Longitude>" << __Longitude << "</Longitude>\n";
+      str << ws << "   <Altitude>" << __Altitude << "</Altitude>\n";
+      str << ws << "   <AltitudeType>" << afrl::cmasi::AltitudeType::get_string(__AltitudeType) << "</AltitudeType>\n";
+      str << ws << "</PathWaypoint>\n";
+
+      return str.str();
+   }
+
+   bool PathWaypoint::operator==(const PathWaypoint & that)
+   {
+      if( afrl::cmasi::Waypoint::operator!=(that) )
+      {
+          return false;
+      }
+      if(__PauseTime != that.__PauseTime) return false;
+      return true;
+
+   }
+
+   bool PathWaypoint::operator!=(const PathWaypoint & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   PathWaypoint& PathWaypoint::setPauseTime(const int64_t val)
+   {
+      __PauseTime = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiPayloadAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiPayloadAction.cpp
new file mode 100644
index 0000000..e21cfc1
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiPayloadAction.cpp
@@ -0,0 +1,175 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/PayloadAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string PayloadAction::Subscription = "afrl.cmasi.PayloadAction";
+   const std::string PayloadAction::TypeName = "PayloadAction";
+   
+   bool isPayloadAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 4) return false;
+      return true;
+   }
+   
+   bool isPayloadAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 4) return false;
+      return true;
+   }
+   
+   std::vector< std::string > PayloadActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.CameraAction");
+       descendants.push_back("afrl.cmasi.GimbalAngleAction");
+       descendants.push_back("afrl.cmasi.GimbalScanAction");
+       descendants.push_back("afrl.cmasi.GimbalStareAction");
+
+       return descendants;
+   }
+   
+   PayloadAction::PayloadAction(void) : afrl::cmasi::VehicleAction()
+   {
+      __PayloadID = 0LL;
+
+   }
+     
+   PayloadAction::PayloadAction(const PayloadAction &that) : afrl::cmasi::VehicleAction(that)
+   {
+        __PayloadID = that.__PayloadID;
+
+   }
+   
+   PayloadAction & PayloadAction::operator=(const PayloadAction &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::VehicleAction::operator=(that);
+
+         __PayloadID = that.__PayloadID;
+
+      }
+      return *this;
+   }
+
+   PayloadAction* PayloadAction::clone() const
+   {
+        return new PayloadAction(*this);
+   }
+   
+   PayloadAction::~PayloadAction(void)
+   {
+
+   }
+  
+   void PayloadAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::VehicleAction::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__PayloadID);
+
+   }
+   
+   void PayloadAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::VehicleAction::unpack(buf);
+      // Copy the buffer into the class
+      __PayloadID = buf.getLong();
+
+   }
+
+   uint32_t PayloadAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::VehicleAction::calculatePackedSize();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string PayloadAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( PayloadAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string PayloadAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<PayloadAction Series=\"CMASI\">\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</PayloadAction>\n";
+
+      return str.str();
+   }
+
+   bool PayloadAction::operator==(const PayloadAction & that)
+   {
+      if( afrl::cmasi::VehicleAction::operator!=(that) )
+      {
+          return false;
+      }
+      if(__PayloadID != that.__PayloadID) return false;
+      return true;
+
+   }
+
+   bool PayloadAction::operator!=(const PayloadAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   PayloadAction& PayloadAction::setPayloadID(const int64_t val)
+   {
+      __PayloadID = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiPayloadConfiguration.cpp b/src/LMCP/afrl/cmasi/afrlcmasiPayloadConfiguration.cpp
new file mode 100644
index 0000000..e5a140e
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiPayloadConfiguration.cpp
@@ -0,0 +1,255 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/PayloadConfiguration.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string PayloadConfiguration::Subscription = "afrl.cmasi.PayloadConfiguration";
+   const std::string PayloadConfiguration::TypeName = "PayloadConfiguration";
+   
+   bool isPayloadConfiguration(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 5) return false;
+      return true;
+   }
+   
+   bool isPayloadConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 5) return false;
+      return true;
+   }
+   
+   std::vector< std::string > PayloadConfigurationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.CameraConfiguration");
+       descendants.push_back("afrl.cmasi.GimbalConfiguration");
+       descendants.push_back("afrl.cmasi.VideoStreamConfiguration");
+       descendants.push_back("afrl.impact.PowerConfiguration");
+       descendants.push_back("afrl.impact.RadioConfiguration");
+       descendants.push_back("afrl.impact.ImpactPayloadConfiguration");
+
+       return descendants;
+   }
+   
+   PayloadConfiguration::PayloadConfiguration(void) : avtas::lmcp::Object()
+   {
+      __PayloadID = 0LL;
+      __PayloadKind = std::string("");
+
+   }
+     
+   PayloadConfiguration::PayloadConfiguration(const PayloadConfiguration &that) : avtas::lmcp::Object(that)
+   {
+        __PayloadID = that.__PayloadID;
+        __PayloadKind = that.__PayloadKind;
+        __Parameters.clear();
+        for (size_t i=0; i< that.__Parameters.size(); i++)
+        {
+           __Parameters.push_back( that.__Parameters[i] == nullptr ? nullptr : that.__Parameters[i]->clone());
+        }
+
+   }
+   
+   PayloadConfiguration & PayloadConfiguration::operator=(const PayloadConfiguration &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Parameters.size(); i++)
+         {
+            if (__Parameters[i] != nullptr) delete __Parameters[i];
+         }
+
+         __PayloadID = that.__PayloadID;
+         __PayloadKind = that.__PayloadKind;
+         __Parameters.clear();
+         for (size_t i=0; i< that.__Parameters.size(); i++)
+         {
+            __Parameters.push_back( that.__Parameters[i] == nullptr ? nullptr : that.__Parameters[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   PayloadConfiguration* PayloadConfiguration::clone() const
+   {
+        return new PayloadConfiguration(*this);
+   }
+   
+   PayloadConfiguration::~PayloadConfiguration(void)
+   {
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if (__Parameters[i] != nullptr) delete __Parameters[i];
+      }
+
+   }
+  
+   void PayloadConfiguration::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__PayloadID);
+      buf.putString(__PayloadKind);
+      buf.putUShort( static_cast<uint16_t>(__Parameters.size()));
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Parameters[i], buf);
+      }
+
+   }
+   
+   void PayloadConfiguration::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __PayloadID = buf.getLong();
+      __PayloadKind = buf.getString();
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if (__Parameters[i] != nullptr)
+            delete __Parameters[i];
+      }
+      __Parameters.clear();
+      uint16_t __Parameters_length = buf.getUShort();
+      for (uint32_t i=0; i< __Parameters_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::KeyValuePair* e = (afrl::cmasi::KeyValuePair*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Parameters.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t PayloadConfiguration::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2 + __PayloadKind.length();
+      size += 2;
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if (__Parameters[i] != nullptr)
+         {
+            size += __Parameters[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string PayloadConfiguration::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( PayloadConfiguration ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "PayloadKind (std::string) = " << __PayloadKind << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string PayloadConfiguration::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<PayloadConfiguration Series=\"CMASI\">\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <PayloadKind>" << __PayloadKind << "</PayloadKind>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</PayloadConfiguration>\n";
+
+      return str.str();
+   }
+
+   bool PayloadConfiguration::operator==(const PayloadConfiguration & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__PayloadID != that.__PayloadID) return false;
+      if(__PayloadKind != that.__PayloadKind) return false;
+      if(__Parameters.size() != that.__Parameters.size()) return false;
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if(__Parameters[i] && that.__Parameters[i])
+         {
+            if(__Parameters[i]->getSeriesNameAsLong() != that.__Parameters[i]->getSeriesNameAsLong()) return false;
+            if(__Parameters[i]->getSeriesVersion() != that.__Parameters[i]->getSeriesVersion()) return false;
+            if(__Parameters[i]->getLmcpType() != that.__Parameters[i]->getLmcpType()) return false;
+            if( *(__Parameters[i]) != *(that.__Parameters[i]) ) return false;
+         }
+         else if(__Parameters[i] != that.__Parameters[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool PayloadConfiguration::operator!=(const PayloadConfiguration & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   PayloadConfiguration& PayloadConfiguration::setPayloadID(const int64_t val)
+   {
+      __PayloadID = val;
+      return *this;
+   }
+
+   PayloadConfiguration& PayloadConfiguration::setPayloadKind(const std::string val)
+   {
+      __PayloadKind = val;
+      return *this;
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiPayloadState.cpp b/src/LMCP/afrl/cmasi/afrlcmasiPayloadState.cpp
new file mode 100644
index 0000000..13597e3
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiPayloadState.cpp
@@ -0,0 +1,240 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/PayloadState.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string PayloadState::Subscription = "afrl.cmasi.PayloadState";
+   const std::string PayloadState::TypeName = "PayloadState";
+   
+   bool isPayloadState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 6) return false;
+      return true;
+   }
+   
+   bool isPayloadState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 6) return false;
+      return true;
+   }
+   
+   std::vector< std::string > PayloadStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.GimballedPayloadState");
+       descendants.push_back("afrl.cmasi.CameraState");
+       descendants.push_back("afrl.cmasi.GimbalState");
+       descendants.push_back("afrl.cmasi.VideoStreamState");
+       descendants.push_back("afrl.impact.RadioState");
+       descendants.push_back("afrl.impact.PowerPlantState");
+
+       return descendants;
+   }
+   
+   PayloadState::PayloadState(void) : avtas::lmcp::Object()
+   {
+      __PayloadID = 0LL;
+
+   }
+     
+   PayloadState::PayloadState(const PayloadState &that) : avtas::lmcp::Object(that)
+   {
+        __PayloadID = that.__PayloadID;
+        __Parameters.clear();
+        for (size_t i=0; i< that.__Parameters.size(); i++)
+        {
+           __Parameters.push_back( that.__Parameters[i] == nullptr ? nullptr : that.__Parameters[i]->clone());
+        }
+
+   }
+   
+   PayloadState & PayloadState::operator=(const PayloadState &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Parameters.size(); i++)
+         {
+            if (__Parameters[i] != nullptr) delete __Parameters[i];
+         }
+
+         __PayloadID = that.__PayloadID;
+         __Parameters.clear();
+         for (size_t i=0; i< that.__Parameters.size(); i++)
+         {
+            __Parameters.push_back( that.__Parameters[i] == nullptr ? nullptr : that.__Parameters[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   PayloadState* PayloadState::clone() const
+   {
+        return new PayloadState(*this);
+   }
+   
+   PayloadState::~PayloadState(void)
+   {
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if (__Parameters[i] != nullptr) delete __Parameters[i];
+      }
+
+   }
+  
+   void PayloadState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__PayloadID);
+      buf.putUShort( static_cast<uint16_t>(__Parameters.size()));
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Parameters[i], buf);
+      }
+
+   }
+   
+   void PayloadState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __PayloadID = buf.getLong();
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if (__Parameters[i] != nullptr)
+            delete __Parameters[i];
+      }
+      __Parameters.clear();
+      uint16_t __Parameters_length = buf.getUShort();
+      for (uint32_t i=0; i< __Parameters_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::KeyValuePair* e = (afrl::cmasi::KeyValuePair*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Parameters.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t PayloadState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if (__Parameters[i] != nullptr)
+         {
+            size += __Parameters[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string PayloadState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( PayloadState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string PayloadState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<PayloadState Series=\"CMASI\">\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</PayloadState>\n";
+
+      return str.str();
+   }
+
+   bool PayloadState::operator==(const PayloadState & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__PayloadID != that.__PayloadID) return false;
+      if(__Parameters.size() != that.__Parameters.size()) return false;
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if(__Parameters[i] && that.__Parameters[i])
+         {
+            if(__Parameters[i]->getSeriesNameAsLong() != that.__Parameters[i]->getSeriesNameAsLong()) return false;
+            if(__Parameters[i]->getSeriesVersion() != that.__Parameters[i]->getSeriesVersion()) return false;
+            if(__Parameters[i]->getLmcpType() != that.__Parameters[i]->getLmcpType()) return false;
+            if( *(__Parameters[i]) != *(that.__Parameters[i]) ) return false;
+         }
+         else if(__Parameters[i] != that.__Parameters[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool PayloadState::operator!=(const PayloadState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   PayloadState& PayloadState::setPayloadID(const int64_t val)
+   {
+      __PayloadID = val;
+      return *this;
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiPayloadStowAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiPayloadStowAction.cpp
new file mode 100644
index 0000000..9e3d61d
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiPayloadStowAction.cpp
@@ -0,0 +1,163 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/PayloadStowAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string PayloadStowAction::Subscription = "afrl.cmasi.PayloadStowAction";
+   const std::string PayloadStowAction::TypeName = "PayloadStowAction";
+   
+   bool isPayloadStowAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 60) return false;
+      return true;
+   }
+   
+   bool isPayloadStowAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 60) return false;
+      return true;
+   }
+   
+   std::vector< std::string > PayloadStowActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   PayloadStowAction::PayloadStowAction(void) : avtas::lmcp::Object()
+   {
+      __PayloadID = 0LL;
+
+   }
+     
+   PayloadStowAction::PayloadStowAction(const PayloadStowAction &that) : avtas::lmcp::Object(that)
+   {
+        __PayloadID = that.__PayloadID;
+
+   }
+   
+   PayloadStowAction & PayloadStowAction::operator=(const PayloadStowAction &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __PayloadID = that.__PayloadID;
+
+      }
+      return *this;
+   }
+
+   PayloadStowAction* PayloadStowAction::clone() const
+   {
+        return new PayloadStowAction(*this);
+   }
+   
+   PayloadStowAction::~PayloadStowAction(void)
+   {
+
+   }
+  
+   void PayloadStowAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__PayloadID);
+
+   }
+   
+   void PayloadStowAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __PayloadID = buf.getLong();
+
+   }
+
+   uint32_t PayloadStowAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string PayloadStowAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( PayloadStowAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string PayloadStowAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<PayloadStowAction Series=\"CMASI\">\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "</PayloadStowAction>\n";
+
+      return str.str();
+   }
+
+   bool PayloadStowAction::operator==(const PayloadStowAction & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__PayloadID != that.__PayloadID) return false;
+      return true;
+
+   }
+
+   bool PayloadStowAction::operator!=(const PayloadStowAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   PayloadStowAction& PayloadStowAction::setPayloadID(const int64_t val)
+   {
+      __PayloadID = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiPointSearchTask.cpp b/src/LMCP/afrl/cmasi/afrlcmasiPointSearchTask.cpp
new file mode 100644
index 0000000..83d6989
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiPointSearchTask.cpp
@@ -0,0 +1,317 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/PointSearchTask.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string PointSearchTask::Subscription = "afrl.cmasi.PointSearchTask";
+   const std::string PointSearchTask::TypeName = "PointSearchTask";
+   
+   bool isPointSearchTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 41) return false;
+      return true;
+   }
+   
+   bool isPointSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 41) return false;
+      return true;
+   }
+   
+   std::vector< std::string > PointSearchTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   PointSearchTask::PointSearchTask(void) : afrl::cmasi::SearchTask()
+   {
+      __SearchLocation = new afrl::cmasi::Location3D();
+      __StandoffDistance = 0.f;
+
+   }
+     
+   PointSearchTask::PointSearchTask(const PointSearchTask &that) : afrl::cmasi::SearchTask(that)
+   {
+        __SearchLocation = that.__SearchLocation == nullptr ? nullptr : that.__SearchLocation->clone();
+        __StandoffDistance = that.__StandoffDistance;
+        __ViewAngleList.clear();
+        for (size_t i=0; i< that.__ViewAngleList.size(); i++)
+        {
+           __ViewAngleList.push_back( that.__ViewAngleList[i] == nullptr ? nullptr : that.__ViewAngleList[i]->clone());
+        }
+
+   }
+   
+   PointSearchTask & PointSearchTask::operator=(const PointSearchTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::SearchTask::operator=(that);
+         if (__SearchLocation != nullptr) delete __SearchLocation;
+         for (size_t i=0; i<__ViewAngleList.size(); i++)
+         {
+            if (__ViewAngleList[i] != nullptr) delete __ViewAngleList[i];
+         }
+
+         __SearchLocation = that.__SearchLocation == nullptr ? nullptr : that.__SearchLocation->clone();
+         __StandoffDistance = that.__StandoffDistance;
+         __ViewAngleList.clear();
+         for (size_t i=0; i< that.__ViewAngleList.size(); i++)
+         {
+            __ViewAngleList.push_back( that.__ViewAngleList[i] == nullptr ? nullptr : that.__ViewAngleList[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   PointSearchTask* PointSearchTask::clone() const
+   {
+        return new PointSearchTask(*this);
+   }
+   
+   PointSearchTask::~PointSearchTask(void)
+   {
+      if (__SearchLocation != nullptr) delete __SearchLocation;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr) delete __ViewAngleList[i];
+      }
+
+   }
+  
+   void PointSearchTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::SearchTask::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __SearchLocation, buf);
+      buf.putFloat(__StandoffDistance);
+      buf.putUShort( static_cast<uint16_t>(__ViewAngleList.size()));
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __ViewAngleList[i], buf);
+      }
+
+   }
+   
+   void PointSearchTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::SearchTask::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__SearchLocation != nullptr) delete __SearchLocation;
+         __SearchLocation = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __SearchLocation = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__SearchLocation != nullptr) __SearchLocation->unpack(buf);
+         }
+      }
+      __StandoffDistance = buf.getFloat();
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr)
+            delete __ViewAngleList[i];
+      }
+      __ViewAngleList.clear();
+      uint16_t __ViewAngleList_length = buf.getUShort();
+      for (uint32_t i=0; i< __ViewAngleList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Wedge* e = (afrl::cmasi::Wedge*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __ViewAngleList.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t PointSearchTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::SearchTask::calculatePackedSize();
+      size += (__SearchLocation != nullptr ? __SearchLocation->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+      size += 2;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr)
+         {
+            size += __ViewAngleList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string PointSearchTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( PointSearchTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "DesiredWavelengthBands (WavelengthBand [ " << __DesiredWavelengthBands.size() << ", var ])\n";
+      oss << indent << "DwellTime (int64_t) = " << __DwellTime << "\n";
+      oss << indent << "GroundSampleDistance (float) = " << __GroundSampleDistance << "\n";
+
+      oss << indent << "SearchLocation (Location3D)";
+      if (__SearchLocation == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "StandoffDistance (float) = " << __StandoffDistance << "\n";
+      oss << indent << "ViewAngleList (Wedge [ " << __ViewAngleList.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string PointSearchTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<PointSearchTask Series=\"CMASI\">\n";
+      if (__SearchLocation != nullptr)
+      {
+         str << ws << "   <SearchLocation>";
+         str << "\n" + __SearchLocation->toXML(depth + 1) + ws + "   ";
+         str << "</SearchLocation>\n";
+      }
+      str << ws << "   <StandoffDistance>" << __StandoffDistance << "</StandoffDistance>\n";
+      str << ws << "   <ViewAngleList>\n";
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         str << (__ViewAngleList[i] == nullptr ? ( ws + "   <null/>\n") : (__ViewAngleList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </ViewAngleList>\n";
+      str << ws << "   <DesiredWavelengthBands>\n";
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         str << ws << "   <WavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__DesiredWavelengthBands[i]) << "</WavelengthBand>\n";
+      }
+      str << ws << "   </DesiredWavelengthBands>\n";
+      str << ws << "   <DwellTime>" << __DwellTime << "</DwellTime>\n";
+      str << ws << "   <GroundSampleDistance>" << __GroundSampleDistance << "</GroundSampleDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</PointSearchTask>\n";
+
+      return str.str();
+   }
+
+   bool PointSearchTask::operator==(const PointSearchTask & that)
+   {
+      if( afrl::cmasi::SearchTask::operator!=(that) )
+      {
+          return false;
+      }
+      if(__SearchLocation && that.__SearchLocation)
+      {
+         if(__SearchLocation->getSeriesNameAsLong() != that.__SearchLocation->getSeriesNameAsLong()) return false;
+         if(__SearchLocation->getSeriesVersion() != that.__SearchLocation->getSeriesVersion()) return false;
+         if(__SearchLocation->getLmcpType() != that.__SearchLocation->getLmcpType()) return false;
+         if( *(__SearchLocation) != *(that.__SearchLocation) ) return false;
+      }
+      else if(__SearchLocation != that.__SearchLocation) return false;
+      if(__StandoffDistance != that.__StandoffDistance) return false;
+      if(__ViewAngleList.size() != that.__ViewAngleList.size()) return false;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if(__ViewAngleList[i] && that.__ViewAngleList[i])
+         {
+            if(__ViewAngleList[i]->getSeriesNameAsLong() != that.__ViewAngleList[i]->getSeriesNameAsLong()) return false;
+            if(__ViewAngleList[i]->getSeriesVersion() != that.__ViewAngleList[i]->getSeriesVersion()) return false;
+            if(__ViewAngleList[i]->getLmcpType() != that.__ViewAngleList[i]->getLmcpType()) return false;
+            if( *(__ViewAngleList[i]) != *(that.__ViewAngleList[i]) ) return false;
+         }
+         else if(__ViewAngleList[i] != that.__ViewAngleList[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool PointSearchTask::operator!=(const PointSearchTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   PointSearchTask& PointSearchTask::setSearchLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__SearchLocation != nullptr) { delete __SearchLocation; __SearchLocation = nullptr; }
+      if (val != nullptr) { __SearchLocation = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   PointSearchTask& PointSearchTask::setStandoffDistance(const float val)
+   {
+      __StandoffDistance = val;
+      return *this;
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiPolygon.cpp b/src/LMCP/afrl/cmasi/afrlcmasiPolygon.cpp
new file mode 100644
index 0000000..1929aec
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiPolygon.cpp
@@ -0,0 +1,222 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/Polygon.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string Polygon::Subscription = "afrl.cmasi.Polygon";
+   const std::string Polygon::TypeName = "Polygon";
+   
+   bool isPolygon(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 42) return false;
+      return true;
+   }
+   
+   bool isPolygon(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 42) return false;
+      return true;
+   }
+   
+   std::vector< std::string > PolygonDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   Polygon::Polygon(void) : afrl::cmasi::AbstractGeometry()
+   {
+
+   }
+     
+   Polygon::Polygon(const Polygon &that) : afrl::cmasi::AbstractGeometry(that)
+   {
+        __BoundaryPoints.clear();
+        for (size_t i=0; i< that.__BoundaryPoints.size(); i++)
+        {
+           __BoundaryPoints.push_back( that.__BoundaryPoints[i] == nullptr ? nullptr : that.__BoundaryPoints[i]->clone());
+        }
+
+   }
+   
+   Polygon & Polygon::operator=(const Polygon &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::AbstractGeometry::operator=(that);
+         for (size_t i=0; i<__BoundaryPoints.size(); i++)
+         {
+            if (__BoundaryPoints[i] != nullptr) delete __BoundaryPoints[i];
+         }
+
+         __BoundaryPoints.clear();
+         for (size_t i=0; i< that.__BoundaryPoints.size(); i++)
+         {
+            __BoundaryPoints.push_back( that.__BoundaryPoints[i] == nullptr ? nullptr : that.__BoundaryPoints[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   Polygon* Polygon::clone() const
+   {
+        return new Polygon(*this);
+   }
+   
+   Polygon::~Polygon(void)
+   {
+      for (size_t i=0; i<__BoundaryPoints.size(); i++)
+      {
+         if (__BoundaryPoints[i] != nullptr) delete __BoundaryPoints[i];
+      }
+
+   }
+  
+   void Polygon::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::AbstractGeometry::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__BoundaryPoints.size()));
+      for (size_t i=0; i<__BoundaryPoints.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __BoundaryPoints[i], buf);
+      }
+
+   }
+   
+   void Polygon::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::AbstractGeometry::unpack(buf);
+      // Copy the buffer into the class
+      for (size_t i=0; i<__BoundaryPoints.size(); i++)
+      {
+         if (__BoundaryPoints[i] != nullptr)
+            delete __BoundaryPoints[i];
+      }
+      __BoundaryPoints.clear();
+      uint16_t __BoundaryPoints_length = buf.getUShort();
+      for (uint32_t i=0; i< __BoundaryPoints_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Location3D* e = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __BoundaryPoints.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t Polygon::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::AbstractGeometry::calculatePackedSize();
+      size += 2;
+      for (size_t i=0; i<__BoundaryPoints.size(); i++)
+      {
+         if (__BoundaryPoints[i] != nullptr)
+         {
+            size += __BoundaryPoints[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string Polygon::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( Polygon ) {\n";
+      indent = std::string((++depth)*3, ' ');
+
+      oss << indent << "BoundaryPoints (Location3D [ " << __BoundaryPoints.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string Polygon::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<Polygon Series=\"CMASI\">\n";
+      str << ws << "   <BoundaryPoints>\n";
+      for (size_t i=0; i<__BoundaryPoints.size(); i++)
+      {
+         str << (__BoundaryPoints[i] == nullptr ? ( ws + "   <null/>\n") : (__BoundaryPoints[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </BoundaryPoints>\n";
+      str << ws << "</Polygon>\n";
+
+      return str.str();
+   }
+
+   bool Polygon::operator==(const Polygon & that)
+   {
+      if( afrl::cmasi::AbstractGeometry::operator!=(that) )
+      {
+          return false;
+      }
+      if(__BoundaryPoints.size() != that.__BoundaryPoints.size()) return false;
+      for (size_t i=0; i<__BoundaryPoints.size(); i++)
+      {
+         if(__BoundaryPoints[i] && that.__BoundaryPoints[i])
+         {
+            if(__BoundaryPoints[i]->getSeriesNameAsLong() != that.__BoundaryPoints[i]->getSeriesNameAsLong()) return false;
+            if(__BoundaryPoints[i]->getSeriesVersion() != that.__BoundaryPoints[i]->getSeriesVersion()) return false;
+            if(__BoundaryPoints[i]->getLmcpType() != that.__BoundaryPoints[i]->getLmcpType()) return false;
+            if( *(__BoundaryPoints[i]) != *(that.__BoundaryPoints[i]) ) return false;
+         }
+         else if(__BoundaryPoints[i] != that.__BoundaryPoints[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool Polygon::operator!=(const Polygon & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiRectangle.cpp b/src/LMCP/afrl/cmasi/afrlcmasiRectangle.cpp
new file mode 100644
index 0000000..9a5f395
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiRectangle.cpp
@@ -0,0 +1,240 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/Rectangle.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string Rectangle::Subscription = "afrl.cmasi.Rectangle";
+   const std::string Rectangle::TypeName = "Rectangle";
+   
+   bool isRectangle(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 43) return false;
+      return true;
+   }
+   
+   bool isRectangle(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 43) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RectangleDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   Rectangle::Rectangle(void) : afrl::cmasi::AbstractGeometry()
+   {
+      __CenterPoint = new afrl::cmasi::Location3D();
+      __Width = 0.f;
+      __Height = 0.f;
+      __Rotation = 0.f;
+
+   }
+     
+   Rectangle::Rectangle(const Rectangle &that) : afrl::cmasi::AbstractGeometry(that)
+   {
+        __CenterPoint = that.__CenterPoint == nullptr ? nullptr : that.__CenterPoint->clone();
+        __Width = that.__Width;
+        __Height = that.__Height;
+        __Rotation = that.__Rotation;
+
+   }
+   
+   Rectangle & Rectangle::operator=(const Rectangle &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::AbstractGeometry::operator=(that);
+         if (__CenterPoint != nullptr) delete __CenterPoint;
+
+         __CenterPoint = that.__CenterPoint == nullptr ? nullptr : that.__CenterPoint->clone();
+         __Width = that.__Width;
+         __Height = that.__Height;
+         __Rotation = that.__Rotation;
+
+      }
+      return *this;
+   }
+
+   Rectangle* Rectangle::clone() const
+   {
+        return new Rectangle(*this);
+   }
+   
+   Rectangle::~Rectangle(void)
+   {
+      if (__CenterPoint != nullptr) delete __CenterPoint;
+
+   }
+  
+   void Rectangle::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::AbstractGeometry::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __CenterPoint, buf);
+      buf.putFloat(__Width);
+      buf.putFloat(__Height);
+      buf.putFloat(__Rotation);
+
+   }
+   
+   void Rectangle::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::AbstractGeometry::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__CenterPoint != nullptr) delete __CenterPoint;
+         __CenterPoint = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __CenterPoint = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__CenterPoint != nullptr) __CenterPoint->unpack(buf);
+         }
+      }
+      __Width = buf.getFloat();
+      __Height = buf.getFloat();
+      __Rotation = buf.getFloat();
+
+   }
+
+   uint32_t Rectangle::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::AbstractGeometry::calculatePackedSize();
+      size += (__CenterPoint != nullptr ? __CenterPoint->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string Rectangle::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( Rectangle ) {\n";
+      indent = std::string((++depth)*3, ' ');
+
+      oss << indent << "CenterPoint (Location3D)";
+      if (__CenterPoint == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "Width (float) = " << __Width << "\n";
+      oss << indent << "Height (float) = " << __Height << "\n";
+      oss << indent << "Rotation (float) = " << __Rotation << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string Rectangle::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<Rectangle Series=\"CMASI\">\n";
+      if (__CenterPoint != nullptr)
+      {
+         str << ws << "   <CenterPoint>";
+         str << "\n" + __CenterPoint->toXML(depth + 1) + ws + "   ";
+         str << "</CenterPoint>\n";
+      }
+      str << ws << "   <Width>" << __Width << "</Width>\n";
+      str << ws << "   <Height>" << __Height << "</Height>\n";
+      str << ws << "   <Rotation>" << __Rotation << "</Rotation>\n";
+      str << ws << "</Rectangle>\n";
+
+      return str.str();
+   }
+
+   bool Rectangle::operator==(const Rectangle & that)
+   {
+      if( afrl::cmasi::AbstractGeometry::operator!=(that) )
+      {
+          return false;
+      }
+      if(__CenterPoint && that.__CenterPoint)
+      {
+         if(__CenterPoint->getSeriesNameAsLong() != that.__CenterPoint->getSeriesNameAsLong()) return false;
+         if(__CenterPoint->getSeriesVersion() != that.__CenterPoint->getSeriesVersion()) return false;
+         if(__CenterPoint->getLmcpType() != that.__CenterPoint->getLmcpType()) return false;
+         if( *(__CenterPoint) != *(that.__CenterPoint) ) return false;
+      }
+      else if(__CenterPoint != that.__CenterPoint) return false;
+      if(__Width != that.__Width) return false;
+      if(__Height != that.__Height) return false;
+      if(__Rotation != that.__Rotation) return false;
+      return true;
+
+   }
+
+   bool Rectangle::operator!=(const Rectangle & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   Rectangle& Rectangle::setCenterPoint(const afrl::cmasi::Location3D* const val)
+   {
+      if (__CenterPoint != nullptr) { delete __CenterPoint; __CenterPoint = nullptr; }
+      if (val != nullptr) { __CenterPoint = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   Rectangle& Rectangle::setWidth(const float val)
+   {
+      __Width = val;
+      return *this;
+   }
+
+   Rectangle& Rectangle::setHeight(const float val)
+   {
+      __Height = val;
+      return *this;
+   }
+
+   Rectangle& Rectangle::setRotation(const float val)
+   {
+      __Rotation = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiRemoveEntities.cpp b/src/LMCP/afrl/cmasi/afrlcmasiRemoveEntities.cpp
new file mode 100644
index 0000000..766874f
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiRemoveEntities.cpp
@@ -0,0 +1,183 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/RemoveEntities.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RemoveEntities::Subscription = "afrl.cmasi.RemoveEntities";
+   const std::string RemoveEntities::TypeName = "RemoveEntities";
+   
+   bool isRemoveEntities(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 53) return false;
+      return true;
+   }
+   
+   bool isRemoveEntities(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 53) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RemoveEntitiesDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RemoveEntities::RemoveEntities(void) : avtas::lmcp::Object()
+   {
+
+   }
+     
+   RemoveEntities::RemoveEntities(const RemoveEntities &that) : avtas::lmcp::Object(that)
+   {
+        __EntityList.clear();
+        for (size_t i=0; i< that.__EntityList.size(); i++)
+        {
+           __EntityList.push_back( that.__EntityList[i]);
+        }
+
+   }
+   
+   RemoveEntities & RemoveEntities::operator=(const RemoveEntities &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __EntityList.clear();
+         for (size_t i=0; i< that.__EntityList.size(); i++)
+         {
+            __EntityList.push_back( that.__EntityList[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   RemoveEntities* RemoveEntities::clone() const
+   {
+        return new RemoveEntities(*this);
+   }
+   
+   RemoveEntities::~RemoveEntities(void)
+   {
+
+   }
+  
+   void RemoveEntities::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__EntityList.size()));
+      for (size_t i=0; i<__EntityList.size(); i++)
+      {
+         buf.putLong(__EntityList[i]);
+      }
+
+   }
+   
+   void RemoveEntities::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __EntityList.clear();
+      uint16_t __EntityList_length = buf.getUShort();
+      for (uint32_t i=0; i< __EntityList_length; i++)
+      {
+         __EntityList.push_back(buf.getLong() );
+      }
+
+   }
+
+   uint32_t RemoveEntities::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2 + sizeof(int64_t) * __EntityList.size();
+
+      return size;
+   }
+
+   std::string RemoveEntities::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RemoveEntities ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "EntityList (int64 [ " << __EntityList.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RemoveEntities::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RemoveEntities Series=\"CMASI\">\n";
+      str << ws << "   <EntityList>\n";
+      for (size_t i=0; i<__EntityList.size(); i++)
+      {
+         str << ws << "   <int64>" << __EntityList[i] << "</int64>\n";
+      }
+      str << ws << "   </EntityList>\n";
+      str << ws << "</RemoveEntities>\n";
+
+      return str.str();
+   }
+
+   bool RemoveEntities::operator==(const RemoveEntities & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__EntityList.size() != that.__EntityList.size()) return false;
+      for (size_t i=0; i<__EntityList.size(); i++)
+      {
+         if(__EntityList[i] != that.__EntityList[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool RemoveEntities::operator!=(const RemoveEntities & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiRemoveTasks.cpp b/src/LMCP/afrl/cmasi/afrlcmasiRemoveTasks.cpp
new file mode 100644
index 0000000..94d4a15
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiRemoveTasks.cpp
@@ -0,0 +1,183 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/RemoveTasks.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RemoveTasks::Subscription = "afrl.cmasi.RemoveTasks";
+   const std::string RemoveTasks::TypeName = "RemoveTasks";
+   
+   bool isRemoveTasks(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 44) return false;
+      return true;
+   }
+   
+   bool isRemoveTasks(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 44) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RemoveTasksDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RemoveTasks::RemoveTasks(void) : avtas::lmcp::Object()
+   {
+
+   }
+     
+   RemoveTasks::RemoveTasks(const RemoveTasks &that) : avtas::lmcp::Object(that)
+   {
+        __TaskList.clear();
+        for (size_t i=0; i< that.__TaskList.size(); i++)
+        {
+           __TaskList.push_back( that.__TaskList[i]);
+        }
+
+   }
+   
+   RemoveTasks & RemoveTasks::operator=(const RemoveTasks &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __TaskList.clear();
+         for (size_t i=0; i< that.__TaskList.size(); i++)
+         {
+            __TaskList.push_back( that.__TaskList[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   RemoveTasks* RemoveTasks::clone() const
+   {
+        return new RemoveTasks(*this);
+   }
+   
+   RemoveTasks::~RemoveTasks(void)
+   {
+
+   }
+  
+   void RemoveTasks::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__TaskList.size()));
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         buf.putLong(__TaskList[i]);
+      }
+
+   }
+   
+   void RemoveTasks::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __TaskList.clear();
+      uint16_t __TaskList_length = buf.getUShort();
+      for (uint32_t i=0; i< __TaskList_length; i++)
+      {
+         __TaskList.push_back(buf.getLong() );
+      }
+
+   }
+
+   uint32_t RemoveTasks::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2 + sizeof(int64_t) * __TaskList.size();
+
+      return size;
+   }
+
+   std::string RemoveTasks::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RemoveTasks ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskList (int64 [ " << __TaskList.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RemoveTasks::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RemoveTasks Series=\"CMASI\">\n";
+      str << ws << "   <TaskList>\n";
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __TaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </TaskList>\n";
+      str << ws << "</RemoveTasks>\n";
+
+      return str.str();
+   }
+
+   bool RemoveTasks::operator==(const RemoveTasks & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__TaskList.size() != that.__TaskList.size()) return false;
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         if(__TaskList[i] != that.__TaskList[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool RemoveTasks::operator!=(const RemoveTasks & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiRemoveZones.cpp b/src/LMCP/afrl/cmasi/afrlcmasiRemoveZones.cpp
new file mode 100644
index 0000000..66212d0
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiRemoveZones.cpp
@@ -0,0 +1,183 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/RemoveZones.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RemoveZones::Subscription = "afrl.cmasi.RemoveZones";
+   const std::string RemoveZones::TypeName = "RemoveZones";
+   
+   bool isRemoveZones(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 52) return false;
+      return true;
+   }
+   
+   bool isRemoveZones(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 52) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RemoveZonesDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RemoveZones::RemoveZones(void) : avtas::lmcp::Object()
+   {
+
+   }
+     
+   RemoveZones::RemoveZones(const RemoveZones &that) : avtas::lmcp::Object(that)
+   {
+        __ZoneList.clear();
+        for (size_t i=0; i< that.__ZoneList.size(); i++)
+        {
+           __ZoneList.push_back( that.__ZoneList[i]);
+        }
+
+   }
+   
+   RemoveZones & RemoveZones::operator=(const RemoveZones &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __ZoneList.clear();
+         for (size_t i=0; i< that.__ZoneList.size(); i++)
+         {
+            __ZoneList.push_back( that.__ZoneList[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   RemoveZones* RemoveZones::clone() const
+   {
+        return new RemoveZones(*this);
+   }
+   
+   RemoveZones::~RemoveZones(void)
+   {
+
+   }
+  
+   void RemoveZones::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__ZoneList.size()));
+      for (size_t i=0; i<__ZoneList.size(); i++)
+      {
+         buf.putLong(__ZoneList[i]);
+      }
+
+   }
+   
+   void RemoveZones::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ZoneList.clear();
+      uint16_t __ZoneList_length = buf.getUShort();
+      for (uint32_t i=0; i< __ZoneList_length; i++)
+      {
+         __ZoneList.push_back(buf.getLong() );
+      }
+
+   }
+
+   uint32_t RemoveZones::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2 + sizeof(int64_t) * __ZoneList.size();
+
+      return size;
+   }
+
+   std::string RemoveZones::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RemoveZones ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ZoneList (int64 [ " << __ZoneList.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RemoveZones::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RemoveZones Series=\"CMASI\">\n";
+      str << ws << "   <ZoneList>\n";
+      for (size_t i=0; i<__ZoneList.size(); i++)
+      {
+         str << ws << "   <int64>" << __ZoneList[i] << "</int64>\n";
+      }
+      str << ws << "   </ZoneList>\n";
+      str << ws << "</RemoveZones>\n";
+
+      return str.str();
+   }
+
+   bool RemoveZones::operator==(const RemoveZones & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ZoneList.size() != that.__ZoneList.size()) return false;
+      for (size_t i=0; i<__ZoneList.size(); i++)
+      {
+         if(__ZoneList[i] != that.__ZoneList[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool RemoveZones::operator!=(const RemoveZones & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiSearchTask.cpp b/src/LMCP/afrl/cmasi/afrlcmasiSearchTask.cpp
new file mode 100644
index 0000000..ed32d33
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiSearchTask.cpp
@@ -0,0 +1,248 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/SearchTask.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string SearchTask::Subscription = "afrl.cmasi.SearchTask";
+   const std::string SearchTask::TypeName = "SearchTask";
+   
+   bool isSearchTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 9) return false;
+      return true;
+   }
+   
+   bool isSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 9) return false;
+      return true;
+   }
+   
+   std::vector< std::string > SearchTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.AreaSearchTask");
+       descendants.push_back("afrl.cmasi.LineSearchTask");
+       descendants.push_back("afrl.cmasi.PointSearchTask");
+       descendants.push_back("afrl.impact.ImpactPointSearchTask");
+       descendants.push_back("afrl.impact.PatternSearchTask");
+       descendants.push_back("afrl.impact.AngledAreaSearchTask");
+       descendants.push_back("afrl.impact.ImpactLineSearchTask");
+       descendants.push_back("afrl.impact.WatchTask");
+       descendants.push_back("afrl.impact.MultiVehicleWatchTask");
+       descendants.push_back("afrl.impact.EscortTask");
+
+       return descendants;
+   }
+   
+   SearchTask::SearchTask(void) : afrl::cmasi::Task()
+   {
+      __DwellTime = 0LL;
+      __GroundSampleDistance = 0.f;
+
+   }
+     
+   SearchTask::SearchTask(const SearchTask &that) : afrl::cmasi::Task(that)
+   {
+        __DesiredWavelengthBands.clear();
+        for (size_t i=0; i< that.__DesiredWavelengthBands.size(); i++)
+        {
+           __DesiredWavelengthBands.push_back( that.__DesiredWavelengthBands[i]);
+        }
+        __DwellTime = that.__DwellTime;
+        __GroundSampleDistance = that.__GroundSampleDistance;
+
+   }
+   
+   SearchTask & SearchTask::operator=(const SearchTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::Task::operator=(that);
+
+         __DesiredWavelengthBands.clear();
+         for (size_t i=0; i< that.__DesiredWavelengthBands.size(); i++)
+         {
+            __DesiredWavelengthBands.push_back( that.__DesiredWavelengthBands[i]);
+         }
+         __DwellTime = that.__DwellTime;
+         __GroundSampleDistance = that.__GroundSampleDistance;
+
+      }
+      return *this;
+   }
+
+   SearchTask* SearchTask::clone() const
+   {
+        return new SearchTask(*this);
+   }
+   
+   SearchTask::~SearchTask(void)
+   {
+
+   }
+  
+   void SearchTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::Task::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__DesiredWavelengthBands.size()));
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         buf.putInt( (int32_t) __DesiredWavelengthBands[i]);
+      }
+      buf.putLong(__DwellTime);
+      buf.putFloat(__GroundSampleDistance);
+
+   }
+   
+   void SearchTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::Task::unpack(buf);
+      // Copy the buffer into the class
+      __DesiredWavelengthBands.clear();
+      uint16_t __DesiredWavelengthBands_length = buf.getUShort();
+      for (uint32_t i=0; i< __DesiredWavelengthBands_length; i++)
+      {
+         __DesiredWavelengthBands.push_back( (afrl::cmasi::WavelengthBand::WavelengthBand) buf.getInt() );
+      }
+      __DwellTime = buf.getLong();
+      __GroundSampleDistance = buf.getFloat();
+
+   }
+
+   uint32_t SearchTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::Task::calculatePackedSize();
+      size += 2 + sizeof(afrl::cmasi::WavelengthBand::WavelengthBand) * __DesiredWavelengthBands.size();
+      size += sizeof(int64_t);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string SearchTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( SearchTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "DesiredWavelengthBands (WavelengthBand [ " << __DesiredWavelengthBands.size() << ", var ])\n";
+      oss << indent << "DwellTime (int64_t) = " << __DwellTime << "\n";
+      oss << indent << "GroundSampleDistance (float) = " << __GroundSampleDistance << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string SearchTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<SearchTask Series=\"CMASI\">\n";
+      str << ws << "   <DesiredWavelengthBands>\n";
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         str << ws << "   <WavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__DesiredWavelengthBands[i]) << "</WavelengthBand>\n";
+      }
+      str << ws << "   </DesiredWavelengthBands>\n";
+      str << ws << "   <DwellTime>" << __DwellTime << "</DwellTime>\n";
+      str << ws << "   <GroundSampleDistance>" << __GroundSampleDistance << "</GroundSampleDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</SearchTask>\n";
+
+      return str.str();
+   }
+
+   bool SearchTask::operator==(const SearchTask & that)
+   {
+      if( afrl::cmasi::Task::operator!=(that) )
+      {
+          return false;
+      }
+      if(__DesiredWavelengthBands.size() != that.__DesiredWavelengthBands.size()) return false;
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         if(__DesiredWavelengthBands[i] != that.__DesiredWavelengthBands[i]) return false;
+      }
+      if(__DwellTime != that.__DwellTime) return false;
+      if(__GroundSampleDistance != that.__GroundSampleDistance) return false;
+      return true;
+
+   }
+
+   bool SearchTask::operator!=(const SearchTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+   SearchTask& SearchTask::setDwellTime(const int64_t val)
+   {
+      __DwellTime = val;
+      return *this;
+   }
+
+   SearchTask& SearchTask::setGroundSampleDistance(const float val)
+   {
+      __GroundSampleDistance = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiServiceStatus.cpp b/src/LMCP/afrl/cmasi/afrlcmasiServiceStatus.cpp
new file mode 100644
index 0000000..53befdc
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiServiceStatus.cpp
@@ -0,0 +1,249 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/ServiceStatus.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string ServiceStatus::Subscription = "afrl.cmasi.ServiceStatus";
+   const std::string ServiceStatus::TypeName = "ServiceStatus";
+   
+   bool isServiceStatus(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 45) return false;
+      return true;
+   }
+   
+   bool isServiceStatus(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 45) return false;
+      return true;
+   }
+   
+   std::vector< std::string > ServiceStatusDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   ServiceStatus::ServiceStatus(void) : avtas::lmcp::Object()
+   {
+      __PercentComplete = 0.f;
+      __StatusType = afrl::cmasi::ServiceStatusType::Information;
+
+   }
+     
+   ServiceStatus::ServiceStatus(const ServiceStatus &that) : avtas::lmcp::Object(that)
+   {
+        __PercentComplete = that.__PercentComplete;
+        __Info.clear();
+        for (size_t i=0; i< that.__Info.size(); i++)
+        {
+           __Info.push_back( that.__Info[i] == nullptr ? nullptr : that.__Info[i]->clone());
+        }
+        __StatusType = that.__StatusType;
+
+   }
+   
+   ServiceStatus & ServiceStatus::operator=(const ServiceStatus &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Info.size(); i++)
+         {
+            if (__Info[i] != nullptr) delete __Info[i];
+         }
+
+         __PercentComplete = that.__PercentComplete;
+         __Info.clear();
+         for (size_t i=0; i< that.__Info.size(); i++)
+         {
+            __Info.push_back( that.__Info[i] == nullptr ? nullptr : that.__Info[i]->clone());
+         }
+         __StatusType = that.__StatusType;
+
+      }
+      return *this;
+   }
+
+   ServiceStatus* ServiceStatus::clone() const
+   {
+        return new ServiceStatus(*this);
+   }
+   
+   ServiceStatus::~ServiceStatus(void)
+   {
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if (__Info[i] != nullptr) delete __Info[i];
+      }
+
+   }
+  
+   void ServiceStatus::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putFloat(__PercentComplete);
+      buf.putUShort( static_cast<uint16_t>(__Info.size()));
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Info[i], buf);
+      }
+      buf.putInt( (int32_t) __StatusType);
+
+   }
+   
+   void ServiceStatus::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __PercentComplete = buf.getFloat();
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if (__Info[i] != nullptr)
+            delete __Info[i];
+      }
+      __Info.clear();
+      uint16_t __Info_length = buf.getUShort();
+      for (uint32_t i=0; i< __Info_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::KeyValuePair* e = (afrl::cmasi::KeyValuePair*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Info.push_back(e);
+         }
+      }
+      __StatusType = (afrl::cmasi::ServiceStatusType::ServiceStatusType) buf.getInt();
+
+   }
+
+   uint32_t ServiceStatus::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(float);
+      size += 2;
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if (__Info[i] != nullptr)
+         {
+            size += __Info[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(afrl::cmasi::ServiceStatusType::ServiceStatusType);
+
+      return size;
+   }
+
+   std::string ServiceStatus::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( ServiceStatus ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PercentComplete (float) = " << __PercentComplete << "\n";
+      oss << indent << "Info (KeyValuePair [ " << __Info.size() << ", var ])\n";
+      oss << indent << "StatusType (ServiceStatusType) = " << __StatusType << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string ServiceStatus::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<ServiceStatus Series=\"CMASI\">\n";
+      str << ws << "   <PercentComplete>" << __PercentComplete << "</PercentComplete>\n";
+      str << ws << "   <Info>\n";
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         str << (__Info[i] == nullptr ? ( ws + "   <null/>\n") : (__Info[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Info>\n";
+      str << ws << "   <StatusType>" << afrl::cmasi::ServiceStatusType::get_string(__StatusType) << "</StatusType>\n";
+      str << ws << "</ServiceStatus>\n";
+
+      return str.str();
+   }
+
+   bool ServiceStatus::operator==(const ServiceStatus & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__PercentComplete != that.__PercentComplete) return false;
+      if(__Info.size() != that.__Info.size()) return false;
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         if(__Info[i] && that.__Info[i])
+         {
+            if(__Info[i]->getSeriesNameAsLong() != that.__Info[i]->getSeriesNameAsLong()) return false;
+            if(__Info[i]->getSeriesVersion() != that.__Info[i]->getSeriesVersion()) return false;
+            if(__Info[i]->getLmcpType() != that.__Info[i]->getLmcpType()) return false;
+            if( *(__Info[i]) != *(that.__Info[i]) ) return false;
+         }
+         else if(__Info[i] != that.__Info[i]) return false;
+      }
+      if(__StatusType != that.__StatusType) return false;
+      return true;
+
+   }
+
+   bool ServiceStatus::operator!=(const ServiceStatus & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   ServiceStatus& ServiceStatus::setPercentComplete(const float val)
+   {
+      __PercentComplete = val;
+      return *this;
+   }
+
+
+   ServiceStatus& ServiceStatus::setStatusType(const afrl::cmasi::ServiceStatusType::ServiceStatusType val)
+   {
+      __StatusType = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiSessionStatus.cpp b/src/LMCP/afrl/cmasi/afrlcmasiSessionStatus.cpp
new file mode 100644
index 0000000..5d2114a
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiSessionStatus.cpp
@@ -0,0 +1,279 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/SessionStatus.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string SessionStatus::Subscription = "afrl.cmasi.SessionStatus";
+   const std::string SessionStatus::TypeName = "SessionStatus";
+   
+   bool isSessionStatus(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 46) return false;
+      return true;
+   }
+   
+   bool isSessionStatus(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 46) return false;
+      return true;
+   }
+   
+   std::vector< std::string > SessionStatusDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   SessionStatus::SessionStatus(void) : avtas::lmcp::Object()
+   {
+      __State = afrl::cmasi::SimulationStatusType::Stopped;
+      __StartTime = 0LL;
+      __ScenarioTime = 0LL;
+      __RealTimeMultiple = 0.f;
+
+   }
+     
+   SessionStatus::SessionStatus(const SessionStatus &that) : avtas::lmcp::Object(that)
+   {
+        __State = that.__State;
+        __StartTime = that.__StartTime;
+        __ScenarioTime = that.__ScenarioTime;
+        __RealTimeMultiple = that.__RealTimeMultiple;
+        __Parameters.clear();
+        for (size_t i=0; i< that.__Parameters.size(); i++)
+        {
+           __Parameters.push_back( that.__Parameters[i] == nullptr ? nullptr : that.__Parameters[i]->clone());
+        }
+
+   }
+   
+   SessionStatus & SessionStatus::operator=(const SessionStatus &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Parameters.size(); i++)
+         {
+            if (__Parameters[i] != nullptr) delete __Parameters[i];
+         }
+
+         __State = that.__State;
+         __StartTime = that.__StartTime;
+         __ScenarioTime = that.__ScenarioTime;
+         __RealTimeMultiple = that.__RealTimeMultiple;
+         __Parameters.clear();
+         for (size_t i=0; i< that.__Parameters.size(); i++)
+         {
+            __Parameters.push_back( that.__Parameters[i] == nullptr ? nullptr : that.__Parameters[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   SessionStatus* SessionStatus::clone() const
+   {
+        return new SessionStatus(*this);
+   }
+   
+   SessionStatus::~SessionStatus(void)
+   {
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if (__Parameters[i] != nullptr) delete __Parameters[i];
+      }
+
+   }
+  
+   void SessionStatus::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putInt( (int32_t) __State);
+      buf.putLong(__StartTime);
+      buf.putLong(__ScenarioTime);
+      buf.putFloat(__RealTimeMultiple);
+      buf.putUShort( static_cast<uint16_t>(__Parameters.size()));
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Parameters[i], buf);
+      }
+
+   }
+   
+   void SessionStatus::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __State = (afrl::cmasi::SimulationStatusType::SimulationStatusType) buf.getInt();
+      __StartTime = buf.getLong();
+      __ScenarioTime = buf.getLong();
+      __RealTimeMultiple = buf.getFloat();
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if (__Parameters[i] != nullptr)
+            delete __Parameters[i];
+      }
+      __Parameters.clear();
+      uint16_t __Parameters_length = buf.getUShort();
+      for (uint32_t i=0; i< __Parameters_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::KeyValuePair* e = (afrl::cmasi::KeyValuePair*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Parameters.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t SessionStatus::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(afrl::cmasi::SimulationStatusType::SimulationStatusType);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += 2;
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if (__Parameters[i] != nullptr)
+         {
+            size += __Parameters[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string SessionStatus::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( SessionStatus ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "State (SimulationStatusType) = " << __State << "\n";
+      oss << indent << "StartTime (int64_t) = " << __StartTime << "\n";
+      oss << indent << "ScenarioTime (int64_t) = " << __ScenarioTime << "\n";
+      oss << indent << "RealTimeMultiple (float) = " << __RealTimeMultiple << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string SessionStatus::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<SessionStatus Series=\"CMASI\">\n";
+      str << ws << "   <State>" << afrl::cmasi::SimulationStatusType::get_string(__State) << "</State>\n";
+      str << ws << "   <StartTime>" << __StartTime << "</StartTime>\n";
+      str << ws << "   <ScenarioTime>" << __ScenarioTime << "</ScenarioTime>\n";
+      str << ws << "   <RealTimeMultiple>" << __RealTimeMultiple << "</RealTimeMultiple>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</SessionStatus>\n";
+
+      return str.str();
+   }
+
+   bool SessionStatus::operator==(const SessionStatus & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__State != that.__State) return false;
+      if(__StartTime != that.__StartTime) return false;
+      if(__ScenarioTime != that.__ScenarioTime) return false;
+      if(__RealTimeMultiple != that.__RealTimeMultiple) return false;
+      if(__Parameters.size() != that.__Parameters.size()) return false;
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if(__Parameters[i] && that.__Parameters[i])
+         {
+            if(__Parameters[i]->getSeriesNameAsLong() != that.__Parameters[i]->getSeriesNameAsLong()) return false;
+            if(__Parameters[i]->getSeriesVersion() != that.__Parameters[i]->getSeriesVersion()) return false;
+            if(__Parameters[i]->getLmcpType() != that.__Parameters[i]->getLmcpType()) return false;
+            if( *(__Parameters[i]) != *(that.__Parameters[i]) ) return false;
+         }
+         else if(__Parameters[i] != that.__Parameters[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool SessionStatus::operator!=(const SessionStatus & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   SessionStatus& SessionStatus::setState(const afrl::cmasi::SimulationStatusType::SimulationStatusType val)
+   {
+      __State = val;
+      return *this;
+   }
+
+   SessionStatus& SessionStatus::setStartTime(const int64_t val)
+   {
+      __StartTime = val;
+      return *this;
+   }
+
+   SessionStatus& SessionStatus::setScenarioTime(const int64_t val)
+   {
+      __ScenarioTime = val;
+      return *this;
+   }
+
+   SessionStatus& SessionStatus::setRealTimeMultiple(const float val)
+   {
+      __RealTimeMultiple = val;
+      return *this;
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiStopMovementAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiStopMovementAction.cpp
new file mode 100644
index 0000000..135cba3
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiStopMovementAction.cpp
@@ -0,0 +1,202 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/StopMovementAction.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string StopMovementAction::Subscription = "afrl.cmasi.StopMovementAction";
+   const std::string StopMovementAction::TypeName = "StopMovementAction";
+   
+   bool isStopMovementAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 58) return false;
+      return true;
+   }
+   
+   bool isStopMovementAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 58) return false;
+      return true;
+   }
+   
+   std::vector< std::string > StopMovementActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   StopMovementAction::StopMovementAction(void) : afrl::cmasi::VehicleAction()
+   {
+      __Location = nullptr;
+
+   }
+     
+   StopMovementAction::StopMovementAction(const StopMovementAction &that) : afrl::cmasi::VehicleAction(that)
+   {
+        __Location = that.__Location == nullptr ? nullptr : that.__Location->clone();
+
+   }
+   
+   StopMovementAction & StopMovementAction::operator=(const StopMovementAction &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::VehicleAction::operator=(that);
+         if (__Location != nullptr) delete __Location;
+
+         __Location = that.__Location == nullptr ? nullptr : that.__Location->clone();
+
+      }
+      return *this;
+   }
+
+   StopMovementAction* StopMovementAction::clone() const
+   {
+        return new StopMovementAction(*this);
+   }
+   
+   StopMovementAction::~StopMovementAction(void)
+   {
+      if (__Location != nullptr) delete __Location;
+
+   }
+  
+   void StopMovementAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::VehicleAction::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Location, buf);
+
+   }
+   
+   void StopMovementAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::VehicleAction::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__Location != nullptr) delete __Location;
+         __Location = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Location = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Location != nullptr) __Location->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t StopMovementAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::VehicleAction::calculatePackedSize();
+      size += (__Location != nullptr ? __Location->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string StopMovementAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( StopMovementAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+      oss << indent << "Location (Location3D)";
+      if (__Location == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string StopMovementAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<StopMovementAction Series=\"CMASI\">\n";
+      if (__Location != nullptr)
+      {
+         str << ws << "   <Location>";
+         str << "\n" + __Location->toXML(depth + 1) + ws + "   ";
+         str << "</Location>\n";
+      }
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</StopMovementAction>\n";
+
+      return str.str();
+   }
+
+   bool StopMovementAction::operator==(const StopMovementAction & that)
+   {
+      if( afrl::cmasi::VehicleAction::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Location && that.__Location)
+      {
+         if(__Location->getSeriesNameAsLong() != that.__Location->getSeriesNameAsLong()) return false;
+         if(__Location->getSeriesVersion() != that.__Location->getSeriesVersion()) return false;
+         if(__Location->getLmcpType() != that.__Location->getLmcpType()) return false;
+         if( *(__Location) != *(that.__Location) ) return false;
+      }
+      else if(__Location != that.__Location) return false;
+      return true;
+
+   }
+
+   bool StopMovementAction::operator!=(const StopMovementAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   StopMovementAction& StopMovementAction::setLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__Location != nullptr) { delete __Location; __Location = nullptr; }
+      if (val != nullptr) { __Location = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiTask.cpp b/src/LMCP/afrl/cmasi/afrlcmasiTask.cpp
new file mode 100644
index 0000000..3aa2ccc
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiTask.cpp
@@ -0,0 +1,347 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/Task.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string Task::Subscription = "afrl.cmasi.Task";
+   const std::string Task::TypeName = "Task";
+   
+   bool isTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 8) return false;
+      return true;
+   }
+   
+   bool isTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 8) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("uxas.messages.task.AssignmentCoordinatorTask");
+       descendants.push_back("afrl.cmasi.SearchTask");
+       descendants.push_back("afrl.cmasi.AreaSearchTask");
+       descendants.push_back("afrl.cmasi.LineSearchTask");
+       descendants.push_back("afrl.cmasi.PointSearchTask");
+       descendants.push_back("afrl.impact.ImpactPointSearchTask");
+       descendants.push_back("afrl.impact.PatternSearchTask");
+       descendants.push_back("afrl.impact.AngledAreaSearchTask");
+       descendants.push_back("afrl.impact.ImpactLineSearchTask");
+       descendants.push_back("afrl.impact.WatchTask");
+       descendants.push_back("afrl.impact.MultiVehicleWatchTask");
+       descendants.push_back("afrl.impact.EscortTask");
+       descendants.push_back("afrl.cmasi.LoiterTask");
+       descendants.push_back("afrl.cmasi.MustFlyTask");
+       descendants.push_back("afrl.impact.CommRelayTask");
+       descendants.push_back("afrl.impact.CordonTask");
+       descendants.push_back("afrl.impact.BlockadeTask");
+       descendants.push_back("afrl.cmasi.perceive.TrackEntityTask");
+
+       return descendants;
+   }
+   
+   Task::Task(void) : avtas::lmcp::Object()
+   {
+      __TaskID = 0LL;
+      __Label = std::string("");
+      __RevisitRate = 0.f;
+      __Priority = 0;
+      __Required = true;
+
+   }
+     
+   Task::Task(const Task &that) : avtas::lmcp::Object(that)
+   {
+        __TaskID = that.__TaskID;
+        __Label = that.__Label;
+        __EligibleEntities.clear();
+        for (size_t i=0; i< that.__EligibleEntities.size(); i++)
+        {
+           __EligibleEntities.push_back( that.__EligibleEntities[i]);
+        }
+        __RevisitRate = that.__RevisitRate;
+        __Parameters.clear();
+        for (size_t i=0; i< that.__Parameters.size(); i++)
+        {
+           __Parameters.push_back( that.__Parameters[i] == nullptr ? nullptr : that.__Parameters[i]->clone());
+        }
+        __Priority = that.__Priority;
+        __Required = that.__Required;
+
+   }
+   
+   Task & Task::operator=(const Task &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Parameters.size(); i++)
+         {
+            if (__Parameters[i] != nullptr) delete __Parameters[i];
+         }
+
+         __TaskID = that.__TaskID;
+         __Label = that.__Label;
+         __EligibleEntities.clear();
+         for (size_t i=0; i< that.__EligibleEntities.size(); i++)
+         {
+            __EligibleEntities.push_back( that.__EligibleEntities[i]);
+         }
+         __RevisitRate = that.__RevisitRate;
+         __Parameters.clear();
+         for (size_t i=0; i< that.__Parameters.size(); i++)
+         {
+            __Parameters.push_back( that.__Parameters[i] == nullptr ? nullptr : that.__Parameters[i]->clone());
+         }
+         __Priority = that.__Priority;
+         __Required = that.__Required;
+
+      }
+      return *this;
+   }
+
+   Task* Task::clone() const
+   {
+        return new Task(*this);
+   }
+   
+   Task::~Task(void)
+   {
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if (__Parameters[i] != nullptr) delete __Parameters[i];
+      }
+
+   }
+  
+   void Task::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__TaskID);
+      buf.putString(__Label);
+      buf.putUShort( static_cast<uint16_t>(__EligibleEntities.size()));
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         buf.putLong(__EligibleEntities[i]);
+      }
+      buf.putFloat(__RevisitRate);
+      buf.putUShort( static_cast<uint16_t>(__Parameters.size()));
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Parameters[i], buf);
+      }
+      buf.putByte(__Priority);
+      buf.putBool(__Required);
+
+   }
+   
+   void Task::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __TaskID = buf.getLong();
+      __Label = buf.getString();
+      __EligibleEntities.clear();
+      uint16_t __EligibleEntities_length = buf.getUShort();
+      for (uint32_t i=0; i< __EligibleEntities_length; i++)
+      {
+         __EligibleEntities.push_back(buf.getLong() );
+      }
+      __RevisitRate = buf.getFloat();
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if (__Parameters[i] != nullptr)
+            delete __Parameters[i];
+      }
+      __Parameters.clear();
+      uint16_t __Parameters_length = buf.getUShort();
+      for (uint32_t i=0; i< __Parameters_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::KeyValuePair* e = (afrl::cmasi::KeyValuePair*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Parameters.push_back(e);
+         }
+      }
+      __Priority = buf.getByte();
+      __Required = buf.getBool();
+
+   }
+
+   uint32_t Task::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2 + __Label.length();
+      size += 2 + sizeof(int64_t) * __EligibleEntities.size();
+      size += sizeof(float);
+      size += 2;
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if (__Parameters[i] != nullptr)
+         {
+            size += __Parameters[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(uint8_t);
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string Task::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( Task ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string Task::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<Task Series=\"CMASI\">\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</Task>\n";
+
+      return str.str();
+   }
+
+   bool Task::operator==(const Task & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__TaskID != that.__TaskID) return false;
+      if(__Label != that.__Label) return false;
+      if(__EligibleEntities.size() != that.__EligibleEntities.size()) return false;
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         if(__EligibleEntities[i] != that.__EligibleEntities[i]) return false;
+      }
+      if(__RevisitRate != that.__RevisitRate) return false;
+      if(__Parameters.size() != that.__Parameters.size()) return false;
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         if(__Parameters[i] && that.__Parameters[i])
+         {
+            if(__Parameters[i]->getSeriesNameAsLong() != that.__Parameters[i]->getSeriesNameAsLong()) return false;
+            if(__Parameters[i]->getSeriesVersion() != that.__Parameters[i]->getSeriesVersion()) return false;
+            if(__Parameters[i]->getLmcpType() != that.__Parameters[i]->getLmcpType()) return false;
+            if( *(__Parameters[i]) != *(that.__Parameters[i]) ) return false;
+         }
+         else if(__Parameters[i] != that.__Parameters[i]) return false;
+      }
+      if(__Priority != that.__Priority) return false;
+      if(__Required != that.__Required) return false;
+      return true;
+
+   }
+
+   bool Task::operator!=(const Task & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   Task& Task::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+   Task& Task::setLabel(const std::string val)
+   {
+      __Label = val;
+      return *this;
+   }
+
+
+   Task& Task::setRevisitRate(const float val)
+   {
+      __RevisitRate = val;
+      return *this;
+   }
+
+
+   Task& Task::setPriority(const uint8_t val)
+   {
+      __Priority = val;
+      return *this;
+   }
+
+   Task& Task::setRequired(const bool val)
+   {
+      __Required = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiVehicleAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiVehicleAction.cpp
new file mode 100644
index 0000000..7850a3c
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiVehicleAction.cpp
@@ -0,0 +1,196 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/VehicleAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string VehicleAction::Subscription = "afrl.cmasi.VehicleAction";
+   const std::string VehicleAction::TypeName = "VehicleAction";
+   
+   bool isVehicleAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 7) return false;
+      return true;
+   }
+   
+   bool isVehicleAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 7) return false;
+      return true;
+   }
+   
+   std::vector< std::string > VehicleActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.PayloadAction");
+       descendants.push_back("afrl.cmasi.CameraAction");
+       descendants.push_back("afrl.cmasi.GimbalAngleAction");
+       descendants.push_back("afrl.cmasi.GimbalScanAction");
+       descendants.push_back("afrl.cmasi.GimbalStareAction");
+       descendants.push_back("afrl.cmasi.NavigationAction");
+       descendants.push_back("afrl.cmasi.GoToWaypointAction");
+       descendants.push_back("afrl.cmasi.LoiterAction");
+       descendants.push_back("afrl.cmasi.FlightDirectorAction");
+       descendants.push_back("afrl.cmasi.VideoStreamAction");
+       descendants.push_back("afrl.cmasi.StopMovementAction");
+       descendants.push_back("afrl.impact.DeployImpactPayload");
+       descendants.push_back("afrl.cmasi.perceive.TrackEntityAction");
+
+       return descendants;
+   }
+   
+   VehicleAction::VehicleAction(void) : avtas::lmcp::Object()
+   {
+
+   }
+     
+   VehicleAction::VehicleAction(const VehicleAction &that) : avtas::lmcp::Object(that)
+   {
+        __AssociatedTaskList.clear();
+        for (size_t i=0; i< that.__AssociatedTaskList.size(); i++)
+        {
+           __AssociatedTaskList.push_back( that.__AssociatedTaskList[i]);
+        }
+
+   }
+   
+   VehicleAction & VehicleAction::operator=(const VehicleAction &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __AssociatedTaskList.clear();
+         for (size_t i=0; i< that.__AssociatedTaskList.size(); i++)
+         {
+            __AssociatedTaskList.push_back( that.__AssociatedTaskList[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   VehicleAction* VehicleAction::clone() const
+   {
+        return new VehicleAction(*this);
+   }
+   
+   VehicleAction::~VehicleAction(void)
+   {
+
+   }
+  
+   void VehicleAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__AssociatedTaskList.size()));
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         buf.putLong(__AssociatedTaskList[i]);
+      }
+
+   }
+   
+   void VehicleAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __AssociatedTaskList.clear();
+      uint16_t __AssociatedTaskList_length = buf.getUShort();
+      for (uint32_t i=0; i< __AssociatedTaskList_length; i++)
+      {
+         __AssociatedTaskList.push_back(buf.getLong() );
+      }
+
+   }
+
+   uint32_t VehicleAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2 + sizeof(int64_t) * __AssociatedTaskList.size();
+
+      return size;
+   }
+
+   std::string VehicleAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( VehicleAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string VehicleAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<VehicleAction Series=\"CMASI\">\n";
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</VehicleAction>\n";
+
+      return str.str();
+   }
+
+   bool VehicleAction::operator==(const VehicleAction & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__AssociatedTaskList.size() != that.__AssociatedTaskList.size()) return false;
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         if(__AssociatedTaskList[i] != that.__AssociatedTaskList[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool VehicleAction::operator!=(const VehicleAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiVehicleActionCommand.cpp b/src/LMCP/afrl/cmasi/afrlcmasiVehicleActionCommand.cpp
new file mode 100644
index 0000000..5abb0b1
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiVehicleActionCommand.cpp
@@ -0,0 +1,277 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/VehicleActionCommand.h"
+#include "afrl/cmasi/PayloadAction.h"
+#include "afrl/cmasi/CameraAction.h"
+#include "afrl/cmasi/GimbalAngleAction.h"
+#include "afrl/cmasi/GimbalScanAction.h"
+#include "afrl/cmasi/GimbalStareAction.h"
+#include "afrl/cmasi/NavigationAction.h"
+#include "afrl/cmasi/GoToWaypointAction.h"
+#include "afrl/cmasi/LoiterAction.h"
+#include "afrl/cmasi/FlightDirectorAction.h"
+#include "afrl/cmasi/VideoStreamAction.h"
+#include "afrl/cmasi/StopMovementAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string VehicleActionCommand::Subscription = "afrl.cmasi.VehicleActionCommand";
+   const std::string VehicleActionCommand::TypeName = "VehicleActionCommand";
+   
+   bool isVehicleActionCommand(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 47) return false;
+      return true;
+   }
+   
+   bool isVehicleActionCommand(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 47) return false;
+      return true;
+   }
+   
+   std::vector< std::string > VehicleActionCommandDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.MissionCommand");
+       descendants.push_back("afrl.cmasi.FollowPathCommand");
+
+       return descendants;
+   }
+   
+   VehicleActionCommand::VehicleActionCommand(void) : avtas::lmcp::Object()
+   {
+      __CommandID = 0LL;
+      __VehicleID = 0LL;
+      __Status = afrl::cmasi::CommandStatusType::Pending;
+
+   }
+     
+   VehicleActionCommand::VehicleActionCommand(const VehicleActionCommand &that) : avtas::lmcp::Object(that)
+   {
+        __CommandID = that.__CommandID;
+        __VehicleID = that.__VehicleID;
+        __VehicleActionList.clear();
+        for (size_t i=0; i< that.__VehicleActionList.size(); i++)
+        {
+           __VehicleActionList.push_back( that.__VehicleActionList[i] == nullptr ? nullptr : that.__VehicleActionList[i]->clone());
+        }
+        __Status = that.__Status;
+
+   }
+   
+   VehicleActionCommand & VehicleActionCommand::operator=(const VehicleActionCommand &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__VehicleActionList.size(); i++)
+         {
+            if (__VehicleActionList[i] != nullptr) delete __VehicleActionList[i];
+         }
+
+         __CommandID = that.__CommandID;
+         __VehicleID = that.__VehicleID;
+         __VehicleActionList.clear();
+         for (size_t i=0; i< that.__VehicleActionList.size(); i++)
+         {
+            __VehicleActionList.push_back( that.__VehicleActionList[i] == nullptr ? nullptr : that.__VehicleActionList[i]->clone());
+         }
+         __Status = that.__Status;
+
+      }
+      return *this;
+   }
+
+   VehicleActionCommand* VehicleActionCommand::clone() const
+   {
+        return new VehicleActionCommand(*this);
+   }
+   
+   VehicleActionCommand::~VehicleActionCommand(void)
+   {
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         if (__VehicleActionList[i] != nullptr) delete __VehicleActionList[i];
+      }
+
+   }
+  
+   void VehicleActionCommand::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__CommandID);
+      buf.putLong(__VehicleID);
+      buf.putUShort( static_cast<uint16_t>(__VehicleActionList.size()));
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __VehicleActionList[i], buf);
+      }
+      buf.putInt( (int32_t) __Status);
+
+   }
+   
+   void VehicleActionCommand::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __CommandID = buf.getLong();
+      __VehicleID = buf.getLong();
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         if (__VehicleActionList[i] != nullptr)
+            delete __VehicleActionList[i];
+      }
+      __VehicleActionList.clear();
+      uint16_t __VehicleActionList_length = buf.getUShort();
+      for (uint32_t i=0; i< __VehicleActionList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::VehicleAction* e = (afrl::cmasi::VehicleAction*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __VehicleActionList.push_back(e);
+         }
+      }
+      __Status = (afrl::cmasi::CommandStatusType::CommandStatusType) buf.getInt();
+
+   }
+
+   uint32_t VehicleActionCommand::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         if (__VehicleActionList[i] != nullptr)
+         {
+            size += __VehicleActionList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(afrl::cmasi::CommandStatusType::CommandStatusType);
+
+      return size;
+   }
+
+   std::string VehicleActionCommand::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( VehicleActionCommand ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "CommandID (int64_t) = " << __CommandID << "\n";
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "VehicleActionList (VehicleAction [ " << __VehicleActionList.size() << ", var ])\n";
+      oss << indent << "Status (CommandStatusType) = " << __Status << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string VehicleActionCommand::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<VehicleActionCommand Series=\"CMASI\">\n";
+      str << ws << "   <CommandID>" << __CommandID << "</CommandID>\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <VehicleActionList>\n";
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         str << (__VehicleActionList[i] == nullptr ? ( ws + "   <null/>\n") : (__VehicleActionList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </VehicleActionList>\n";
+      str << ws << "   <Status>" << afrl::cmasi::CommandStatusType::get_string(__Status) << "</Status>\n";
+      str << ws << "</VehicleActionCommand>\n";
+
+      return str.str();
+   }
+
+   bool VehicleActionCommand::operator==(const VehicleActionCommand & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__CommandID != that.__CommandID) return false;
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__VehicleActionList.size() != that.__VehicleActionList.size()) return false;
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         if(__VehicleActionList[i] && that.__VehicleActionList[i])
+         {
+            if(__VehicleActionList[i]->getSeriesNameAsLong() != that.__VehicleActionList[i]->getSeriesNameAsLong()) return false;
+            if(__VehicleActionList[i]->getSeriesVersion() != that.__VehicleActionList[i]->getSeriesVersion()) return false;
+            if(__VehicleActionList[i]->getLmcpType() != that.__VehicleActionList[i]->getLmcpType()) return false;
+            if( *(__VehicleActionList[i]) != *(that.__VehicleActionList[i]) ) return false;
+         }
+         else if(__VehicleActionList[i] != that.__VehicleActionList[i]) return false;
+      }
+      if(__Status != that.__Status) return false;
+      return true;
+
+   }
+
+   bool VehicleActionCommand::operator!=(const VehicleActionCommand & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   VehicleActionCommand& VehicleActionCommand::setCommandID(const int64_t val)
+   {
+      __CommandID = val;
+      return *this;
+   }
+
+   VehicleActionCommand& VehicleActionCommand::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+
+   VehicleActionCommand& VehicleActionCommand::setStatus(const afrl::cmasi::CommandStatusType::CommandStatusType val)
+   {
+      __Status = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiVideoStreamAction.cpp b/src/LMCP/afrl/cmasi/afrlcmasiVideoStreamAction.cpp
new file mode 100644
index 0000000..9609723
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiVideoStreamAction.cpp
@@ -0,0 +1,186 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/VideoStreamAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string VideoStreamAction::Subscription = "afrl.cmasi.VideoStreamAction";
+   const std::string VideoStreamAction::TypeName = "VideoStreamAction";
+   
+   bool isVideoStreamAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 48) return false;
+      return true;
+   }
+   
+   bool isVideoStreamAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 48) return false;
+      return true;
+   }
+   
+   std::vector< std::string > VideoStreamActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   VideoStreamAction::VideoStreamAction(void) : afrl::cmasi::VehicleAction()
+   {
+      __VideoStreamID = 0;
+      __ActiveSensor = 0;
+
+   }
+     
+   VideoStreamAction::VideoStreamAction(const VideoStreamAction &that) : afrl::cmasi::VehicleAction(that)
+   {
+        __VideoStreamID = that.__VideoStreamID;
+        __ActiveSensor = that.__ActiveSensor;
+
+   }
+   
+   VideoStreamAction & VideoStreamAction::operator=(const VideoStreamAction &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::VehicleAction::operator=(that);
+
+         __VideoStreamID = that.__VideoStreamID;
+         __ActiveSensor = that.__ActiveSensor;
+
+      }
+      return *this;
+   }
+
+   VideoStreamAction* VideoStreamAction::clone() const
+   {
+        return new VideoStreamAction(*this);
+   }
+   
+   VideoStreamAction::~VideoStreamAction(void)
+   {
+
+   }
+  
+   void VideoStreamAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::VehicleAction::pack(buf);
+      // Copy the class into the buffer
+      buf.putInt(__VideoStreamID);
+      buf.putInt(__ActiveSensor);
+
+   }
+   
+   void VideoStreamAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::VehicleAction::unpack(buf);
+      // Copy the buffer into the class
+      __VideoStreamID = buf.getInt();
+      __ActiveSensor = buf.getInt();
+
+   }
+
+   uint32_t VideoStreamAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::VehicleAction::calculatePackedSize();
+      size += sizeof(int32_t);
+      size += sizeof(int32_t);
+
+      return size;
+   }
+
+   std::string VideoStreamAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( VideoStreamAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+      oss << indent << "VideoStreamID (int32_t) = " << __VideoStreamID << "\n";
+      oss << indent << "ActiveSensor (int32_t) = " << __ActiveSensor << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string VideoStreamAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<VideoStreamAction Series=\"CMASI\">\n";
+      str << ws << "   <VideoStreamID>" << __VideoStreamID << "</VideoStreamID>\n";
+      str << ws << "   <ActiveSensor>" << __ActiveSensor << "</ActiveSensor>\n";
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</VideoStreamAction>\n";
+
+      return str.str();
+   }
+
+   bool VideoStreamAction::operator==(const VideoStreamAction & that)
+   {
+      if( afrl::cmasi::VehicleAction::operator!=(that) )
+      {
+          return false;
+      }
+      if(__VideoStreamID != that.__VideoStreamID) return false;
+      if(__ActiveSensor != that.__ActiveSensor) return false;
+      return true;
+
+   }
+
+   bool VideoStreamAction::operator!=(const VideoStreamAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   VideoStreamAction& VideoStreamAction::setVideoStreamID(const int32_t val)
+   {
+      __VideoStreamID = val;
+      return *this;
+   }
+
+   VideoStreamAction& VideoStreamAction::setActiveSensor(const int32_t val)
+   {
+      __ActiveSensor = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiVideoStreamConfiguration.cpp b/src/LMCP/afrl/cmasi/afrlcmasiVideoStreamConfiguration.cpp
new file mode 100644
index 0000000..7090942
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiVideoStreamConfiguration.cpp
@@ -0,0 +1,195 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/VideoStreamConfiguration.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string VideoStreamConfiguration::Subscription = "afrl.cmasi.VideoStreamConfiguration";
+   const std::string VideoStreamConfiguration::TypeName = "VideoStreamConfiguration";
+   
+   bool isVideoStreamConfiguration(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 49) return false;
+      return true;
+   }
+   
+   bool isVideoStreamConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 49) return false;
+      return true;
+   }
+   
+   std::vector< std::string > VideoStreamConfigurationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   VideoStreamConfiguration::VideoStreamConfiguration(void) : afrl::cmasi::PayloadConfiguration()
+   {
+
+   }
+     
+   VideoStreamConfiguration::VideoStreamConfiguration(const VideoStreamConfiguration &that) : afrl::cmasi::PayloadConfiguration(that)
+   {
+        __AvailableSensorList.clear();
+        for (size_t i=0; i< that.__AvailableSensorList.size(); i++)
+        {
+           __AvailableSensorList.push_back( that.__AvailableSensorList[i]);
+        }
+
+   }
+   
+   VideoStreamConfiguration & VideoStreamConfiguration::operator=(const VideoStreamConfiguration &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadConfiguration::operator=(that);
+
+         __AvailableSensorList.clear();
+         for (size_t i=0; i< that.__AvailableSensorList.size(); i++)
+         {
+            __AvailableSensorList.push_back( that.__AvailableSensorList[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   VideoStreamConfiguration* VideoStreamConfiguration::clone() const
+   {
+        return new VideoStreamConfiguration(*this);
+   }
+   
+   VideoStreamConfiguration::~VideoStreamConfiguration(void)
+   {
+
+   }
+  
+   void VideoStreamConfiguration::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadConfiguration::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__AvailableSensorList.size()));
+      for (size_t i=0; i<__AvailableSensorList.size(); i++)
+      {
+         buf.putLong(__AvailableSensorList[i]);
+      }
+
+   }
+   
+   void VideoStreamConfiguration::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadConfiguration::unpack(buf);
+      // Copy the buffer into the class
+      __AvailableSensorList.clear();
+      uint16_t __AvailableSensorList_length = buf.getUShort();
+      for (uint32_t i=0; i< __AvailableSensorList_length; i++)
+      {
+         __AvailableSensorList.push_back(buf.getLong() );
+      }
+
+   }
+
+   uint32_t VideoStreamConfiguration::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadConfiguration::calculatePackedSize();
+      size += 2 + sizeof(int64_t) * __AvailableSensorList.size();
+
+      return size;
+   }
+
+   std::string VideoStreamConfiguration::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( VideoStreamConfiguration ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "PayloadKind (std::string) = " << __PayloadKind << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      oss << indent << "AvailableSensorList (int64 [ " << __AvailableSensorList.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string VideoStreamConfiguration::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<VideoStreamConfiguration Series=\"CMASI\">\n";
+      str << ws << "   <AvailableSensorList>\n";
+      for (size_t i=0; i<__AvailableSensorList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AvailableSensorList[i] << "</int64>\n";
+      }
+      str << ws << "   </AvailableSensorList>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <PayloadKind>" << __PayloadKind << "</PayloadKind>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</VideoStreamConfiguration>\n";
+
+      return str.str();
+   }
+
+   bool VideoStreamConfiguration::operator==(const VideoStreamConfiguration & that)
+   {
+      if( afrl::cmasi::PayloadConfiguration::operator!=(that) )
+      {
+          return false;
+      }
+      if(__AvailableSensorList.size() != that.__AvailableSensorList.size()) return false;
+      for (size_t i=0; i<__AvailableSensorList.size(); i++)
+      {
+         if(__AvailableSensorList[i] != that.__AvailableSensorList[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool VideoStreamConfiguration::operator!=(const VideoStreamConfiguration & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiVideoStreamState.cpp b/src/LMCP/afrl/cmasi/afrlcmasiVideoStreamState.cpp
new file mode 100644
index 0000000..2aa5404
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiVideoStreamState.cpp
@@ -0,0 +1,173 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/VideoStreamState.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string VideoStreamState::Subscription = "afrl.cmasi.VideoStreamState";
+   const std::string VideoStreamState::TypeName = "VideoStreamState";
+   
+   bool isVideoStreamState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 50) return false;
+      return true;
+   }
+   
+   bool isVideoStreamState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 50) return false;
+      return true;
+   }
+   
+   std::vector< std::string > VideoStreamStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   VideoStreamState::VideoStreamState(void) : afrl::cmasi::PayloadState()
+   {
+      __ActiveSensor = 0LL;
+
+   }
+     
+   VideoStreamState::VideoStreamState(const VideoStreamState &that) : afrl::cmasi::PayloadState(that)
+   {
+        __ActiveSensor = that.__ActiveSensor;
+
+   }
+   
+   VideoStreamState & VideoStreamState::operator=(const VideoStreamState &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadState::operator=(that);
+
+         __ActiveSensor = that.__ActiveSensor;
+
+      }
+      return *this;
+   }
+
+   VideoStreamState* VideoStreamState::clone() const
+   {
+        return new VideoStreamState(*this);
+   }
+   
+   VideoStreamState::~VideoStreamState(void)
+   {
+
+   }
+  
+   void VideoStreamState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadState::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ActiveSensor);
+
+   }
+   
+   void VideoStreamState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadState::unpack(buf);
+      // Copy the buffer into the class
+      __ActiveSensor = buf.getLong();
+
+   }
+
+   uint32_t VideoStreamState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadState::calculatePackedSize();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string VideoStreamState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( VideoStreamState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      oss << indent << "ActiveSensor (int64_t) = " << __ActiveSensor << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string VideoStreamState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<VideoStreamState Series=\"CMASI\">\n";
+      str << ws << "   <ActiveSensor>" << __ActiveSensor << "</ActiveSensor>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</VideoStreamState>\n";
+
+      return str.str();
+   }
+
+   bool VideoStreamState::operator==(const VideoStreamState & that)
+   {
+      if( afrl::cmasi::PayloadState::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ActiveSensor != that.__ActiveSensor) return false;
+      return true;
+
+   }
+
+   bool VideoStreamState::operator!=(const VideoStreamState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   VideoStreamState& VideoStreamState::setActiveSensor(const int64_t val)
+   {
+      __ActiveSensor = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiWaypoint.cpp b/src/LMCP/afrl/cmasi/afrlcmasiWaypoint.cpp
new file mode 100644
index 0000000..0daf5d7
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiWaypoint.cpp
@@ -0,0 +1,395 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PayloadAction.h"
+#include "afrl/cmasi/CameraAction.h"
+#include "afrl/cmasi/GimbalAngleAction.h"
+#include "afrl/cmasi/GimbalScanAction.h"
+#include "afrl/cmasi/GimbalStareAction.h"
+#include "afrl/cmasi/NavigationAction.h"
+#include "afrl/cmasi/GoToWaypointAction.h"
+#include "afrl/cmasi/LoiterAction.h"
+#include "afrl/cmasi/FlightDirectorAction.h"
+#include "afrl/cmasi/VideoStreamAction.h"
+#include "afrl/cmasi/StopMovementAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string Waypoint::Subscription = "afrl.cmasi.Waypoint";
+   const std::string Waypoint::TypeName = "Waypoint";
+   
+   bool isWaypoint(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 35) return false;
+      return true;
+   }
+   
+   bool isWaypoint(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 35) return false;
+      return true;
+   }
+   
+   std::vector< std::string > WaypointDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("afrl.cmasi.PathWaypoint");
+
+       return descendants;
+   }
+   
+   Waypoint::Waypoint(void) : afrl::cmasi::Location3D()
+   {
+      __Number = 0LL;
+      __NextWaypoint = 0LL;
+      __Speed = 0.f;
+      __SpeedType = afrl::cmasi::SpeedType::Airspeed;
+      __ClimbRate = 0.f;
+      __TurnType = afrl::cmasi::TurnType::TurnShort;
+      __ContingencyWaypointA = 0LL;
+      __ContingencyWaypointB = 0LL;
+
+   }
+     
+   Waypoint::Waypoint(const Waypoint &that) : afrl::cmasi::Location3D(that)
+   {
+        __Number = that.__Number;
+        __NextWaypoint = that.__NextWaypoint;
+        __Speed = that.__Speed;
+        __SpeedType = that.__SpeedType;
+        __ClimbRate = that.__ClimbRate;
+        __TurnType = that.__TurnType;
+        __VehicleActionList.clear();
+        for (size_t i=0; i< that.__VehicleActionList.size(); i++)
+        {
+           __VehicleActionList.push_back( that.__VehicleActionList[i] == nullptr ? nullptr : that.__VehicleActionList[i]->clone());
+        }
+        __ContingencyWaypointA = that.__ContingencyWaypointA;
+        __ContingencyWaypointB = that.__ContingencyWaypointB;
+        __AssociatedTasks.clear();
+        for (size_t i=0; i< that.__AssociatedTasks.size(); i++)
+        {
+           __AssociatedTasks.push_back( that.__AssociatedTasks[i]);
+        }
+
+   }
+   
+   Waypoint & Waypoint::operator=(const Waypoint &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::Location3D::operator=(that);
+         for (size_t i=0; i<__VehicleActionList.size(); i++)
+         {
+            if (__VehicleActionList[i] != nullptr) delete __VehicleActionList[i];
+         }
+
+         __Number = that.__Number;
+         __NextWaypoint = that.__NextWaypoint;
+         __Speed = that.__Speed;
+         __SpeedType = that.__SpeedType;
+         __ClimbRate = that.__ClimbRate;
+         __TurnType = that.__TurnType;
+         __VehicleActionList.clear();
+         for (size_t i=0; i< that.__VehicleActionList.size(); i++)
+         {
+            __VehicleActionList.push_back( that.__VehicleActionList[i] == nullptr ? nullptr : that.__VehicleActionList[i]->clone());
+         }
+         __ContingencyWaypointA = that.__ContingencyWaypointA;
+         __ContingencyWaypointB = that.__ContingencyWaypointB;
+         __AssociatedTasks.clear();
+         for (size_t i=0; i< that.__AssociatedTasks.size(); i++)
+         {
+            __AssociatedTasks.push_back( that.__AssociatedTasks[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   Waypoint* Waypoint::clone() const
+   {
+        return new Waypoint(*this);
+   }
+   
+   Waypoint::~Waypoint(void)
+   {
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         if (__VehicleActionList[i] != nullptr) delete __VehicleActionList[i];
+      }
+
+   }
+  
+   void Waypoint::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::Location3D::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__Number);
+      buf.putLong(__NextWaypoint);
+      buf.putFloat(__Speed);
+      buf.putInt( (int32_t) __SpeedType);
+      buf.putFloat(__ClimbRate);
+      buf.putInt( (int32_t) __TurnType);
+      buf.putUShort( static_cast<uint16_t>(__VehicleActionList.size()));
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __VehicleActionList[i], buf);
+      }
+      buf.putLong(__ContingencyWaypointA);
+      buf.putLong(__ContingencyWaypointB);
+      buf.putUShort( static_cast<uint16_t>(__AssociatedTasks.size()));
+      for (size_t i=0; i<__AssociatedTasks.size(); i++)
+      {
+         buf.putLong(__AssociatedTasks[i]);
+      }
+
+   }
+   
+   void Waypoint::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::Location3D::unpack(buf);
+      // Copy the buffer into the class
+      __Number = buf.getLong();
+      __NextWaypoint = buf.getLong();
+      __Speed = buf.getFloat();
+      __SpeedType = (afrl::cmasi::SpeedType::SpeedType) buf.getInt();
+      __ClimbRate = buf.getFloat();
+      __TurnType = (afrl::cmasi::TurnType::TurnType) buf.getInt();
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         if (__VehicleActionList[i] != nullptr)
+            delete __VehicleActionList[i];
+      }
+      __VehicleActionList.clear();
+      uint16_t __VehicleActionList_length = buf.getUShort();
+      for (uint32_t i=0; i< __VehicleActionList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::VehicleAction* e = (afrl::cmasi::VehicleAction*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __VehicleActionList.push_back(e);
+         }
+      }
+      __ContingencyWaypointA = buf.getLong();
+      __ContingencyWaypointB = buf.getLong();
+      __AssociatedTasks.clear();
+      uint16_t __AssociatedTasks_length = buf.getUShort();
+      for (uint32_t i=0; i< __AssociatedTasks_length; i++)
+      {
+         __AssociatedTasks.push_back(buf.getLong() );
+      }
+
+   }
+
+   uint32_t Waypoint::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::Location3D::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::SpeedType::SpeedType);
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::TurnType::TurnType);
+      size += 2;
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         if (__VehicleActionList[i] != nullptr)
+         {
+            size += __VehicleActionList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += 2 + sizeof(int64_t) * __AssociatedTasks.size();
+
+      return size;
+   }
+
+   std::string Waypoint::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( Waypoint ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "Latitude (double) = " << __Latitude << "\n";
+      oss << indent << "Longitude (double) = " << __Longitude << "\n";
+      oss << indent << "Altitude (float) = " << __Altitude << "\n";
+      oss << indent << "AltitudeType (AltitudeType) = " << __AltitudeType << "\n";
+
+      oss << indent << "Number (int64_t) = " << __Number << "\n";
+      oss << indent << "NextWaypoint (int64_t) = " << __NextWaypoint << "\n";
+      oss << indent << "Speed (float) = " << __Speed << "\n";
+      oss << indent << "SpeedType (SpeedType) = " << __SpeedType << "\n";
+      oss << indent << "ClimbRate (float) = " << __ClimbRate << "\n";
+      oss << indent << "TurnType (TurnType) = " << __TurnType << "\n";
+      oss << indent << "VehicleActionList (VehicleAction [ " << __VehicleActionList.size() << ", var ])\n";
+      oss << indent << "ContingencyWaypointA (int64_t) = " << __ContingencyWaypointA << "\n";
+      oss << indent << "ContingencyWaypointB (int64_t) = " << __ContingencyWaypointB << "\n";
+      oss << indent << "AssociatedTasks (int64 [ " << __AssociatedTasks.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string Waypoint::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<Waypoint Series=\"CMASI\">\n";
+      str << ws << "   <Number>" << __Number << "</Number>\n";
+      str << ws << "   <NextWaypoint>" << __NextWaypoint << "</NextWaypoint>\n";
+      str << ws << "   <Speed>" << __Speed << "</Speed>\n";
+      str << ws << "   <SpeedType>" << afrl::cmasi::SpeedType::get_string(__SpeedType) << "</SpeedType>\n";
+      str << ws << "   <ClimbRate>" << __ClimbRate << "</ClimbRate>\n";
+      str << ws << "   <TurnType>" << afrl::cmasi::TurnType::get_string(__TurnType) << "</TurnType>\n";
+      str << ws << "   <VehicleActionList>\n";
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         str << (__VehicleActionList[i] == nullptr ? ( ws + "   <null/>\n") : (__VehicleActionList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </VehicleActionList>\n";
+      str << ws << "   <ContingencyWaypointA>" << __ContingencyWaypointA << "</ContingencyWaypointA>\n";
+      str << ws << "   <ContingencyWaypointB>" << __ContingencyWaypointB << "</ContingencyWaypointB>\n";
+      str << ws << "   <AssociatedTasks>\n";
+      for (size_t i=0; i<__AssociatedTasks.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTasks[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTasks>\n";
+      str << ws << "   <Latitude>" << __Latitude << "</Latitude>\n";
+      str << ws << "   <Longitude>" << __Longitude << "</Longitude>\n";
+      str << ws << "   <Altitude>" << __Altitude << "</Altitude>\n";
+      str << ws << "   <AltitudeType>" << afrl::cmasi::AltitudeType::get_string(__AltitudeType) << "</AltitudeType>\n";
+      str << ws << "</Waypoint>\n";
+
+      return str.str();
+   }
+
+   bool Waypoint::operator==(const Waypoint & that)
+   {
+      if( afrl::cmasi::Location3D::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Number != that.__Number) return false;
+      if(__NextWaypoint != that.__NextWaypoint) return false;
+      if(__Speed != that.__Speed) return false;
+      if(__SpeedType != that.__SpeedType) return false;
+      if(__ClimbRate != that.__ClimbRate) return false;
+      if(__TurnType != that.__TurnType) return false;
+      if(__VehicleActionList.size() != that.__VehicleActionList.size()) return false;
+      for (size_t i=0; i<__VehicleActionList.size(); i++)
+      {
+         if(__VehicleActionList[i] && that.__VehicleActionList[i])
+         {
+            if(__VehicleActionList[i]->getSeriesNameAsLong() != that.__VehicleActionList[i]->getSeriesNameAsLong()) return false;
+            if(__VehicleActionList[i]->getSeriesVersion() != that.__VehicleActionList[i]->getSeriesVersion()) return false;
+            if(__VehicleActionList[i]->getLmcpType() != that.__VehicleActionList[i]->getLmcpType()) return false;
+            if( *(__VehicleActionList[i]) != *(that.__VehicleActionList[i]) ) return false;
+         }
+         else if(__VehicleActionList[i] != that.__VehicleActionList[i]) return false;
+      }
+      if(__ContingencyWaypointA != that.__ContingencyWaypointA) return false;
+      if(__ContingencyWaypointB != that.__ContingencyWaypointB) return false;
+      if(__AssociatedTasks.size() != that.__AssociatedTasks.size()) return false;
+      for (size_t i=0; i<__AssociatedTasks.size(); i++)
+      {
+         if(__AssociatedTasks[i] != that.__AssociatedTasks[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool Waypoint::operator!=(const Waypoint & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   Waypoint& Waypoint::setNumber(const int64_t val)
+   {
+      __Number = val;
+      return *this;
+   }
+
+   Waypoint& Waypoint::setNextWaypoint(const int64_t val)
+   {
+      __NextWaypoint = val;
+      return *this;
+   }
+
+   Waypoint& Waypoint::setSpeed(const float val)
+   {
+      __Speed = val;
+      return *this;
+   }
+
+   Waypoint& Waypoint::setSpeedType(const afrl::cmasi::SpeedType::SpeedType val)
+   {
+      __SpeedType = val;
+      return *this;
+   }
+
+   Waypoint& Waypoint::setClimbRate(const float val)
+   {
+      __ClimbRate = val;
+      return *this;
+   }
+
+   Waypoint& Waypoint::setTurnType(const afrl::cmasi::TurnType::TurnType val)
+   {
+      __TurnType = val;
+      return *this;
+   }
+
+
+   Waypoint& Waypoint::setContingencyWaypointA(const int64_t val)
+   {
+      __ContingencyWaypointA = val;
+      return *this;
+   }
+
+   Waypoint& Waypoint::setContingencyWaypointB(const int64_t val)
+   {
+      __ContingencyWaypointB = val;
+      return *this;
+   }
+
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiWaypointTransfer.cpp b/src/LMCP/afrl/cmasi/afrlcmasiWaypointTransfer.cpp
new file mode 100644
index 0000000..0b2c950
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiWaypointTransfer.cpp
@@ -0,0 +1,250 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/WaypointTransfer.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string WaypointTransfer::Subscription = "afrl.cmasi.WaypointTransfer";
+   const std::string WaypointTransfer::TypeName = "WaypointTransfer";
+   
+   bool isWaypointTransfer(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 59) return false;
+      return true;
+   }
+   
+   bool isWaypointTransfer(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 59) return false;
+      return true;
+   }
+   
+   std::vector< std::string > WaypointTransferDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   WaypointTransfer::WaypointTransfer(void) : avtas::lmcp::Object()
+   {
+      __EntityID = 0LL;
+      __TransferMode = afrl::cmasi::WaypointTransferMode::AddWaypoints;
+
+   }
+     
+   WaypointTransfer::WaypointTransfer(const WaypointTransfer &that) : avtas::lmcp::Object(that)
+   {
+        __EntityID = that.__EntityID;
+        __Waypoints.clear();
+        for (size_t i=0; i< that.__Waypoints.size(); i++)
+        {
+           __Waypoints.push_back( that.__Waypoints[i] == nullptr ? nullptr : that.__Waypoints[i]->clone());
+        }
+        __TransferMode = that.__TransferMode;
+
+   }
+   
+   WaypointTransfer & WaypointTransfer::operator=(const WaypointTransfer &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Waypoints.size(); i++)
+         {
+            if (__Waypoints[i] != nullptr) delete __Waypoints[i];
+         }
+
+         __EntityID = that.__EntityID;
+         __Waypoints.clear();
+         for (size_t i=0; i< that.__Waypoints.size(); i++)
+         {
+            __Waypoints.push_back( that.__Waypoints[i] == nullptr ? nullptr : that.__Waypoints[i]->clone());
+         }
+         __TransferMode = that.__TransferMode;
+
+      }
+      return *this;
+   }
+
+   WaypointTransfer* WaypointTransfer::clone() const
+   {
+        return new WaypointTransfer(*this);
+   }
+   
+   WaypointTransfer::~WaypointTransfer(void)
+   {
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         if (__Waypoints[i] != nullptr) delete __Waypoints[i];
+      }
+
+   }
+  
+   void WaypointTransfer::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__EntityID);
+      buf.putUShort( static_cast<uint16_t>(__Waypoints.size()));
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Waypoints[i], buf);
+      }
+      buf.putInt( (int32_t) __TransferMode);
+
+   }
+   
+   void WaypointTransfer::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __EntityID = buf.getLong();
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         if (__Waypoints[i] != nullptr)
+            delete __Waypoints[i];
+      }
+      __Waypoints.clear();
+      uint16_t __Waypoints_length = buf.getUShort();
+      for (uint32_t i=0; i< __Waypoints_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Waypoint* e = (afrl::cmasi::Waypoint*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Waypoints.push_back(e);
+         }
+      }
+      __TransferMode = (afrl::cmasi::WaypointTransferMode::WaypointTransferMode) buf.getInt();
+
+   }
+
+   uint32_t WaypointTransfer::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         if (__Waypoints[i] != nullptr)
+         {
+            size += __Waypoints[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(afrl::cmasi::WaypointTransferMode::WaypointTransferMode);
+
+      return size;
+   }
+
+   std::string WaypointTransfer::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( WaypointTransfer ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "EntityID (int64_t) = " << __EntityID << "\n";
+      oss << indent << "Waypoints (Waypoint [ " << __Waypoints.size() << ", var ])\n";
+      oss << indent << "TransferMode (WaypointTransferMode) = " << __TransferMode << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string WaypointTransfer::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<WaypointTransfer Series=\"CMASI\">\n";
+      str << ws << "   <EntityID>" << __EntityID << "</EntityID>\n";
+      str << ws << "   <Waypoints>\n";
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         str << (__Waypoints[i] == nullptr ? ( ws + "   <null/>\n") : (__Waypoints[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Waypoints>\n";
+      str << ws << "   <TransferMode>" << afrl::cmasi::WaypointTransferMode::get_string(__TransferMode) << "</TransferMode>\n";
+      str << ws << "</WaypointTransfer>\n";
+
+      return str.str();
+   }
+
+   bool WaypointTransfer::operator==(const WaypointTransfer & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__EntityID != that.__EntityID) return false;
+      if(__Waypoints.size() != that.__Waypoints.size()) return false;
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         if(__Waypoints[i] && that.__Waypoints[i])
+         {
+            if(__Waypoints[i]->getSeriesNameAsLong() != that.__Waypoints[i]->getSeriesNameAsLong()) return false;
+            if(__Waypoints[i]->getSeriesVersion() != that.__Waypoints[i]->getSeriesVersion()) return false;
+            if(__Waypoints[i]->getLmcpType() != that.__Waypoints[i]->getLmcpType()) return false;
+            if( *(__Waypoints[i]) != *(that.__Waypoints[i]) ) return false;
+         }
+         else if(__Waypoints[i] != that.__Waypoints[i]) return false;
+      }
+      if(__TransferMode != that.__TransferMode) return false;
+      return true;
+
+   }
+
+   bool WaypointTransfer::operator!=(const WaypointTransfer & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   WaypointTransfer& WaypointTransfer::setEntityID(const int64_t val)
+   {
+      __EntityID = val;
+      return *this;
+   }
+
+
+   WaypointTransfer& WaypointTransfer::setTransferMode(const afrl::cmasi::WaypointTransferMode::WaypointTransferMode val)
+   {
+      __TransferMode = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiWeatherReport.cpp b/src/LMCP/afrl/cmasi/afrlcmasiWeatherReport.cpp
new file mode 100644
index 0000000..71af89a
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiWeatherReport.cpp
@@ -0,0 +1,269 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/WeatherReport.h"
+#include "afrl/cmasi/KeepInZone.h"
+#include "afrl/cmasi/KeepOutZone.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string WeatherReport::Subscription = "afrl.cmasi.WeatherReport";
+   const std::string WeatherReport::TypeName = "WeatherReport";
+   
+   bool isWeatherReport(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 55) return false;
+      return true;
+   }
+   
+   bool isWeatherReport(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 55) return false;
+      return true;
+   }
+   
+   std::vector< std::string > WeatherReportDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   WeatherReport::WeatherReport(void) : avtas::lmcp::Object()
+   {
+      __Area = nullptr;
+      __WindSpeed = 0.f;
+      __WindDirection = 0.f;
+      __Visibility = 0.f;
+      __CloudCeiling = 0.f;
+      __CloudCoverage = 0.f;
+
+   }
+     
+   WeatherReport::WeatherReport(const WeatherReport &that) : avtas::lmcp::Object(that)
+   {
+        __Area = that.__Area == nullptr ? nullptr : that.__Area->clone();
+        __WindSpeed = that.__WindSpeed;
+        __WindDirection = that.__WindDirection;
+        __Visibility = that.__Visibility;
+        __CloudCeiling = that.__CloudCeiling;
+        __CloudCoverage = that.__CloudCoverage;
+
+   }
+   
+   WeatherReport & WeatherReport::operator=(const WeatherReport &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__Area != nullptr) delete __Area;
+
+         __Area = that.__Area == nullptr ? nullptr : that.__Area->clone();
+         __WindSpeed = that.__WindSpeed;
+         __WindDirection = that.__WindDirection;
+         __Visibility = that.__Visibility;
+         __CloudCeiling = that.__CloudCeiling;
+         __CloudCoverage = that.__CloudCoverage;
+
+      }
+      return *this;
+   }
+
+   WeatherReport* WeatherReport::clone() const
+   {
+        return new WeatherReport(*this);
+   }
+   
+   WeatherReport::~WeatherReport(void)
+   {
+      if (__Area != nullptr) delete __Area;
+
+   }
+  
+   void WeatherReport::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Area, buf);
+      buf.putFloat(__WindSpeed);
+      buf.putFloat(__WindDirection);
+      buf.putFloat(__Visibility);
+      buf.putFloat(__CloudCeiling);
+      buf.putFloat(__CloudCoverage);
+
+   }
+   
+   void WeatherReport::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__Area != nullptr) delete __Area;
+         __Area = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Area = (afrl::cmasi::AbstractZone*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Area != nullptr) __Area->unpack(buf);
+         }
+      }
+      __WindSpeed = buf.getFloat();
+      __WindDirection = buf.getFloat();
+      __Visibility = buf.getFloat();
+      __CloudCeiling = buf.getFloat();
+      __CloudCoverage = buf.getFloat();
+
+   }
+
+   uint32_t WeatherReport::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += (__Area != nullptr ? __Area->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string WeatherReport::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( WeatherReport ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "Area (AbstractZone)";
+      if (__Area == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "WindSpeed (float) = " << __WindSpeed << "\n";
+      oss << indent << "WindDirection (float) = " << __WindDirection << "\n";
+      oss << indent << "Visibility (float) = " << __Visibility << "\n";
+      oss << indent << "CloudCeiling (float) = " << __CloudCeiling << "\n";
+      oss << indent << "CloudCoverage (float) = " << __CloudCoverage << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string WeatherReport::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<WeatherReport Series=\"CMASI\">\n";
+      if (__Area != nullptr)
+      {
+         str << ws << "   <Area>";
+         str << "\n" + __Area->toXML(depth + 1) + ws + "   ";
+         str << "</Area>\n";
+      }
+      str << ws << "   <WindSpeed>" << __WindSpeed << "</WindSpeed>\n";
+      str << ws << "   <WindDirection>" << __WindDirection << "</WindDirection>\n";
+      str << ws << "   <Visibility>" << __Visibility << "</Visibility>\n";
+      str << ws << "   <CloudCeiling>" << __CloudCeiling << "</CloudCeiling>\n";
+      str << ws << "   <CloudCoverage>" << __CloudCoverage << "</CloudCoverage>\n";
+      str << ws << "</WeatherReport>\n";
+
+      return str.str();
+   }
+
+   bool WeatherReport::operator==(const WeatherReport & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Area && that.__Area)
+      {
+         if(__Area->getSeriesNameAsLong() != that.__Area->getSeriesNameAsLong()) return false;
+         if(__Area->getSeriesVersion() != that.__Area->getSeriesVersion()) return false;
+         if(__Area->getLmcpType() != that.__Area->getLmcpType()) return false;
+         if( *(__Area) != *(that.__Area) ) return false;
+      }
+      else if(__Area != that.__Area) return false;
+      if(__WindSpeed != that.__WindSpeed) return false;
+      if(__WindDirection != that.__WindDirection) return false;
+      if(__Visibility != that.__Visibility) return false;
+      if(__CloudCeiling != that.__CloudCeiling) return false;
+      if(__CloudCoverage != that.__CloudCoverage) return false;
+      return true;
+
+   }
+
+   bool WeatherReport::operator!=(const WeatherReport & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   WeatherReport& WeatherReport::setArea(const afrl::cmasi::AbstractZone* const val)
+   {
+      if (__Area != nullptr) { delete __Area; __Area = nullptr; }
+      if (val != nullptr) { __Area = const_cast< afrl::cmasi::AbstractZone* > (val); }
+      return *this;
+   }
+
+   WeatherReport& WeatherReport::setWindSpeed(const float val)
+   {
+      __WindSpeed = val;
+      return *this;
+   }
+
+   WeatherReport& WeatherReport::setWindDirection(const float val)
+   {
+      __WindDirection = val;
+      return *this;
+   }
+
+   WeatherReport& WeatherReport::setVisibility(const float val)
+   {
+      __Visibility = val;
+      return *this;
+   }
+
+   WeatherReport& WeatherReport::setCloudCeiling(const float val)
+   {
+      __CloudCeiling = val;
+      return *this;
+   }
+
+   WeatherReport& WeatherReport::setCloudCoverage(const float val)
+   {
+      __CloudCoverage = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/afrlcmasiWedge.cpp b/src/LMCP/afrl/cmasi/afrlcmasiWedge.cpp
new file mode 100644
index 0000000..90c876a
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/afrlcmasiWedge.cpp
@@ -0,0 +1,208 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/Wedge.h"
+
+
+namespace afrl {
+namespace cmasi {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string Wedge::Subscription = "afrl.cmasi.Wedge";
+   const std::string Wedge::TypeName = "Wedge";
+   
+   bool isWedge(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 16) return false;
+      return true;
+   }
+   
+   bool isWedge(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 4849604199710720000LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 16) return false;
+      return true;
+   }
+   
+   std::vector< std::string > WedgeDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   Wedge::Wedge(void) : avtas::lmcp::Object()
+   {
+      __AzimuthCenterline = 0.f;
+      __VerticalCenterline = 0.f;
+      __AzimuthExtent = 0.f;
+      __VerticalExtent = 0.f;
+
+   }
+     
+   Wedge::Wedge(const Wedge &that) : avtas::lmcp::Object(that)
+   {
+        __AzimuthCenterline = that.__AzimuthCenterline;
+        __VerticalCenterline = that.__VerticalCenterline;
+        __AzimuthExtent = that.__AzimuthExtent;
+        __VerticalExtent = that.__VerticalExtent;
+
+   }
+   
+   Wedge & Wedge::operator=(const Wedge &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __AzimuthCenterline = that.__AzimuthCenterline;
+         __VerticalCenterline = that.__VerticalCenterline;
+         __AzimuthExtent = that.__AzimuthExtent;
+         __VerticalExtent = that.__VerticalExtent;
+
+      }
+      return *this;
+   }
+
+   Wedge* Wedge::clone() const
+   {
+        return new Wedge(*this);
+   }
+   
+   Wedge::~Wedge(void)
+   {
+
+   }
+  
+   void Wedge::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putFloat(__AzimuthCenterline);
+      buf.putFloat(__VerticalCenterline);
+      buf.putFloat(__AzimuthExtent);
+      buf.putFloat(__VerticalExtent);
+
+   }
+   
+   void Wedge::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __AzimuthCenterline = buf.getFloat();
+      __VerticalCenterline = buf.getFloat();
+      __AzimuthExtent = buf.getFloat();
+      __VerticalExtent = buf.getFloat();
+
+   }
+
+   uint32_t Wedge::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string Wedge::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( Wedge ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AzimuthCenterline (float) = " << __AzimuthCenterline << "\n";
+      oss << indent << "VerticalCenterline (float) = " << __VerticalCenterline << "\n";
+      oss << indent << "AzimuthExtent (float) = " << __AzimuthExtent << "\n";
+      oss << indent << "VerticalExtent (float) = " << __VerticalExtent << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string Wedge::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<Wedge Series=\"CMASI\">\n";
+      str << ws << "   <AzimuthCenterline>" << __AzimuthCenterline << "</AzimuthCenterline>\n";
+      str << ws << "   <VerticalCenterline>" << __VerticalCenterline << "</VerticalCenterline>\n";
+      str << ws << "   <AzimuthExtent>" << __AzimuthExtent << "</AzimuthExtent>\n";
+      str << ws << "   <VerticalExtent>" << __VerticalExtent << "</VerticalExtent>\n";
+      str << ws << "</Wedge>\n";
+
+      return str.str();
+   }
+
+   bool Wedge::operator==(const Wedge & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__AzimuthCenterline != that.__AzimuthCenterline) return false;
+      if(__VerticalCenterline != that.__VerticalCenterline) return false;
+      if(__AzimuthExtent != that.__AzimuthExtent) return false;
+      if(__VerticalExtent != that.__VerticalExtent) return false;
+      return true;
+
+   }
+
+   bool Wedge::operator!=(const Wedge & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   Wedge& Wedge::setAzimuthCenterline(const float val)
+   {
+      __AzimuthCenterline = val;
+      return *this;
+   }
+
+   Wedge& Wedge::setVerticalCenterline(const float val)
+   {
+      __VerticalCenterline = val;
+      return *this;
+   }
+
+   Wedge& Wedge::setAzimuthExtent(const float val)
+   {
+      __AzimuthExtent = val;
+      return *this;
+   }
+
+   Wedge& Wedge::setVerticalExtent(const float val)
+   {
+      __VerticalExtent = val;
+      return *this;
+   }
+
+
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/perceive/EntityPerception.h b/src/LMCP/afrl/cmasi/perceive/EntityPerception.h
new file mode 100644
index 0000000..5351f9d
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/EntityPerception.h
@@ -0,0 +1,170 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_PERCEIVE_ENTITYPERCEPTION_H_
+#define _AFRL_CMASI_PERCEIVE_ENTITYPERCEPTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "PERCEIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace cmasi {
+namespace perceive {
+
+
+   bool isEntityPerception(avtas::lmcp::Object* obj);
+   bool isEntityPerception(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > EntityPerceptionDescendants();
+   
+   class EntityPerception : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      EntityPerception(void);
+
+      // Copy Constructor
+      EntityPerception(const EntityPerception &that);
+
+      // Assignment Operator
+      EntityPerception & operator=(const EntityPerception &that);
+
+      // Destructor
+      virtual ~EntityPerception(void);
+
+      // Equals overload
+      bool operator==(const EntityPerception & that);
+      bool operator!=(const EntityPerception & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual EntityPerception* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 1; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("PERCEIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5784119745305990725LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 1; }
+
+      // Accessors and Modifiers
+      /** A scenario-unique ID for this target entity. IDs should be greater than zero. Since this is a perception, the entity ID may not be known. In that case, this field should be set to zero. (Units: None)*/
+      uint32_t getPerceivedEntityID(void) const { return __PerceivedEntityID; }
+      EntityPerception& setPerceivedEntityID(const uint32_t val);
+
+      /** ID of the entity or aircraft that reported the detection/perception (Units: None)*/
+      uint32_t getPerceiverID(void) const { return __PerceiverID; }
+      EntityPerception& setPerceiverID(const uint32_t val);
+
+      /** The IDs of the payloads that reported this perception. (Units: None)*/
+      std::vector<uint32_t> & getPerceiverPayloads(void) { return __PerceiverPayloads; }
+
+      /** The perceived target velocity in three-dimensions. The velocity should be stated in tangential-plane coordinates using the North-East-Down coordinate system. (Units: meter/sec)*/
+      float* getVelocity(void) { return __Velocity; }
+
+      /** Velocity error for this perception. The error terms should be in the same coordinate system as the velocity. (Units: meter/sec)*/
+      float* getVelocityError(void) { return __VelocityError; }
+
+      /** If true, denotes that the velocity and velocity error have meaning. (Units: None)*/
+      bool getVelocityValid(void) const { return __VelocityValid; }
+      EntityPerception& setVelocityValid(const bool val);
+
+      /** Euler angle tangential-plane attitude for this entity. Should be stated as Psi-Theta-Phi. For information on Euler coordinates, see <a href="http://en.wikipedia.org/wiki/Euler_angle">Euler Angles</a> (Units: degree)*/
+      float* getAttitude(void) { return __Attitude; }
+
+      /** Error in the perception of the entity attitude. This should be in the same coordinate system as the attitude. (Units: degree)*/
+      float* getAttitudeError(void) { return __AttitudeError; }
+
+      /** If true, denotes that the attitude and attitude error have meaning. (Units: None)*/
+      bool getAttitudeValid(void) const { return __AttitudeValid; }
+      EntityPerception& setAttitudeValid(const bool val);
+
+      /** The entity location (Units: None)*/
+      afrl::cmasi::Location3D* const getLocation(void) { return __Location; }
+      EntityPerception& setLocation(const afrl::cmasi::Location3D* const val);
+
+      /** Error in the perception of the location of this entity. The first index is North-South error, the second index is the East-West error, and the third index is the vertical error. The result is an error cylinder. (Units: meter)*/
+      float* getLocationError(void) { return __LocationError; }
+
+      /** Time that this entity was perceived since scenario start. (Units: millisecond)*/
+      int64_t getTimeLastSeen(void) const { return __TimeLastSeen; }
+      EntityPerception& setTimeLastSeen(const int64_t val);
+
+
+
+   protected:
+      /** A scenario-unique ID for this target entity. IDs should be greater than zero. Since this is a perception, the entity ID may not be known. In that case, this field should be set to zero. */
+      uint32_t __PerceivedEntityID;
+      /** ID of the entity or aircraft that reported the detection/perception */
+      uint32_t __PerceiverID;
+      /** The IDs of the payloads that reported this perception. */
+      std::vector< uint32_t > __PerceiverPayloads;
+      /** The perceived target velocity in three-dimensions. The velocity should be stated in tangential-plane coordinates using the North-East-Down coordinate system. */
+      float __Velocity[3];
+      /** Velocity error for this perception. The error terms should be in the same coordinate system as the velocity. */
+      float __VelocityError[3];
+      /** If true, denotes that the velocity and velocity error have meaning. */
+      bool __VelocityValid;
+      /** Euler angle tangential-plane attitude for this entity. Should be stated as Psi-Theta-Phi. For information on Euler coordinates, see <a href="http://en.wikipedia.org/wiki/Euler_angle">Euler Angles</a> */
+      float __Attitude[3];
+      /** Error in the perception of the entity attitude. This should be in the same coordinate system as the attitude. */
+      float __AttitudeError[3];
+      /** If true, denotes that the attitude and attitude error have meaning. */
+      bool __AttitudeValid;
+      /** The entity location */
+      afrl::cmasi::Location3D* __Location;
+      /** Error in the perception of the location of this entity. The first index is North-South error, the second index is the East-West error, and the third index is the vertical error. The result is an error cylinder. */
+      float __LocationError[3];
+      /** Time that this entity was perceived since scenario start. */
+      int64_t __TimeLastSeen;
+
+   };
+
+} // end namespace perceive
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_PERCEIVE_ENTITYPERCEPTION_H_
diff --git a/src/LMCP/afrl/cmasi/perceive/EntityPerceptionDescendants.h b/src/LMCP/afrl/cmasi/perceive/EntityPerceptionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/EntityPerceptionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/perceive/PERCEIVE.h b/src/LMCP/afrl/cmasi/perceive/PERCEIVE.h
new file mode 100644
index 0000000..f49723b
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/PERCEIVE.h
@@ -0,0 +1,21 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_PERCEIVE_ENTIRESERIESHEADER_H_
+#define _AFRL_CMASI_PERCEIVE_ENTIRESERIESHEADER_H_
+
+#include "afrl/cmasi/perceive/EntityPerception.h"
+#include "afrl/cmasi/perceive/TrackEntityAction.h"
+#include "afrl/cmasi/perceive/TrackEntityTask.h"
+#include "afrl/cmasi/perceive/PERCEIVEEnum.h"
+
+
+#endif //_AFRL_CMASI_PERCEIVE_ENTIRESERIESHEADER_H_
diff --git a/src/LMCP/afrl/cmasi/perceive/PERCEIVEEnum.h b/src/LMCP/afrl/cmasi/perceive/PERCEIVEEnum.h
new file mode 100644
index 0000000..6799cc3
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/PERCEIVEEnum.h
@@ -0,0 +1,36 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_PERCEIVE_PERCEIVEENUM_H_
+#define _AFRL_CMASI_PERCEIVE_PERCEIVEENUM_H_
+
+
+namespace afrl {
+namespace cmasi {
+namespace perceive {
+
+
+   namespace PERCEIVEEnum {
+
+      enum LmcpType {
+         ENTITYPERCEPTION = 1,
+         TRACKENTITYACTION = 2,
+         TRACKENTITYTASK = 3
+      };
+
+   }
+
+} // end namespace perceive
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif //_AFRL_CMASI_PERCEIVE_PERCEIVEENUM_H_
diff --git a/src/LMCP/afrl/cmasi/perceive/PERCEIVEXMLReader.cpp b/src/LMCP/afrl/cmasi/perceive/PERCEIVEXMLReader.cpp
new file mode 100644
index 0000000..7a3a23c
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/PERCEIVEXMLReader.cpp
@@ -0,0 +1,257 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/cmasi/perceive/PERCEIVEXMLReader.h"
+#include "avtas/lmcp/XMLParser.h"
+#include <vector>
+#include <string>
+#include "avtas/lmcp/LmcpXMLReader.h"
+
+#include "afrl/cmasi/perceive/EntityPerception.h"
+#include "afrl/cmasi/perceive/TrackEntityAction.h"
+#include "afrl/cmasi/perceive/TrackEntityTask.h"
+#include "afrl/cmasi/perceive/PERCEIVEEnum.h"
+
+
+using namespace avtas::lmcp;
+using namespace avtas::lmcp::xml;
+
+
+namespace afrl {
+namespace cmasi {
+namespace perceive {
+
+
+    avtas::lmcp::Object* SeriesXMLReader :: visitType(avtas::lmcp::Node* el){
+
+        if (el == NULL) return NULL;
+        
+        std::string type = el->getTagName();
+            
+        if (type == "EntityPerception"){
+           EntityPerception* o = new EntityPerception();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "PerceivedEntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPerceivedEntityID( get_uint32( tmp ));
+                 continue;
+              }
+              if(name == "PerceiverID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPerceiverID( get_uint32( tmp ));
+                 continue;
+              }
+              if(name == "PerceiverPayloads")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getPerceiverPayloads().push_back( get_uint32( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "Velocity")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getVelocity()[j] = get_real32( tmp->getChild(j));
+                 }
+                 continue;
+              }
+              if(name == "VelocityError")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getVelocityError()[j] = get_real32( tmp->getChild(j));
+                 }
+                 continue;
+              }
+              if(name == "VelocityValid")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVelocityValid( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "Attitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAttitude()[j] = get_real32( tmp->getChild(j));
+                 }
+                 continue;
+              }
+              if(name == "AttitudeError")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAttitudeError()[j] = get_real32( tmp->getChild(j));
+                 }
+                 continue;
+              }
+              if(name == "AttitudeValid")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAttitudeValid( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "Location")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "LocationError")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getLocationError()[j] = get_real32( tmp->getChild(j));
+                 }
+                 continue;
+              }
+              if(name == "TimeLastSeen")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeLastSeen( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TrackEntityAction"){
+           TrackEntityAction* o = new TrackEntityAction();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "EntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityID( get_uint32( tmp ));
+                 continue;
+              }
+              if(name == "SensorID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSensorID( get_uint32( tmp ));
+                 continue;
+              }
+              if(name == "ReturnToWaypoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setReturnToWaypoint( get_uint32( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TrackEntityTask"){
+           TrackEntityTask* o = new TrackEntityTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "EntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityID( get_uint32( tmp ));
+                 continue;
+              }
+              if(name == "SensorModality")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSensorModality( afrl::cmasi::WavelengthBand::get_WavelengthBand( get_string( tmp )));
+                 continue;
+              }
+              if(name == "GroundSampleDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundSampleDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+
+
+         return NULL;
+        
+    }
+
+} // end namespace perceive
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/perceive/PERCEIVEXMLReader.h b/src/LMCP/afrl/cmasi/perceive/PERCEIVEXMLReader.h
new file mode 100644
index 0000000..b001b6f
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/PERCEIVEXMLReader.h
@@ -0,0 +1,47 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef PERCEIVE_SERIESXMLREADER_H_
+#define PERCEIVE_SERIESXMLREADER_H_
+
+#include "avtas/lmcp/Object.h"
+#include "avtas/lmcp/Node.h"
+#include "avtas/lmcp/NodeUtil.h"
+
+#include <iostream>
+
+
+using namespace avtas::lmcp;
+
+namespace afrl {
+namespace cmasi {
+namespace perceive {
+
+
+class SeriesXMLReader {
+
+    /** reads an LMCP XML Storage file and returns a list of LMCPObjects */
+    public:
+
+        SeriesXMLReader(void) {}
+
+        virtual ~SeriesXMLReader(){}  
+
+        static avtas::lmcp::Object * visitType(avtas::lmcp::Node* el );
+
+};
+
+} // end namespace perceive
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif 
diff --git a/src/LMCP/afrl/cmasi/perceive/TrackEntityAction.h b/src/LMCP/afrl/cmasi/perceive/TrackEntityAction.h
new file mode 100644
index 0000000..1750c2e
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/TrackEntityAction.h
@@ -0,0 +1,120 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_PERCEIVE_TRACKENTITYACTION_H_
+#define _AFRL_CMASI_PERCEIVE_TRACKENTITYACTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "PERCEIVEEnum.h"
+#include "afrl/cmasi/VehicleAction.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+namespace perceive {
+
+
+   bool isTrackEntityAction(avtas::lmcp::Object* obj);
+   bool isTrackEntityAction(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TrackEntityActionDescendants();
+   
+   class TrackEntityAction : public afrl::cmasi::VehicleAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TrackEntityAction(void);
+
+      // Copy Constructor
+      TrackEntityAction(const TrackEntityAction &that);
+
+      // Assignment Operator
+      TrackEntityAction & operator=(const TrackEntityAction &that);
+
+      // Destructor
+      virtual ~TrackEntityAction(void);
+
+      // Equals overload
+      bool operator==(const TrackEntityAction & that);
+      bool operator!=(const TrackEntityAction & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TrackEntityAction* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 2; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("PERCEIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5784119745305990725LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 1; }
+
+      // Accessors and Modifiers
+      /** The unique identifier of the target to be tracked. (Units: None)*/
+      uint32_t getEntityID(void) const { return __EntityID; }
+      TrackEntityAction& setEntityID(const uint32_t val);
+
+      /** The unique identifier of the sensor that is to be actively steered to track the target. (Units: None)*/
+      uint32_t getSensorID(void) const { return __SensorID; }
+      TrackEntityAction& setSensorID(const uint32_t val);
+
+      /** The waypoint that this vehicle is to return to when complete (or lost track) (Units: None)*/
+      uint32_t getReturnToWaypoint(void) const { return __ReturnToWaypoint; }
+      TrackEntityAction& setReturnToWaypoint(const uint32_t val);
+
+
+
+   protected:
+      /** The unique identifier of the target to be tracked. */
+      uint32_t __EntityID;
+      /** The unique identifier of the sensor that is to be actively steered to track the target. */
+      uint32_t __SensorID;
+      /** The waypoint that this vehicle is to return to when complete (or lost track) */
+      uint32_t __ReturnToWaypoint;
+
+   };
+
+} // end namespace perceive
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_PERCEIVE_TRACKENTITYACTION_H_
diff --git a/src/LMCP/afrl/cmasi/perceive/TrackEntityActionDescendants.h b/src/LMCP/afrl/cmasi/perceive/TrackEntityActionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/TrackEntityActionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/perceive/TrackEntityTask.h b/src/LMCP/afrl/cmasi/perceive/TrackEntityTask.h
new file mode 100644
index 0000000..cd8cde0
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/TrackEntityTask.h
@@ -0,0 +1,121 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_CMASI_PERCEIVE_TRACKENTITYTASK_H_
+#define _AFRL_CMASI_PERCEIVE_TRACKENTITYTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "PERCEIVEEnum.h"
+#include "afrl/cmasi/Task.h"
+#include "afrl/cmasi/WavelengthBand.h"
+
+
+
+namespace afrl {
+namespace cmasi {
+namespace perceive {
+
+
+   bool isTrackEntityTask(avtas::lmcp::Object* obj);
+   bool isTrackEntityTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TrackEntityTaskDescendants();
+   
+   class TrackEntityTask : public afrl::cmasi::Task {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TrackEntityTask(void);
+
+      // Copy Constructor
+      TrackEntityTask(const TrackEntityTask &that);
+
+      // Assignment Operator
+      TrackEntityTask & operator=(const TrackEntityTask &that);
+
+      // Destructor
+      virtual ~TrackEntityTask(void);
+
+      // Equals overload
+      bool operator==(const TrackEntityTask & that);
+      bool operator!=(const TrackEntityTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TrackEntityTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 3; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("PERCEIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5784119745305990725LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 1; }
+
+      // Accessors and Modifiers
+      /** The ID of the target to be tracked. (Units: None)*/
+      uint32_t getEntityID(void) const { return __EntityID; }
+      TrackEntityTask& setEntityID(const uint32_t val);
+
+      /** Required sensor modality for tracking the target (Units: None)*/
+      afrl::cmasi::WavelengthBand::WavelengthBand getSensorModality(void) const { return __SensorModality; }
+      TrackEntityTask& setSensorModality(const afrl::cmasi::WavelengthBand::WavelengthBand val);
+
+      /** The minimum ground sample distance that should be maintained for this target track operation. (Units: meter)*/
+      float getGroundSampleDistance(void) const { return __GroundSampleDistance; }
+      TrackEntityTask& setGroundSampleDistance(const float val);
+
+
+
+   protected:
+      /** The ID of the target to be tracked. */
+      uint32_t __EntityID;
+      /** Required sensor modality for tracking the target */
+      afrl::cmasi::WavelengthBand::WavelengthBand __SensorModality;
+      /** The minimum ground sample distance that should be maintained for this target track operation. */
+      float __GroundSampleDistance;
+
+   };
+
+} // end namespace perceive
+} // end namespace cmasi
+} // end namespace afrl
+
+
+#endif // _AFRL_CMASI_PERCEIVE_TRACKENTITYTASK_H_
diff --git a/src/LMCP/afrl/cmasi/perceive/TrackEntityTaskDescendants.h b/src/LMCP/afrl/cmasi/perceive/TrackEntityTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/TrackEntityTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/cmasi/perceive/afrlcmasiperceiveEntityPerception.cpp b/src/LMCP/afrl/cmasi/perceive/afrlcmasiperceiveEntityPerception.cpp
new file mode 100644
index 0000000..fb6c5d3
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/afrlcmasiperceiveEntityPerception.cpp
@@ -0,0 +1,471 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/perceive/EntityPerception.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace cmasi {
+namespace perceive {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string EntityPerception::Subscription = "afrl.cmasi.perceive.EntityPerception";
+   const std::string EntityPerception::TypeName = "EntityPerception";
+   
+   bool isEntityPerception(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5784119745305990725LL) return false;
+      if(obj->getSeriesVersion() != 1) return false;
+      if(obj->getLmcpType() != 1) return false;
+      return true;
+   }
+   
+   bool isEntityPerception(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5784119745305990725LL) return false;
+      if(obj->getSeriesVersion() != 1) return false;
+      if(obj->getLmcpType() != 1) return false;
+      return true;
+   }
+   
+   std::vector< std::string > EntityPerceptionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   EntityPerception::EntityPerception(void) : avtas::lmcp::Object()
+   {
+      __PerceivedEntityID = 0;
+      __PerceiverID = 0;
+      for (uint32_t i=0; i<3; i++)
+      {
+         __Velocity[i] = 0.f;
+      }
+      for (uint32_t i=0; i<3; i++)
+      {
+         __VelocityError[i] = 0.f;
+      }
+      __VelocityValid = false;
+      for (uint32_t i=0; i<3; i++)
+      {
+         __Attitude[i] = 0.f;
+      }
+      for (uint32_t i=0; i<3; i++)
+      {
+         __AttitudeError[i] = 0.f;
+      }
+      __AttitudeValid = false;
+      __Location = new afrl::cmasi::Location3D();
+      for (uint32_t i=0; i<3; i++)
+      {
+         __LocationError[i] = 0.f;
+      }
+      __TimeLastSeen = 0LL;
+
+   }
+     
+   EntityPerception::EntityPerception(const EntityPerception &that) : avtas::lmcp::Object(that)
+   {
+        __PerceivedEntityID = that.__PerceivedEntityID;
+        __PerceiverID = that.__PerceiverID;
+        __PerceiverPayloads.clear();
+        for (size_t i=0; i< that.__PerceiverPayloads.size(); i++)
+        {
+           __PerceiverPayloads.push_back( that.__PerceiverPayloads[i]);
+        }
+        for (uint32_t i=0; i<3; i++)
+        {
+           __Velocity[i] = that.__Velocity[i];
+        }
+        for (uint32_t i=0; i<3; i++)
+        {
+           __VelocityError[i] = that.__VelocityError[i];
+        }
+        __VelocityValid = that.__VelocityValid;
+        for (uint32_t i=0; i<3; i++)
+        {
+           __Attitude[i] = that.__Attitude[i];
+        }
+        for (uint32_t i=0; i<3; i++)
+        {
+           __AttitudeError[i] = that.__AttitudeError[i];
+        }
+        __AttitudeValid = that.__AttitudeValid;
+        __Location = that.__Location == nullptr ? nullptr : that.__Location->clone();
+        for (uint32_t i=0; i<3; i++)
+        {
+           __LocationError[i] = that.__LocationError[i];
+        }
+        __TimeLastSeen = that.__TimeLastSeen;
+
+   }
+   
+   EntityPerception & EntityPerception::operator=(const EntityPerception &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__Location != nullptr) delete __Location;
+
+         __PerceivedEntityID = that.__PerceivedEntityID;
+         __PerceiverID = that.__PerceiverID;
+         __PerceiverPayloads.clear();
+         for (size_t i=0; i< that.__PerceiverPayloads.size(); i++)
+         {
+            __PerceiverPayloads.push_back( that.__PerceiverPayloads[i]);
+         }
+         for (uint32_t i=0; i<3; i++)
+         {
+            __Velocity[i] = that.__Velocity[i];
+         }
+         for (uint32_t i=0; i<3; i++)
+         {
+            __VelocityError[i] = that.__VelocityError[i];
+         }
+         __VelocityValid = that.__VelocityValid;
+         for (uint32_t i=0; i<3; i++)
+         {
+            __Attitude[i] = that.__Attitude[i];
+         }
+         for (uint32_t i=0; i<3; i++)
+         {
+            __AttitudeError[i] = that.__AttitudeError[i];
+         }
+         __AttitudeValid = that.__AttitudeValid;
+         __Location = that.__Location == nullptr ? nullptr : that.__Location->clone();
+         for (uint32_t i=0; i<3; i++)
+         {
+            __LocationError[i] = that.__LocationError[i];
+         }
+         __TimeLastSeen = that.__TimeLastSeen;
+
+      }
+      return *this;
+   }
+
+   EntityPerception* EntityPerception::clone() const
+   {
+        return new EntityPerception(*this);
+   }
+   
+   EntityPerception::~EntityPerception(void)
+   {
+      if (__Location != nullptr) delete __Location;
+
+   }
+  
+   void EntityPerception::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putUInt(__PerceivedEntityID);
+      buf.putUInt(__PerceiverID);
+      buf.putUShort( static_cast<uint16_t>(__PerceiverPayloads.size()));
+      for (size_t i=0; i<__PerceiverPayloads.size(); i++)
+      {
+         buf.putUInt(__PerceiverPayloads[i]);
+      }
+      for (uint32_t i=0; i<3; i++)
+      {
+         buf.putFloat(__Velocity[i]);
+      }
+      for (uint32_t i=0; i<3; i++)
+      {
+         buf.putFloat(__VelocityError[i]);
+      }
+      buf.putBool(__VelocityValid);
+      for (uint32_t i=0; i<3; i++)
+      {
+         buf.putFloat(__Attitude[i]);
+      }
+      for (uint32_t i=0; i<3; i++)
+      {
+         buf.putFloat(__AttitudeError[i]);
+      }
+      buf.putBool(__AttitudeValid);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Location, buf);
+      for (uint32_t i=0; i<3; i++)
+      {
+         buf.putFloat(__LocationError[i]);
+      }
+      buf.putLong(__TimeLastSeen);
+
+   }
+   
+   void EntityPerception::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __PerceivedEntityID = buf.getUInt();
+      __PerceiverID = buf.getUInt();
+      __PerceiverPayloads.clear();
+      uint16_t __PerceiverPayloads_length = buf.getUShort();
+      for (uint32_t i=0; i< __PerceiverPayloads_length; i++)
+      {
+         __PerceiverPayloads.push_back(buf.getUInt() );
+      }
+      for (uint32_t i=0; i<3; i++)
+      {
+         __Velocity[i] = buf.getFloat();
+      }
+      for (uint32_t i=0; i<3; i++)
+      {
+         __VelocityError[i] = buf.getFloat();
+      }
+      __VelocityValid = buf.getBool();
+      for (uint32_t i=0; i<3; i++)
+      {
+         __Attitude[i] = buf.getFloat();
+      }
+      for (uint32_t i=0; i<3; i++)
+      {
+         __AttitudeError[i] = buf.getFloat();
+      }
+      __AttitudeValid = buf.getBool();
+      {
+         if (__Location != nullptr) delete __Location;
+         __Location = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Location = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Location != nullptr) __Location->unpack(buf);
+         }
+      }
+      for (uint32_t i=0; i<3; i++)
+      {
+         __LocationError[i] = buf.getFloat();
+      }
+      __TimeLastSeen = buf.getLong();
+
+   }
+
+   uint32_t EntityPerception::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(uint32_t);
+      size += sizeof(uint32_t);
+      size += 2 + sizeof(uint32_t) * __PerceiverPayloads.size();
+      size += sizeof(float) * 3;
+      size += sizeof(float) * 3;
+      size += sizeof(bool);
+      size += sizeof(float) * 3;
+      size += sizeof(float) * 3;
+      size += sizeof(bool);
+      size += (__Location != nullptr ? __Location->calculatePackedSize() + 15 : 1);
+      size += sizeof(float) * 3;
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string EntityPerception::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( EntityPerception ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PerceivedEntityID (uint32_t) = " << __PerceivedEntityID << "\n";
+      oss << indent << "PerceiverID (uint32_t) = " << __PerceiverID << "\n";
+      oss << indent << "PerceiverPayloads (uint32 [ " << __PerceiverPayloads.size() << ", var ])\n";
+      oss << indent << "Velocity (real32 [ " << __Velocity << " ])\n";
+      oss << indent << "VelocityError (real32 [ " << __VelocityError << " ])\n";
+      oss << indent << "VelocityValid (bool) = " << __VelocityValid << "\n";
+      oss << indent << "Attitude (real32 [ " << __Attitude << " ])\n";
+      oss << indent << "AttitudeError (real32 [ " << __AttitudeError << " ])\n";
+      oss << indent << "AttitudeValid (bool) = " << __AttitudeValid << "\n";
+      oss << indent << "Location (Location3D)";
+      if (__Location == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "LocationError (real32 [ " << __LocationError << " ])\n";
+      oss << indent << "TimeLastSeen (int64_t) = " << __TimeLastSeen << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string EntityPerception::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<EntityPerception Series=\"PERCEIVE\">\n";
+      str << ws << "   <PerceivedEntityID>" << __PerceivedEntityID << "</PerceivedEntityID>\n";
+      str << ws << "   <PerceiverID>" << __PerceiverID << "</PerceiverID>\n";
+      str << ws << "   <PerceiverPayloads>\n";
+      for (size_t i=0; i<__PerceiverPayloads.size(); i++)
+      {
+         str << ws << "   <uint32>" << __PerceiverPayloads[i] << "</uint32>\n";
+      }
+      str << ws << "   </PerceiverPayloads>\n";
+      str << ws << "   <Velocity>\n";
+      for (uint32_t i=0; i<3; i++)
+      {
+         str << ws << "   <real32>" << __Velocity[i] << "</real32>\n";
+      }
+      str << ws << "   </Velocity>\n";
+      str << ws << "   <VelocityError>\n";
+      for (uint32_t i=0; i<3; i++)
+      {
+         str << ws << "   <real32>" << __VelocityError[i] << "</real32>\n";
+      }
+      str << ws << "   </VelocityError>\n";
+      str << ws << "   <VelocityValid>" << (__VelocityValid ? "true" : "false") << "</VelocityValid>\n";
+      str << ws << "   <Attitude>\n";
+      for (uint32_t i=0; i<3; i++)
+      {
+         str << ws << "   <real32>" << __Attitude[i] << "</real32>\n";
+      }
+      str << ws << "   </Attitude>\n";
+      str << ws << "   <AttitudeError>\n";
+      for (uint32_t i=0; i<3; i++)
+      {
+         str << ws << "   <real32>" << __AttitudeError[i] << "</real32>\n";
+      }
+      str << ws << "   </AttitudeError>\n";
+      str << ws << "   <AttitudeValid>" << (__AttitudeValid ? "true" : "false") << "</AttitudeValid>\n";
+      if (__Location != nullptr)
+      {
+         str << ws << "   <Location>";
+         str << "\n" + __Location->toXML(depth + 1) + ws + "   ";
+         str << "</Location>\n";
+      }
+      str << ws << "   <LocationError>\n";
+      for (uint32_t i=0; i<3; i++)
+      {
+         str << ws << "   <real32>" << __LocationError[i] << "</real32>\n";
+      }
+      str << ws << "   </LocationError>\n";
+      str << ws << "   <TimeLastSeen>" << __TimeLastSeen << "</TimeLastSeen>\n";
+      str << ws << "</EntityPerception>\n";
+
+      return str.str();
+   }
+
+   bool EntityPerception::operator==(const EntityPerception & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__PerceivedEntityID != that.__PerceivedEntityID) return false;
+      if(__PerceiverID != that.__PerceiverID) return false;
+      if(__PerceiverPayloads.size() != that.__PerceiverPayloads.size()) return false;
+      for (size_t i=0; i<__PerceiverPayloads.size(); i++)
+      {
+         if(__PerceiverPayloads[i] != that.__PerceiverPayloads[i]) return false;
+      }
+      for (uint32_t i=0; i<3; i++)
+      {
+         if(__Velocity[i] != that.__Velocity[i]) return false;
+      }
+      for (uint32_t i=0; i<3; i++)
+      {
+         if(__VelocityError[i] != that.__VelocityError[i]) return false;
+      }
+      if(__VelocityValid != that.__VelocityValid) return false;
+      for (uint32_t i=0; i<3; i++)
+      {
+         if(__Attitude[i] != that.__Attitude[i]) return false;
+      }
+      for (uint32_t i=0; i<3; i++)
+      {
+         if(__AttitudeError[i] != that.__AttitudeError[i]) return false;
+      }
+      if(__AttitudeValid != that.__AttitudeValid) return false;
+      if(__Location && that.__Location)
+      {
+         if(__Location->getSeriesNameAsLong() != that.__Location->getSeriesNameAsLong()) return false;
+         if(__Location->getSeriesVersion() != that.__Location->getSeriesVersion()) return false;
+         if(__Location->getLmcpType() != that.__Location->getLmcpType()) return false;
+         if( *(__Location) != *(that.__Location) ) return false;
+      }
+      else if(__Location != that.__Location) return false;
+      for (uint32_t i=0; i<3; i++)
+      {
+         if(__LocationError[i] != that.__LocationError[i]) return false;
+      }
+      if(__TimeLastSeen != that.__TimeLastSeen) return false;
+      return true;
+
+   }
+
+   bool EntityPerception::operator!=(const EntityPerception & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   EntityPerception& EntityPerception::setPerceivedEntityID(const uint32_t val)
+   {
+      __PerceivedEntityID = val;
+      return *this;
+   }
+
+   EntityPerception& EntityPerception::setPerceiverID(const uint32_t val)
+   {
+      __PerceiverID = val;
+      return *this;
+   }
+
+
+
+
+   EntityPerception& EntityPerception::setVelocityValid(const bool val)
+   {
+      __VelocityValid = val;
+      return *this;
+   }
+
+
+
+   EntityPerception& EntityPerception::setAttitudeValid(const bool val)
+   {
+      __AttitudeValid = val;
+      return *this;
+   }
+
+   EntityPerception& EntityPerception::setLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__Location != nullptr) { delete __Location; __Location = nullptr; }
+      if (val != nullptr) { __Location = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+
+   EntityPerception& EntityPerception::setTimeLastSeen(const int64_t val)
+   {
+      __TimeLastSeen = val;
+      return *this;
+   }
+
+
+} // end namespace perceive
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/perceive/afrlcmasiperceiveTrackEntityAction.cpp b/src/LMCP/afrl/cmasi/perceive/afrlcmasiperceiveTrackEntityAction.cpp
new file mode 100644
index 0000000..8586c60
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/afrlcmasiperceiveTrackEntityAction.cpp
@@ -0,0 +1,203 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/perceive/TrackEntityAction.h"
+
+
+namespace afrl {
+namespace cmasi {
+namespace perceive {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TrackEntityAction::Subscription = "afrl.cmasi.perceive.TrackEntityAction";
+   const std::string TrackEntityAction::TypeName = "TrackEntityAction";
+   
+   bool isTrackEntityAction(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5784119745305990725LL) return false;
+      if(obj->getSeriesVersion() != 1) return false;
+      if(obj->getLmcpType() != 2) return false;
+      return true;
+   }
+   
+   bool isTrackEntityAction(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5784119745305990725LL) return false;
+      if(obj->getSeriesVersion() != 1) return false;
+      if(obj->getLmcpType() != 2) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TrackEntityActionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TrackEntityAction::TrackEntityAction(void) : afrl::cmasi::VehicleAction()
+   {
+      __EntityID = 0;
+      __SensorID = 0;
+      __ReturnToWaypoint = 0;
+
+   }
+     
+   TrackEntityAction::TrackEntityAction(const TrackEntityAction &that) : afrl::cmasi::VehicleAction(that)
+   {
+        __EntityID = that.__EntityID;
+        __SensorID = that.__SensorID;
+        __ReturnToWaypoint = that.__ReturnToWaypoint;
+
+   }
+   
+   TrackEntityAction & TrackEntityAction::operator=(const TrackEntityAction &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::VehicleAction::operator=(that);
+
+         __EntityID = that.__EntityID;
+         __SensorID = that.__SensorID;
+         __ReturnToWaypoint = that.__ReturnToWaypoint;
+
+      }
+      return *this;
+   }
+
+   TrackEntityAction* TrackEntityAction::clone() const
+   {
+        return new TrackEntityAction(*this);
+   }
+   
+   TrackEntityAction::~TrackEntityAction(void)
+   {
+
+   }
+  
+   void TrackEntityAction::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::VehicleAction::pack(buf);
+      // Copy the class into the buffer
+      buf.putUInt(__EntityID);
+      buf.putUInt(__SensorID);
+      buf.putUInt(__ReturnToWaypoint);
+
+   }
+   
+   void TrackEntityAction::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::VehicleAction::unpack(buf);
+      // Copy the buffer into the class
+      __EntityID = buf.getUInt();
+      __SensorID = buf.getUInt();
+      __ReturnToWaypoint = buf.getUInt();
+
+   }
+
+   uint32_t TrackEntityAction::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::VehicleAction::calculatePackedSize();
+      size += sizeof(uint32_t);
+      size += sizeof(uint32_t);
+      size += sizeof(uint32_t);
+
+      return size;
+   }
+
+   std::string TrackEntityAction::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TrackEntityAction ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+      oss << indent << "EntityID (uint32_t) = " << __EntityID << "\n";
+      oss << indent << "SensorID (uint32_t) = " << __SensorID << "\n";
+      oss << indent << "ReturnToWaypoint (uint32_t) = " << __ReturnToWaypoint << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TrackEntityAction::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TrackEntityAction Series=\"PERCEIVE\">\n";
+      str << ws << "   <EntityID>" << __EntityID << "</EntityID>\n";
+      str << ws << "   <SensorID>" << __SensorID << "</SensorID>\n";
+      str << ws << "   <ReturnToWaypoint>" << __ReturnToWaypoint << "</ReturnToWaypoint>\n";
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</TrackEntityAction>\n";
+
+      return str.str();
+   }
+
+   bool TrackEntityAction::operator==(const TrackEntityAction & that)
+   {
+      if( afrl::cmasi::VehicleAction::operator!=(that) )
+      {
+          return false;
+      }
+      if(__EntityID != that.__EntityID) return false;
+      if(__SensorID != that.__SensorID) return false;
+      if(__ReturnToWaypoint != that.__ReturnToWaypoint) return false;
+      return true;
+
+   }
+
+   bool TrackEntityAction::operator!=(const TrackEntityAction & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TrackEntityAction& TrackEntityAction::setEntityID(const uint32_t val)
+   {
+      __EntityID = val;
+      return *this;
+   }
+
+   TrackEntityAction& TrackEntityAction::setSensorID(const uint32_t val)
+   {
+      __SensorID = val;
+      return *this;
+   }
+
+   TrackEntityAction& TrackEntityAction::setReturnToWaypoint(const uint32_t val)
+   {
+      __ReturnToWaypoint = val;
+      return *this;
+   }
+
+
+} // end namespace perceive
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/cmasi/perceive/afrlcmasiperceiveTrackEntityTask.cpp b/src/LMCP/afrl/cmasi/perceive/afrlcmasiperceiveTrackEntityTask.cpp
new file mode 100644
index 0000000..18502aa
--- /dev/null
+++ b/src/LMCP/afrl/cmasi/perceive/afrlcmasiperceiveTrackEntityTask.cpp
@@ -0,0 +1,220 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/cmasi/perceive/TrackEntityTask.h"
+
+
+namespace afrl {
+namespace cmasi {
+namespace perceive {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TrackEntityTask::Subscription = "afrl.cmasi.perceive.TrackEntityTask";
+   const std::string TrackEntityTask::TypeName = "TrackEntityTask";
+   
+   bool isTrackEntityTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5784119745305990725LL) return false;
+      if(obj->getSeriesVersion() != 1) return false;
+      if(obj->getLmcpType() != 3) return false;
+      return true;
+   }
+   
+   bool isTrackEntityTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5784119745305990725LL) return false;
+      if(obj->getSeriesVersion() != 1) return false;
+      if(obj->getLmcpType() != 3) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TrackEntityTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TrackEntityTask::TrackEntityTask(void) : afrl::cmasi::Task()
+   {
+      __EntityID = 0;
+      __SensorModality = afrl::cmasi::WavelengthBand::AllAny;
+      __GroundSampleDistance = 0.f;
+
+   }
+     
+   TrackEntityTask::TrackEntityTask(const TrackEntityTask &that) : afrl::cmasi::Task(that)
+   {
+        __EntityID = that.__EntityID;
+        __SensorModality = that.__SensorModality;
+        __GroundSampleDistance = that.__GroundSampleDistance;
+
+   }
+   
+   TrackEntityTask & TrackEntityTask::operator=(const TrackEntityTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::Task::operator=(that);
+
+         __EntityID = that.__EntityID;
+         __SensorModality = that.__SensorModality;
+         __GroundSampleDistance = that.__GroundSampleDistance;
+
+      }
+      return *this;
+   }
+
+   TrackEntityTask* TrackEntityTask::clone() const
+   {
+        return new TrackEntityTask(*this);
+   }
+   
+   TrackEntityTask::~TrackEntityTask(void)
+   {
+
+   }
+  
+   void TrackEntityTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::Task::pack(buf);
+      // Copy the class into the buffer
+      buf.putUInt(__EntityID);
+      buf.putInt( (int32_t) __SensorModality);
+      buf.putFloat(__GroundSampleDistance);
+
+   }
+   
+   void TrackEntityTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::Task::unpack(buf);
+      // Copy the buffer into the class
+      __EntityID = buf.getUInt();
+      __SensorModality = (afrl::cmasi::WavelengthBand::WavelengthBand) buf.getInt();
+      __GroundSampleDistance = buf.getFloat();
+
+   }
+
+   uint32_t TrackEntityTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::Task::calculatePackedSize();
+      size += sizeof(uint32_t);
+      size += sizeof(afrl::cmasi::WavelengthBand::WavelengthBand);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string TrackEntityTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TrackEntityTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "EntityID (uint32_t) = " << __EntityID << "\n";
+      oss << indent << "SensorModality (WavelengthBand) = " << __SensorModality << "\n";
+      oss << indent << "GroundSampleDistance (float) = " << __GroundSampleDistance << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TrackEntityTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TrackEntityTask Series=\"PERCEIVE\">\n";
+      str << ws << "   <EntityID>" << __EntityID << "</EntityID>\n";
+      str << ws << "   <SensorModality>" << afrl::cmasi::WavelengthBand::get_string(__SensorModality) << "</SensorModality>\n";
+      str << ws << "   <GroundSampleDistance>" << __GroundSampleDistance << "</GroundSampleDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</TrackEntityTask>\n";
+
+      return str.str();
+   }
+
+   bool TrackEntityTask::operator==(const TrackEntityTask & that)
+   {
+      if( afrl::cmasi::Task::operator!=(that) )
+      {
+          return false;
+      }
+      if(__EntityID != that.__EntityID) return false;
+      if(__SensorModality != that.__SensorModality) return false;
+      if(__GroundSampleDistance != that.__GroundSampleDistance) return false;
+      return true;
+
+   }
+
+   bool TrackEntityTask::operator!=(const TrackEntityTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TrackEntityTask& TrackEntityTask::setEntityID(const uint32_t val)
+   {
+      __EntityID = val;
+      return *this;
+   }
+
+   TrackEntityTask& TrackEntityTask::setSensorModality(const afrl::cmasi::WavelengthBand::WavelengthBand val)
+   {
+      __SensorModality = val;
+      return *this;
+   }
+
+   TrackEntityTask& TrackEntityTask::setGroundSampleDistance(const float val)
+   {
+      __GroundSampleDistance = val;
+      return *this;
+   }
+
+
+} // end namespace perceive
+} // end namespace cmasi
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/AngledAreaSearchTask.h b/src/LMCP/afrl/impact/AngledAreaSearchTask.h
new file mode 100644
index 0000000..7f43f75
--- /dev/null
+++ b/src/LMCP/afrl/impact/AngledAreaSearchTask.h
@@ -0,0 +1,119 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_ANGLEDAREASEARCHTASK_H_
+#define _AFRL_IMPACT_ANGLEDAREASEARCHTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isAngledAreaSearchTask(avtas::lmcp::Object* obj);
+   bool isAngledAreaSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AngledAreaSearchTaskDescendants();
+   
+   class AngledAreaSearchTask : public afrl::cmasi::SearchTask {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AngledAreaSearchTask(void);
+
+      // Copy Constructor
+      AngledAreaSearchTask(const AngledAreaSearchTask &that);
+
+      // Assignment Operator
+      AngledAreaSearchTask & operator=(const AngledAreaSearchTask &that);
+
+      // Destructor
+      virtual ~AngledAreaSearchTask(void);
+
+      // Equals overload
+      bool operator==(const AngledAreaSearchTask & that);
+      bool operator!=(const AngledAreaSearchTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AngledAreaSearchTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 27; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Area to search (from available areas of interest) (Units: None)*/
+      int64_t getSearchAreaID(void) const { return __SearchAreaID; }
+      AngledAreaSearchTask& setSearchAreaID(const int64_t val);
+
+      /** Sweep angle defined from true North in clockwise manner (Units: degrees)*/
+      float getSweepAngle(void) const { return __SweepAngle; }
+      AngledAreaSearchTask& setSweepAngle(const float val);
+
+      /** Start point for this search (Units: None)*/
+      afrl::cmasi::Location3D* const getStartPoint(void) { return __StartPoint; }
+      AngledAreaSearchTask& setStartPoint(const afrl::cmasi::Location3D* const val);
+
+
+
+   protected:
+      /** Area to search (from available areas of interest) */
+      int64_t __SearchAreaID;
+      /** Sweep angle defined from true North in clockwise manner */
+      float __SweepAngle;
+      /** Start point for this search */
+      afrl::cmasi::Location3D* __StartPoint;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_ANGLEDAREASEARCHTASK_H_
diff --git a/src/LMCP/afrl/impact/AngledAreaSearchTaskDescendants.h b/src/LMCP/afrl/impact/AngledAreaSearchTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/AngledAreaSearchTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/AreaOfInterest.h b/src/LMCP/afrl/impact/AreaOfInterest.h
new file mode 100644
index 0000000..240f38a
--- /dev/null
+++ b/src/LMCP/afrl/impact/AreaOfInterest.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_AREAOFINTEREST_H_
+#define _AFRL_IMPACT_AREAOFINTEREST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AbstractGeometry.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isAreaOfInterest(avtas::lmcp::Object* obj);
+   bool isAreaOfInterest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AreaOfInterestDescendants();
+   
+   class AreaOfInterest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AreaOfInterest(void);
+
+      // Copy Constructor
+      AreaOfInterest(const AreaOfInterest &that);
+
+      // Assignment Operator
+      AreaOfInterest & operator=(const AreaOfInterest &that);
+
+      // Destructor
+      virtual ~AreaOfInterest(void);
+
+      // Equals overload
+      bool operator==(const AreaOfInterest & that);
+      bool operator!=(const AreaOfInterest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AreaOfInterest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 24; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** ID for area of interest (Units: None)*/
+      int64_t getAreaID(void) const { return __AreaID; }
+      AreaOfInterest& setAreaID(const int64_t val);
+
+      /** Geometry describing the area (Units: None)*/
+      afrl::cmasi::AbstractGeometry* const getArea(void) { return __Area; }
+      AreaOfInterest& setArea(const afrl::cmasi::AbstractGeometry* const val);
+
+
+
+   protected:
+      /** ID for area of interest */
+      int64_t __AreaID;
+      /** Geometry describing the area */
+      afrl::cmasi::AbstractGeometry* __Area;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_AREAOFINTEREST_H_
diff --git a/src/LMCP/afrl/impact/AreaOfInterestDescendants.h b/src/LMCP/afrl/impact/AreaOfInterestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/AreaOfInterestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/AreaSearchPattern.h b/src/LMCP/afrl/impact/AreaSearchPattern.h
new file mode 100644
index 0000000..438cf53
--- /dev/null
+++ b/src/LMCP/afrl/impact/AreaSearchPattern.h
@@ -0,0 +1,60 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_AREASEARCHPATTERN_H_
+#define _AFRL_IMPACT_AREASEARCHPATTERN_H_
+
+#include <string>
+
+namespace afrl {
+namespace impact {
+
+
+
+   namespace AreaSearchPattern {
+   enum AreaSearchPattern {
+       /**  Spiral search  */
+       Spiral = 0,
+       /**  Sector  */
+       Sector = 1,
+       /**  Sweep  */
+       Sweep = 2
+
+   };
+
+   // generates a new AreaSearchPattern value for the passed string
+   inline AreaSearchPattern get_AreaSearchPattern(std::string str) {
+       if ( str == "Spiral") return Spiral;
+       if ( str == "Sector") return Sector;
+       if ( str == "Sweep") return Sweep;
+        return Spiral;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(AreaSearchPattern e) {
+       switch(e) {
+        case Spiral: return "Spiral";
+        case Sector: return "Sector";
+        case Sweep: return "Sweep";
+        default: return "Spiral";
+
+       }
+   }
+
+   }  // namespace AreaSearchPattern
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_AREASEARCHPATTERN_H_
diff --git a/src/LMCP/afrl/impact/BatchRoutePlanRequest.h b/src/LMCP/afrl/impact/BatchRoutePlanRequest.h
new file mode 100644
index 0000000..babc445
--- /dev/null
+++ b/src/LMCP/afrl/impact/BatchRoutePlanRequest.h
@@ -0,0 +1,140 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_BATCHROUTEPLANREQUEST_H_
+#define _AFRL_IMPACT_BATCHROUTEPLANREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isBatchRoutePlanRequest(avtas::lmcp::Object* obj);
+   bool isBatchRoutePlanRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > BatchRoutePlanRequestDescendants();
+   
+   class BatchRoutePlanRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      BatchRoutePlanRequest(void);
+
+      // Copy Constructor
+      BatchRoutePlanRequest(const BatchRoutePlanRequest &that);
+
+      // Assignment Operator
+      BatchRoutePlanRequest & operator=(const BatchRoutePlanRequest &that);
+
+      // Destructor
+      virtual ~BatchRoutePlanRequest(void);
+
+      // Equals overload
+      bool operator==(const BatchRoutePlanRequest & that);
+      bool operator!=(const BatchRoutePlanRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual BatchRoutePlanRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 9; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Request ID for correlating with response (Units: None)*/
+      int64_t getRequestID(void) const { return __RequestID; }
+      BatchRoutePlanRequest& setRequestID(const int64_t val);
+
+      /** An array of vehicles (by ID) to consider when planning (Units: None)*/
+      std::vector<int64_t> & getVehicles(void) { return __Vehicles; }
+
+      /** List of task IDs to be planned to (Units: None)*/
+      std::vector<int64_t> & getTaskList(void) { return __TaskList; }
+
+      /** Operating region to be considered during planning (Units: None)*/
+      int64_t getOperatingRegion(void) const { return __OperatingRegion; }
+      BatchRoutePlanRequest& setOperatingRegion(const int64_t val);
+
+      /** Flag to report timing between tasks (Units: None)*/
+      bool getComputeTaskToTaskTiming(void) const { return __ComputeTaskToTaskTiming; }
+      BatchRoutePlanRequest& setComputeTaskToTaskTiming(const bool val);
+
+      /** Flag to report timing between incremental progress on task and subsequent tasks (Units: None)*/
+      bool getComputeInterTaskToTaskTiming(void) const { return __ComputeInterTaskToTaskTiming; }
+      BatchRoutePlanRequest& setComputeInterTaskToTaskTiming(const bool val);
+
+      /** List of task percentages along task to plan from (Units: None)*/
+      std::vector<float> & getInterTaskPercentage(void) { return __InterTaskPercentage; }
+
+
+
+   protected:
+      /** Request ID for correlating with response */
+      int64_t __RequestID;
+      /** An array of vehicles (by ID) to consider when planning */
+      std::vector< int64_t > __Vehicles;
+      /** List of task IDs to be planned to */
+      std::vector< int64_t > __TaskList;
+      /** Operating region to be considered during planning */
+      int64_t __OperatingRegion;
+      /** Flag to report timing between tasks */
+      bool __ComputeTaskToTaskTiming;
+      /** Flag to report timing between incremental progress on task and subsequent tasks */
+      bool __ComputeInterTaskToTaskTiming;
+      /** List of task percentages along task to plan from */
+      std::vector< float > __InterTaskPercentage;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_BATCHROUTEPLANREQUEST_H_
diff --git a/src/LMCP/afrl/impact/BatchRoutePlanRequestDescendants.h b/src/LMCP/afrl/impact/BatchRoutePlanRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/BatchRoutePlanRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/BatchRoutePlanResponse.h b/src/LMCP/afrl/impact/BatchRoutePlanResponse.h
new file mode 100644
index 0000000..bb8e80a
--- /dev/null
+++ b/src/LMCP/afrl/impact/BatchRoutePlanResponse.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_BATCHROUTEPLANRESPONSE_H_
+#define _AFRL_IMPACT_BATCHROUTEPLANRESPONSE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/impact/TaskTimingPair.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isBatchRoutePlanResponse(avtas::lmcp::Object* obj);
+   bool isBatchRoutePlanResponse(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > BatchRoutePlanResponseDescendants();
+   
+   class BatchRoutePlanResponse : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      BatchRoutePlanResponse(void);
+
+      // Copy Constructor
+      BatchRoutePlanResponse(const BatchRoutePlanResponse &that);
+
+      // Assignment Operator
+      BatchRoutePlanResponse & operator=(const BatchRoutePlanResponse &that);
+
+      // Destructor
+      virtual ~BatchRoutePlanResponse(void);
+
+      // Equals overload
+      bool operator==(const BatchRoutePlanResponse & that);
+      bool operator!=(const BatchRoutePlanResponse & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual BatchRoutePlanResponse* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 10; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Response ID matching request from ({@link BatchRoutePlanRequest}) (Units: None)*/
+      int64_t getResponseID(void) const { return __ResponseID; }
+      BatchRoutePlanResponse& setResponseID(const int64_t val);
+
+      /** Set of task-to-task timings for each requested vehicle (Units: None)*/
+      std::vector<afrl::impact::TaskTimingPair*> & getVehicleTiming(void) { return __VehicleTiming; }
+
+
+
+   protected:
+      /** Response ID matching request from ({@link BatchRoutePlanRequest}) */
+      int64_t __ResponseID;
+      /** Set of task-to-task timings for each requested vehicle */
+      std::vector< afrl::impact::TaskTimingPair* > __VehicleTiming;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_BATCHROUTEPLANRESPONSE_H_
diff --git a/src/LMCP/afrl/impact/BatchRoutePlanResponseDescendants.h b/src/LMCP/afrl/impact/BatchRoutePlanResponseDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/BatchRoutePlanResponseDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/BatchSummaryRequest.h b/src/LMCP/afrl/impact/BatchSummaryRequest.h
new file mode 100644
index 0000000..9902904
--- /dev/null
+++ b/src/LMCP/afrl/impact/BatchSummaryRequest.h
@@ -0,0 +1,128 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_BATCHSUMMARYREQUEST_H_
+#define _AFRL_IMPACT_BATCHSUMMARYREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isBatchSummaryRequest(avtas::lmcp::Object* obj);
+   bool isBatchSummaryRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > BatchSummaryRequestDescendants();
+   
+   class BatchSummaryRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      BatchSummaryRequest(void);
+
+      // Copy Constructor
+      BatchSummaryRequest(const BatchSummaryRequest &that);
+
+      // Assignment Operator
+      BatchSummaryRequest & operator=(const BatchSummaryRequest &that);
+
+      // Destructor
+      virtual ~BatchSummaryRequest(void);
+
+      // Equals overload
+      bool operator==(const BatchSummaryRequest & that);
+      bool operator!=(const BatchSummaryRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual BatchSummaryRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 12; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Request ID for correlating with response (Units: None)*/
+      int64_t getRequestID(void) const { return __RequestID; }
+      BatchSummaryRequest& setRequestID(const int64_t val);
+
+      /** An array of vehicles (by ID) to consider when planning (Units: None)*/
+      std::vector<int64_t> & getVehicles(void) { return __Vehicles; }
+
+      /** List of task IDs to be planned to (Units: None)*/
+      std::vector<int64_t> & getTaskList(void) { return __TaskList; }
+
+      /** List of task percentages along task to plan from (Units: None)*/
+      std::vector<float> & getInterTaskPercentage(void) { return __InterTaskPercentage; }
+
+      /** Operating region to be considered during planning (Units: None)*/
+      int64_t getOperatingRegion(void) const { return __OperatingRegion; }
+      BatchSummaryRequest& setOperatingRegion(const int64_t val);
+
+
+
+   protected:
+      /** Request ID for correlating with response */
+      int64_t __RequestID;
+      /** An array of vehicles (by ID) to consider when planning */
+      std::vector< int64_t > __Vehicles;
+      /** List of task IDs to be planned to */
+      std::vector< int64_t > __TaskList;
+      /** List of task percentages along task to plan from */
+      std::vector< float > __InterTaskPercentage;
+      /** Operating region to be considered during planning */
+      int64_t __OperatingRegion;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_BATCHSUMMARYREQUEST_H_
diff --git a/src/LMCP/afrl/impact/BatchSummaryRequestDescendants.h b/src/LMCP/afrl/impact/BatchSummaryRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/BatchSummaryRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/BatchSummaryResponse.h b/src/LMCP/afrl/impact/BatchSummaryResponse.h
new file mode 100644
index 0000000..48cefaf
--- /dev/null
+++ b/src/LMCP/afrl/impact/BatchSummaryResponse.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_BATCHSUMMARYRESPONSE_H_
+#define _AFRL_IMPACT_BATCHSUMMARYRESPONSE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/impact/TaskSummary.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isBatchSummaryResponse(avtas::lmcp::Object* obj);
+   bool isBatchSummaryResponse(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > BatchSummaryResponseDescendants();
+   
+   class BatchSummaryResponse : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      BatchSummaryResponse(void);
+
+      // Copy Constructor
+      BatchSummaryResponse(const BatchSummaryResponse &that);
+
+      // Assignment Operator
+      BatchSummaryResponse & operator=(const BatchSummaryResponse &that);
+
+      // Destructor
+      virtual ~BatchSummaryResponse(void);
+
+      // Equals overload
+      bool operator==(const BatchSummaryResponse & that);
+      bool operator!=(const BatchSummaryResponse & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual BatchSummaryResponse* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 13; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Response ID matching request from ({@link BatchSummaryRequest}) (Units: None)*/
+      int64_t getResponseID(void) const { return __ResponseID; }
+      BatchSummaryResponse& setResponseID(const int64_t val);
+
+      /** Set of vehicle-to-task and task-to-task summaries including timing, communication, and remaining energy (Units: None)*/
+      std::vector<afrl::impact::TaskSummary*> & getSummaries(void) { return __Summaries; }
+
+
+
+   protected:
+      /** Response ID matching request from ({@link BatchSummaryRequest}) */
+      int64_t __ResponseID;
+      /** Set of vehicle-to-task and task-to-task summaries including timing, communication, and remaining energy */
+      std::vector< afrl::impact::TaskSummary* > __Summaries;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_BATCHSUMMARYRESPONSE_H_
diff --git a/src/LMCP/afrl/impact/BatchSummaryResponseDescendants.h b/src/LMCP/afrl/impact/BatchSummaryResponseDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/BatchSummaryResponseDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/BlockadeTask.h b/src/LMCP/afrl/impact/BlockadeTask.h
new file mode 100644
index 0000000..72462f2
--- /dev/null
+++ b/src/LMCP/afrl/impact/BlockadeTask.h
@@ -0,0 +1,125 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_BLOCKADETASK_H_
+#define _AFRL_IMPACT_BLOCKADETASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/Task.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isBlockadeTask(avtas::lmcp::Object* obj);
+   bool isBlockadeTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > BlockadeTaskDescendants();
+   
+   class BlockadeTask : public afrl::cmasi::Task {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      BlockadeTask(void);
+
+      // Copy Constructor
+      BlockadeTask(const BlockadeTask &that);
+
+      // Assignment Operator
+      BlockadeTask & operator=(const BlockadeTask &that);
+
+      // Destructor
+      virtual ~BlockadeTask(void);
+
+      // Equals overload
+      bool operator==(const BlockadeTask & that);
+      bool operator!=(const BlockadeTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual BlockadeTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 33; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Entity to surround and deny access (Units: None)*/
+      int64_t getBlockedEntityID(void) const { return __BlockedEntityID; }
+      BlockadeTask& setBlockedEntityID(const int64_t val);
+
+      /** When in blocking formation, the distance that vehicles should stand off. (Units: meters)*/
+      float getStandoffDistance(void) const { return __StandoffDistance; }
+      BlockadeTask& setStandoffDistance(const float val);
+
+      /** Number of vehicles to simultaneously block the target (Units: None)*/
+      uint8_t getNumberVehicles(void) const { return __NumberVehicles; }
+      BlockadeTask& setNumberVehicles(const uint8_t val);
+
+      /** Biases the blockade so that more vehicles are between enemy and protected location. If no location is given, then blockade attempts to block in direction of enemy travel (Units: None)*/
+      afrl::cmasi::Location3D* const getProtectedLocation(void) { return __ProtectedLocation; }
+      BlockadeTask& setProtectedLocation(const afrl::cmasi::Location3D* const val);
+
+
+
+   protected:
+      /** Entity to surround and deny access */
+      int64_t __BlockedEntityID;
+      /** When in blocking formation, the distance that vehicles should stand off. */
+      float __StandoffDistance;
+      /** Number of vehicles to simultaneously block the target */
+      uint8_t __NumberVehicles;
+      /** Biases the blockade so that more vehicles are between enemy and protected location. If no location is given, then blockade attempts to block in direction of enemy travel */
+      afrl::cmasi::Location3D* __ProtectedLocation;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_BLOCKADETASK_H_
diff --git a/src/LMCP/afrl/impact/BlockadeTaskDescendants.h b/src/LMCP/afrl/impact/BlockadeTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/BlockadeTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/CommRelayTask.h b/src/LMCP/afrl/impact/CommRelayTask.h
new file mode 100644
index 0000000..60a842b
--- /dev/null
+++ b/src/LMCP/afrl/impact/CommRelayTask.h
@@ -0,0 +1,119 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_COMMRELAYTASK_H_
+#define _AFRL_IMPACT_COMMRELAYTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/Task.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isCommRelayTask(avtas::lmcp::Object* obj);
+   bool isCommRelayTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > CommRelayTaskDescendants();
+   
+   class CommRelayTask : public afrl::cmasi::Task {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      CommRelayTask(void);
+
+      // Copy Constructor
+      CommRelayTask(const CommRelayTask &that);
+
+      // Assignment Operator
+      CommRelayTask & operator=(const CommRelayTask &that);
+
+      // Destructor
+      virtual ~CommRelayTask(void);
+
+      // Equals overload
+      bool operator==(const CommRelayTask & that);
+      bool operator!=(const CommRelayTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual CommRelayTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 31; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** ID of entity which requires comm relay support (Units: None)*/
+      int64_t getSupportedEntityID(void) const { return __SupportedEntityID; }
+      CommRelayTask& setSupportedEntityID(const int64_t val);
+
+      /** Destination location for supported entity (Units: None)*/
+      afrl::cmasi::Location3D* const getDestinationLocation(void) { return __DestinationLocation; }
+      CommRelayTask& setDestinationLocation(const afrl::cmasi::Location3D* const val);
+
+      /** ID of entity to which communication will be delivered (i.e. Tower ID) (Units: None)*/
+      int64_t getTowerID(void) const { return __TowerID; }
+      CommRelayTask& setTowerID(const int64_t val);
+
+
+
+   protected:
+      /** ID of entity which requires comm relay support */
+      int64_t __SupportedEntityID;
+      /** Destination location for supported entity */
+      afrl::cmasi::Location3D* __DestinationLocation;
+      /** ID of entity to which communication will be delivered (i.e. Tower ID) */
+      int64_t __TowerID;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_COMMRELAYTASK_H_
diff --git a/src/LMCP/afrl/impact/CommRelayTaskDescendants.h b/src/LMCP/afrl/impact/CommRelayTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/CommRelayTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/ConfigurationRequest.h b/src/LMCP/afrl/impact/ConfigurationRequest.h
new file mode 100644
index 0000000..3540dc6
--- /dev/null
+++ b/src/LMCP/afrl/impact/ConfigurationRequest.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_CONFIGURATIONREQUEST_H_
+#define _AFRL_IMPACT_CONFIGURATIONREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isConfigurationRequest(avtas::lmcp::Object* obj);
+   bool isConfigurationRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > ConfigurationRequestDescendants();
+   
+   class ConfigurationRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      ConfigurationRequest(void);
+
+      // Copy Constructor
+      ConfigurationRequest(const ConfigurationRequest &that);
+
+      // Assignment Operator
+      ConfigurationRequest & operator=(const ConfigurationRequest &that);
+
+      // Destructor
+      virtual ~ConfigurationRequest(void);
+
+      // Equals overload
+      bool operator==(const ConfigurationRequest & that);
+      bool operator!=(const ConfigurationRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual ConfigurationRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 35; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Vehicle IDs for which the corresponding configuration should be sent. If the list is empty, all available configurations should be sent in response. (Units: None)*/
+      std::vector<int64_t> & getVehicleID(void) { return __VehicleID; }
+
+
+
+   protected:
+      /** Vehicle IDs for which the corresponding configuration should be sent. If the list is empty, all available configurations should be sent in response. */
+      std::vector< int64_t > __VehicleID;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_CONFIGURATIONREQUEST_H_
diff --git a/src/LMCP/afrl/impact/ConfigurationRequestDescendants.h b/src/LMCP/afrl/impact/ConfigurationRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/ConfigurationRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/CordonTask.h b/src/LMCP/afrl/impact/CordonTask.h
new file mode 100644
index 0000000..3fdbd01
--- /dev/null
+++ b/src/LMCP/afrl/impact/CordonTask.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_CORDONTASK_H_
+#define _AFRL_IMPACT_CORDONTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/Task.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isCordonTask(avtas::lmcp::Object* obj);
+   bool isCordonTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > CordonTaskDescendants();
+   
+   class CordonTask : public afrl::cmasi::Task {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      CordonTask(void);
+
+      // Copy Constructor
+      CordonTask(const CordonTask &that);
+
+      // Assignment Operator
+      CordonTask & operator=(const CordonTask &that);
+
+      // Destructor
+      virtual ~CordonTask(void);
+
+      // Equals overload
+      bool operator==(const CordonTask & that);
+      bool operator!=(const CordonTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual CordonTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 32; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Block road access to this location (Units: None)*/
+      afrl::cmasi::Location3D* const getCordonLocation(void) { return __CordonLocation; }
+      CordonTask& setCordonLocation(const afrl::cmasi::Location3D* const val);
+
+      /** Distance away from 'CordonLocation' that access should be blocked (Units: meters)*/
+      float getStandoffDistance(void) const { return __StandoffDistance; }
+      CordonTask& setStandoffDistance(const float val);
+
+
+
+   protected:
+      /** Block road access to this location */
+      afrl::cmasi::Location3D* __CordonLocation;
+      /** Distance away from 'CordonLocation' that access should be blocked */
+      float __StandoffDistance;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_CORDONTASK_H_
diff --git a/src/LMCP/afrl/impact/CordonTaskDescendants.h b/src/LMCP/afrl/impact/CordonTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/CordonTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/DeployImpactPayload.h b/src/LMCP/afrl/impact/DeployImpactPayload.h
new file mode 100644
index 0000000..c8fbe18
--- /dev/null
+++ b/src/LMCP/afrl/impact/DeployImpactPayload.h
@@ -0,0 +1,119 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_DEPLOYIMPACTPAYLOAD_H_
+#define _AFRL_IMPACT_DEPLOYIMPACTPAYLOAD_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/VehicleAction.h"
+#include "afrl/impact/ImpactPayloadType.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isDeployImpactPayload(avtas::lmcp::Object* obj);
+   bool isDeployImpactPayload(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > DeployImpactPayloadDescendants();
+   
+   class DeployImpactPayload : public afrl::cmasi::VehicleAction {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      DeployImpactPayload(void);
+
+      // Copy Constructor
+      DeployImpactPayload(const DeployImpactPayload &that);
+
+      // Assignment Operator
+      DeployImpactPayload & operator=(const DeployImpactPayload &that);
+
+      // Destructor
+      virtual ~DeployImpactPayload(void);
+
+      // Equals overload
+      bool operator==(const DeployImpactPayload & that);
+      bool operator!=(const DeployImpactPayload & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual DeployImpactPayload* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 7; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** IMPACT vehicle from which to deploy payload (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      DeployImpactPayload& setVehicleID(const int64_t val);
+
+      /** Payload to deploy (Units: None)*/
+      afrl::impact::ImpactPayloadType::ImpactPayloadType getDeployedPayload(void) const { return __DeployedPayload; }
+      DeployImpactPayload& setDeployedPayload(const afrl::impact::ImpactPayloadType::ImpactPayloadType val);
+
+      /** Entity to which the payload will be deployed. If zero, then payload is assumed deployed at the current position of the deploying vehicle. (Units: None)*/
+      int64_t getTargetEntityID(void) const { return __TargetEntityID; }
+      DeployImpactPayload& setTargetEntityID(const int64_t val);
+
+
+
+   protected:
+      /** IMPACT vehicle from which to deploy payload */
+      int64_t __VehicleID;
+      /** Payload to deploy */
+      afrl::impact::ImpactPayloadType::ImpactPayloadType __DeployedPayload;
+      /** Entity to which the payload will be deployed. If zero, then payload is assumed deployed at the current position of the deploying vehicle. */
+      int64_t __TargetEntityID;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_DEPLOYIMPACTPAYLOAD_H_
diff --git a/src/LMCP/afrl/impact/DeployImpactPayloadDescendants.h b/src/LMCP/afrl/impact/DeployImpactPayloadDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/DeployImpactPayloadDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/EscortTask.h b/src/LMCP/afrl/impact/EscortTask.h
new file mode 100644
index 0000000..7467b69
--- /dev/null
+++ b/src/LMCP/afrl/impact/EscortTask.h
@@ -0,0 +1,125 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_ESCORTTASK_H_
+#define _AFRL_IMPACT_ESCORTTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/Waypoint.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isEscortTask(avtas::lmcp::Object* obj);
+   bool isEscortTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > EscortTaskDescendants();
+   
+   class EscortTask : public afrl::cmasi::SearchTask {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      EscortTask(void);
+
+      // Copy Constructor
+      EscortTask(const EscortTask &that);
+
+      // Assignment Operator
+      EscortTask & operator=(const EscortTask &that);
+
+      // Destructor
+      virtual ~EscortTask(void);
+
+      // Equals overload
+      bool operator==(const EscortTask & that);
+      bool operator!=(const EscortTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual EscortTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 34; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** ID of entity which will provide the basis for the escort. Tasked vehicle will attempt to stay 'StandoffDistance' ahead of this entity on its route. (Units: None)*/
+      int64_t getSupportedEntityID(void) const { return __SupportedEntityID; }
+      EscortTask& setSupportedEntityID(const int64_t val);
+
+      /** ID of line which describes the route that the 'SupportedEntityID' is following. If the 'SupportedEntityID' is one of the controlled entities, such as a taskable ground vehicle, then 'RouteID' can be zero and this task will use current, known route for that vehicle. Otherwise, 'RouteID' must be an ID for a previously described '{@link LineOfInterest}'. (Units: None)*/
+      int64_t getRouteID(void) const { return __RouteID; }
+      EscortTask& setRouteID(const int64_t val);
+
+      /** Waypoints that the supported entity is presumed to be following if 'RouteID' is zero (Units: None)*/
+      std::vector<afrl::cmasi::Waypoint*> & getPrescribedWaypoints(void) { return __PrescribedWaypoints; }
+
+      /** Distance ahead (positive) or behind (negative) that the vehicle will provide surveillance relative to 'SupportedEntityID's location on route 'RouteID' (Units: meters)*/
+      float getStandoffDistance(void) const { return __StandoffDistance; }
+      EscortTask& setStandoffDistance(const float val);
+
+
+
+   protected:
+      /** ID of entity which will provide the basis for the escort. Tasked vehicle will attempt to stay 'StandoffDistance' ahead of this entity on its route. */
+      int64_t __SupportedEntityID;
+      /** ID of line which describes the route that the 'SupportedEntityID' is following. If the 'SupportedEntityID' is one of the controlled entities, such as a taskable ground vehicle, then 'RouteID' can be zero and this task will use current, known route for that vehicle. Otherwise, 'RouteID' must be an ID for a previously described '{@link LineOfInterest}'. */
+      int64_t __RouteID;
+      /** Waypoints that the supported entity is presumed to be following if 'RouteID' is zero */
+      std::vector< afrl::cmasi::Waypoint* > __PrescribedWaypoints;
+      /** Distance ahead (positive) or behind (negative) that the vehicle will provide surveillance relative to 'SupportedEntityID's location on route 'RouteID' */
+      float __StandoffDistance;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_ESCORTTASK_H_
diff --git a/src/LMCP/afrl/impact/EscortTaskDescendants.h b/src/LMCP/afrl/impact/EscortTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/EscortTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/GroundVehicleConfiguration.h b/src/LMCP/afrl/impact/GroundVehicleConfiguration.h
new file mode 100644
index 0000000..0f83f1e
--- /dev/null
+++ b/src/LMCP/afrl/impact/GroundVehicleConfiguration.h
@@ -0,0 +1,124 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_GROUNDVEHICLECONFIGURATION_H_
+#define _AFRL_IMPACT_GROUNDVEHICLECONFIGURATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/EntityConfiguration.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isGroundVehicleConfiguration(avtas::lmcp::Object* obj);
+   bool isGroundVehicleConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > GroundVehicleConfigurationDescendants();
+   
+   class GroundVehicleConfiguration : public afrl::cmasi::EntityConfiguration {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      GroundVehicleConfiguration(void);
+
+      // Copy Constructor
+      GroundVehicleConfiguration(const GroundVehicleConfiguration &that);
+
+      // Assignment Operator
+      GroundVehicleConfiguration & operator=(const GroundVehicleConfiguration &that);
+
+      // Destructor
+      virtual ~GroundVehicleConfiguration(void);
+
+      // Equals overload
+      bool operator==(const GroundVehicleConfiguration & that);
+      bool operator!=(const GroundVehicleConfiguration & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual GroundVehicleConfiguration* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 36; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Valid operational road network. UGV adheres to positions defined in this graph. Indicated by previously sent GraphRegion's ID (Units: None)*/
+      int64_t getRoadGraphID(void) const { return __RoadGraphID; }
+      GroundVehicleConfiguration& setRoadGraphID(const int64_t val);
+
+      /** The minimum speed that should be commanded for this vehicle (Units: meter/sec)*/
+      float getMinimumSpeed(void) const { return __MinimumSpeed; }
+      GroundVehicleConfiguration& setMinimumSpeed(const float val);
+
+      /** The maximum speed that should be commanded for this vehicle (Units: meter/sec)*/
+      float getMaximumSpeed(void) const { return __MaximumSpeed; }
+      GroundVehicleConfiguration& setMaximumSpeed(const float val);
+
+      /** The consumption rate of available energy at nominal speed, expressed in terms of the percentage of maximum capacity used per second. (Units: %/sec)*/
+      float getEnergyRate(void) const { return __EnergyRate; }
+      GroundVehicleConfiguration& setEnergyRate(const float val);
+
+
+
+   protected:
+      /** Valid operational road network. UGV adheres to positions defined in this graph. Indicated by previously sent GraphRegion's ID */
+      int64_t __RoadGraphID;
+      /** The minimum speed that should be commanded for this vehicle */
+      float __MinimumSpeed;
+      /** The maximum speed that should be commanded for this vehicle */
+      float __MaximumSpeed;
+      /** The consumption rate of available energy at nominal speed, expressed in terms of the percentage of maximum capacity used per second. */
+      float __EnergyRate;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_GROUNDVEHICLECONFIGURATION_H_
diff --git a/src/LMCP/afrl/impact/GroundVehicleConfigurationDescendants.h b/src/LMCP/afrl/impact/GroundVehicleConfigurationDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/GroundVehicleConfigurationDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/GroundVehicleState.h b/src/LMCP/afrl/impact/GroundVehicleState.h
new file mode 100644
index 0000000..265e1da
--- /dev/null
+++ b/src/LMCP/afrl/impact/GroundVehicleState.h
@@ -0,0 +1,100 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_GROUNDVEHICLESTATE_H_
+#define _AFRL_IMPACT_GROUNDVEHICLESTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/EntityState.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isGroundVehicleState(avtas::lmcp::Object* obj);
+   bool isGroundVehicleState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > GroundVehicleStateDescendants();
+   
+   class GroundVehicleState : public afrl::cmasi::EntityState {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      GroundVehicleState(void);
+
+      // Copy Constructor
+      GroundVehicleState(const GroundVehicleState &that);
+
+      // Assignment Operator
+      GroundVehicleState & operator=(const GroundVehicleState &that);
+
+      // Destructor
+      virtual ~GroundVehicleState(void);
+
+      // Equals overload
+      bool operator==(const GroundVehicleState & that);
+      bool operator!=(const GroundVehicleState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual GroundVehicleState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 37; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+
+
+   protected:
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_GROUNDVEHICLESTATE_H_
diff --git a/src/LMCP/afrl/impact/GroundVehicleStateDescendants.h b/src/LMCP/afrl/impact/GroundVehicleStateDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/GroundVehicleStateDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/IMPACT.h b/src/LMCP/afrl/impact/IMPACT.h
new file mode 100644
index 0000000..2cf7e1f
--- /dev/null
+++ b/src/LMCP/afrl/impact/IMPACT.h
@@ -0,0 +1,62 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_ENTIRESERIESHEADER_H_
+#define _AFRL_IMPACT_ENTIRESERIESHEADER_H_
+
+#include "afrl/impact/PowerConfiguration.h"
+#include "afrl/impact/RadioConfiguration.h"
+#include "afrl/impact/RadioTowerConfiguration.h"
+#include "afrl/impact/RadioState.h"
+#include "afrl/impact/RadioTowerState.h"
+#include "afrl/impact/ImpactPayloadConfiguration.h"
+#include "afrl/impact/DeployImpactPayload.h"
+#include "afrl/impact/PowerPlantState.h"
+#include "afrl/impact/BatchRoutePlanRequest.h"
+#include "afrl/impact/BatchRoutePlanResponse.h"
+#include "afrl/impact/TaskTimingPair.h"
+#include "afrl/impact/BatchSummaryRequest.h"
+#include "afrl/impact/BatchSummaryResponse.h"
+#include "afrl/impact/TaskSummary.h"
+#include "afrl/impact/VehicleSummary.h"
+#include "afrl/impact/ImpactHeartbeat.h"
+#include "afrl/impact/ImpactComponentJoin.h"
+#include "afrl/impact/ImpactComponentLeave.h"
+#include "afrl/impact/SpeedAltPair.h"
+#include "afrl/impact/ImpactAutomationRequest.h"
+#include "afrl/impact/ImpactAutomationResponse.h"
+#include "afrl/impact/PointOfInterest.h"
+#include "afrl/impact/LineOfInterest.h"
+#include "afrl/impact/AreaOfInterest.h"
+#include "afrl/impact/ImpactPointSearchTask.h"
+#include "afrl/impact/PatternSearchTask.h"
+#include "afrl/impact/AngledAreaSearchTask.h"
+#include "afrl/impact/ImpactLineSearchTask.h"
+#include "afrl/impact/WatchTask.h"
+#include "afrl/impact/MultiVehicleWatchTask.h"
+#include "afrl/impact/CommRelayTask.h"
+#include "afrl/impact/CordonTask.h"
+#include "afrl/impact/BlockadeTask.h"
+#include "afrl/impact/EscortTask.h"
+#include "afrl/impact/ConfigurationRequest.h"
+#include "afrl/impact/GroundVehicleConfiguration.h"
+#include "afrl/impact/GroundVehicleState.h"
+#include "afrl/impact/WaterReport.h"
+#include "afrl/impact/WaterZone.h"
+#include "afrl/impact/SurfaceVehicleConfiguration.h"
+#include "afrl/impact/SurfaceVehicleState.h"
+#include "afrl/impact/AreaSearchPattern.h"
+#include "afrl/impact/PowerPlant.h"
+#include "afrl/impact/ImpactPayloadType.h"
+#include "afrl/impact/IMPACTEnum.h"
+
+
+#endif //_AFRL_IMPACT_ENTIRESERIESHEADER_H_
diff --git a/src/LMCP/afrl/impact/IMPACTEnum.h b/src/LMCP/afrl/impact/IMPACTEnum.h
new file mode 100644
index 0000000..afaf44f
--- /dev/null
+++ b/src/LMCP/afrl/impact/IMPACTEnum.h
@@ -0,0 +1,72 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_IMPACTENUM_H_
+#define _AFRL_IMPACT_IMPACTENUM_H_
+
+
+namespace afrl {
+namespace impact {
+
+
+   namespace IMPACTEnum {
+
+      enum LmcpType {
+         POWERCONFIGURATION = 1,
+         RADIOCONFIGURATION = 2,
+         RADIOTOWERCONFIGURATION = 3,
+         RADIOSTATE = 4,
+         RADIOTOWERSTATE = 5,
+         IMPACTPAYLOADCONFIGURATION = 6,
+         DEPLOYIMPACTPAYLOAD = 7,
+         POWERPLANTSTATE = 8,
+         BATCHROUTEPLANREQUEST = 9,
+         BATCHROUTEPLANRESPONSE = 10,
+         TASKTIMINGPAIR = 11,
+         BATCHSUMMARYREQUEST = 12,
+         BATCHSUMMARYRESPONSE = 13,
+         TASKSUMMARY = 14,
+         VEHICLESUMMARY = 15,
+         IMPACTHEARTBEAT = 16,
+         IMPACTCOMPONENTJOIN = 17,
+         IMPACTCOMPONENTLEAVE = 18,
+         SPEEDALTPAIR = 19,
+         IMPACTAUTOMATIONREQUEST = 20,
+         IMPACTAUTOMATIONRESPONSE = 21,
+         POINTOFINTEREST = 22,
+         LINEOFINTEREST = 23,
+         AREAOFINTEREST = 24,
+         IMPACTPOINTSEARCHTASK = 25,
+         PATTERNSEARCHTASK = 26,
+         ANGLEDAREASEARCHTASK = 27,
+         IMPACTLINESEARCHTASK = 28,
+         WATCHTASK = 29,
+         MULTIVEHICLEWATCHTASK = 30,
+         COMMRELAYTASK = 31,
+         CORDONTASK = 32,
+         BLOCKADETASK = 33,
+         ESCORTTASK = 34,
+         CONFIGURATIONREQUEST = 35,
+         GROUNDVEHICLECONFIGURATION = 36,
+         GROUNDVEHICLESTATE = 37,
+         WATERREPORT = 38,
+         WATERZONE = 39,
+         SURFACEVEHICLECONFIGURATION = 40,
+         SURFACEVEHICLESTATE = 41
+      };
+
+   }
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif //_AFRL_IMPACT_IMPACTENUM_H_
diff --git a/src/LMCP/afrl/impact/IMPACTXMLReader.cpp b/src/LMCP/afrl/impact/IMPACTXMLReader.cpp
new file mode 100644
index 0000000..f8cbad7
--- /dev/null
+++ b/src/LMCP/afrl/impact/IMPACTXMLReader.cpp
@@ -0,0 +1,2713 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "afrl/impact/IMPACTXMLReader.h"
+#include "avtas/lmcp/XMLParser.h"
+#include <vector>
+#include <string>
+#include "avtas/lmcp/LmcpXMLReader.h"
+
+#include "afrl/impact/PowerConfiguration.h"
+#include "afrl/impact/RadioConfiguration.h"
+#include "afrl/impact/RadioTowerConfiguration.h"
+#include "afrl/impact/RadioState.h"
+#include "afrl/impact/RadioTowerState.h"
+#include "afrl/impact/ImpactPayloadConfiguration.h"
+#include "afrl/impact/DeployImpactPayload.h"
+#include "afrl/impact/PowerPlantState.h"
+#include "afrl/impact/BatchRoutePlanRequest.h"
+#include "afrl/impact/BatchRoutePlanResponse.h"
+#include "afrl/impact/TaskTimingPair.h"
+#include "afrl/impact/BatchSummaryRequest.h"
+#include "afrl/impact/BatchSummaryResponse.h"
+#include "afrl/impact/TaskSummary.h"
+#include "afrl/impact/VehicleSummary.h"
+#include "afrl/impact/ImpactHeartbeat.h"
+#include "afrl/impact/ImpactComponentJoin.h"
+#include "afrl/impact/ImpactComponentLeave.h"
+#include "afrl/impact/SpeedAltPair.h"
+#include "afrl/impact/ImpactAutomationRequest.h"
+#include "afrl/impact/ImpactAutomationResponse.h"
+#include "afrl/impact/PointOfInterest.h"
+#include "afrl/impact/LineOfInterest.h"
+#include "afrl/impact/AreaOfInterest.h"
+#include "afrl/impact/ImpactPointSearchTask.h"
+#include "afrl/impact/PatternSearchTask.h"
+#include "afrl/impact/AngledAreaSearchTask.h"
+#include "afrl/impact/ImpactLineSearchTask.h"
+#include "afrl/impact/WatchTask.h"
+#include "afrl/impact/MultiVehicleWatchTask.h"
+#include "afrl/impact/CommRelayTask.h"
+#include "afrl/impact/CordonTask.h"
+#include "afrl/impact/BlockadeTask.h"
+#include "afrl/impact/EscortTask.h"
+#include "afrl/impact/ConfigurationRequest.h"
+#include "afrl/impact/GroundVehicleConfiguration.h"
+#include "afrl/impact/GroundVehicleState.h"
+#include "afrl/impact/WaterReport.h"
+#include "afrl/impact/WaterZone.h"
+#include "afrl/impact/SurfaceVehicleConfiguration.h"
+#include "afrl/impact/SurfaceVehicleState.h"
+#include "afrl/impact/AreaSearchPattern.h"
+#include "afrl/impact/PowerPlant.h"
+#include "afrl/impact/ImpactPayloadType.h"
+#include "afrl/impact/IMPACTEnum.h"
+
+
+using namespace avtas::lmcp;
+using namespace avtas::lmcp::xml;
+
+
+namespace afrl {
+namespace impact {
+
+
+    avtas::lmcp::Object* SeriesXMLReader :: visitType(avtas::lmcp::Node* el){
+
+        if (el == NULL) return NULL;
+        
+        std::string type = el->getTagName();
+            
+        if (type == "PowerConfiguration"){
+           PowerConfiguration* o = new PowerConfiguration();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "NominalPowerConfiguration")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalPowerConfiguration( afrl::impact::PowerPlant::get_PowerPlant( get_string( tmp )));
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PayloadKind")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadKind( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RadioConfiguration"){
+           RadioConfiguration* o = new RadioConfiguration();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Range")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRange( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "RallyPoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setRallyPoint((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "Timeout")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeout( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PayloadKind")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadKind( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RadioTowerConfiguration"){
+           RadioTowerConfiguration* o = new RadioTowerConfiguration();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Position")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setPosition((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "Range")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRange( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Enabled")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEnabled( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "ID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Affiliation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAffiliation( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EntityType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityType( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "NominalSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "NominalAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "NominalAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "PayloadConfigurationList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPayloadConfigurationList().push_back( (afrl::cmasi::PayloadConfiguration*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Info")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getInfo().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RadioState"){
+           RadioState* o = new RadioState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Enabled")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEnabled( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "InRange")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setInRange( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RadioTowerState"){
+           RadioTowerState* o = new RadioTowerState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Enabled")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEnabled( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "ID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "u")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setU( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "v")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setV( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "w")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setW( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "udot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setUdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "vdot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "wdot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Heading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHeading( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Pitch")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPitch( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Roll")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRoll( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "p")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setP( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "q")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setQ( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "r")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setR( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Course")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCourse( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Groundspeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundspeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Location")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "EnergyAvailable")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEnergyAvailable( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ActualEnergyRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setActualEnergyRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "PayloadStateList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPayloadStateList().push_back( (afrl::cmasi::PayloadState*) oo);
+                 }
+                 continue;
+              }
+              if(name == "CurrentWaypoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCurrentWaypoint( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "CurrentCommand")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCurrentCommand( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Mode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMode( afrl::cmasi::NavigationMode::get_NavigationMode( get_string( tmp )));
+                 continue;
+              }
+              if(name == "AssociatedTasks")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTasks().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "Time")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Info")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getInfo().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "ImpactPayloadConfiguration"){
+           ImpactPayloadConfiguration* o = new ImpactPayloadConfiguration();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "AvailablePayloads")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAvailablePayloads().push_back( afrl::impact::ImpactPayloadType::get_ImpactPayloadType(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PayloadKind")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadKind( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "DeployImpactPayload"){
+           DeployImpactPayload* o = new DeployImpactPayload();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "DeployedPayload")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDeployedPayload( afrl::impact::ImpactPayloadType::get_ImpactPayloadType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "TargetEntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTargetEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "PowerPlantState"){
+           PowerPlantState* o = new PowerPlantState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ActivePowerPlant")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setActivePowerPlant( afrl::impact::PowerPlant::get_PowerPlant( get_string( tmp )));
+                 continue;
+              }
+              if(name == "PayloadID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayloadID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "BatchRoutePlanRequest"){
+           BatchRoutePlanRequest* o = new BatchRoutePlanRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Vehicles")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getVehicles().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "TaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "OperatingRegion")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setOperatingRegion( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "ComputeTaskToTaskTiming")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setComputeTaskToTaskTiming( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "ComputeInterTaskToTaskTiming")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setComputeInterTaskToTaskTiming( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "InterTaskPercentage")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getInterTaskPercentage().push_back( get_real32( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "BatchRoutePlanResponse"){
+           BatchRoutePlanResponse* o = new BatchRoutePlanResponse();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ResponseID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setResponseID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleTiming")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getVehicleTiming().push_back( (afrl::impact::TaskTimingPair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskTimingPair"){
+           TaskTimingPair* o = new TaskTimingPair();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "InitialTaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setInitialTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "InitialTaskPercentage")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setInitialTaskPercentage( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "DestinationTaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDestinationTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TimeToGo")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeToGo( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "BatchSummaryRequest"){
+           BatchSummaryRequest* o = new BatchSummaryRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Vehicles")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getVehicles().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "TaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "InterTaskPercentage")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getInterTaskPercentage().push_back( get_real32( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "OperatingRegion")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setOperatingRegion( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "BatchSummaryResponse"){
+           BatchSummaryResponse* o = new BatchSummaryResponse();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ResponseID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setResponseID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Summaries")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getSummaries().push_back( (afrl::impact::TaskSummary*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskSummary"){
+           TaskSummary* o = new TaskSummary();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PerformingVehicles")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPerformingVehicles().push_back( (afrl::impact::VehicleSummary*) oo);
+                 }
+                 continue;
+              }
+              if(name == "BestEffort")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setBestEffort( get_real32( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "VehicleSummary"){
+           VehicleSummary* o = new VehicleSummary();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "DestinationTaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDestinationTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "InitialTaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setInitialTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "InitialTaskPercentage")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setInitialTaskPercentage( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "EstimateTimeToTaskPercentage")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEstimateTimeToTaskPercentage( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TimeToArrive")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeToArrive( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TimeOnTask")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeOnTask( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "EnergyRemaining")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEnergyRemaining( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "BeyondCommRange")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setBeyondCommRange( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "ImpactHeartbeat"){
+           ImpactHeartbeat* o = new ImpactHeartbeat();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ComponentLabel")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setComponentLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "HeartbeatTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHeartbeatTime( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "ImpactComponentJoin"){
+           ImpactComponentJoin* o = new ImpactComponentJoin();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ComponentLabel")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setComponentLabel( get_string( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "ImpactComponentLeave"){
+           ImpactComponentLeave* o = new ImpactComponentLeave();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ComponentLabel")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setComponentLabel( get_string( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "SpeedAltPair"){
+           SpeedAltPair* o = new SpeedAltPair();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Speed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Altitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "AltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "ImpactAutomationRequest"){
+           ImpactAutomationRequest* o = new ImpactAutomationRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TrialRequest")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setTrialRequest((afrl::cmasi::AutomationRequest*) oo );
+                 continue;
+              }
+              if(name == "OverridePlanningConditions")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getOverridePlanningConditions().push_back( (afrl::impact::SpeedAltPair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "PlayID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPlayID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "SolutionID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSolutionID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Sandbox")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSandbox( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "ImpactAutomationResponse"){
+           ImpactAutomationResponse* o = new ImpactAutomationResponse();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ResponseID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setResponseID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TrialResponse")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setTrialResponse((afrl::cmasi::AutomationResponse*) oo );
+                 continue;
+              }
+              if(name == "PlayID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPlayID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "SolutionID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSolutionID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Sandbox")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSandbox( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "Summaries")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getSummaries().push_back( (afrl::impact::TaskSummary*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "PointOfInterest"){
+           PointOfInterest* o = new PointOfInterest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "PointID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPointID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Location")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "LineOfInterest"){
+           LineOfInterest* o = new LineOfInterest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "LineID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLineID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Line")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getLine().push_back( (afrl::cmasi::Location3D*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "AreaOfInterest"){
+           AreaOfInterest* o = new AreaOfInterest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "AreaID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAreaID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Area")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setArea((afrl::cmasi::AbstractGeometry*) oo );
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "ImpactPointSearchTask"){
+           ImpactPointSearchTask* o = new ImpactPointSearchTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "SearchLocationID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSearchLocationID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "SearchLocation")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setSearchLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "StandoffDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStandoffDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ViewAngleList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getViewAngleList().push_back( (afrl::cmasi::Wedge*) oo);
+                 }
+                 continue;
+              }
+              if(name == "DesiredAction")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setDesiredAction((afrl::cmasi::LoiterAction*) oo );
+                 continue;
+              }
+              if(name == "DesiredWavelengthBands")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getDesiredWavelengthBands().push_back( afrl::cmasi::WavelengthBand::get_WavelengthBand(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "DwellTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDwellTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "GroundSampleDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundSampleDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "PatternSearchTask"){
+           PatternSearchTask* o = new PatternSearchTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "SearchLocationID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSearchLocationID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "SearchLocation")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setSearchLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "Pattern")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPattern( afrl::impact::AreaSearchPattern::get_AreaSearchPattern( get_string( tmp )));
+                 continue;
+              }
+              if(name == "Extent")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setExtent( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "DesiredWavelengthBands")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getDesiredWavelengthBands().push_back( afrl::cmasi::WavelengthBand::get_WavelengthBand(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "DwellTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDwellTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "GroundSampleDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundSampleDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "AngledAreaSearchTask"){
+           AngledAreaSearchTask* o = new AngledAreaSearchTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "SearchAreaID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSearchAreaID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "SweepAngle")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSweepAngle( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "StartPoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setStartPoint((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "DesiredWavelengthBands")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getDesiredWavelengthBands().push_back( afrl::cmasi::WavelengthBand::get_WavelengthBand(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "DwellTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDwellTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "GroundSampleDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundSampleDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "ImpactLineSearchTask"){
+           ImpactLineSearchTask* o = new ImpactLineSearchTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "LineID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLineID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "ViewAngleList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getViewAngleList().push_back( (afrl::cmasi::Wedge*) oo);
+                 }
+                 continue;
+              }
+              if(name == "UseInertialViewAngles")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setUseInertialViewAngles( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "DesiredWavelengthBands")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getDesiredWavelengthBands().push_back( afrl::cmasi::WavelengthBand::get_WavelengthBand(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "DwellTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDwellTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "GroundSampleDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundSampleDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "WatchTask"){
+           WatchTask* o = new WatchTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "WatchedEntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWatchedEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "DesiredWavelengthBands")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getDesiredWavelengthBands().push_back( afrl::cmasi::WavelengthBand::get_WavelengthBand(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "DwellTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDwellTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "GroundSampleDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundSampleDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "MultiVehicleWatchTask"){
+           MultiVehicleWatchTask* o = new MultiVehicleWatchTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "WatchedEntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWatchedEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "NumberVehicles")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNumberVehicles( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "DesiredWavelengthBands")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getDesiredWavelengthBands().push_back( afrl::cmasi::WavelengthBand::get_WavelengthBand(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "DwellTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDwellTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "GroundSampleDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundSampleDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "CommRelayTask"){
+           CommRelayTask* o = new CommRelayTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "SupportedEntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSupportedEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "DestinationLocation")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setDestinationLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "TowerID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTowerID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "CordonTask"){
+           CordonTask* o = new CordonTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "CordonLocation")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setCordonLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "StandoffDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStandoffDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "BlockadeTask"){
+           BlockadeTask* o = new BlockadeTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "BlockedEntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setBlockedEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "StandoffDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStandoffDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "NumberVehicles")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNumberVehicles( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "ProtectedLocation")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setProtectedLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "EscortTask"){
+           EscortTask* o = new EscortTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "SupportedEntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSupportedEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "RouteID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRouteID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PrescribedWaypoints")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPrescribedWaypoints().push_back( (afrl::cmasi::Waypoint*) oo);
+                 }
+                 continue;
+              }
+              if(name == "StandoffDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStandoffDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "DesiredWavelengthBands")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getDesiredWavelengthBands().push_back( afrl::cmasi::WavelengthBand::get_WavelengthBand(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "DwellTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDwellTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "GroundSampleDistance")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundSampleDistance( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "ConfigurationRequest"){
+           ConfigurationRequest* o = new ConfigurationRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getVehicleID().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "GroundVehicleConfiguration"){
+           GroundVehicleConfiguration* o = new GroundVehicleConfiguration();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RoadGraphID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRoadGraphID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "MinimumSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinimumSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaximumSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaximumSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "EnergyRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEnergyRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Affiliation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAffiliation( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EntityType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityType( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "NominalSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "NominalAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "NominalAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "PayloadConfigurationList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPayloadConfigurationList().push_back( (afrl::cmasi::PayloadConfiguration*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Info")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getInfo().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "GroundVehicleState"){
+           GroundVehicleState* o = new GroundVehicleState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "u")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setU( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "v")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setV( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "w")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setW( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "udot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setUdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "vdot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "wdot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Heading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHeading( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Pitch")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPitch( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Roll")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRoll( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "p")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setP( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "q")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setQ( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "r")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setR( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Course")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCourse( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Groundspeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundspeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Location")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "EnergyAvailable")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEnergyAvailable( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ActualEnergyRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setActualEnergyRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "PayloadStateList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPayloadStateList().push_back( (afrl::cmasi::PayloadState*) oo);
+                 }
+                 continue;
+              }
+              if(name == "CurrentWaypoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCurrentWaypoint( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "CurrentCommand")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCurrentCommand( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Mode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMode( afrl::cmasi::NavigationMode::get_NavigationMode( get_string( tmp )));
+                 continue;
+              }
+              if(name == "AssociatedTasks")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTasks().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "Time")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Info")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getInfo().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "WaterReport"){
+           WaterReport* o = new WaterReport();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Area")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setArea((afrl::cmasi::AbstractGeometry*) oo );
+                 continue;
+              }
+              if(name == "CurrentSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCurrentSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "CurrentDirection")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCurrentDirection( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "WaveDirection")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWaveDirection( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "WaveHeight")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWaveHeight( get_real32( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "WaterZone"){
+           WaterZone* o = new WaterZone();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ZoneID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setZoneID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "MinAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MinAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "MaxAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "AffectedAircraft")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAffectedAircraft().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "StartTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "EndTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEndTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Padding")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPadding( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Boundary")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setBoundary((afrl::cmasi::AbstractGeometry*) oo );
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "SurfaceVehicleConfiguration"){
+           SurfaceVehicleConfiguration* o = new SurfaceVehicleConfiguration();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "WaterArea")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWaterArea( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "MinimumSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMinimumSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaximumSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaximumSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "EnergyRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEnergyRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxBankAngle")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxBankAngle( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "MaxBankRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaxBankRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Affiliation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAffiliation( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EntityType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityType( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "NominalSpeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "NominalAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "NominalAltitudeType")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNominalAltitudeType( afrl::cmasi::AltitudeType::get_AltitudeType( get_string( tmp )));
+                 continue;
+              }
+              if(name == "PayloadConfigurationList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPayloadConfigurationList().push_back( (afrl::cmasi::PayloadConfiguration*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Info")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getInfo().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "SurfaceVehicleState"){
+           SurfaceVehicleState* o = new SurfaceVehicleState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "BankAngle")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setBankAngle( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Speed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSpeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "u")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setU( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "v")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setV( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "w")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setW( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "udot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setUdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "vdot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "wdot")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWdot( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Heading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHeading( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Pitch")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPitch( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Roll")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRoll( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "p")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setP( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "q")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setQ( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "r")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setR( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Course")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCourse( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Groundspeed")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGroundspeed( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Location")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "EnergyAvailable")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEnergyAvailable( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "ActualEnergyRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setActualEnergyRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "PayloadStateList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPayloadStateList().push_back( (afrl::cmasi::PayloadState*) oo);
+                 }
+                 continue;
+              }
+              if(name == "CurrentWaypoint")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCurrentWaypoint( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "CurrentCommand")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCurrentCommand( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Mode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMode( afrl::cmasi::NavigationMode::get_NavigationMode( get_string( tmp )));
+                 continue;
+              }
+              if(name == "AssociatedTasks")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedTasks().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "Time")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Info")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getInfo().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+
+
+         return NULL;
+        
+    }
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/IMPACTXMLReader.h b/src/LMCP/afrl/impact/IMPACTXMLReader.h
new file mode 100644
index 0000000..71bcc6b
--- /dev/null
+++ b/src/LMCP/afrl/impact/IMPACTXMLReader.h
@@ -0,0 +1,45 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef IMPACT_SERIESXMLREADER_H_
+#define IMPACT_SERIESXMLREADER_H_
+
+#include "avtas/lmcp/Object.h"
+#include "avtas/lmcp/Node.h"
+#include "avtas/lmcp/NodeUtil.h"
+
+#include <iostream>
+
+
+using namespace avtas::lmcp;
+
+namespace afrl {
+namespace impact {
+
+
+class SeriesXMLReader {
+
+    /** reads an LMCP XML Storage file and returns a list of LMCPObjects */
+    public:
+
+        SeriesXMLReader(void) {}
+
+        virtual ~SeriesXMLReader(){}  
+
+        static avtas::lmcp::Object * visitType(avtas::lmcp::Node* el );
+
+};
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif 
diff --git a/src/LMCP/afrl/impact/ImpactAutomationRequest.h b/src/LMCP/afrl/impact/ImpactAutomationRequest.h
new file mode 100644
index 0000000..5cee527
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactAutomationRequest.h
@@ -0,0 +1,138 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_IMPACTAUTOMATIONREQUEST_H_
+#define _AFRL_IMPACT_IMPACTAUTOMATIONREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AutomationRequest.h"
+#include "afrl/impact/SpeedAltPair.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isImpactAutomationRequest(avtas::lmcp::Object* obj);
+   bool isImpactAutomationRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > ImpactAutomationRequestDescendants();
+   
+   class ImpactAutomationRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      ImpactAutomationRequest(void);
+
+      // Copy Constructor
+      ImpactAutomationRequest(const ImpactAutomationRequest &that);
+
+      // Assignment Operator
+      ImpactAutomationRequest & operator=(const ImpactAutomationRequest &that);
+
+      // Destructor
+      virtual ~ImpactAutomationRequest(void);
+
+      // Equals overload
+      bool operator==(const ImpactAutomationRequest & that);
+      bool operator!=(const ImpactAutomationRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual ImpactAutomationRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 20; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Request ID for correlating with response (Units: None)*/
+      int64_t getRequestID(void) const { return __RequestID; }
+      ImpactAutomationRequest& setRequestID(const int64_t val);
+
+      /** Standard CMASI Automation request (Units: None)*/
+      afrl::cmasi::AutomationRequest* const getTrialRequest(void) { return __TrialRequest; }
+      ImpactAutomationRequest& setTrialRequest(const afrl::cmasi::AutomationRequest* const val);
+
+      /** Override nominal speed/alt. If a vehicle is not in list, its nominal speed/alt is used (Units: None)*/
+      std::vector<afrl::impact::SpeedAltPair*> & getOverridePlanningConditions(void) { return __OverridePlanningConditions; }
+
+      /** Associated play ID (Units: None)*/
+      int64_t getPlayID(void) const { return __PlayID; }
+      ImpactAutomationRequest& setPlayID(const int64_t val);
+
+      /** Associated solution ID (Units: None)*/
+      int64_t getSolutionID(void) const { return __SolutionID; }
+      ImpactAutomationRequest& setSolutionID(const int64_t val);
+
+      /** Flag indicating 'sandbox', i.e. not to be implemented (Units: None)*/
+      bool getSandbox(void) const { return __Sandbox; }
+      ImpactAutomationRequest& setSandbox(const bool val);
+
+
+
+   protected:
+      /** Request ID for correlating with response */
+      int64_t __RequestID;
+      /** Standard CMASI Automation request */
+      afrl::cmasi::AutomationRequest* __TrialRequest;
+      /** Override nominal speed/alt. If a vehicle is not in list, its nominal speed/alt is used */
+      std::vector< afrl::impact::SpeedAltPair* > __OverridePlanningConditions;
+      /** Associated play ID */
+      int64_t __PlayID;
+      /** Associated solution ID */
+      int64_t __SolutionID;
+      /** Flag indicating 'sandbox', i.e. not to be implemented */
+      bool __Sandbox;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_IMPACTAUTOMATIONREQUEST_H_
diff --git a/src/LMCP/afrl/impact/ImpactAutomationRequestDescendants.h b/src/LMCP/afrl/impact/ImpactAutomationRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactAutomationRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/ImpactAutomationResponse.h b/src/LMCP/afrl/impact/ImpactAutomationResponse.h
new file mode 100644
index 0000000..375aa76
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactAutomationResponse.h
@@ -0,0 +1,138 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_IMPACTAUTOMATIONRESPONSE_H_
+#define _AFRL_IMPACT_IMPACTAUTOMATIONRESPONSE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AutomationResponse.h"
+#include "afrl/impact/TaskSummary.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isImpactAutomationResponse(avtas::lmcp::Object* obj);
+   bool isImpactAutomationResponse(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > ImpactAutomationResponseDescendants();
+   
+   class ImpactAutomationResponse : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      ImpactAutomationResponse(void);
+
+      // Copy Constructor
+      ImpactAutomationResponse(const ImpactAutomationResponse &that);
+
+      // Assignment Operator
+      ImpactAutomationResponse & operator=(const ImpactAutomationResponse &that);
+
+      // Destructor
+      virtual ~ImpactAutomationResponse(void);
+
+      // Equals overload
+      bool operator==(const ImpactAutomationResponse & that);
+      bool operator!=(const ImpactAutomationResponse & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual ImpactAutomationResponse* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 21; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Response ID matching request from ({@link ImpactAutomationRequest}) (Units: None)*/
+      int64_t getResponseID(void) const { return __ResponseID; }
+      ImpactAutomationResponse& setResponseID(const int64_t val);
+
+      /** Automation response from the request (Units: None)*/
+      afrl::cmasi::AutomationResponse* const getTrialResponse(void) { return __TrialResponse; }
+      ImpactAutomationResponse& setTrialResponse(const afrl::cmasi::AutomationResponse* const val);
+
+      /** Associated play ID (Units: None)*/
+      int64_t getPlayID(void) const { return __PlayID; }
+      ImpactAutomationResponse& setPlayID(const int64_t val);
+
+      /** Associated solution ID (Units: None)*/
+      int64_t getSolutionID(void) const { return __SolutionID; }
+      ImpactAutomationResponse& setSolutionID(const int64_t val);
+
+      /** Flag indicating 'sandbox', i.e. not to be implemented (Units: None)*/
+      bool getSandbox(void) const { return __Sandbox; }
+      ImpactAutomationResponse& setSandbox(const bool val);
+
+      /** Set of vehicle-to-task summaries that will be implemented by this automation response. Including timing, communication, and remaining energy (Units: None)*/
+      std::vector<afrl::impact::TaskSummary*> & getSummaries(void) { return __Summaries; }
+
+
+
+   protected:
+      /** Response ID matching request from ({@link ImpactAutomationRequest}) */
+      int64_t __ResponseID;
+      /** Automation response from the request */
+      afrl::cmasi::AutomationResponse* __TrialResponse;
+      /** Associated play ID */
+      int64_t __PlayID;
+      /** Associated solution ID */
+      int64_t __SolutionID;
+      /** Flag indicating 'sandbox', i.e. not to be implemented */
+      bool __Sandbox;
+      /** Set of vehicle-to-task summaries that will be implemented by this automation response. Including timing, communication, and remaining energy */
+      std::vector< afrl::impact::TaskSummary* > __Summaries;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_IMPACTAUTOMATIONRESPONSE_H_
diff --git a/src/LMCP/afrl/impact/ImpactAutomationResponseDescendants.h b/src/LMCP/afrl/impact/ImpactAutomationResponseDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactAutomationResponseDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/ImpactComponentJoin.h b/src/LMCP/afrl/impact/ImpactComponentJoin.h
new file mode 100644
index 0000000..a4470dd
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactComponentJoin.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_IMPACTCOMPONENTJOIN_H_
+#define _AFRL_IMPACT_IMPACTCOMPONENTJOIN_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isImpactComponentJoin(avtas::lmcp::Object* obj);
+   bool isImpactComponentJoin(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > ImpactComponentJoinDescendants();
+   
+   class ImpactComponentJoin : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      ImpactComponentJoin(void);
+
+      // Copy Constructor
+      ImpactComponentJoin(const ImpactComponentJoin &that);
+
+      // Assignment Operator
+      ImpactComponentJoin & operator=(const ImpactComponentJoin &that);
+
+      // Destructor
+      virtual ~ImpactComponentJoin(void);
+
+      // Equals overload
+      bool operator==(const ImpactComponentJoin & that);
+      bool operator!=(const ImpactComponentJoin & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual ImpactComponentJoin* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 17; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Label of component joining network (Units: None)*/
+      std::string getComponentLabel(void) const { return __ComponentLabel; }
+      ImpactComponentJoin& setComponentLabel(const std::string val);
+
+
+
+   protected:
+      /** Label of component joining network */
+      std::string __ComponentLabel;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_IMPACTCOMPONENTJOIN_H_
diff --git a/src/LMCP/afrl/impact/ImpactComponentJoinDescendants.h b/src/LMCP/afrl/impact/ImpactComponentJoinDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactComponentJoinDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/ImpactComponentLeave.h b/src/LMCP/afrl/impact/ImpactComponentLeave.h
new file mode 100644
index 0000000..28ee497
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactComponentLeave.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_IMPACTCOMPONENTLEAVE_H_
+#define _AFRL_IMPACT_IMPACTCOMPONENTLEAVE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isImpactComponentLeave(avtas::lmcp::Object* obj);
+   bool isImpactComponentLeave(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > ImpactComponentLeaveDescendants();
+   
+   class ImpactComponentLeave : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      ImpactComponentLeave(void);
+
+      // Copy Constructor
+      ImpactComponentLeave(const ImpactComponentLeave &that);
+
+      // Assignment Operator
+      ImpactComponentLeave & operator=(const ImpactComponentLeave &that);
+
+      // Destructor
+      virtual ~ImpactComponentLeave(void);
+
+      // Equals overload
+      bool operator==(const ImpactComponentLeave & that);
+      bool operator!=(const ImpactComponentLeave & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual ImpactComponentLeave* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 18; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Label of component leaving network (Units: None)*/
+      std::string getComponentLabel(void) const { return __ComponentLabel; }
+      ImpactComponentLeave& setComponentLabel(const std::string val);
+
+
+
+   protected:
+      /** Label of component leaving network */
+      std::string __ComponentLabel;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_IMPACTCOMPONENTLEAVE_H_
diff --git a/src/LMCP/afrl/impact/ImpactComponentLeaveDescendants.h b/src/LMCP/afrl/impact/ImpactComponentLeaveDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactComponentLeaveDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/ImpactHeartbeat.h b/src/LMCP/afrl/impact/ImpactHeartbeat.h
new file mode 100644
index 0000000..fb1668a
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactHeartbeat.h
@@ -0,0 +1,112 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_IMPACTHEARTBEAT_H_
+#define _AFRL_IMPACT_IMPACTHEARTBEAT_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isImpactHeartbeat(avtas::lmcp::Object* obj);
+   bool isImpactHeartbeat(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > ImpactHeartbeatDescendants();
+   
+   class ImpactHeartbeat : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      ImpactHeartbeat(void);
+
+      // Copy Constructor
+      ImpactHeartbeat(const ImpactHeartbeat &that);
+
+      // Assignment Operator
+      ImpactHeartbeat & operator=(const ImpactHeartbeat &that);
+
+      // Destructor
+      virtual ~ImpactHeartbeat(void);
+
+      // Equals overload
+      bool operator==(const ImpactHeartbeat & that);
+      bool operator!=(const ImpactHeartbeat & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual ImpactHeartbeat* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 16; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Label of system component sending heartbeat (Units: None)*/
+      std::string getComponentLabel(void) const { return __ComponentLabel; }
+      ImpactHeartbeat& setComponentLabel(const std::string val);
+
+      /** Time at which this heatbeat was sent (milliseconds since 1 Jan 1970 00:00 GMT) (Units: milliseconds)*/
+      int64_t getHeartbeatTime(void) const { return __HeartbeatTime; }
+      ImpactHeartbeat& setHeartbeatTime(const int64_t val);
+
+
+
+   protected:
+      /** Label of system component sending heartbeat */
+      std::string __ComponentLabel;
+      /** Time at which this heatbeat was sent (milliseconds since 1 Jan 1970 00:00 GMT) */
+      int64_t __HeartbeatTime;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_IMPACTHEARTBEAT_H_
diff --git a/src/LMCP/afrl/impact/ImpactHeartbeatDescendants.h b/src/LMCP/afrl/impact/ImpactHeartbeatDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactHeartbeatDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/ImpactLineSearchTask.h b/src/LMCP/afrl/impact/ImpactLineSearchTask.h
new file mode 100644
index 0000000..0ff83c9
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactLineSearchTask.h
@@ -0,0 +1,119 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_IMPACTLINESEARCHTASK_H_
+#define _AFRL_IMPACT_IMPACTLINESEARCHTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/Wedge.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isImpactLineSearchTask(avtas::lmcp::Object* obj);
+   bool isImpactLineSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > ImpactLineSearchTaskDescendants();
+   
+   class ImpactLineSearchTask : public afrl::cmasi::SearchTask {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      ImpactLineSearchTask(void);
+
+      // Copy Constructor
+      ImpactLineSearchTask(const ImpactLineSearchTask &that);
+
+      // Assignment Operator
+      ImpactLineSearchTask & operator=(const ImpactLineSearchTask &that);
+
+      // Destructor
+      virtual ~ImpactLineSearchTask(void);
+
+      // Equals overload
+      bool operator==(const ImpactLineSearchTask & that);
+      bool operator!=(const ImpactLineSearchTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual ImpactLineSearchTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 28; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** ID of line to search (from available lines of interest) (Units: None)*/
+      int64_t getLineID(void) const { return __LineID; }
+      ImpactLineSearchTask& setLineID(const int64_t val);
+
+      /** Defines a list of acceptable look-angles for this task. See the documentation above for details. (Units: None)*/
+      std::vector<afrl::cmasi::Wedge*> & getViewAngleList(void) { return __ViewAngleList; }
+
+      /** If true, the ViewAngleList specifies inertial (North-East) angles. See documentation above. (Units: None)*/
+      bool getUseInertialViewAngles(void) const { return __UseInertialViewAngles; }
+      ImpactLineSearchTask& setUseInertialViewAngles(const bool val);
+
+
+
+   protected:
+      /** ID of line to search (from available lines of interest) */
+      int64_t __LineID;
+      /** Defines a list of acceptable look-angles for this task. See the documentation above for details. */
+      std::vector< afrl::cmasi::Wedge* > __ViewAngleList;
+      /** If true, the ViewAngleList specifies inertial (North-East) angles. See documentation above. */
+      bool __UseInertialViewAngles;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_IMPACTLINESEARCHTASK_H_
diff --git a/src/LMCP/afrl/impact/ImpactLineSearchTaskDescendants.h b/src/LMCP/afrl/impact/ImpactLineSearchTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactLineSearchTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/ImpactPayloadConfiguration.h b/src/LMCP/afrl/impact/ImpactPayloadConfiguration.h
new file mode 100644
index 0000000..5eb5902
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactPayloadConfiguration.h
@@ -0,0 +1,107 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_IMPACTPAYLOADCONFIGURATION_H_
+#define _AFRL_IMPACT_IMPACTPAYLOADCONFIGURATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/PayloadConfiguration.h"
+#include "afrl/impact/ImpactPayloadType.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isImpactPayloadConfiguration(avtas::lmcp::Object* obj);
+   bool isImpactPayloadConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > ImpactPayloadConfigurationDescendants();
+   
+   class ImpactPayloadConfiguration : public afrl::cmasi::PayloadConfiguration {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      ImpactPayloadConfiguration(void);
+
+      // Copy Constructor
+      ImpactPayloadConfiguration(const ImpactPayloadConfiguration &that);
+
+      // Assignment Operator
+      ImpactPayloadConfiguration & operator=(const ImpactPayloadConfiguration &that);
+
+      // Destructor
+      virtual ~ImpactPayloadConfiguration(void);
+
+      // Equals overload
+      bool operator==(const ImpactPayloadConfiguration & that);
+      bool operator!=(const ImpactPayloadConfiguration & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual ImpactPayloadConfiguration* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 6; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Payloads available for this entity (Units: None)*/
+      std::vector<afrl::impact::ImpactPayloadType::ImpactPayloadType> & getAvailablePayloads(void) { return __AvailablePayloads; }
+
+
+
+   protected:
+      /** Payloads available for this entity */
+      std::vector< afrl::impact::ImpactPayloadType::ImpactPayloadType > __AvailablePayloads;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_IMPACTPAYLOADCONFIGURATION_H_
diff --git a/src/LMCP/afrl/impact/ImpactPayloadConfigurationDescendants.h b/src/LMCP/afrl/impact/ImpactPayloadConfigurationDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactPayloadConfigurationDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/ImpactPayloadType.h b/src/LMCP/afrl/impact/ImpactPayloadType.h
new file mode 100644
index 0000000..d29077e
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactPayloadType.h
@@ -0,0 +1,128 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_IMPACTPAYLOADTYPE_H_
+#define _AFRL_IMPACT_IMPACTPAYLOADTYPE_H_
+
+#include <string>
+
+namespace afrl {
+namespace impact {
+
+
+
+   namespace ImpactPayloadType {
+   enum ImpactPayloadType {
+       /**  Unknown  */
+       Unknown = 0,
+       /**  EO  */
+       EO = 1,
+       /**  Forward Looking Infra Red  */
+       FLIR = 2,
+       /**  Mid Wave Infra Red  */
+       MWIR = 3,
+       /**  LFIR  */
+       LFIR = 4,
+       /**  Auto-tracking payload  */
+       Track = 5,
+       /**  Placement of physical tag for tracking  */
+       Tag = 6,
+       /**  Megaphone  */
+       Megaphone = 7,
+       /**  Siren  */
+       Siren = 8,
+       /**  Search Light  */
+       SearchLight = 9,
+       /**  Browning .50 caliber weapon  */
+       FiftyCal = 10,
+       /**  M240B  */
+       M240B = 11,
+       /**  Flashbang  */
+       Flashbang = 12,
+       /**  Tear Gas  */
+       TearGas = 13,
+       /**  Taser  */
+       Taser = 14,
+       /**  Heat Beam  */
+       HeatBeam = 15,
+       /**  Scan Eagle Guided Munition  */
+       SEGM = 16,
+       /**  Comm Relay  */
+       CommRelay = 17,
+       /**  Ground Moving Target Indicator  */
+       GMTI = 18,
+       /**  Laser Designator  */
+       LaserDesignator = 19
+
+   };
+
+   // generates a new ImpactPayloadType value for the passed string
+   inline ImpactPayloadType get_ImpactPayloadType(std::string str) {
+       if ( str == "Unknown") return Unknown;
+       if ( str == "EO") return EO;
+       if ( str == "FLIR") return FLIR;
+       if ( str == "MWIR") return MWIR;
+       if ( str == "LFIR") return LFIR;
+       if ( str == "Track") return Track;
+       if ( str == "Tag") return Tag;
+       if ( str == "Megaphone") return Megaphone;
+       if ( str == "Siren") return Siren;
+       if ( str == "SearchLight") return SearchLight;
+       if ( str == "FiftyCal") return FiftyCal;
+       if ( str == "M240B") return M240B;
+       if ( str == "Flashbang") return Flashbang;
+       if ( str == "TearGas") return TearGas;
+       if ( str == "Taser") return Taser;
+       if ( str == "HeatBeam") return HeatBeam;
+       if ( str == "SEGM") return SEGM;
+       if ( str == "CommRelay") return CommRelay;
+       if ( str == "GMTI") return GMTI;
+       if ( str == "LaserDesignator") return LaserDesignator;
+        return Unknown;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(ImpactPayloadType e) {
+       switch(e) {
+        case Unknown: return "Unknown";
+        case EO: return "EO";
+        case FLIR: return "FLIR";
+        case MWIR: return "MWIR";
+        case LFIR: return "LFIR";
+        case Track: return "Track";
+        case Tag: return "Tag";
+        case Megaphone: return "Megaphone";
+        case Siren: return "Siren";
+        case SearchLight: return "SearchLight";
+        case FiftyCal: return "FiftyCal";
+        case M240B: return "M240B";
+        case Flashbang: return "Flashbang";
+        case TearGas: return "TearGas";
+        case Taser: return "Taser";
+        case HeatBeam: return "HeatBeam";
+        case SEGM: return "SEGM";
+        case CommRelay: return "CommRelay";
+        case GMTI: return "GMTI";
+        case LaserDesignator: return "LaserDesignator";
+        default: return "Unknown";
+
+       }
+   }
+
+   }  // namespace ImpactPayloadType
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_IMPACTPAYLOADTYPE_H_
diff --git a/src/LMCP/afrl/impact/ImpactPointSearchTask.h b/src/LMCP/afrl/impact/ImpactPointSearchTask.h
new file mode 100644
index 0000000..25c459f
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactPointSearchTask.h
@@ -0,0 +1,133 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_IMPACTPOINTSEARCHTASK_H_
+#define _AFRL_IMPACT_IMPACTPOINTSEARCHTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/Location3D.h"
+#include "afrl/cmasi/Wedge.h"
+#include "afrl/cmasi/LoiterAction.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isImpactPointSearchTask(avtas::lmcp::Object* obj);
+   bool isImpactPointSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > ImpactPointSearchTaskDescendants();
+   
+   class ImpactPointSearchTask : public afrl::cmasi::SearchTask {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      ImpactPointSearchTask(void);
+
+      // Copy Constructor
+      ImpactPointSearchTask(const ImpactPointSearchTask &that);
+
+      // Assignment Operator
+      ImpactPointSearchTask & operator=(const ImpactPointSearchTask &that);
+
+      // Destructor
+      virtual ~ImpactPointSearchTask(void);
+
+      // Equals overload
+      bool operator==(const ImpactPointSearchTask & that);
+      bool operator!=(const ImpactPointSearchTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual ImpactPointSearchTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 25; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Point to search (from available points of interest). Only valid if ID is non-zero (Units: None)*/
+      int64_t getSearchLocationID(void) const { return __SearchLocationID; }
+      ImpactPointSearchTask& setSearchLocationID(const int64_t val);
+
+      /** If search location ID is zero, then use direct coordinates (Units: None)*/
+      afrl::cmasi::Location3D* const getSearchLocation(void) { return __SearchLocation; }
+      ImpactPointSearchTask& setSearchLocation(const afrl::cmasi::Location3D* const val);
+
+      /**Minimum distance that an aircraft must maintain from the point of interest. (Units: meter)*/
+      float getStandoffDistance(void) const { return __StandoffDistance; }
+      ImpactPointSearchTask& setStandoffDistance(const float val);
+
+      /** A list of acceptable look-angles for this task. Each wedge is defined relative to true North. To be a valid look angle, a sensor must be looking from a direction within the bounds of the wedge. (Units: None)*/
+      std::vector<afrl::cmasi::Wedge*> & getViewAngleList(void) { return __ViewAngleList; }
+
+      /** Loiter action to complete to fulfill task. If null, then simply points camera but main trajectory does not change. Otherwise, completes the specified loiter action. (Units: None)*/
+      afrl::cmasi::LoiterAction* const getDesiredAction(void) { return __DesiredAction; }
+      ImpactPointSearchTask& setDesiredAction(const afrl::cmasi::LoiterAction* const val);
+
+
+
+   protected:
+      /** Point to search (from available points of interest). Only valid if ID is non-zero */
+      int64_t __SearchLocationID;
+      /** If search location ID is zero, then use direct coordinates */
+      afrl::cmasi::Location3D* __SearchLocation;
+      /**Minimum distance that an aircraft must maintain from the point of interest. */
+      float __StandoffDistance;
+      /** A list of acceptable look-angles for this task. Each wedge is defined relative to true North. To be a valid look angle, a sensor must be looking from a direction within the bounds of the wedge. */
+      std::vector< afrl::cmasi::Wedge* > __ViewAngleList;
+      /** Loiter action to complete to fulfill task. If null, then simply points camera but main trajectory does not change. Otherwise, completes the specified loiter action. */
+      afrl::cmasi::LoiterAction* __DesiredAction;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_IMPACTPOINTSEARCHTASK_H_
diff --git a/src/LMCP/afrl/impact/ImpactPointSearchTaskDescendants.h b/src/LMCP/afrl/impact/ImpactPointSearchTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/ImpactPointSearchTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/LineOfInterest.h b/src/LMCP/afrl/impact/LineOfInterest.h
new file mode 100644
index 0000000..52af29d
--- /dev/null
+++ b/src/LMCP/afrl/impact/LineOfInterest.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_LINEOFINTEREST_H_
+#define _AFRL_IMPACT_LINEOFINTEREST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isLineOfInterest(avtas::lmcp::Object* obj);
+   bool isLineOfInterest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > LineOfInterestDescendants();
+   
+   class LineOfInterest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      LineOfInterest(void);
+
+      // Copy Constructor
+      LineOfInterest(const LineOfInterest &that);
+
+      // Assignment Operator
+      LineOfInterest & operator=(const LineOfInterest &that);
+
+      // Destructor
+      virtual ~LineOfInterest(void);
+
+      // Equals overload
+      bool operator==(const LineOfInterest & that);
+      bool operator!=(const LineOfInterest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual LineOfInterest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 23; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** ID for lines of interest (Units: None)*/
+      int64_t getLineID(void) const { return __LineID; }
+      LineOfInterest& setLineID(const int64_t val);
+
+      /** List of points to search (Units: None)*/
+      std::vector<afrl::cmasi::Location3D*> & getLine(void) { return __Line; }
+
+
+
+   protected:
+      /** ID for lines of interest */
+      int64_t __LineID;
+      /** List of points to search */
+      std::vector< afrl::cmasi::Location3D* > __Line;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_LINEOFINTEREST_H_
diff --git a/src/LMCP/afrl/impact/LineOfInterestDescendants.h b/src/LMCP/afrl/impact/LineOfInterestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/LineOfInterestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/MultiVehicleWatchTask.h b/src/LMCP/afrl/impact/MultiVehicleWatchTask.h
new file mode 100644
index 0000000..5f067f3
--- /dev/null
+++ b/src/LMCP/afrl/impact/MultiVehicleWatchTask.h
@@ -0,0 +1,112 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_MULTIVEHICLEWATCHTASK_H_
+#define _AFRL_IMPACT_MULTIVEHICLEWATCHTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/SearchTask.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isMultiVehicleWatchTask(avtas::lmcp::Object* obj);
+   bool isMultiVehicleWatchTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > MultiVehicleWatchTaskDescendants();
+   
+   class MultiVehicleWatchTask : public afrl::cmasi::SearchTask {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      MultiVehicleWatchTask(void);
+
+      // Copy Constructor
+      MultiVehicleWatchTask(const MultiVehicleWatchTask &that);
+
+      // Assignment Operator
+      MultiVehicleWatchTask & operator=(const MultiVehicleWatchTask &that);
+
+      // Destructor
+      virtual ~MultiVehicleWatchTask(void);
+
+      // Equals overload
+      bool operator==(const MultiVehicleWatchTask & that);
+      bool operator!=(const MultiVehicleWatchTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual MultiVehicleWatchTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 30; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Entity ID to follow and watch (Units: None)*/
+      int64_t getWatchedEntityID(void) const { return __WatchedEntityID; }
+      MultiVehicleWatchTask& setWatchedEntityID(const int64_t val);
+
+      /** Number of vehicles to simultaneously overwatch the target (Units: None)*/
+      uint8_t getNumberVehicles(void) const { return __NumberVehicles; }
+      MultiVehicleWatchTask& setNumberVehicles(const uint8_t val);
+
+
+
+   protected:
+      /** Entity ID to follow and watch */
+      int64_t __WatchedEntityID;
+      /** Number of vehicles to simultaneously overwatch the target */
+      uint8_t __NumberVehicles;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_MULTIVEHICLEWATCHTASK_H_
diff --git a/src/LMCP/afrl/impact/MultiVehicleWatchTaskDescendants.h b/src/LMCP/afrl/impact/MultiVehicleWatchTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/MultiVehicleWatchTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/PatternSearchTask.h b/src/LMCP/afrl/impact/PatternSearchTask.h
new file mode 100644
index 0000000..990aaa7
--- /dev/null
+++ b/src/LMCP/afrl/impact/PatternSearchTask.h
@@ -0,0 +1,126 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_PATTERNSEARCHTASK_H_
+#define _AFRL_IMPACT_PATTERNSEARCHTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/Location3D.h"
+#include "afrl/impact/AreaSearchPattern.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isPatternSearchTask(avtas::lmcp::Object* obj);
+   bool isPatternSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > PatternSearchTaskDescendants();
+   
+   class PatternSearchTask : public afrl::cmasi::SearchTask {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      PatternSearchTask(void);
+
+      // Copy Constructor
+      PatternSearchTask(const PatternSearchTask &that);
+
+      // Assignment Operator
+      PatternSearchTask & operator=(const PatternSearchTask &that);
+
+      // Destructor
+      virtual ~PatternSearchTask(void);
+
+      // Equals overload
+      bool operator==(const PatternSearchTask & that);
+      bool operator!=(const PatternSearchTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual PatternSearchTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 26; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Point at which to search is centered (from available points of interest) (Units: None)*/
+      int64_t getSearchLocationID(void) const { return __SearchLocationID; }
+      PatternSearchTask& setSearchLocationID(const int64_t val);
+
+      /** If search search location ID is zero, then use direct coordinates (Units: None)*/
+      afrl::cmasi::Location3D* const getSearchLocation(void) { return __SearchLocation; }
+      PatternSearchTask& setSearchLocation(const afrl::cmasi::Location3D* const val);
+
+      /** Search pattern to use (Units: None)*/
+      afrl::impact::AreaSearchPattern::AreaSearchPattern getPattern(void) const { return __Pattern; }
+      PatternSearchTask& setPattern(const afrl::impact::AreaSearchPattern::AreaSearchPattern val);
+
+      /** Pattern extent (Units: meters)*/
+      float getExtent(void) const { return __Extent; }
+      PatternSearchTask& setExtent(const float val);
+
+
+
+   protected:
+      /** Point at which to search is centered (from available points of interest) */
+      int64_t __SearchLocationID;
+      /** If search search location ID is zero, then use direct coordinates */
+      afrl::cmasi::Location3D* __SearchLocation;
+      /** Search pattern to use */
+      afrl::impact::AreaSearchPattern::AreaSearchPattern __Pattern;
+      /** Pattern extent */
+      float __Extent;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_PATTERNSEARCHTASK_H_
diff --git a/src/LMCP/afrl/impact/PatternSearchTaskDescendants.h b/src/LMCP/afrl/impact/PatternSearchTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/PatternSearchTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/PointOfInterest.h b/src/LMCP/afrl/impact/PointOfInterest.h
new file mode 100644
index 0000000..4c3cfab
--- /dev/null
+++ b/src/LMCP/afrl/impact/PointOfInterest.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_POINTOFINTEREST_H_
+#define _AFRL_IMPACT_POINTOFINTEREST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isPointOfInterest(avtas::lmcp::Object* obj);
+   bool isPointOfInterest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > PointOfInterestDescendants();
+   
+   class PointOfInterest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      PointOfInterest(void);
+
+      // Copy Constructor
+      PointOfInterest(const PointOfInterest &that);
+
+      // Assignment Operator
+      PointOfInterest & operator=(const PointOfInterest &that);
+
+      // Destructor
+      virtual ~PointOfInterest(void);
+
+      // Equals overload
+      bool operator==(const PointOfInterest & that);
+      bool operator!=(const PointOfInterest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual PointOfInterest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 22; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** ID for points of interest (Units: None)*/
+      int64_t getPointID(void) const { return __PointID; }
+      PointOfInterest& setPointID(const int64_t val);
+
+      /** Point of interest location (Units: None)*/
+      afrl::cmasi::Location3D* const getLocation(void) { return __Location; }
+      PointOfInterest& setLocation(const afrl::cmasi::Location3D* const val);
+
+
+
+   protected:
+      /** ID for points of interest */
+      int64_t __PointID;
+      /** Point of interest location */
+      afrl::cmasi::Location3D* __Location;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_POINTOFINTEREST_H_
diff --git a/src/LMCP/afrl/impact/PointOfInterestDescendants.h b/src/LMCP/afrl/impact/PointOfInterestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/PointOfInterestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/PowerConfiguration.h b/src/LMCP/afrl/impact/PowerConfiguration.h
new file mode 100644
index 0000000..21d0b2e
--- /dev/null
+++ b/src/LMCP/afrl/impact/PowerConfiguration.h
@@ -0,0 +1,107 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_POWERCONFIGURATION_H_
+#define _AFRL_IMPACT_POWERCONFIGURATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/PayloadConfiguration.h"
+#include "afrl/impact/PowerPlant.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isPowerConfiguration(avtas::lmcp::Object* obj);
+   bool isPowerConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > PowerConfigurationDescendants();
+   
+   class PowerConfiguration : public afrl::cmasi::PayloadConfiguration {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      PowerConfiguration(void);
+
+      // Copy Constructor
+      PowerConfiguration(const PowerConfiguration &that);
+
+      // Assignment Operator
+      PowerConfiguration & operator=(const PowerConfiguration &that);
+
+      // Destructor
+      virtual ~PowerConfiguration(void);
+
+      // Equals overload
+      bool operator==(const PowerConfiguration & that);
+      bool operator!=(const PowerConfiguration & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual PowerConfiguration* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 1; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Power generation system (used for acoustic signature) (Units: None)*/
+      afrl::impact::PowerPlant::PowerPlant getNominalPowerConfiguration(void) const { return __NominalPowerConfiguration; }
+      PowerConfiguration& setNominalPowerConfiguration(const afrl::impact::PowerPlant::PowerPlant val);
+
+
+
+   protected:
+      /** Power generation system (used for acoustic signature) */
+      afrl::impact::PowerPlant::PowerPlant __NominalPowerConfiguration;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_POWERCONFIGURATION_H_
diff --git a/src/LMCP/afrl/impact/PowerConfigurationDescendants.h b/src/LMCP/afrl/impact/PowerConfigurationDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/PowerConfigurationDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/PowerPlant.h b/src/LMCP/afrl/impact/PowerPlant.h
new file mode 100644
index 0000000..2a9f9b6
--- /dev/null
+++ b/src/LMCP/afrl/impact/PowerPlant.h
@@ -0,0 +1,68 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_POWERPLANT_H_
+#define _AFRL_IMPACT_POWERPLANT_H_
+
+#include <string>
+
+namespace afrl {
+namespace impact {
+
+
+
+   namespace PowerPlant {
+   enum PowerPlant {
+       /**  Conventional gasoline  */
+       Gasoline = 0,
+       /**  Heavy Fuel (JP5)  */
+       JP5 = 1,
+       /**  Heavy Fuel (JP8)  */
+       JP8 = 2,
+       /**  Fuel Cell (Hydrogen)  */
+       FuelCell = 3,
+       /**  Hybrid electric/gasoline  */
+       Hybrid = 4
+
+   };
+
+   // generates a new PowerPlant value for the passed string
+   inline PowerPlant get_PowerPlant(std::string str) {
+       if ( str == "Gasoline") return Gasoline;
+       if ( str == "JP5") return JP5;
+       if ( str == "JP8") return JP8;
+       if ( str == "FuelCell") return FuelCell;
+       if ( str == "Hybrid") return Hybrid;
+        return Gasoline;
+
+   }
+
+
+   // generates a string value for the given enum
+   inline std::string get_string(PowerPlant e) {
+       switch(e) {
+        case Gasoline: return "Gasoline";
+        case JP5: return "JP5";
+        case JP8: return "JP8";
+        case FuelCell: return "FuelCell";
+        case Hybrid: return "Hybrid";
+        default: return "Gasoline";
+
+       }
+   }
+
+   }  // namespace PowerPlant
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_POWERPLANT_H_
diff --git a/src/LMCP/afrl/impact/PowerPlantState.h b/src/LMCP/afrl/impact/PowerPlantState.h
new file mode 100644
index 0000000..c7ff7d2
--- /dev/null
+++ b/src/LMCP/afrl/impact/PowerPlantState.h
@@ -0,0 +1,107 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_POWERPLANTSTATE_H_
+#define _AFRL_IMPACT_POWERPLANTSTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/PayloadState.h"
+#include "afrl/impact/PowerPlant.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isPowerPlantState(avtas::lmcp::Object* obj);
+   bool isPowerPlantState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > PowerPlantStateDescendants();
+   
+   class PowerPlantState : public afrl::cmasi::PayloadState {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      PowerPlantState(void);
+
+      // Copy Constructor
+      PowerPlantState(const PowerPlantState &that);
+
+      // Assignment Operator
+      PowerPlantState & operator=(const PowerPlantState &that);
+
+      // Destructor
+      virtual ~PowerPlantState(void);
+
+      // Equals overload
+      bool operator==(const PowerPlantState & that);
+      bool operator!=(const PowerPlantState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual PowerPlantState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 8; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** The active power plant (Units: None)*/
+      afrl::impact::PowerPlant::PowerPlant getActivePowerPlant(void) const { return __ActivePowerPlant; }
+      PowerPlantState& setActivePowerPlant(const afrl::impact::PowerPlant::PowerPlant val);
+
+
+
+   protected:
+      /** The active power plant */
+      afrl::impact::PowerPlant::PowerPlant __ActivePowerPlant;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_POWERPLANTSTATE_H_
diff --git a/src/LMCP/afrl/impact/PowerPlantStateDescendants.h b/src/LMCP/afrl/impact/PowerPlantStateDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/PowerPlantStateDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/RadioConfiguration.h b/src/LMCP/afrl/impact/RadioConfiguration.h
new file mode 100644
index 0000000..4f332c4
--- /dev/null
+++ b/src/LMCP/afrl/impact/RadioConfiguration.h
@@ -0,0 +1,119 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_RADIOCONFIGURATION_H_
+#define _AFRL_IMPACT_RADIOCONFIGURATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/PayloadConfiguration.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isRadioConfiguration(avtas::lmcp::Object* obj);
+   bool isRadioConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RadioConfigurationDescendants();
+   
+   class RadioConfiguration : public afrl::cmasi::PayloadConfiguration {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RadioConfiguration(void);
+
+      // Copy Constructor
+      RadioConfiguration(const RadioConfiguration &that);
+
+      // Assignment Operator
+      RadioConfiguration & operator=(const RadioConfiguration &that);
+
+      // Destructor
+      virtual ~RadioConfiguration(void);
+
+      // Equals overload
+      bool operator==(const RadioConfiguration & that);
+      bool operator!=(const RadioConfiguration & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RadioConfiguration* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 2; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** The range of the radio (Units: meters)*/
+      float getRange(void) const { return __Range; }
+      RadioConfiguration& setRange(const float val);
+
+      /** The vehicle's rally point (Units: None)*/
+      afrl::cmasi::Location3D* const getRallyPoint(void) { return __RallyPoint; }
+      RadioConfiguration& setRallyPoint(const afrl::cmasi::Location3D* const val);
+
+      /** Time after loss of communications the vehicle should return to its rally point (Units: milliseconds)*/
+      int64_t getTimeout(void) const { return __Timeout; }
+      RadioConfiguration& setTimeout(const int64_t val);
+
+
+
+   protected:
+      /** The range of the radio */
+      float __Range;
+      /** The vehicle's rally point */
+      afrl::cmasi::Location3D* __RallyPoint;
+      /** Time after loss of communications the vehicle should return to its rally point */
+      int64_t __Timeout;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_RADIOCONFIGURATION_H_
diff --git a/src/LMCP/afrl/impact/RadioConfigurationDescendants.h b/src/LMCP/afrl/impact/RadioConfigurationDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/RadioConfigurationDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/RadioState.h b/src/LMCP/afrl/impact/RadioState.h
new file mode 100644
index 0000000..e180fd5
--- /dev/null
+++ b/src/LMCP/afrl/impact/RadioState.h
@@ -0,0 +1,112 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_RADIOSTATE_H_
+#define _AFRL_IMPACT_RADIOSTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/PayloadState.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isRadioState(avtas::lmcp::Object* obj);
+   bool isRadioState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RadioStateDescendants();
+   
+   class RadioState : public afrl::cmasi::PayloadState {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RadioState(void);
+
+      // Copy Constructor
+      RadioState(const RadioState &that);
+
+      // Assignment Operator
+      RadioState & operator=(const RadioState &that);
+
+      // Destructor
+      virtual ~RadioState(void);
+
+      // Equals overload
+      bool operator==(const RadioState & that);
+      bool operator!=(const RadioState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RadioState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 4; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Whether the radio is enabled (Units: None)*/
+      bool getEnabled(void) const { return __Enabled; }
+      RadioState& setEnabled(const bool val);
+
+      /** Whether the vehicle is in communications range (Units: None)*/
+      bool getInRange(void) const { return __InRange; }
+      RadioState& setInRange(const bool val);
+
+
+
+   protected:
+      /** Whether the radio is enabled */
+      bool __Enabled;
+      /** Whether the vehicle is in communications range */
+      bool __InRange;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_RADIOSTATE_H_
diff --git a/src/LMCP/afrl/impact/RadioStateDescendants.h b/src/LMCP/afrl/impact/RadioStateDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/RadioStateDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/RadioTowerConfiguration.h b/src/LMCP/afrl/impact/RadioTowerConfiguration.h
new file mode 100644
index 0000000..f754cf4
--- /dev/null
+++ b/src/LMCP/afrl/impact/RadioTowerConfiguration.h
@@ -0,0 +1,119 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_RADIOTOWERCONFIGURATION_H_
+#define _AFRL_IMPACT_RADIOTOWERCONFIGURATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/EntityConfiguration.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isRadioTowerConfiguration(avtas::lmcp::Object* obj);
+   bool isRadioTowerConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RadioTowerConfigurationDescendants();
+   
+   class RadioTowerConfiguration : public afrl::cmasi::EntityConfiguration {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RadioTowerConfiguration(void);
+
+      // Copy Constructor
+      RadioTowerConfiguration(const RadioTowerConfiguration &that);
+
+      // Assignment Operator
+      RadioTowerConfiguration & operator=(const RadioTowerConfiguration &that);
+
+      // Destructor
+      virtual ~RadioTowerConfiguration(void);
+
+      // Equals overload
+      bool operator==(const RadioTowerConfiguration & that);
+      bool operator!=(const RadioTowerConfiguration & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RadioTowerConfiguration* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 3; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** The position of the tower (Units: None)*/
+      afrl::cmasi::Location3D* const getPosition(void) { return __Position; }
+      RadioTowerConfiguration& setPosition(const afrl::cmasi::Location3D* const val);
+
+      /** The range of the radio (Units: meters)*/
+      float getRange(void) const { return __Range; }
+      RadioTowerConfiguration& setRange(const float val);
+
+      /** Whether the radio is enabled (Units: None)*/
+      bool getEnabled(void) const { return __Enabled; }
+      RadioTowerConfiguration& setEnabled(const bool val);
+
+
+
+   protected:
+      /** The position of the tower */
+      afrl::cmasi::Location3D* __Position;
+      /** The range of the radio */
+      float __Range;
+      /** Whether the radio is enabled */
+      bool __Enabled;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_RADIOTOWERCONFIGURATION_H_
diff --git a/src/LMCP/afrl/impact/RadioTowerConfigurationDescendants.h b/src/LMCP/afrl/impact/RadioTowerConfigurationDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/RadioTowerConfigurationDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/RadioTowerState.h b/src/LMCP/afrl/impact/RadioTowerState.h
new file mode 100644
index 0000000..b54472f
--- /dev/null
+++ b/src/LMCP/afrl/impact/RadioTowerState.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_RADIOTOWERSTATE_H_
+#define _AFRL_IMPACT_RADIOTOWERSTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/EntityState.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isRadioTowerState(avtas::lmcp::Object* obj);
+   bool isRadioTowerState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RadioTowerStateDescendants();
+   
+   class RadioTowerState : public afrl::cmasi::EntityState {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RadioTowerState(void);
+
+      // Copy Constructor
+      RadioTowerState(const RadioTowerState &that);
+
+      // Assignment Operator
+      RadioTowerState & operator=(const RadioTowerState &that);
+
+      // Destructor
+      virtual ~RadioTowerState(void);
+
+      // Equals overload
+      bool operator==(const RadioTowerState & that);
+      bool operator!=(const RadioTowerState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RadioTowerState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 5; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Whether the radio is enabled (Units: None)*/
+      bool getEnabled(void) const { return __Enabled; }
+      RadioTowerState& setEnabled(const bool val);
+
+
+
+   protected:
+      /** Whether the radio is enabled */
+      bool __Enabled;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_RADIOTOWERSTATE_H_
diff --git a/src/LMCP/afrl/impact/RadioTowerStateDescendants.h b/src/LMCP/afrl/impact/RadioTowerStateDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/RadioTowerStateDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/SpeedAltPair.h b/src/LMCP/afrl/impact/SpeedAltPair.h
new file mode 100644
index 0000000..be3f362
--- /dev/null
+++ b/src/LMCP/afrl/impact/SpeedAltPair.h
@@ -0,0 +1,125 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_SPEEDALTPAIR_H_
+#define _AFRL_IMPACT_SPEEDALTPAIR_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AltitudeType.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isSpeedAltPair(avtas::lmcp::Object* obj);
+   bool isSpeedAltPair(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > SpeedAltPairDescendants();
+   
+   class SpeedAltPair : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      SpeedAltPair(void);
+
+      // Copy Constructor
+      SpeedAltPair(const SpeedAltPair &that);
+
+      // Assignment Operator
+      SpeedAltPair & operator=(const SpeedAltPair &that);
+
+      // Destructor
+      virtual ~SpeedAltPair(void);
+
+      // Equals overload
+      bool operator==(const SpeedAltPair & that);
+      bool operator!=(const SpeedAltPair & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual SpeedAltPair* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 19; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** ID of vehicle for which altitude and speed is attached (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      SpeedAltPair& setVehicleID(const int64_t val);
+
+      /** The speed attached to this vehicle (Units: meter/sec)*/
+      float getSpeed(void) const { return __Speed; }
+      SpeedAltPair& setSpeed(const float val);
+
+      /** Altitude attached to this vehicle (Units: meter)*/
+      float getAltitude(void) const { return __Altitude; }
+      SpeedAltPair& setAltitude(const float val);
+
+      /** Altitude type for specified altitude (Units: None)*/
+      afrl::cmasi::AltitudeType::AltitudeType getAltitudeType(void) const { return __AltitudeType; }
+      SpeedAltPair& setAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val);
+
+
+
+   protected:
+      /** ID of vehicle for which altitude and speed is attached */
+      int64_t __VehicleID;
+      /** The speed attached to this vehicle */
+      float __Speed;
+      /** Altitude attached to this vehicle */
+      float __Altitude;
+      /** Altitude type for specified altitude */
+      afrl::cmasi::AltitudeType::AltitudeType __AltitudeType;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_SPEEDALTPAIR_H_
diff --git a/src/LMCP/afrl/impact/SpeedAltPairDescendants.h b/src/LMCP/afrl/impact/SpeedAltPairDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/SpeedAltPairDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/SurfaceVehicleConfiguration.h b/src/LMCP/afrl/impact/SurfaceVehicleConfiguration.h
new file mode 100644
index 0000000..ab79f73
--- /dev/null
+++ b/src/LMCP/afrl/impact/SurfaceVehicleConfiguration.h
@@ -0,0 +1,136 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_SURFACEVEHICLECONFIGURATION_H_
+#define _AFRL_IMPACT_SURFACEVEHICLECONFIGURATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/EntityConfiguration.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isSurfaceVehicleConfiguration(avtas::lmcp::Object* obj);
+   bool isSurfaceVehicleConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > SurfaceVehicleConfigurationDescendants();
+   
+   class SurfaceVehicleConfiguration : public afrl::cmasi::EntityConfiguration {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      SurfaceVehicleConfiguration(void);
+
+      // Copy Constructor
+      SurfaceVehicleConfiguration(const SurfaceVehicleConfiguration &that);
+
+      // Assignment Operator
+      SurfaceVehicleConfiguration & operator=(const SurfaceVehicleConfiguration &that);
+
+      // Destructor
+      virtual ~SurfaceVehicleConfiguration(void);
+
+      // Equals overload
+      bool operator==(const SurfaceVehicleConfiguration & that);
+      bool operator!=(const SurfaceVehicleConfiguration & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual SurfaceVehicleConfiguration* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 40; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Valid operational water zone (by ID). USV adheres to this area (Units: None)*/
+      int64_t getWaterArea(void) const { return __WaterArea; }
+      SurfaceVehicleConfiguration& setWaterArea(const int64_t val);
+
+      /** The minimum speed that should be commanded for this vehicle (Units: meter/sec)*/
+      float getMinimumSpeed(void) const { return __MinimumSpeed; }
+      SurfaceVehicleConfiguration& setMinimumSpeed(const float val);
+
+      /** The maximum speed that should be commanded for this vehicle (Units: meter/sec)*/
+      float getMaximumSpeed(void) const { return __MaximumSpeed; }
+      SurfaceVehicleConfiguration& setMaximumSpeed(const float val);
+
+      /** The consumption rate of available energy at nominal speed, expressed in terms of the percentage of maximum capacity used per second. (Units: %/sec)*/
+      float getEnergyRate(void) const { return __EnergyRate; }
+      SurfaceVehicleConfiguration& setEnergyRate(const float val);
+
+      /** The maximum angle that this vehicle will bank (Units: degree)*/
+      float getMaxBankAngle(void) const { return __MaxBankAngle; }
+      SurfaceVehicleConfiguration& setMaxBankAngle(const float val);
+
+      /** The maximum angular rate that this vehicle will bank (Units: degree/sec)*/
+      float getMaxBankRate(void) const { return __MaxBankRate; }
+      SurfaceVehicleConfiguration& setMaxBankRate(const float val);
+
+
+
+   protected:
+      /** Valid operational water zone (by ID). USV adheres to this area */
+      int64_t __WaterArea;
+      /** The minimum speed that should be commanded for this vehicle */
+      float __MinimumSpeed;
+      /** The maximum speed that should be commanded for this vehicle */
+      float __MaximumSpeed;
+      /** The consumption rate of available energy at nominal speed, expressed in terms of the percentage of maximum capacity used per second. */
+      float __EnergyRate;
+      /** The maximum angle that this vehicle will bank */
+      float __MaxBankAngle;
+      /** The maximum angular rate that this vehicle will bank */
+      float __MaxBankRate;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_SURFACEVEHICLECONFIGURATION_H_
diff --git a/src/LMCP/afrl/impact/SurfaceVehicleConfigurationDescendants.h b/src/LMCP/afrl/impact/SurfaceVehicleConfigurationDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/SurfaceVehicleConfigurationDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/SurfaceVehicleState.h b/src/LMCP/afrl/impact/SurfaceVehicleState.h
new file mode 100644
index 0000000..bf4a7bd
--- /dev/null
+++ b/src/LMCP/afrl/impact/SurfaceVehicleState.h
@@ -0,0 +1,112 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_SURFACEVEHICLESTATE_H_
+#define _AFRL_IMPACT_SURFACEVEHICLESTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/EntityState.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isSurfaceVehicleState(avtas::lmcp::Object* obj);
+   bool isSurfaceVehicleState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > SurfaceVehicleStateDescendants();
+   
+   class SurfaceVehicleState : public afrl::cmasi::EntityState {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      SurfaceVehicleState(void);
+
+      // Copy Constructor
+      SurfaceVehicleState(const SurfaceVehicleState &that);
+
+      // Assignment Operator
+      SurfaceVehicleState & operator=(const SurfaceVehicleState &that);
+
+      // Destructor
+      virtual ~SurfaceVehicleState(void);
+
+      // Equals overload
+      bool operator==(const SurfaceVehicleState & that);
+      bool operator!=(const SurfaceVehicleState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual SurfaceVehicleState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 41; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Current bank angle of the surface vehicle (Units: degree)*/
+      float getBankAngle(void) const { return __BankAngle; }
+      SurfaceVehicleState& setBankAngle(const float val);
+
+      /** Forward speed of the vehicle relative to the mass of water (Units: meter/sec)*/
+      float getSpeed(void) const { return __Speed; }
+      SurfaceVehicleState& setSpeed(const float val);
+
+
+
+   protected:
+      /** Current bank angle of the surface vehicle */
+      float __BankAngle;
+      /** Forward speed of the vehicle relative to the mass of water */
+      float __Speed;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_SURFACEVEHICLESTATE_H_
diff --git a/src/LMCP/afrl/impact/SurfaceVehicleStateDescendants.h b/src/LMCP/afrl/impact/SurfaceVehicleStateDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/SurfaceVehicleStateDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/TaskSummary.h b/src/LMCP/afrl/impact/TaskSummary.h
new file mode 100644
index 0000000..8904f9a
--- /dev/null
+++ b/src/LMCP/afrl/impact/TaskSummary.h
@@ -0,0 +1,119 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_TASKSUMMARY_H_
+#define _AFRL_IMPACT_TASKSUMMARY_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/impact/VehicleSummary.h"
+
+#include <vector>
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isTaskSummary(avtas::lmcp::Object* obj);
+   bool isTaskSummary(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskSummaryDescendants();
+   
+   class TaskSummary : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskSummary(void);
+
+      // Copy Constructor
+      TaskSummary(const TaskSummary &that);
+
+      // Assignment Operator
+      TaskSummary & operator=(const TaskSummary &that);
+
+      // Destructor
+      virtual ~TaskSummary(void);
+
+      // Equals overload
+      bool operator==(const TaskSummary & that);
+      bool operator!=(const TaskSummary & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskSummary* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 14; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** ID of task in consideration (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskSummary& setTaskID(const int64_t val);
+
+      /** Summary of information for each vehicle used simultaneously to complete this task. If there are zero performing vehicles, then 'TaskID' cannot be completed with any set of available vehicles in the system. (Units: None)*/
+      std::vector<afrl::impact::VehicleSummary*> & getPerformingVehicles(void) { return __PerformingVehicles; }
+
+      /** Task cannot be completed as specified and is using best effort. Estimated percent achieved while using best effort strategy. (Units: %)*/
+      float getBestEffort(void) const { return __BestEffort; }
+      TaskSummary& setBestEffort(const float val);
+
+
+
+   protected:
+      /** ID of task in consideration */
+      int64_t __TaskID;
+      /** Summary of information for each vehicle used simultaneously to complete this task. If there are zero performing vehicles, then 'TaskID' cannot be completed with any set of available vehicles in the system. */
+      std::vector< afrl::impact::VehicleSummary* > __PerformingVehicles;
+      /** Task cannot be completed as specified and is using best effort. Estimated percent achieved while using best effort strategy. */
+      float __BestEffort;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_TASKSUMMARY_H_
diff --git a/src/LMCP/afrl/impact/TaskSummaryDescendants.h b/src/LMCP/afrl/impact/TaskSummaryDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/TaskSummaryDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/TaskTimingPair.h b/src/LMCP/afrl/impact/TaskTimingPair.h
new file mode 100644
index 0000000..3305405
--- /dev/null
+++ b/src/LMCP/afrl/impact/TaskTimingPair.h
@@ -0,0 +1,130 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_TASKTIMINGPAIR_H_
+#define _AFRL_IMPACT_TASKTIMINGPAIR_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isTaskTimingPair(avtas::lmcp::Object* obj);
+   bool isTaskTimingPair(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskTimingPairDescendants();
+   
+   class TaskTimingPair : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskTimingPair(void);
+
+      // Copy Constructor
+      TaskTimingPair(const TaskTimingPair &that);
+
+      // Assignment Operator
+      TaskTimingPair & operator=(const TaskTimingPair &that);
+
+      // Destructor
+      virtual ~TaskTimingPair(void);
+
+      // Equals overload
+      bool operator==(const TaskTimingPair & that);
+      bool operator!=(const TaskTimingPair & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskTimingPair* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 11; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Corresponding Vehicle ID (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      TaskTimingPair& setVehicleID(const int64_t val);
+
+      /** Initial task ID (if zero, corresponds to current vehicle location) (Units: None)*/
+      int64_t getInitialTaskID(void) const { return __InitialTaskID; }
+      TaskTimingPair& setInitialTaskID(const int64_t val);
+
+      /** Normalized progress along initial task (0.0 .. 1.0) (Units: None)*/
+      float getInitialTaskPercentage(void) const { return __InitialTaskPercentage; }
+      TaskTimingPair& setInitialTaskPercentage(const float val);
+
+      /** Destination task ID (Units: None)*/
+      int64_t getDestinationTaskID(void) const { return __DestinationTaskID; }
+      TaskTimingPair& setDestinationTaskID(const int64_t val);
+
+      /** Timing corresponding to travel between tasks. If time is less than zero, no feasible path exists between tasks. If 'DestinationTaskID' is equal to 'InitialTaskID' then 'TimeToGo' is the time to complete the task when performed by 'VehicleID' (Units: milliseconds)*/
+      int64_t getTimeToGo(void) const { return __TimeToGo; }
+      TaskTimingPair& setTimeToGo(const int64_t val);
+
+
+
+   protected:
+      /** Corresponding Vehicle ID */
+      int64_t __VehicleID;
+      /** Initial task ID (if zero, corresponds to current vehicle location) */
+      int64_t __InitialTaskID;
+      /** Normalized progress along initial task (0.0 .. 1.0) */
+      float __InitialTaskPercentage;
+      /** Destination task ID */
+      int64_t __DestinationTaskID;
+      /** Timing corresponding to travel between tasks. If time is less than zero, no feasible path exists between tasks. If 'DestinationTaskID' is equal to 'InitialTaskID' then 'TimeToGo' is the time to complete the task when performed by 'VehicleID' */
+      int64_t __TimeToGo;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_TASKTIMINGPAIR_H_
diff --git a/src/LMCP/afrl/impact/TaskTimingPairDescendants.h b/src/LMCP/afrl/impact/TaskTimingPairDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/TaskTimingPairDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/VehicleSummary.h b/src/LMCP/afrl/impact/VehicleSummary.h
new file mode 100644
index 0000000..8388c03
--- /dev/null
+++ b/src/LMCP/afrl/impact/VehicleSummary.h
@@ -0,0 +1,154 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_VEHICLESUMMARY_H_
+#define _AFRL_IMPACT_VEHICLESUMMARY_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isVehicleSummary(avtas::lmcp::Object* obj);
+   bool isVehicleSummary(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > VehicleSummaryDescendants();
+   
+   class VehicleSummary : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      VehicleSummary(void);
+
+      // Copy Constructor
+      VehicleSummary(const VehicleSummary &that);
+
+      // Assignment Operator
+      VehicleSummary & operator=(const VehicleSummary &that);
+
+      // Destructor
+      virtual ~VehicleSummary(void);
+
+      // Equals overload
+      bool operator==(const VehicleSummary & that);
+      bool operator!=(const VehicleSummary & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual VehicleSummary* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 15; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** ID of vehicle considered to complete 'DestinationTaskID' (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      VehicleSummary& setVehicleID(const int64_t val);
+
+      /** ID of task for which 'VehicleID' is considered to perform (Units: None)*/
+      int64_t getDestinationTaskID(void) const { return __DestinationTaskID; }
+      VehicleSummary& setDestinationTaskID(const int64_t val);
+
+      /** ID of task from which 'VehicleID' is considered leave from. If zero, from current position of vehicle (Units: None)*/
+      int64_t getInitialTaskID(void) const { return __InitialTaskID; }
+      VehicleSummary& setInitialTaskID(const int64_t val);
+
+      /** Percentage along initial task that vehicle should plan from (Units: None)*/
+      float getInitialTaskPercentage(void) const { return __InitialTaskPercentage; }
+      VehicleSummary& setInitialTaskPercentage(const float val);
+
+      /** Estimated time from start of task to task-percentage location (Units: milliseconds)*/
+      int64_t getEstimateTimeToTaskPercentage(void) const { return __EstimateTimeToTaskPercentage; }
+      VehicleSummary& setEstimateTimeToTaskPercentage(const int64_t val);
+
+      /** Travel time from the current vehicle location to the start of the task. (Units: milliseconds)*/
+      int64_t getTimeToArrive(void) const { return __TimeToArrive; }
+      VehicleSummary& setTimeToArrive(const int64_t val);
+
+      /** Time for this task to be completed by the specified vehicle (Units: milliseconds)*/
+      int64_t getTimeOnTask(void) const { return __TimeOnTask; }
+      VehicleSummary& setTimeOnTask(const int64_t val);
+
+      /** Energy remaining for vehicle after task has been completed, expressed in terms of the percentage of maximum capacity (Units: %)*/
+      float getEnergyRemaining(void) const { return __EnergyRemaining; }
+      VehicleSummary& setEnergyRemaining(const float val);
+
+      /** Flag for indicating that the vehicle will leave communication range either enroute or during the task (Units: None)*/
+      bool getBeyondCommRange(void) const { return __BeyondCommRange; }
+      VehicleSummary& setBeyondCommRange(const bool val);
+
+
+
+   protected:
+      /** ID of vehicle considered to complete 'DestinationTaskID' */
+      int64_t __VehicleID;
+      /** ID of task for which 'VehicleID' is considered to perform */
+      int64_t __DestinationTaskID;
+      /** ID of task from which 'VehicleID' is considered leave from. If zero, from current position of vehicle */
+      int64_t __InitialTaskID;
+      /** Percentage along initial task that vehicle should plan from */
+      float __InitialTaskPercentage;
+      /** Estimated time from start of task to task-percentage location */
+      int64_t __EstimateTimeToTaskPercentage;
+      /** Travel time from the current vehicle location to the start of the task. */
+      int64_t __TimeToArrive;
+      /** Time for this task to be completed by the specified vehicle */
+      int64_t __TimeOnTask;
+      /** Energy remaining for vehicle after task has been completed, expressed in terms of the percentage of maximum capacity */
+      float __EnergyRemaining;
+      /** Flag for indicating that the vehicle will leave communication range either enroute or during the task */
+      bool __BeyondCommRange;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_VEHICLESUMMARY_H_
diff --git a/src/LMCP/afrl/impact/VehicleSummaryDescendants.h b/src/LMCP/afrl/impact/VehicleSummaryDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/VehicleSummaryDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/WatchTask.h b/src/LMCP/afrl/impact/WatchTask.h
new file mode 100644
index 0000000..5d615ef
--- /dev/null
+++ b/src/LMCP/afrl/impact/WatchTask.h
@@ -0,0 +1,106 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_WATCHTASK_H_
+#define _AFRL_IMPACT_WATCHTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/SearchTask.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isWatchTask(avtas::lmcp::Object* obj);
+   bool isWatchTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > WatchTaskDescendants();
+   
+   class WatchTask : public afrl::cmasi::SearchTask {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      WatchTask(void);
+
+      // Copy Constructor
+      WatchTask(const WatchTask &that);
+
+      // Assignment Operator
+      WatchTask & operator=(const WatchTask &that);
+
+      // Destructor
+      virtual ~WatchTask(void);
+
+      // Equals overload
+      bool operator==(const WatchTask & that);
+      bool operator!=(const WatchTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual WatchTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 29; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Entity ID to follow and watch (Units: None)*/
+      int64_t getWatchedEntityID(void) const { return __WatchedEntityID; }
+      WatchTask& setWatchedEntityID(const int64_t val);
+
+
+
+   protected:
+      /** Entity ID to follow and watch */
+      int64_t __WatchedEntityID;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_WATCHTASK_H_
diff --git a/src/LMCP/afrl/impact/WatchTaskDescendants.h b/src/LMCP/afrl/impact/WatchTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/WatchTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/WaterReport.h b/src/LMCP/afrl/impact/WaterReport.h
new file mode 100644
index 0000000..56110a1
--- /dev/null
+++ b/src/LMCP/afrl/impact/WaterReport.h
@@ -0,0 +1,131 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_WATERREPORT_H_
+#define _AFRL_IMPACT_WATERREPORT_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AbstractGeometry.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isWaterReport(avtas::lmcp::Object* obj);
+   bool isWaterReport(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > WaterReportDescendants();
+   
+   class WaterReport : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      WaterReport(void);
+
+      // Copy Constructor
+      WaterReport(const WaterReport &that);
+
+      // Assignment Operator
+      WaterReport & operator=(const WaterReport &that);
+
+      // Destructor
+      virtual ~WaterReport(void);
+
+      // Equals overload
+      bool operator==(const WaterReport & that);
+      bool operator!=(const WaterReport & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual WaterReport* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 38; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+      /** Area for which this report is valid (Units: None)*/
+      afrl::cmasi::AbstractGeometry* const getArea(void) { return __Area; }
+      WaterReport& setArea(const afrl::cmasi::AbstractGeometry* const val);
+
+      /** Speed of the current, e.g. due to tides or river flow (Units: meters/sec)*/
+      float getCurrentSpeed(void) const { return __CurrentSpeed; }
+      WaterReport& setCurrentSpeed(const float val);
+
+      /** Direction of the current (Units: degree)*/
+      float getCurrentDirection(void) const { return __CurrentDirection; }
+      WaterReport& setCurrentDirection(const float val);
+
+      /** Wave direction of travel. Generally in the direction of the wind, except near sea coasts(Units: degree)*/
+      float getWaveDirection(void) const { return __WaveDirection; }
+      WaterReport& setWaveDirection(const float val);
+
+      /** Average wave height (Units: meters)*/
+      float getWaveHeight(void) const { return __WaveHeight; }
+      WaterReport& setWaveHeight(const float val);
+
+
+
+   protected:
+      /** Area for which this report is valid */
+      afrl::cmasi::AbstractGeometry* __Area;
+      /** Speed of the current, e.g. due to tides or river flow */
+      float __CurrentSpeed;
+      /** Direction of the current */
+      float __CurrentDirection;
+      /** Wave direction of travel. Generally in the direction of the wind, except near sea coasts*/
+      float __WaveDirection;
+      /** Average wave height */
+      float __WaveHeight;
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_WATERREPORT_H_
diff --git a/src/LMCP/afrl/impact/WaterReportDescendants.h b/src/LMCP/afrl/impact/WaterReportDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/WaterReportDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/WaterZone.h b/src/LMCP/afrl/impact/WaterZone.h
new file mode 100644
index 0000000..8ee0021
--- /dev/null
+++ b/src/LMCP/afrl/impact/WaterZone.h
@@ -0,0 +1,100 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AFRL_IMPACT_WATERZONE_H_
+#define _AFRL_IMPACT_WATERZONE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "IMPACTEnum.h"
+#include "afrl/cmasi/AbstractZone.h"
+
+
+
+namespace afrl {
+namespace impact {
+
+
+   bool isWaterZone(avtas::lmcp::Object* obj);
+   bool isWaterZone(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > WaterZoneDescendants();
+   
+   class WaterZone : public afrl::cmasi::AbstractZone {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      WaterZone(void);
+
+      // Copy Constructor
+      WaterZone(const WaterZone &that);
+
+      // Assignment Operator
+      WaterZone & operator=(const WaterZone &that);
+
+      // Destructor
+      virtual ~WaterZone(void);
+
+      // Equals overload
+      bool operator==(const WaterZone & that);
+      bool operator!=(const WaterZone & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual WaterZone* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 39; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("IMPACT"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5281966179208134656LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 11; }
+
+      // Accessors and Modifiers
+
+
+   protected:
+
+   };
+
+} // end namespace impact
+} // end namespace afrl
+
+
+#endif // _AFRL_IMPACT_WATERZONE_H_
diff --git a/src/LMCP/afrl/impact/WaterZoneDescendants.h b/src/LMCP/afrl/impact/WaterZoneDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/afrl/impact/WaterZoneDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/afrl/impact/afrlimpactAngledAreaSearchTask.cpp b/src/LMCP/afrl/impact/afrlimpactAngledAreaSearchTask.cpp
new file mode 100644
index 0000000..33c3045
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactAngledAreaSearchTask.cpp
@@ -0,0 +1,261 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/AngledAreaSearchTask.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AngledAreaSearchTask::Subscription = "afrl.impact.AngledAreaSearchTask";
+   const std::string AngledAreaSearchTask::TypeName = "AngledAreaSearchTask";
+   
+   bool isAngledAreaSearchTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 27) return false;
+      return true;
+   }
+   
+   bool isAngledAreaSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 27) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AngledAreaSearchTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   AngledAreaSearchTask::AngledAreaSearchTask(void) : afrl::cmasi::SearchTask()
+   {
+      __SearchAreaID = 0LL;
+      __SweepAngle = 0.f;
+      __StartPoint = new afrl::cmasi::Location3D();
+
+   }
+     
+   AngledAreaSearchTask::AngledAreaSearchTask(const AngledAreaSearchTask &that) : afrl::cmasi::SearchTask(that)
+   {
+        __SearchAreaID = that.__SearchAreaID;
+        __SweepAngle = that.__SweepAngle;
+        __StartPoint = that.__StartPoint == nullptr ? nullptr : that.__StartPoint->clone();
+
+   }
+   
+   AngledAreaSearchTask & AngledAreaSearchTask::operator=(const AngledAreaSearchTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::SearchTask::operator=(that);
+         if (__StartPoint != nullptr) delete __StartPoint;
+
+         __SearchAreaID = that.__SearchAreaID;
+         __SweepAngle = that.__SweepAngle;
+         __StartPoint = that.__StartPoint == nullptr ? nullptr : that.__StartPoint->clone();
+
+      }
+      return *this;
+   }
+
+   AngledAreaSearchTask* AngledAreaSearchTask::clone() const
+   {
+        return new AngledAreaSearchTask(*this);
+   }
+   
+   AngledAreaSearchTask::~AngledAreaSearchTask(void)
+   {
+      if (__StartPoint != nullptr) delete __StartPoint;
+
+   }
+  
+   void AngledAreaSearchTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::SearchTask::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__SearchAreaID);
+      buf.putFloat(__SweepAngle);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __StartPoint, buf);
+
+   }
+   
+   void AngledAreaSearchTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::SearchTask::unpack(buf);
+      // Copy the buffer into the class
+      __SearchAreaID = buf.getLong();
+      __SweepAngle = buf.getFloat();
+      {
+         if (__StartPoint != nullptr) delete __StartPoint;
+         __StartPoint = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __StartPoint = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__StartPoint != nullptr) __StartPoint->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t AngledAreaSearchTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::SearchTask::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += (__StartPoint != nullptr ? __StartPoint->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string AngledAreaSearchTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AngledAreaSearchTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "DesiredWavelengthBands (WavelengthBand [ " << __DesiredWavelengthBands.size() << ", var ])\n";
+      oss << indent << "DwellTime (int64_t) = " << __DwellTime << "\n";
+      oss << indent << "GroundSampleDistance (float) = " << __GroundSampleDistance << "\n";
+
+      oss << indent << "SearchAreaID (int64_t) = " << __SearchAreaID << "\n";
+      oss << indent << "SweepAngle (float) = " << __SweepAngle << "\n";
+      oss << indent << "StartPoint (Location3D)";
+      if (__StartPoint == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AngledAreaSearchTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AngledAreaSearchTask Series=\"IMPACT\">\n";
+      str << ws << "   <SearchAreaID>" << __SearchAreaID << "</SearchAreaID>\n";
+      str << ws << "   <SweepAngle>" << __SweepAngle << "</SweepAngle>\n";
+      if (__StartPoint != nullptr)
+      {
+         str << ws << "   <StartPoint>";
+         str << "\n" + __StartPoint->toXML(depth + 1) + ws + "   ";
+         str << "</StartPoint>\n";
+      }
+      str << ws << "   <DesiredWavelengthBands>\n";
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         str << ws << "   <WavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__DesiredWavelengthBands[i]) << "</WavelengthBand>\n";
+      }
+      str << ws << "   </DesiredWavelengthBands>\n";
+      str << ws << "   <DwellTime>" << __DwellTime << "</DwellTime>\n";
+      str << ws << "   <GroundSampleDistance>" << __GroundSampleDistance << "</GroundSampleDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</AngledAreaSearchTask>\n";
+
+      return str.str();
+   }
+
+   bool AngledAreaSearchTask::operator==(const AngledAreaSearchTask & that)
+   {
+      if( afrl::cmasi::SearchTask::operator!=(that) )
+      {
+          return false;
+      }
+      if(__SearchAreaID != that.__SearchAreaID) return false;
+      if(__SweepAngle != that.__SweepAngle) return false;
+      if(__StartPoint && that.__StartPoint)
+      {
+         if(__StartPoint->getSeriesNameAsLong() != that.__StartPoint->getSeriesNameAsLong()) return false;
+         if(__StartPoint->getSeriesVersion() != that.__StartPoint->getSeriesVersion()) return false;
+         if(__StartPoint->getLmcpType() != that.__StartPoint->getLmcpType()) return false;
+         if( *(__StartPoint) != *(that.__StartPoint) ) return false;
+      }
+      else if(__StartPoint != that.__StartPoint) return false;
+      return true;
+
+   }
+
+   bool AngledAreaSearchTask::operator!=(const AngledAreaSearchTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   AngledAreaSearchTask& AngledAreaSearchTask::setSearchAreaID(const int64_t val)
+   {
+      __SearchAreaID = val;
+      return *this;
+   }
+
+   AngledAreaSearchTask& AngledAreaSearchTask::setSweepAngle(const float val)
+   {
+      __SweepAngle = val;
+      return *this;
+   }
+
+   AngledAreaSearchTask& AngledAreaSearchTask::setStartPoint(const afrl::cmasi::Location3D* const val)
+   {
+      if (__StartPoint != nullptr) { delete __StartPoint; __StartPoint = nullptr; }
+      if (val != nullptr) { __StartPoint = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactAreaOfInterest.cpp b/src/LMCP/afrl/impact/afrlimpactAreaOfInterest.cpp
new file mode 100644
index 0000000..654fb89
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactAreaOfInterest.cpp
@@ -0,0 +1,210 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/AreaOfInterest.h"
+#include "afrl/cmasi/Circle.h"
+#include "afrl/cmasi/Polygon.h"
+#include "afrl/cmasi/Rectangle.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AreaOfInterest::Subscription = "afrl.impact.AreaOfInterest";
+   const std::string AreaOfInterest::TypeName = "AreaOfInterest";
+   
+   bool isAreaOfInterest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 24) return false;
+      return true;
+   }
+   
+   bool isAreaOfInterest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 24) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AreaOfInterestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   AreaOfInterest::AreaOfInterest(void) : avtas::lmcp::Object()
+   {
+      __AreaID = 0LL;
+      __Area = new afrl::cmasi::AbstractGeometry();
+
+   }
+     
+   AreaOfInterest::AreaOfInterest(const AreaOfInterest &that) : avtas::lmcp::Object(that)
+   {
+        __AreaID = that.__AreaID;
+        __Area = that.__Area == nullptr ? nullptr : that.__Area->clone();
+
+   }
+   
+   AreaOfInterest & AreaOfInterest::operator=(const AreaOfInterest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__Area != nullptr) delete __Area;
+
+         __AreaID = that.__AreaID;
+         __Area = that.__Area == nullptr ? nullptr : that.__Area->clone();
+
+      }
+      return *this;
+   }
+
+   AreaOfInterest* AreaOfInterest::clone() const
+   {
+        return new AreaOfInterest(*this);
+   }
+   
+   AreaOfInterest::~AreaOfInterest(void)
+   {
+      if (__Area != nullptr) delete __Area;
+
+   }
+  
+   void AreaOfInterest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__AreaID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Area, buf);
+
+   }
+   
+   void AreaOfInterest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __AreaID = buf.getLong();
+      {
+         if (__Area != nullptr) delete __Area;
+         __Area = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Area = (afrl::cmasi::AbstractGeometry*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Area != nullptr) __Area->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t AreaOfInterest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__Area != nullptr ? __Area->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string AreaOfInterest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AreaOfInterest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AreaID (int64_t) = " << __AreaID << "\n";
+      oss << indent << "Area (AbstractGeometry)";
+      if (__Area == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AreaOfInterest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AreaOfInterest Series=\"IMPACT\">\n";
+      str << ws << "   <AreaID>" << __AreaID << "</AreaID>\n";
+      if (__Area != nullptr)
+      {
+         str << ws << "   <Area>";
+         str << "\n" + __Area->toXML(depth + 1) + ws + "   ";
+         str << "</Area>\n";
+      }
+      str << ws << "</AreaOfInterest>\n";
+
+      return str.str();
+   }
+
+   bool AreaOfInterest::operator==(const AreaOfInterest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__AreaID != that.__AreaID) return false;
+      if(__Area && that.__Area)
+      {
+         if(__Area->getSeriesNameAsLong() != that.__Area->getSeriesNameAsLong()) return false;
+         if(__Area->getSeriesVersion() != that.__Area->getSeriesVersion()) return false;
+         if(__Area->getLmcpType() != that.__Area->getLmcpType()) return false;
+         if( *(__Area) != *(that.__Area) ) return false;
+      }
+      else if(__Area != that.__Area) return false;
+      return true;
+
+   }
+
+   bool AreaOfInterest::operator!=(const AreaOfInterest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   AreaOfInterest& AreaOfInterest::setAreaID(const int64_t val)
+   {
+      __AreaID = val;
+      return *this;
+   }
+
+   AreaOfInterest& AreaOfInterest::setArea(const afrl::cmasi::AbstractGeometry* const val)
+   {
+      if (__Area != nullptr) { delete __Area; __Area = nullptr; }
+      if (val != nullptr) { __Area = const_cast< afrl::cmasi::AbstractGeometry* > (val); }
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactBatchRoutePlanRequest.cpp b/src/LMCP/afrl/impact/afrlimpactBatchRoutePlanRequest.cpp
new file mode 100644
index 0000000..b181de5
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactBatchRoutePlanRequest.cpp
@@ -0,0 +1,313 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/BatchRoutePlanRequest.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string BatchRoutePlanRequest::Subscription = "afrl.impact.BatchRoutePlanRequest";
+   const std::string BatchRoutePlanRequest::TypeName = "BatchRoutePlanRequest";
+   
+   bool isBatchRoutePlanRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 9) return false;
+      return true;
+   }
+   
+   bool isBatchRoutePlanRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 9) return false;
+      return true;
+   }
+   
+   std::vector< std::string > BatchRoutePlanRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   BatchRoutePlanRequest::BatchRoutePlanRequest(void) : avtas::lmcp::Object()
+   {
+      __RequestID = 0LL;
+      __OperatingRegion = 0LL;
+      __ComputeTaskToTaskTiming = false;
+      __ComputeInterTaskToTaskTiming = false;
+
+   }
+     
+   BatchRoutePlanRequest::BatchRoutePlanRequest(const BatchRoutePlanRequest &that) : avtas::lmcp::Object(that)
+   {
+        __RequestID = that.__RequestID;
+        __Vehicles.clear();
+        for (size_t i=0; i< that.__Vehicles.size(); i++)
+        {
+           __Vehicles.push_back( that.__Vehicles[i]);
+        }
+        __TaskList.clear();
+        for (size_t i=0; i< that.__TaskList.size(); i++)
+        {
+           __TaskList.push_back( that.__TaskList[i]);
+        }
+        __OperatingRegion = that.__OperatingRegion;
+        __ComputeTaskToTaskTiming = that.__ComputeTaskToTaskTiming;
+        __ComputeInterTaskToTaskTiming = that.__ComputeInterTaskToTaskTiming;
+        __InterTaskPercentage.clear();
+        for (size_t i=0; i< that.__InterTaskPercentage.size(); i++)
+        {
+           __InterTaskPercentage.push_back( that.__InterTaskPercentage[i]);
+        }
+
+   }
+   
+   BatchRoutePlanRequest & BatchRoutePlanRequest::operator=(const BatchRoutePlanRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __RequestID = that.__RequestID;
+         __Vehicles.clear();
+         for (size_t i=0; i< that.__Vehicles.size(); i++)
+         {
+            __Vehicles.push_back( that.__Vehicles[i]);
+         }
+         __TaskList.clear();
+         for (size_t i=0; i< that.__TaskList.size(); i++)
+         {
+            __TaskList.push_back( that.__TaskList[i]);
+         }
+         __OperatingRegion = that.__OperatingRegion;
+         __ComputeTaskToTaskTiming = that.__ComputeTaskToTaskTiming;
+         __ComputeInterTaskToTaskTiming = that.__ComputeInterTaskToTaskTiming;
+         __InterTaskPercentage.clear();
+         for (size_t i=0; i< that.__InterTaskPercentage.size(); i++)
+         {
+            __InterTaskPercentage.push_back( that.__InterTaskPercentage[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   BatchRoutePlanRequest* BatchRoutePlanRequest::clone() const
+   {
+        return new BatchRoutePlanRequest(*this);
+   }
+   
+   BatchRoutePlanRequest::~BatchRoutePlanRequest(void)
+   {
+
+   }
+  
+   void BatchRoutePlanRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RequestID);
+      buf.putUShort( static_cast<uint16_t>(__Vehicles.size()));
+      for (size_t i=0; i<__Vehicles.size(); i++)
+      {
+         buf.putLong(__Vehicles[i]);
+      }
+      buf.putUShort( static_cast<uint16_t>(__TaskList.size()));
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         buf.putLong(__TaskList[i]);
+      }
+      buf.putLong(__OperatingRegion);
+      buf.putBool(__ComputeTaskToTaskTiming);
+      buf.putBool(__ComputeInterTaskToTaskTiming);
+      buf.putUShort( static_cast<uint16_t>(__InterTaskPercentage.size()));
+      for (size_t i=0; i<__InterTaskPercentage.size(); i++)
+      {
+         buf.putFloat(__InterTaskPercentage[i]);
+      }
+
+   }
+   
+   void BatchRoutePlanRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RequestID = buf.getLong();
+      __Vehicles.clear();
+      uint16_t __Vehicles_length = buf.getUShort();
+      for (uint32_t i=0; i< __Vehicles_length; i++)
+      {
+         __Vehicles.push_back(buf.getLong() );
+      }
+      __TaskList.clear();
+      uint16_t __TaskList_length = buf.getUShort();
+      for (uint32_t i=0; i< __TaskList_length; i++)
+      {
+         __TaskList.push_back(buf.getLong() );
+      }
+      __OperatingRegion = buf.getLong();
+      __ComputeTaskToTaskTiming = buf.getBool();
+      __ComputeInterTaskToTaskTiming = buf.getBool();
+      __InterTaskPercentage.clear();
+      uint16_t __InterTaskPercentage_length = buf.getUShort();
+      for (uint32_t i=0; i< __InterTaskPercentage_length; i++)
+      {
+         __InterTaskPercentage.push_back(buf.getFloat() );
+      }
+
+   }
+
+   uint32_t BatchRoutePlanRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2 + sizeof(int64_t) * __Vehicles.size();
+      size += 2 + sizeof(int64_t) * __TaskList.size();
+      size += sizeof(int64_t);
+      size += sizeof(bool);
+      size += sizeof(bool);
+      size += 2 + sizeof(float) * __InterTaskPercentage.size();
+
+      return size;
+   }
+
+   std::string BatchRoutePlanRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( BatchRoutePlanRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RequestID (int64_t) = " << __RequestID << "\n";
+      oss << indent << "Vehicles (int64 [ " << __Vehicles.size() << ", var ])\n";
+      oss << indent << "TaskList (int64 [ " << __TaskList.size() << ", var ])\n";
+      oss << indent << "OperatingRegion (int64_t) = " << __OperatingRegion << "\n";
+      oss << indent << "ComputeTaskToTaskTiming (bool) = " << __ComputeTaskToTaskTiming << "\n";
+      oss << indent << "ComputeInterTaskToTaskTiming (bool) = " << __ComputeInterTaskToTaskTiming << "\n";
+      oss << indent << "InterTaskPercentage (real32 [ " << __InterTaskPercentage.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string BatchRoutePlanRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<BatchRoutePlanRequest Series=\"IMPACT\">\n";
+      str << ws << "   <RequestID>" << __RequestID << "</RequestID>\n";
+      str << ws << "   <Vehicles>\n";
+      for (size_t i=0; i<__Vehicles.size(); i++)
+      {
+         str << ws << "   <int64>" << __Vehicles[i] << "</int64>\n";
+      }
+      str << ws << "   </Vehicles>\n";
+      str << ws << "   <TaskList>\n";
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __TaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </TaskList>\n";
+      str << ws << "   <OperatingRegion>" << __OperatingRegion << "</OperatingRegion>\n";
+      str << ws << "   <ComputeTaskToTaskTiming>" << (__ComputeTaskToTaskTiming ? "true" : "false") << "</ComputeTaskToTaskTiming>\n";
+      str << ws << "   <ComputeInterTaskToTaskTiming>" << (__ComputeInterTaskToTaskTiming ? "true" : "false") << "</ComputeInterTaskToTaskTiming>\n";
+      str << ws << "   <InterTaskPercentage>\n";
+      for (size_t i=0; i<__InterTaskPercentage.size(); i++)
+      {
+         str << ws << "   <real32>" << __InterTaskPercentage[i] << "</real32>\n";
+      }
+      str << ws << "   </InterTaskPercentage>\n";
+      str << ws << "</BatchRoutePlanRequest>\n";
+
+      return str.str();
+   }
+
+   bool BatchRoutePlanRequest::operator==(const BatchRoutePlanRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RequestID != that.__RequestID) return false;
+      if(__Vehicles.size() != that.__Vehicles.size()) return false;
+      for (size_t i=0; i<__Vehicles.size(); i++)
+      {
+         if(__Vehicles[i] != that.__Vehicles[i]) return false;
+      }
+      if(__TaskList.size() != that.__TaskList.size()) return false;
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         if(__TaskList[i] != that.__TaskList[i]) return false;
+      }
+      if(__OperatingRegion != that.__OperatingRegion) return false;
+      if(__ComputeTaskToTaskTiming != that.__ComputeTaskToTaskTiming) return false;
+      if(__ComputeInterTaskToTaskTiming != that.__ComputeInterTaskToTaskTiming) return false;
+      if(__InterTaskPercentage.size() != that.__InterTaskPercentage.size()) return false;
+      for (size_t i=0; i<__InterTaskPercentage.size(); i++)
+      {
+         if(__InterTaskPercentage[i] != that.__InterTaskPercentage[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool BatchRoutePlanRequest::operator!=(const BatchRoutePlanRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   BatchRoutePlanRequest& BatchRoutePlanRequest::setRequestID(const int64_t val)
+   {
+      __RequestID = val;
+      return *this;
+   }
+
+
+
+   BatchRoutePlanRequest& BatchRoutePlanRequest::setOperatingRegion(const int64_t val)
+   {
+      __OperatingRegion = val;
+      return *this;
+   }
+
+   BatchRoutePlanRequest& BatchRoutePlanRequest::setComputeTaskToTaskTiming(const bool val)
+   {
+      __ComputeTaskToTaskTiming = val;
+      return *this;
+   }
+
+   BatchRoutePlanRequest& BatchRoutePlanRequest::setComputeInterTaskToTaskTiming(const bool val)
+   {
+      __ComputeInterTaskToTaskTiming = val;
+      return *this;
+   }
+
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactBatchRoutePlanResponse.cpp b/src/LMCP/afrl/impact/afrlimpactBatchRoutePlanResponse.cpp
new file mode 100644
index 0000000..0ca2c9a
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactBatchRoutePlanResponse.cpp
@@ -0,0 +1,234 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/BatchRoutePlanResponse.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string BatchRoutePlanResponse::Subscription = "afrl.impact.BatchRoutePlanResponse";
+   const std::string BatchRoutePlanResponse::TypeName = "BatchRoutePlanResponse";
+   
+   bool isBatchRoutePlanResponse(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 10) return false;
+      return true;
+   }
+   
+   bool isBatchRoutePlanResponse(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 10) return false;
+      return true;
+   }
+   
+   std::vector< std::string > BatchRoutePlanResponseDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   BatchRoutePlanResponse::BatchRoutePlanResponse(void) : avtas::lmcp::Object()
+   {
+      __ResponseID = 0LL;
+
+   }
+     
+   BatchRoutePlanResponse::BatchRoutePlanResponse(const BatchRoutePlanResponse &that) : avtas::lmcp::Object(that)
+   {
+        __ResponseID = that.__ResponseID;
+        __VehicleTiming.clear();
+        for (size_t i=0; i< that.__VehicleTiming.size(); i++)
+        {
+           __VehicleTiming.push_back( that.__VehicleTiming[i] == nullptr ? nullptr : that.__VehicleTiming[i]->clone());
+        }
+
+   }
+   
+   BatchRoutePlanResponse & BatchRoutePlanResponse::operator=(const BatchRoutePlanResponse &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__VehicleTiming.size(); i++)
+         {
+            if (__VehicleTiming[i] != nullptr) delete __VehicleTiming[i];
+         }
+
+         __ResponseID = that.__ResponseID;
+         __VehicleTiming.clear();
+         for (size_t i=0; i< that.__VehicleTiming.size(); i++)
+         {
+            __VehicleTiming.push_back( that.__VehicleTiming[i] == nullptr ? nullptr : that.__VehicleTiming[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   BatchRoutePlanResponse* BatchRoutePlanResponse::clone() const
+   {
+        return new BatchRoutePlanResponse(*this);
+   }
+   
+   BatchRoutePlanResponse::~BatchRoutePlanResponse(void)
+   {
+      for (size_t i=0; i<__VehicleTiming.size(); i++)
+      {
+         if (__VehicleTiming[i] != nullptr) delete __VehicleTiming[i];
+      }
+
+   }
+  
+   void BatchRoutePlanResponse::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ResponseID);
+      buf.putUShort( static_cast<uint16_t>(__VehicleTiming.size()));
+      for (size_t i=0; i<__VehicleTiming.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __VehicleTiming[i], buf);
+      }
+
+   }
+   
+   void BatchRoutePlanResponse::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ResponseID = buf.getLong();
+      for (size_t i=0; i<__VehicleTiming.size(); i++)
+      {
+         if (__VehicleTiming[i] != nullptr)
+            delete __VehicleTiming[i];
+      }
+      __VehicleTiming.clear();
+      uint16_t __VehicleTiming_length = buf.getUShort();
+      for (uint32_t i=0; i< __VehicleTiming_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::impact::TaskTimingPair* e = (afrl::impact::TaskTimingPair*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __VehicleTiming.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t BatchRoutePlanResponse::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__VehicleTiming.size(); i++)
+      {
+         if (__VehicleTiming[i] != nullptr)
+         {
+            size += __VehicleTiming[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string BatchRoutePlanResponse::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( BatchRoutePlanResponse ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ResponseID (int64_t) = " << __ResponseID << "\n";
+      oss << indent << "VehicleTiming (TaskTimingPair [ " << __VehicleTiming.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string BatchRoutePlanResponse::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<BatchRoutePlanResponse Series=\"IMPACT\">\n";
+      str << ws << "   <ResponseID>" << __ResponseID << "</ResponseID>\n";
+      str << ws << "   <VehicleTiming>\n";
+      for (size_t i=0; i<__VehicleTiming.size(); i++)
+      {
+         str << (__VehicleTiming[i] == nullptr ? ( ws + "   <null/>\n") : (__VehicleTiming[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </VehicleTiming>\n";
+      str << ws << "</BatchRoutePlanResponse>\n";
+
+      return str.str();
+   }
+
+   bool BatchRoutePlanResponse::operator==(const BatchRoutePlanResponse & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ResponseID != that.__ResponseID) return false;
+      if(__VehicleTiming.size() != that.__VehicleTiming.size()) return false;
+      for (size_t i=0; i<__VehicleTiming.size(); i++)
+      {
+         if(__VehicleTiming[i] && that.__VehicleTiming[i])
+         {
+            if(__VehicleTiming[i]->getSeriesNameAsLong() != that.__VehicleTiming[i]->getSeriesNameAsLong()) return false;
+            if(__VehicleTiming[i]->getSeriesVersion() != that.__VehicleTiming[i]->getSeriesVersion()) return false;
+            if(__VehicleTiming[i]->getLmcpType() != that.__VehicleTiming[i]->getLmcpType()) return false;
+            if( *(__VehicleTiming[i]) != *(that.__VehicleTiming[i]) ) return false;
+         }
+         else if(__VehicleTiming[i] != that.__VehicleTiming[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool BatchRoutePlanResponse::operator!=(const BatchRoutePlanResponse & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   BatchRoutePlanResponse& BatchRoutePlanResponse::setResponseID(const int64_t val)
+   {
+      __ResponseID = val;
+      return *this;
+   }
+
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactBatchSummaryRequest.cpp b/src/LMCP/afrl/impact/afrlimpactBatchSummaryRequest.cpp
new file mode 100644
index 0000000..287560a
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactBatchSummaryRequest.cpp
@@ -0,0 +1,283 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/BatchSummaryRequest.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string BatchSummaryRequest::Subscription = "afrl.impact.BatchSummaryRequest";
+   const std::string BatchSummaryRequest::TypeName = "BatchSummaryRequest";
+   
+   bool isBatchSummaryRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 12) return false;
+      return true;
+   }
+   
+   bool isBatchSummaryRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 12) return false;
+      return true;
+   }
+   
+   std::vector< std::string > BatchSummaryRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   BatchSummaryRequest::BatchSummaryRequest(void) : avtas::lmcp::Object()
+   {
+      __RequestID = 0LL;
+      __OperatingRegion = 0LL;
+
+   }
+     
+   BatchSummaryRequest::BatchSummaryRequest(const BatchSummaryRequest &that) : avtas::lmcp::Object(that)
+   {
+        __RequestID = that.__RequestID;
+        __Vehicles.clear();
+        for (size_t i=0; i< that.__Vehicles.size(); i++)
+        {
+           __Vehicles.push_back( that.__Vehicles[i]);
+        }
+        __TaskList.clear();
+        for (size_t i=0; i< that.__TaskList.size(); i++)
+        {
+           __TaskList.push_back( that.__TaskList[i]);
+        }
+        __InterTaskPercentage.clear();
+        for (size_t i=0; i< that.__InterTaskPercentage.size(); i++)
+        {
+           __InterTaskPercentage.push_back( that.__InterTaskPercentage[i]);
+        }
+        __OperatingRegion = that.__OperatingRegion;
+
+   }
+   
+   BatchSummaryRequest & BatchSummaryRequest::operator=(const BatchSummaryRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __RequestID = that.__RequestID;
+         __Vehicles.clear();
+         for (size_t i=0; i< that.__Vehicles.size(); i++)
+         {
+            __Vehicles.push_back( that.__Vehicles[i]);
+         }
+         __TaskList.clear();
+         for (size_t i=0; i< that.__TaskList.size(); i++)
+         {
+            __TaskList.push_back( that.__TaskList[i]);
+         }
+         __InterTaskPercentage.clear();
+         for (size_t i=0; i< that.__InterTaskPercentage.size(); i++)
+         {
+            __InterTaskPercentage.push_back( that.__InterTaskPercentage[i]);
+         }
+         __OperatingRegion = that.__OperatingRegion;
+
+      }
+      return *this;
+   }
+
+   BatchSummaryRequest* BatchSummaryRequest::clone() const
+   {
+        return new BatchSummaryRequest(*this);
+   }
+   
+   BatchSummaryRequest::~BatchSummaryRequest(void)
+   {
+
+   }
+  
+   void BatchSummaryRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RequestID);
+      buf.putUShort( static_cast<uint16_t>(__Vehicles.size()));
+      for (size_t i=0; i<__Vehicles.size(); i++)
+      {
+         buf.putLong(__Vehicles[i]);
+      }
+      buf.putUShort( static_cast<uint16_t>(__TaskList.size()));
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         buf.putLong(__TaskList[i]);
+      }
+      buf.putUShort( static_cast<uint16_t>(__InterTaskPercentage.size()));
+      for (size_t i=0; i<__InterTaskPercentage.size(); i++)
+      {
+         buf.putFloat(__InterTaskPercentage[i]);
+      }
+      buf.putLong(__OperatingRegion);
+
+   }
+   
+   void BatchSummaryRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RequestID = buf.getLong();
+      __Vehicles.clear();
+      uint16_t __Vehicles_length = buf.getUShort();
+      for (uint32_t i=0; i< __Vehicles_length; i++)
+      {
+         __Vehicles.push_back(buf.getLong() );
+      }
+      __TaskList.clear();
+      uint16_t __TaskList_length = buf.getUShort();
+      for (uint32_t i=0; i< __TaskList_length; i++)
+      {
+         __TaskList.push_back(buf.getLong() );
+      }
+      __InterTaskPercentage.clear();
+      uint16_t __InterTaskPercentage_length = buf.getUShort();
+      for (uint32_t i=0; i< __InterTaskPercentage_length; i++)
+      {
+         __InterTaskPercentage.push_back(buf.getFloat() );
+      }
+      __OperatingRegion = buf.getLong();
+
+   }
+
+   uint32_t BatchSummaryRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2 + sizeof(int64_t) * __Vehicles.size();
+      size += 2 + sizeof(int64_t) * __TaskList.size();
+      size += 2 + sizeof(float) * __InterTaskPercentage.size();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string BatchSummaryRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( BatchSummaryRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RequestID (int64_t) = " << __RequestID << "\n";
+      oss << indent << "Vehicles (int64 [ " << __Vehicles.size() << ", var ])\n";
+      oss << indent << "TaskList (int64 [ " << __TaskList.size() << ", var ])\n";
+      oss << indent << "InterTaskPercentage (real32 [ " << __InterTaskPercentage.size() << ", var ])\n";
+      oss << indent << "OperatingRegion (int64_t) = " << __OperatingRegion << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string BatchSummaryRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<BatchSummaryRequest Series=\"IMPACT\">\n";
+      str << ws << "   <RequestID>" << __RequestID << "</RequestID>\n";
+      str << ws << "   <Vehicles>\n";
+      for (size_t i=0; i<__Vehicles.size(); i++)
+      {
+         str << ws << "   <int64>" << __Vehicles[i] << "</int64>\n";
+      }
+      str << ws << "   </Vehicles>\n";
+      str << ws << "   <TaskList>\n";
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __TaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </TaskList>\n";
+      str << ws << "   <InterTaskPercentage>\n";
+      for (size_t i=0; i<__InterTaskPercentage.size(); i++)
+      {
+         str << ws << "   <real32>" << __InterTaskPercentage[i] << "</real32>\n";
+      }
+      str << ws << "   </InterTaskPercentage>\n";
+      str << ws << "   <OperatingRegion>" << __OperatingRegion << "</OperatingRegion>\n";
+      str << ws << "</BatchSummaryRequest>\n";
+
+      return str.str();
+   }
+
+   bool BatchSummaryRequest::operator==(const BatchSummaryRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RequestID != that.__RequestID) return false;
+      if(__Vehicles.size() != that.__Vehicles.size()) return false;
+      for (size_t i=0; i<__Vehicles.size(); i++)
+      {
+         if(__Vehicles[i] != that.__Vehicles[i]) return false;
+      }
+      if(__TaskList.size() != that.__TaskList.size()) return false;
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         if(__TaskList[i] != that.__TaskList[i]) return false;
+      }
+      if(__InterTaskPercentage.size() != that.__InterTaskPercentage.size()) return false;
+      for (size_t i=0; i<__InterTaskPercentage.size(); i++)
+      {
+         if(__InterTaskPercentage[i] != that.__InterTaskPercentage[i]) return false;
+      }
+      if(__OperatingRegion != that.__OperatingRegion) return false;
+      return true;
+
+   }
+
+   bool BatchSummaryRequest::operator!=(const BatchSummaryRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   BatchSummaryRequest& BatchSummaryRequest::setRequestID(const int64_t val)
+   {
+      __RequestID = val;
+      return *this;
+   }
+
+
+
+
+   BatchSummaryRequest& BatchSummaryRequest::setOperatingRegion(const int64_t val)
+   {
+      __OperatingRegion = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactBatchSummaryResponse.cpp b/src/LMCP/afrl/impact/afrlimpactBatchSummaryResponse.cpp
new file mode 100644
index 0000000..644f928
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactBatchSummaryResponse.cpp
@@ -0,0 +1,234 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/BatchSummaryResponse.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string BatchSummaryResponse::Subscription = "afrl.impact.BatchSummaryResponse";
+   const std::string BatchSummaryResponse::TypeName = "BatchSummaryResponse";
+   
+   bool isBatchSummaryResponse(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 13) return false;
+      return true;
+   }
+   
+   bool isBatchSummaryResponse(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 13) return false;
+      return true;
+   }
+   
+   std::vector< std::string > BatchSummaryResponseDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   BatchSummaryResponse::BatchSummaryResponse(void) : avtas::lmcp::Object()
+   {
+      __ResponseID = 0LL;
+
+   }
+     
+   BatchSummaryResponse::BatchSummaryResponse(const BatchSummaryResponse &that) : avtas::lmcp::Object(that)
+   {
+        __ResponseID = that.__ResponseID;
+        __Summaries.clear();
+        for (size_t i=0; i< that.__Summaries.size(); i++)
+        {
+           __Summaries.push_back( that.__Summaries[i] == nullptr ? nullptr : that.__Summaries[i]->clone());
+        }
+
+   }
+   
+   BatchSummaryResponse & BatchSummaryResponse::operator=(const BatchSummaryResponse &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Summaries.size(); i++)
+         {
+            if (__Summaries[i] != nullptr) delete __Summaries[i];
+         }
+
+         __ResponseID = that.__ResponseID;
+         __Summaries.clear();
+         for (size_t i=0; i< that.__Summaries.size(); i++)
+         {
+            __Summaries.push_back( that.__Summaries[i] == nullptr ? nullptr : that.__Summaries[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   BatchSummaryResponse* BatchSummaryResponse::clone() const
+   {
+        return new BatchSummaryResponse(*this);
+   }
+   
+   BatchSummaryResponse::~BatchSummaryResponse(void)
+   {
+      for (size_t i=0; i<__Summaries.size(); i++)
+      {
+         if (__Summaries[i] != nullptr) delete __Summaries[i];
+      }
+
+   }
+  
+   void BatchSummaryResponse::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ResponseID);
+      buf.putUShort( static_cast<uint16_t>(__Summaries.size()));
+      for (size_t i=0; i<__Summaries.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Summaries[i], buf);
+      }
+
+   }
+   
+   void BatchSummaryResponse::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ResponseID = buf.getLong();
+      for (size_t i=0; i<__Summaries.size(); i++)
+      {
+         if (__Summaries[i] != nullptr)
+            delete __Summaries[i];
+      }
+      __Summaries.clear();
+      uint16_t __Summaries_length = buf.getUShort();
+      for (uint32_t i=0; i< __Summaries_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::impact::TaskSummary* e = (afrl::impact::TaskSummary*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Summaries.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t BatchSummaryResponse::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__Summaries.size(); i++)
+      {
+         if (__Summaries[i] != nullptr)
+         {
+            size += __Summaries[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string BatchSummaryResponse::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( BatchSummaryResponse ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ResponseID (int64_t) = " << __ResponseID << "\n";
+      oss << indent << "Summaries (TaskSummary [ " << __Summaries.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string BatchSummaryResponse::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<BatchSummaryResponse Series=\"IMPACT\">\n";
+      str << ws << "   <ResponseID>" << __ResponseID << "</ResponseID>\n";
+      str << ws << "   <Summaries>\n";
+      for (size_t i=0; i<__Summaries.size(); i++)
+      {
+         str << (__Summaries[i] == nullptr ? ( ws + "   <null/>\n") : (__Summaries[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Summaries>\n";
+      str << ws << "</BatchSummaryResponse>\n";
+
+      return str.str();
+   }
+
+   bool BatchSummaryResponse::operator==(const BatchSummaryResponse & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ResponseID != that.__ResponseID) return false;
+      if(__Summaries.size() != that.__Summaries.size()) return false;
+      for (size_t i=0; i<__Summaries.size(); i++)
+      {
+         if(__Summaries[i] && that.__Summaries[i])
+         {
+            if(__Summaries[i]->getSeriesNameAsLong() != that.__Summaries[i]->getSeriesNameAsLong()) return false;
+            if(__Summaries[i]->getSeriesVersion() != that.__Summaries[i]->getSeriesVersion()) return false;
+            if(__Summaries[i]->getLmcpType() != that.__Summaries[i]->getLmcpType()) return false;
+            if( *(__Summaries[i]) != *(that.__Summaries[i]) ) return false;
+         }
+         else if(__Summaries[i] != that.__Summaries[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool BatchSummaryResponse::operator!=(const BatchSummaryResponse & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   BatchSummaryResponse& BatchSummaryResponse::setResponseID(const int64_t val)
+   {
+      __ResponseID = val;
+      return *this;
+   }
+
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactBlockadeTask.cpp b/src/LMCP/afrl/impact/afrlimpactBlockadeTask.cpp
new file mode 100644
index 0000000..030c998
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactBlockadeTask.cpp
@@ -0,0 +1,264 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/BlockadeTask.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string BlockadeTask::Subscription = "afrl.impact.BlockadeTask";
+   const std::string BlockadeTask::TypeName = "BlockadeTask";
+   
+   bool isBlockadeTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 33) return false;
+      return true;
+   }
+   
+   bool isBlockadeTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 33) return false;
+      return true;
+   }
+   
+   std::vector< std::string > BlockadeTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   BlockadeTask::BlockadeTask(void) : afrl::cmasi::Task()
+   {
+      __BlockedEntityID = 0LL;
+      __StandoffDistance = 0.f;
+      __NumberVehicles = 1;
+      __ProtectedLocation = nullptr;
+
+   }
+     
+   BlockadeTask::BlockadeTask(const BlockadeTask &that) : afrl::cmasi::Task(that)
+   {
+        __BlockedEntityID = that.__BlockedEntityID;
+        __StandoffDistance = that.__StandoffDistance;
+        __NumberVehicles = that.__NumberVehicles;
+        __ProtectedLocation = that.__ProtectedLocation == nullptr ? nullptr : that.__ProtectedLocation->clone();
+
+   }
+   
+   BlockadeTask & BlockadeTask::operator=(const BlockadeTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::Task::operator=(that);
+         if (__ProtectedLocation != nullptr) delete __ProtectedLocation;
+
+         __BlockedEntityID = that.__BlockedEntityID;
+         __StandoffDistance = that.__StandoffDistance;
+         __NumberVehicles = that.__NumberVehicles;
+         __ProtectedLocation = that.__ProtectedLocation == nullptr ? nullptr : that.__ProtectedLocation->clone();
+
+      }
+      return *this;
+   }
+
+   BlockadeTask* BlockadeTask::clone() const
+   {
+        return new BlockadeTask(*this);
+   }
+   
+   BlockadeTask::~BlockadeTask(void)
+   {
+      if (__ProtectedLocation != nullptr) delete __ProtectedLocation;
+
+   }
+  
+   void BlockadeTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::Task::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__BlockedEntityID);
+      buf.putFloat(__StandoffDistance);
+      buf.putByte(__NumberVehicles);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __ProtectedLocation, buf);
+
+   }
+   
+   void BlockadeTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::Task::unpack(buf);
+      // Copy the buffer into the class
+      __BlockedEntityID = buf.getLong();
+      __StandoffDistance = buf.getFloat();
+      __NumberVehicles = buf.getByte();
+      {
+         if (__ProtectedLocation != nullptr) delete __ProtectedLocation;
+         __ProtectedLocation = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __ProtectedLocation = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__ProtectedLocation != nullptr) __ProtectedLocation->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t BlockadeTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::Task::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += sizeof(uint8_t);
+      size += (__ProtectedLocation != nullptr ? __ProtectedLocation->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string BlockadeTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( BlockadeTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "BlockedEntityID (int64_t) = " << __BlockedEntityID << "\n";
+      oss << indent << "StandoffDistance (float) = " << __StandoffDistance << "\n";
+      oss << indent << "NumberVehicles (uint8_t) = " << __NumberVehicles << "\n";
+      oss << indent << "ProtectedLocation (Location3D)";
+      if (__ProtectedLocation == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string BlockadeTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<BlockadeTask Series=\"IMPACT\">\n";
+      str << ws << "   <BlockedEntityID>" << __BlockedEntityID << "</BlockedEntityID>\n";
+      str << ws << "   <StandoffDistance>" << __StandoffDistance << "</StandoffDistance>\n";
+      str << ws << "   <NumberVehicles>" << (int32_t) __NumberVehicles << "</NumberVehicles>\n";
+      if (__ProtectedLocation != nullptr)
+      {
+         str << ws << "   <ProtectedLocation>";
+         str << "\n" + __ProtectedLocation->toXML(depth + 1) + ws + "   ";
+         str << "</ProtectedLocation>\n";
+      }
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</BlockadeTask>\n";
+
+      return str.str();
+   }
+
+   bool BlockadeTask::operator==(const BlockadeTask & that)
+   {
+      if( afrl::cmasi::Task::operator!=(that) )
+      {
+          return false;
+      }
+      if(__BlockedEntityID != that.__BlockedEntityID) return false;
+      if(__StandoffDistance != that.__StandoffDistance) return false;
+      if(__NumberVehicles != that.__NumberVehicles) return false;
+      if(__ProtectedLocation && that.__ProtectedLocation)
+      {
+         if(__ProtectedLocation->getSeriesNameAsLong() != that.__ProtectedLocation->getSeriesNameAsLong()) return false;
+         if(__ProtectedLocation->getSeriesVersion() != that.__ProtectedLocation->getSeriesVersion()) return false;
+         if(__ProtectedLocation->getLmcpType() != that.__ProtectedLocation->getLmcpType()) return false;
+         if( *(__ProtectedLocation) != *(that.__ProtectedLocation) ) return false;
+      }
+      else if(__ProtectedLocation != that.__ProtectedLocation) return false;
+      return true;
+
+   }
+
+   bool BlockadeTask::operator!=(const BlockadeTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   BlockadeTask& BlockadeTask::setBlockedEntityID(const int64_t val)
+   {
+      __BlockedEntityID = val;
+      return *this;
+   }
+
+   BlockadeTask& BlockadeTask::setStandoffDistance(const float val)
+   {
+      __StandoffDistance = val;
+      return *this;
+   }
+
+   BlockadeTask& BlockadeTask::setNumberVehicles(const uint8_t val)
+   {
+      __NumberVehicles = val;
+      return *this;
+   }
+
+   BlockadeTask& BlockadeTask::setProtectedLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__ProtectedLocation != nullptr) { delete __ProtectedLocation; __ProtectedLocation = nullptr; }
+      if (val != nullptr) { __ProtectedLocation = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactCommRelayTask.cpp b/src/LMCP/afrl/impact/afrlimpactCommRelayTask.cpp
new file mode 100644
index 0000000..93b4717
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactCommRelayTask.cpp
@@ -0,0 +1,249 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/CommRelayTask.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string CommRelayTask::Subscription = "afrl.impact.CommRelayTask";
+   const std::string CommRelayTask::TypeName = "CommRelayTask";
+   
+   bool isCommRelayTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 31) return false;
+      return true;
+   }
+   
+   bool isCommRelayTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 31) return false;
+      return true;
+   }
+   
+   std::vector< std::string > CommRelayTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   CommRelayTask::CommRelayTask(void) : afrl::cmasi::Task()
+   {
+      __SupportedEntityID = 0LL;
+      __DestinationLocation = new afrl::cmasi::Location3D();
+      __TowerID = 0LL;
+
+   }
+     
+   CommRelayTask::CommRelayTask(const CommRelayTask &that) : afrl::cmasi::Task(that)
+   {
+        __SupportedEntityID = that.__SupportedEntityID;
+        __DestinationLocation = that.__DestinationLocation == nullptr ? nullptr : that.__DestinationLocation->clone();
+        __TowerID = that.__TowerID;
+
+   }
+   
+   CommRelayTask & CommRelayTask::operator=(const CommRelayTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::Task::operator=(that);
+         if (__DestinationLocation != nullptr) delete __DestinationLocation;
+
+         __SupportedEntityID = that.__SupportedEntityID;
+         __DestinationLocation = that.__DestinationLocation == nullptr ? nullptr : that.__DestinationLocation->clone();
+         __TowerID = that.__TowerID;
+
+      }
+      return *this;
+   }
+
+   CommRelayTask* CommRelayTask::clone() const
+   {
+        return new CommRelayTask(*this);
+   }
+   
+   CommRelayTask::~CommRelayTask(void)
+   {
+      if (__DestinationLocation != nullptr) delete __DestinationLocation;
+
+   }
+  
+   void CommRelayTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::Task::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__SupportedEntityID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __DestinationLocation, buf);
+      buf.putLong(__TowerID);
+
+   }
+   
+   void CommRelayTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::Task::unpack(buf);
+      // Copy the buffer into the class
+      __SupportedEntityID = buf.getLong();
+      {
+         if (__DestinationLocation != nullptr) delete __DestinationLocation;
+         __DestinationLocation = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __DestinationLocation = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__DestinationLocation != nullptr) __DestinationLocation->unpack(buf);
+         }
+      }
+      __TowerID = buf.getLong();
+
+   }
+
+   uint32_t CommRelayTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::Task::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__DestinationLocation != nullptr ? __DestinationLocation->calculatePackedSize() + 15 : 1);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string CommRelayTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( CommRelayTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "SupportedEntityID (int64_t) = " << __SupportedEntityID << "\n";
+      oss << indent << "DestinationLocation (Location3D)";
+      if (__DestinationLocation == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "TowerID (int64_t) = " << __TowerID << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string CommRelayTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<CommRelayTask Series=\"IMPACT\">\n";
+      str << ws << "   <SupportedEntityID>" << __SupportedEntityID << "</SupportedEntityID>\n";
+      if (__DestinationLocation != nullptr)
+      {
+         str << ws << "   <DestinationLocation>";
+         str << "\n" + __DestinationLocation->toXML(depth + 1) + ws + "   ";
+         str << "</DestinationLocation>\n";
+      }
+      str << ws << "   <TowerID>" << __TowerID << "</TowerID>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</CommRelayTask>\n";
+
+      return str.str();
+   }
+
+   bool CommRelayTask::operator==(const CommRelayTask & that)
+   {
+      if( afrl::cmasi::Task::operator!=(that) )
+      {
+          return false;
+      }
+      if(__SupportedEntityID != that.__SupportedEntityID) return false;
+      if(__DestinationLocation && that.__DestinationLocation)
+      {
+         if(__DestinationLocation->getSeriesNameAsLong() != that.__DestinationLocation->getSeriesNameAsLong()) return false;
+         if(__DestinationLocation->getSeriesVersion() != that.__DestinationLocation->getSeriesVersion()) return false;
+         if(__DestinationLocation->getLmcpType() != that.__DestinationLocation->getLmcpType()) return false;
+         if( *(__DestinationLocation) != *(that.__DestinationLocation) ) return false;
+      }
+      else if(__DestinationLocation != that.__DestinationLocation) return false;
+      if(__TowerID != that.__TowerID) return false;
+      return true;
+
+   }
+
+   bool CommRelayTask::operator!=(const CommRelayTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   CommRelayTask& CommRelayTask::setSupportedEntityID(const int64_t val)
+   {
+      __SupportedEntityID = val;
+      return *this;
+   }
+
+   CommRelayTask& CommRelayTask::setDestinationLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__DestinationLocation != nullptr) { delete __DestinationLocation; __DestinationLocation = nullptr; }
+      if (val != nullptr) { __DestinationLocation = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   CommRelayTask& CommRelayTask::setTowerID(const int64_t val)
+   {
+      __TowerID = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactConfigurationRequest.cpp b/src/LMCP/afrl/impact/afrlimpactConfigurationRequest.cpp
new file mode 100644
index 0000000..853d2a4
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactConfigurationRequest.cpp
@@ -0,0 +1,183 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/ConfigurationRequest.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string ConfigurationRequest::Subscription = "afrl.impact.ConfigurationRequest";
+   const std::string ConfigurationRequest::TypeName = "ConfigurationRequest";
+   
+   bool isConfigurationRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 35) return false;
+      return true;
+   }
+   
+   bool isConfigurationRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 35) return false;
+      return true;
+   }
+   
+   std::vector< std::string > ConfigurationRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   ConfigurationRequest::ConfigurationRequest(void) : avtas::lmcp::Object()
+   {
+
+   }
+     
+   ConfigurationRequest::ConfigurationRequest(const ConfigurationRequest &that) : avtas::lmcp::Object(that)
+   {
+        __VehicleID.clear();
+        for (size_t i=0; i< that.__VehicleID.size(); i++)
+        {
+           __VehicleID.push_back( that.__VehicleID[i]);
+        }
+
+   }
+   
+   ConfigurationRequest & ConfigurationRequest::operator=(const ConfigurationRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __VehicleID.clear();
+         for (size_t i=0; i< that.__VehicleID.size(); i++)
+         {
+            __VehicleID.push_back( that.__VehicleID[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   ConfigurationRequest* ConfigurationRequest::clone() const
+   {
+        return new ConfigurationRequest(*this);
+   }
+   
+   ConfigurationRequest::~ConfigurationRequest(void)
+   {
+
+   }
+  
+   void ConfigurationRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__VehicleID.size()));
+      for (size_t i=0; i<__VehicleID.size(); i++)
+      {
+         buf.putLong(__VehicleID[i]);
+      }
+
+   }
+   
+   void ConfigurationRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __VehicleID.clear();
+      uint16_t __VehicleID_length = buf.getUShort();
+      for (uint32_t i=0; i< __VehicleID_length; i++)
+      {
+         __VehicleID.push_back(buf.getLong() );
+      }
+
+   }
+
+   uint32_t ConfigurationRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2 + sizeof(int64_t) * __VehicleID.size();
+
+      return size;
+   }
+
+   std::string ConfigurationRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( ConfigurationRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "VehicleID (int64 [ " << __VehicleID.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string ConfigurationRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<ConfigurationRequest Series=\"IMPACT\">\n";
+      str << ws << "   <VehicleID>\n";
+      for (size_t i=0; i<__VehicleID.size(); i++)
+      {
+         str << ws << "   <int64>" << __VehicleID[i] << "</int64>\n";
+      }
+      str << ws << "   </VehicleID>\n";
+      str << ws << "</ConfigurationRequest>\n";
+
+      return str.str();
+   }
+
+   bool ConfigurationRequest::operator==(const ConfigurationRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__VehicleID.size() != that.__VehicleID.size()) return false;
+      for (size_t i=0; i<__VehicleID.size(); i++)
+      {
+         if(__VehicleID[i] != that.__VehicleID[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool ConfigurationRequest::operator!=(const ConfigurationRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactCordonTask.cpp b/src/LMCP/afrl/impact/afrlimpactCordonTask.cpp
new file mode 100644
index 0000000..70dfe58
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactCordonTask.cpp
@@ -0,0 +1,234 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/CordonTask.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string CordonTask::Subscription = "afrl.impact.CordonTask";
+   const std::string CordonTask::TypeName = "CordonTask";
+   
+   bool isCordonTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 32) return false;
+      return true;
+   }
+   
+   bool isCordonTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 32) return false;
+      return true;
+   }
+   
+   std::vector< std::string > CordonTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   CordonTask::CordonTask(void) : afrl::cmasi::Task()
+   {
+      __CordonLocation = new afrl::cmasi::Location3D();
+      __StandoffDistance = 100.f;
+
+   }
+     
+   CordonTask::CordonTask(const CordonTask &that) : afrl::cmasi::Task(that)
+   {
+        __CordonLocation = that.__CordonLocation == nullptr ? nullptr : that.__CordonLocation->clone();
+        __StandoffDistance = that.__StandoffDistance;
+
+   }
+   
+   CordonTask & CordonTask::operator=(const CordonTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::Task::operator=(that);
+         if (__CordonLocation != nullptr) delete __CordonLocation;
+
+         __CordonLocation = that.__CordonLocation == nullptr ? nullptr : that.__CordonLocation->clone();
+         __StandoffDistance = that.__StandoffDistance;
+
+      }
+      return *this;
+   }
+
+   CordonTask* CordonTask::clone() const
+   {
+        return new CordonTask(*this);
+   }
+   
+   CordonTask::~CordonTask(void)
+   {
+      if (__CordonLocation != nullptr) delete __CordonLocation;
+
+   }
+  
+   void CordonTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::Task::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __CordonLocation, buf);
+      buf.putFloat(__StandoffDistance);
+
+   }
+   
+   void CordonTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::Task::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__CordonLocation != nullptr) delete __CordonLocation;
+         __CordonLocation = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __CordonLocation = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__CordonLocation != nullptr) __CordonLocation->unpack(buf);
+         }
+      }
+      __StandoffDistance = buf.getFloat();
+
+   }
+
+   uint32_t CordonTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::Task::calculatePackedSize();
+      size += (__CordonLocation != nullptr ? __CordonLocation->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string CordonTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( CordonTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "CordonLocation (Location3D)";
+      if (__CordonLocation == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "StandoffDistance (float) = " << __StandoffDistance << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string CordonTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<CordonTask Series=\"IMPACT\">\n";
+      if (__CordonLocation != nullptr)
+      {
+         str << ws << "   <CordonLocation>";
+         str << "\n" + __CordonLocation->toXML(depth + 1) + ws + "   ";
+         str << "</CordonLocation>\n";
+      }
+      str << ws << "   <StandoffDistance>" << __StandoffDistance << "</StandoffDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</CordonTask>\n";
+
+      return str.str();
+   }
+
+   bool CordonTask::operator==(const CordonTask & that)
+   {
+      if( afrl::cmasi::Task::operator!=(that) )
+      {
+          return false;
+      }
+      if(__CordonLocation && that.__CordonLocation)
+      {
+         if(__CordonLocation->getSeriesNameAsLong() != that.__CordonLocation->getSeriesNameAsLong()) return false;
+         if(__CordonLocation->getSeriesVersion() != that.__CordonLocation->getSeriesVersion()) return false;
+         if(__CordonLocation->getLmcpType() != that.__CordonLocation->getLmcpType()) return false;
+         if( *(__CordonLocation) != *(that.__CordonLocation) ) return false;
+      }
+      else if(__CordonLocation != that.__CordonLocation) return false;
+      if(__StandoffDistance != that.__StandoffDistance) return false;
+      return true;
+
+   }
+
+   bool CordonTask::operator!=(const CordonTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   CordonTask& CordonTask::setCordonLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__CordonLocation != nullptr) { delete __CordonLocation; __CordonLocation = nullptr; }
+      if (val != nullptr) { __CordonLocation = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   CordonTask& CordonTask::setStandoffDistance(const float val)
+   {
+      __StandoffDistance = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactDeployImpactPayload.cpp b/src/LMCP/afrl/impact/afrlimpactDeployImpactPayload.cpp
new file mode 100644
index 0000000..ad09051
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactDeployImpactPayload.cpp
@@ -0,0 +1,201 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/DeployImpactPayload.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string DeployImpactPayload::Subscription = "afrl.impact.DeployImpactPayload";
+   const std::string DeployImpactPayload::TypeName = "DeployImpactPayload";
+   
+   bool isDeployImpactPayload(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 7) return false;
+      return true;
+   }
+   
+   bool isDeployImpactPayload(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 7) return false;
+      return true;
+   }
+   
+   std::vector< std::string > DeployImpactPayloadDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   DeployImpactPayload::DeployImpactPayload(void) : afrl::cmasi::VehicleAction()
+   {
+      __VehicleID = 0LL;
+      __DeployedPayload = afrl::impact::ImpactPayloadType::Unknown;
+      __TargetEntityID = 0LL;
+
+   }
+     
+   DeployImpactPayload::DeployImpactPayload(const DeployImpactPayload &that) : afrl::cmasi::VehicleAction(that)
+   {
+        __VehicleID = that.__VehicleID;
+        __DeployedPayload = that.__DeployedPayload;
+        __TargetEntityID = that.__TargetEntityID;
+
+   }
+   
+   DeployImpactPayload & DeployImpactPayload::operator=(const DeployImpactPayload &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::VehicleAction::operator=(that);
+
+         __VehicleID = that.__VehicleID;
+         __DeployedPayload = that.__DeployedPayload;
+         __TargetEntityID = that.__TargetEntityID;
+
+      }
+      return *this;
+   }
+
+   DeployImpactPayload* DeployImpactPayload::clone() const
+   {
+        return new DeployImpactPayload(*this);
+   }
+   
+   DeployImpactPayload::~DeployImpactPayload(void)
+   {
+
+   }
+  
+   void DeployImpactPayload::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::VehicleAction::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__VehicleID);
+      buf.putInt( (int32_t) __DeployedPayload);
+      buf.putLong(__TargetEntityID);
+
+   }
+   
+   void DeployImpactPayload::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::VehicleAction::unpack(buf);
+      // Copy the buffer into the class
+      __VehicleID = buf.getLong();
+      __DeployedPayload = (afrl::impact::ImpactPayloadType::ImpactPayloadType) buf.getInt();
+      __TargetEntityID = buf.getLong();
+
+   }
+
+   uint32_t DeployImpactPayload::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::VehicleAction::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(afrl::impact::ImpactPayloadType::ImpactPayloadType);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string DeployImpactPayload::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( DeployImpactPayload ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AssociatedTaskList (int64 [ " << __AssociatedTaskList.size() << ", var ])\n";
+
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "DeployedPayload (ImpactPayloadType) = " << __DeployedPayload << "\n";
+      oss << indent << "TargetEntityID (int64_t) = " << __TargetEntityID << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string DeployImpactPayload::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<DeployImpactPayload Series=\"IMPACT\">\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <DeployedPayload>" << afrl::impact::ImpactPayloadType::get_string(__DeployedPayload) << "</DeployedPayload>\n";
+      str << ws << "   <TargetEntityID>" << __TargetEntityID << "</TargetEntityID>\n";
+      str << ws << "   <AssociatedTaskList>\n";
+      for (size_t i=0; i<__AssociatedTaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTaskList>\n";
+      str << ws << "</DeployImpactPayload>\n";
+
+      return str.str();
+   }
+
+   bool DeployImpactPayload::operator==(const DeployImpactPayload & that)
+   {
+      if( afrl::cmasi::VehicleAction::operator!=(that) )
+      {
+          return false;
+      }
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__DeployedPayload != that.__DeployedPayload) return false;
+      if(__TargetEntityID != that.__TargetEntityID) return false;
+      return true;
+
+   }
+
+   bool DeployImpactPayload::operator!=(const DeployImpactPayload & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   DeployImpactPayload& DeployImpactPayload::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+   DeployImpactPayload& DeployImpactPayload::setDeployedPayload(const afrl::impact::ImpactPayloadType::ImpactPayloadType val)
+   {
+      __DeployedPayload = val;
+      return *this;
+   }
+
+   DeployImpactPayload& DeployImpactPayload::setTargetEntityID(const int64_t val)
+   {
+      __TargetEntityID = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactEscortTask.cpp b/src/LMCP/afrl/impact/afrlimpactEscortTask.cpp
new file mode 100644
index 0000000..59f1528
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactEscortTask.cpp
@@ -0,0 +1,302 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/EscortTask.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string EscortTask::Subscription = "afrl.impact.EscortTask";
+   const std::string EscortTask::TypeName = "EscortTask";
+   
+   bool isEscortTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 34) return false;
+      return true;
+   }
+   
+   bool isEscortTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 34) return false;
+      return true;
+   }
+   
+   std::vector< std::string > EscortTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   EscortTask::EscortTask(void) : afrl::cmasi::SearchTask()
+   {
+      __SupportedEntityID = 0LL;
+      __RouteID = 0LL;
+      __StandoffDistance = 100.f;
+
+   }
+     
+   EscortTask::EscortTask(const EscortTask &that) : afrl::cmasi::SearchTask(that)
+   {
+        __SupportedEntityID = that.__SupportedEntityID;
+        __RouteID = that.__RouteID;
+        __PrescribedWaypoints.clear();
+        for (size_t i=0; i< that.__PrescribedWaypoints.size(); i++)
+        {
+           __PrescribedWaypoints.push_back( that.__PrescribedWaypoints[i] == nullptr ? nullptr : that.__PrescribedWaypoints[i]->clone());
+        }
+        __StandoffDistance = that.__StandoffDistance;
+
+   }
+   
+   EscortTask & EscortTask::operator=(const EscortTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::SearchTask::operator=(that);
+         for (size_t i=0; i<__PrescribedWaypoints.size(); i++)
+         {
+            if (__PrescribedWaypoints[i] != nullptr) delete __PrescribedWaypoints[i];
+         }
+
+         __SupportedEntityID = that.__SupportedEntityID;
+         __RouteID = that.__RouteID;
+         __PrescribedWaypoints.clear();
+         for (size_t i=0; i< that.__PrescribedWaypoints.size(); i++)
+         {
+            __PrescribedWaypoints.push_back( that.__PrescribedWaypoints[i] == nullptr ? nullptr : that.__PrescribedWaypoints[i]->clone());
+         }
+         __StandoffDistance = that.__StandoffDistance;
+
+      }
+      return *this;
+   }
+
+   EscortTask* EscortTask::clone() const
+   {
+        return new EscortTask(*this);
+   }
+   
+   EscortTask::~EscortTask(void)
+   {
+      for (size_t i=0; i<__PrescribedWaypoints.size(); i++)
+      {
+         if (__PrescribedWaypoints[i] != nullptr) delete __PrescribedWaypoints[i];
+      }
+
+   }
+  
+   void EscortTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::SearchTask::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__SupportedEntityID);
+      buf.putLong(__RouteID);
+      buf.putUShort( static_cast<uint16_t>(__PrescribedWaypoints.size()));
+      for (size_t i=0; i<__PrescribedWaypoints.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __PrescribedWaypoints[i], buf);
+      }
+      buf.putFloat(__StandoffDistance);
+
+   }
+   
+   void EscortTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::SearchTask::unpack(buf);
+      // Copy the buffer into the class
+      __SupportedEntityID = buf.getLong();
+      __RouteID = buf.getLong();
+      for (size_t i=0; i<__PrescribedWaypoints.size(); i++)
+      {
+         if (__PrescribedWaypoints[i] != nullptr)
+            delete __PrescribedWaypoints[i];
+      }
+      __PrescribedWaypoints.clear();
+      uint16_t __PrescribedWaypoints_length = buf.getUShort();
+      for (uint32_t i=0; i< __PrescribedWaypoints_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Waypoint* e = (afrl::cmasi::Waypoint*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __PrescribedWaypoints.push_back(e);
+         }
+      }
+      __StandoffDistance = buf.getFloat();
+
+   }
+
+   uint32_t EscortTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::SearchTask::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__PrescribedWaypoints.size(); i++)
+      {
+         if (__PrescribedWaypoints[i] != nullptr)
+         {
+            size += __PrescribedWaypoints[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string EscortTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( EscortTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "DesiredWavelengthBands (WavelengthBand [ " << __DesiredWavelengthBands.size() << ", var ])\n";
+      oss << indent << "DwellTime (int64_t) = " << __DwellTime << "\n";
+      oss << indent << "GroundSampleDistance (float) = " << __GroundSampleDistance << "\n";
+
+      oss << indent << "SupportedEntityID (int64_t) = " << __SupportedEntityID << "\n";
+      oss << indent << "RouteID (int64_t) = " << __RouteID << "\n";
+      oss << indent << "PrescribedWaypoints (Waypoint [ " << __PrescribedWaypoints.size() << ", var ])\n";
+      oss << indent << "StandoffDistance (float) = " << __StandoffDistance << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string EscortTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<EscortTask Series=\"IMPACT\">\n";
+      str << ws << "   <SupportedEntityID>" << __SupportedEntityID << "</SupportedEntityID>\n";
+      str << ws << "   <RouteID>" << __RouteID << "</RouteID>\n";
+      str << ws << "   <PrescribedWaypoints>\n";
+      for (size_t i=0; i<__PrescribedWaypoints.size(); i++)
+      {
+         str << (__PrescribedWaypoints[i] == nullptr ? ( ws + "   <null/>\n") : (__PrescribedWaypoints[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PrescribedWaypoints>\n";
+      str << ws << "   <StandoffDistance>" << __StandoffDistance << "</StandoffDistance>\n";
+      str << ws << "   <DesiredWavelengthBands>\n";
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         str << ws << "   <WavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__DesiredWavelengthBands[i]) << "</WavelengthBand>\n";
+      }
+      str << ws << "   </DesiredWavelengthBands>\n";
+      str << ws << "   <DwellTime>" << __DwellTime << "</DwellTime>\n";
+      str << ws << "   <GroundSampleDistance>" << __GroundSampleDistance << "</GroundSampleDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</EscortTask>\n";
+
+      return str.str();
+   }
+
+   bool EscortTask::operator==(const EscortTask & that)
+   {
+      if( afrl::cmasi::SearchTask::operator!=(that) )
+      {
+          return false;
+      }
+      if(__SupportedEntityID != that.__SupportedEntityID) return false;
+      if(__RouteID != that.__RouteID) return false;
+      if(__PrescribedWaypoints.size() != that.__PrescribedWaypoints.size()) return false;
+      for (size_t i=0; i<__PrescribedWaypoints.size(); i++)
+      {
+         if(__PrescribedWaypoints[i] && that.__PrescribedWaypoints[i])
+         {
+            if(__PrescribedWaypoints[i]->getSeriesNameAsLong() != that.__PrescribedWaypoints[i]->getSeriesNameAsLong()) return false;
+            if(__PrescribedWaypoints[i]->getSeriesVersion() != that.__PrescribedWaypoints[i]->getSeriesVersion()) return false;
+            if(__PrescribedWaypoints[i]->getLmcpType() != that.__PrescribedWaypoints[i]->getLmcpType()) return false;
+            if( *(__PrescribedWaypoints[i]) != *(that.__PrescribedWaypoints[i]) ) return false;
+         }
+         else if(__PrescribedWaypoints[i] != that.__PrescribedWaypoints[i]) return false;
+      }
+      if(__StandoffDistance != that.__StandoffDistance) return false;
+      return true;
+
+   }
+
+   bool EscortTask::operator!=(const EscortTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   EscortTask& EscortTask::setSupportedEntityID(const int64_t val)
+   {
+      __SupportedEntityID = val;
+      return *this;
+   }
+
+   EscortTask& EscortTask::setRouteID(const int64_t val)
+   {
+      __RouteID = val;
+      return *this;
+   }
+
+
+   EscortTask& EscortTask::setStandoffDistance(const float val)
+   {
+      __StandoffDistance = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactGroundVehicleConfiguration.cpp b/src/LMCP/afrl/impact/afrlimpactGroundVehicleConfiguration.cpp
new file mode 100644
index 0000000..4f09fb5
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactGroundVehicleConfiguration.cpp
@@ -0,0 +1,237 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/GroundVehicleConfiguration.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string GroundVehicleConfiguration::Subscription = "afrl.impact.GroundVehicleConfiguration";
+   const std::string GroundVehicleConfiguration::TypeName = "GroundVehicleConfiguration";
+   
+   bool isGroundVehicleConfiguration(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 36) return false;
+      return true;
+   }
+   
+   bool isGroundVehicleConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 36) return false;
+      return true;
+   }
+   
+   std::vector< std::string > GroundVehicleConfigurationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   GroundVehicleConfiguration::GroundVehicleConfiguration(void) : afrl::cmasi::EntityConfiguration()
+   {
+      __RoadGraphID = 0LL;
+      __MinimumSpeed = 0.f;
+      __MaximumSpeed = 0.f;
+      __EnergyRate = 0.f;
+
+   }
+     
+   GroundVehicleConfiguration::GroundVehicleConfiguration(const GroundVehicleConfiguration &that) : afrl::cmasi::EntityConfiguration(that)
+   {
+        __RoadGraphID = that.__RoadGraphID;
+        __MinimumSpeed = that.__MinimumSpeed;
+        __MaximumSpeed = that.__MaximumSpeed;
+        __EnergyRate = that.__EnergyRate;
+
+   }
+   
+   GroundVehicleConfiguration & GroundVehicleConfiguration::operator=(const GroundVehicleConfiguration &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::EntityConfiguration::operator=(that);
+
+         __RoadGraphID = that.__RoadGraphID;
+         __MinimumSpeed = that.__MinimumSpeed;
+         __MaximumSpeed = that.__MaximumSpeed;
+         __EnergyRate = that.__EnergyRate;
+
+      }
+      return *this;
+   }
+
+   GroundVehicleConfiguration* GroundVehicleConfiguration::clone() const
+   {
+        return new GroundVehicleConfiguration(*this);
+   }
+   
+   GroundVehicleConfiguration::~GroundVehicleConfiguration(void)
+   {
+
+   }
+  
+   void GroundVehicleConfiguration::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::EntityConfiguration::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RoadGraphID);
+      buf.putFloat(__MinimumSpeed);
+      buf.putFloat(__MaximumSpeed);
+      buf.putFloat(__EnergyRate);
+
+   }
+   
+   void GroundVehicleConfiguration::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::EntityConfiguration::unpack(buf);
+      // Copy the buffer into the class
+      __RoadGraphID = buf.getLong();
+      __MinimumSpeed = buf.getFloat();
+      __MaximumSpeed = buf.getFloat();
+      __EnergyRate = buf.getFloat();
+
+   }
+
+   uint32_t GroundVehicleConfiguration::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::EntityConfiguration::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string GroundVehicleConfiguration::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( GroundVehicleConfiguration ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ID (int64_t) = " << __ID << "\n";
+      oss << indent << "Affiliation (std::string) = " << __Affiliation << "\n";
+      oss << indent << "EntityType (std::string) = " << __EntityType << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "NominalSpeed (float) = " << __NominalSpeed << "\n";
+      oss << indent << "NominalAltitude (float) = " << __NominalAltitude << "\n";
+      oss << indent << "NominalAltitudeType (AltitudeType) = " << __NominalAltitudeType << "\n";
+      oss << indent << "PayloadConfigurationList (PayloadConfiguration [ " << __PayloadConfigurationList.size() << ", var ])\n";
+      oss << indent << "Info (KeyValuePair [ " << __Info.size() << ", var ])\n";
+
+      oss << indent << "RoadGraphID (int64_t) = " << __RoadGraphID << "\n";
+      oss << indent << "MinimumSpeed (float) = " << __MinimumSpeed << "\n";
+      oss << indent << "MaximumSpeed (float) = " << __MaximumSpeed << "\n";
+      oss << indent << "EnergyRate (float) = " << __EnergyRate << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string GroundVehicleConfiguration::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<GroundVehicleConfiguration Series=\"IMPACT\">\n";
+      str << ws << "   <RoadGraphID>" << __RoadGraphID << "</RoadGraphID>\n";
+      str << ws << "   <MinimumSpeed>" << __MinimumSpeed << "</MinimumSpeed>\n";
+      str << ws << "   <MaximumSpeed>" << __MaximumSpeed << "</MaximumSpeed>\n";
+      str << ws << "   <EnergyRate>" << __EnergyRate << "</EnergyRate>\n";
+      str << ws << "   <ID>" << __ID << "</ID>\n";
+      str << ws << "   <Affiliation>" << __Affiliation << "</Affiliation>\n";
+      str << ws << "   <EntityType>" << __EntityType << "</EntityType>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <NominalSpeed>" << __NominalSpeed << "</NominalSpeed>\n";
+      str << ws << "   <NominalAltitude>" << __NominalAltitude << "</NominalAltitude>\n";
+      str << ws << "   <NominalAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__NominalAltitudeType) << "</NominalAltitudeType>\n";
+      str << ws << "   <PayloadConfigurationList>\n";
+      for (size_t i=0; i<__PayloadConfigurationList.size(); i++)
+      {
+         str << (__PayloadConfigurationList[i] == nullptr ? ( ws + "   <null/>\n") : (__PayloadConfigurationList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PayloadConfigurationList>\n";
+      str << ws << "   <Info>\n";
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         str << (__Info[i] == nullptr ? ( ws + "   <null/>\n") : (__Info[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Info>\n";
+      str << ws << "</GroundVehicleConfiguration>\n";
+
+      return str.str();
+   }
+
+   bool GroundVehicleConfiguration::operator==(const GroundVehicleConfiguration & that)
+   {
+      if( afrl::cmasi::EntityConfiguration::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RoadGraphID != that.__RoadGraphID) return false;
+      if(__MinimumSpeed != that.__MinimumSpeed) return false;
+      if(__MaximumSpeed != that.__MaximumSpeed) return false;
+      if(__EnergyRate != that.__EnergyRate) return false;
+      return true;
+
+   }
+
+   bool GroundVehicleConfiguration::operator!=(const GroundVehicleConfiguration & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   GroundVehicleConfiguration& GroundVehicleConfiguration::setRoadGraphID(const int64_t val)
+   {
+      __RoadGraphID = val;
+      return *this;
+   }
+
+   GroundVehicleConfiguration& GroundVehicleConfiguration::setMinimumSpeed(const float val)
+   {
+      __MinimumSpeed = val;
+      return *this;
+   }
+
+   GroundVehicleConfiguration& GroundVehicleConfiguration::setMaximumSpeed(const float val)
+   {
+      __MaximumSpeed = val;
+      return *this;
+   }
+
+   GroundVehicleConfiguration& GroundVehicleConfiguration::setEnergyRate(const float val)
+   {
+      __EnergyRate = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactGroundVehicleState.cpp b/src/LMCP/afrl/impact/afrlimpactGroundVehicleState.cpp
new file mode 100644
index 0000000..b91b0ef
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactGroundVehicleState.cpp
@@ -0,0 +1,222 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/GroundVehicleState.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string GroundVehicleState::Subscription = "afrl.impact.GroundVehicleState";
+   const std::string GroundVehicleState::TypeName = "GroundVehicleState";
+   
+   bool isGroundVehicleState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 37) return false;
+      return true;
+   }
+   
+   bool isGroundVehicleState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 37) return false;
+      return true;
+   }
+   
+   std::vector< std::string > GroundVehicleStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   GroundVehicleState::GroundVehicleState(void) : afrl::cmasi::EntityState()
+   {
+
+   }
+     
+   GroundVehicleState::GroundVehicleState(const GroundVehicleState &that) : afrl::cmasi::EntityState(that)
+   {
+
+   }
+   
+   GroundVehicleState & GroundVehicleState::operator=(const GroundVehicleState &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::EntityState::operator=(that);
+
+
+      }
+      return *this;
+   }
+
+   GroundVehicleState* GroundVehicleState::clone() const
+   {
+        return new GroundVehicleState(*this);
+   }
+   
+   GroundVehicleState::~GroundVehicleState(void)
+   {
+
+   }
+  
+   void GroundVehicleState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::EntityState::pack(buf);
+      // Copy the class into the buffer
+
+   }
+   
+   void GroundVehicleState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::EntityState::unpack(buf);
+      // Copy the buffer into the class
+
+   }
+
+   uint32_t GroundVehicleState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::EntityState::calculatePackedSize();
+
+      return size;
+   }
+
+   std::string GroundVehicleState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( GroundVehicleState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ID (int64_t) = " << __ID << "\n";
+      oss << indent << "u (float) = " << __u << "\n";
+      oss << indent << "v (float) = " << __v << "\n";
+      oss << indent << "w (float) = " << __w << "\n";
+      oss << indent << "udot (float) = " << __udot << "\n";
+      oss << indent << "vdot (float) = " << __vdot << "\n";
+      oss << indent << "wdot (float) = " << __wdot << "\n";
+      oss << indent << "Heading (float) = " << __Heading << "\n";
+      oss << indent << "Pitch (float) = " << __Pitch << "\n";
+      oss << indent << "Roll (float) = " << __Roll << "\n";
+      oss << indent << "p (float) = " << __p << "\n";
+      oss << indent << "q (float) = " << __q << "\n";
+      oss << indent << "r (float) = " << __r << "\n";
+      oss << indent << "Course (float) = " << __Course << "\n";
+      oss << indent << "Groundspeed (float) = " << __Groundspeed << "\n";
+      oss << indent << "Location (Location3D)";
+      if (__Location == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "EnergyAvailable (float) = " << __EnergyAvailable << "\n";
+      oss << indent << "ActualEnergyRate (float) = " << __ActualEnergyRate << "\n";
+      oss << indent << "PayloadStateList (PayloadState [ " << __PayloadStateList.size() << ", var ])\n";
+      oss << indent << "CurrentWaypoint (int64_t) = " << __CurrentWaypoint << "\n";
+      oss << indent << "CurrentCommand (int64_t) = " << __CurrentCommand << "\n";
+      oss << indent << "Mode (NavigationMode) = " << __Mode << "\n";
+      oss << indent << "AssociatedTasks (int64 [ " << __AssociatedTasks.size() << ", var ])\n";
+      oss << indent << "Time (int64_t) = " << __Time << "\n";
+      oss << indent << "Info (KeyValuePair [ " << __Info.size() << ", var ])\n";
+
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string GroundVehicleState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<GroundVehicleState Series=\"IMPACT\">\n";
+      str << ws << "   <ID>" << __ID << "</ID>\n";
+      str << ws << "   <u>" << __u << "</u>\n";
+      str << ws << "   <v>" << __v << "</v>\n";
+      str << ws << "   <w>" << __w << "</w>\n";
+      str << ws << "   <udot>" << __udot << "</udot>\n";
+      str << ws << "   <vdot>" << __vdot << "</vdot>\n";
+      str << ws << "   <wdot>" << __wdot << "</wdot>\n";
+      str << ws << "   <Heading>" << __Heading << "</Heading>\n";
+      str << ws << "   <Pitch>" << __Pitch << "</Pitch>\n";
+      str << ws << "   <Roll>" << __Roll << "</Roll>\n";
+      str << ws << "   <p>" << __p << "</p>\n";
+      str << ws << "   <q>" << __q << "</q>\n";
+      str << ws << "   <r>" << __r << "</r>\n";
+      str << ws << "   <Course>" << __Course << "</Course>\n";
+      str << ws << "   <Groundspeed>" << __Groundspeed << "</Groundspeed>\n";
+      if (__Location != nullptr)
+      {
+         str << ws << "   <Location>";
+         str << "\n" + __Location->toXML(depth + 1) + ws + "   ";
+         str << "</Location>\n";
+      }
+      str << ws << "   <EnergyAvailable>" << __EnergyAvailable << "</EnergyAvailable>\n";
+      str << ws << "   <ActualEnergyRate>" << __ActualEnergyRate << "</ActualEnergyRate>\n";
+      str << ws << "   <PayloadStateList>\n";
+      for (size_t i=0; i<__PayloadStateList.size(); i++)
+      {
+         str << (__PayloadStateList[i] == nullptr ? ( ws + "   <null/>\n") : (__PayloadStateList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PayloadStateList>\n";
+      str << ws << "   <CurrentWaypoint>" << __CurrentWaypoint << "</CurrentWaypoint>\n";
+      str << ws << "   <CurrentCommand>" << __CurrentCommand << "</CurrentCommand>\n";
+      str << ws << "   <Mode>" << afrl::cmasi::NavigationMode::get_string(__Mode) << "</Mode>\n";
+      str << ws << "   <AssociatedTasks>\n";
+      for (size_t i=0; i<__AssociatedTasks.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTasks[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTasks>\n";
+      str << ws << "   <Time>" << __Time << "</Time>\n";
+      str << ws << "   <Info>\n";
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         str << (__Info[i] == nullptr ? ( ws + "   <null/>\n") : (__Info[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Info>\n";
+      str << ws << "</GroundVehicleState>\n";
+
+      return str.str();
+   }
+
+   bool GroundVehicleState::operator==(const GroundVehicleState & that)
+   {
+      if( afrl::cmasi::EntityState::operator!=(that) )
+      {
+          return false;
+      }
+      return true;
+
+   }
+
+   bool GroundVehicleState::operator!=(const GroundVehicleState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactImpactAutomationRequest.cpp b/src/LMCP/afrl/impact/afrlimpactImpactAutomationRequest.cpp
new file mode 100644
index 0000000..57bdd21
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactImpactAutomationRequest.cpp
@@ -0,0 +1,323 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/ImpactAutomationRequest.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string ImpactAutomationRequest::Subscription = "afrl.impact.ImpactAutomationRequest";
+   const std::string ImpactAutomationRequest::TypeName = "ImpactAutomationRequest";
+   
+   bool isImpactAutomationRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 20) return false;
+      return true;
+   }
+   
+   bool isImpactAutomationRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 20) return false;
+      return true;
+   }
+   
+   std::vector< std::string > ImpactAutomationRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   ImpactAutomationRequest::ImpactAutomationRequest(void) : avtas::lmcp::Object()
+   {
+      __RequestID = 0LL;
+      __TrialRequest = new afrl::cmasi::AutomationRequest();
+      __PlayID = 0LL;
+      __SolutionID = 0LL;
+      __Sandbox = false;
+
+   }
+     
+   ImpactAutomationRequest::ImpactAutomationRequest(const ImpactAutomationRequest &that) : avtas::lmcp::Object(that)
+   {
+        __RequestID = that.__RequestID;
+        __TrialRequest = that.__TrialRequest == nullptr ? nullptr : that.__TrialRequest->clone();
+        __OverridePlanningConditions.clear();
+        for (size_t i=0; i< that.__OverridePlanningConditions.size(); i++)
+        {
+           __OverridePlanningConditions.push_back( that.__OverridePlanningConditions[i] == nullptr ? nullptr : that.__OverridePlanningConditions[i]->clone());
+        }
+        __PlayID = that.__PlayID;
+        __SolutionID = that.__SolutionID;
+        __Sandbox = that.__Sandbox;
+
+   }
+   
+   ImpactAutomationRequest & ImpactAutomationRequest::operator=(const ImpactAutomationRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__TrialRequest != nullptr) delete __TrialRequest;
+         for (size_t i=0; i<__OverridePlanningConditions.size(); i++)
+         {
+            if (__OverridePlanningConditions[i] != nullptr) delete __OverridePlanningConditions[i];
+         }
+
+         __RequestID = that.__RequestID;
+         __TrialRequest = that.__TrialRequest == nullptr ? nullptr : that.__TrialRequest->clone();
+         __OverridePlanningConditions.clear();
+         for (size_t i=0; i< that.__OverridePlanningConditions.size(); i++)
+         {
+            __OverridePlanningConditions.push_back( that.__OverridePlanningConditions[i] == nullptr ? nullptr : that.__OverridePlanningConditions[i]->clone());
+         }
+         __PlayID = that.__PlayID;
+         __SolutionID = that.__SolutionID;
+         __Sandbox = that.__Sandbox;
+
+      }
+      return *this;
+   }
+
+   ImpactAutomationRequest* ImpactAutomationRequest::clone() const
+   {
+        return new ImpactAutomationRequest(*this);
+   }
+   
+   ImpactAutomationRequest::~ImpactAutomationRequest(void)
+   {
+      if (__TrialRequest != nullptr) delete __TrialRequest;
+      for (size_t i=0; i<__OverridePlanningConditions.size(); i++)
+      {
+         if (__OverridePlanningConditions[i] != nullptr) delete __OverridePlanningConditions[i];
+      }
+
+   }
+  
+   void ImpactAutomationRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RequestID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __TrialRequest, buf);
+      buf.putUShort( static_cast<uint16_t>(__OverridePlanningConditions.size()));
+      for (size_t i=0; i<__OverridePlanningConditions.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __OverridePlanningConditions[i], buf);
+      }
+      buf.putLong(__PlayID);
+      buf.putLong(__SolutionID);
+      buf.putBool(__Sandbox);
+
+   }
+   
+   void ImpactAutomationRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RequestID = buf.getLong();
+      {
+         if (__TrialRequest != nullptr) delete __TrialRequest;
+         __TrialRequest = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __TrialRequest = (afrl::cmasi::AutomationRequest*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__TrialRequest != nullptr) __TrialRequest->unpack(buf);
+         }
+      }
+      for (size_t i=0; i<__OverridePlanningConditions.size(); i++)
+      {
+         if (__OverridePlanningConditions[i] != nullptr)
+            delete __OverridePlanningConditions[i];
+      }
+      __OverridePlanningConditions.clear();
+      uint16_t __OverridePlanningConditions_length = buf.getUShort();
+      for (uint32_t i=0; i< __OverridePlanningConditions_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::impact::SpeedAltPair* e = (afrl::impact::SpeedAltPair*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __OverridePlanningConditions.push_back(e);
+         }
+      }
+      __PlayID = buf.getLong();
+      __SolutionID = buf.getLong();
+      __Sandbox = buf.getBool();
+
+   }
+
+   uint32_t ImpactAutomationRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__TrialRequest != nullptr ? __TrialRequest->calculatePackedSize() + 15 : 1);
+      size += 2;
+      for (size_t i=0; i<__OverridePlanningConditions.size(); i++)
+      {
+         if (__OverridePlanningConditions[i] != nullptr)
+         {
+            size += __OverridePlanningConditions[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string ImpactAutomationRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( ImpactAutomationRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RequestID (int64_t) = " << __RequestID << "\n";
+      oss << indent << "TrialRequest (AutomationRequest)";
+      if (__TrialRequest == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "OverridePlanningConditions (SpeedAltPair [ " << __OverridePlanningConditions.size() << ", var ])\n";
+      oss << indent << "PlayID (int64_t) = " << __PlayID << "\n";
+      oss << indent << "SolutionID (int64_t) = " << __SolutionID << "\n";
+      oss << indent << "Sandbox (bool) = " << __Sandbox << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string ImpactAutomationRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<ImpactAutomationRequest Series=\"IMPACT\">\n";
+      str << ws << "   <RequestID>" << __RequestID << "</RequestID>\n";
+      if (__TrialRequest != nullptr)
+      {
+         str << ws << "   <TrialRequest>";
+         str << "\n" + __TrialRequest->toXML(depth + 1) + ws + "   ";
+         str << "</TrialRequest>\n";
+      }
+      str << ws << "   <OverridePlanningConditions>\n";
+      for (size_t i=0; i<__OverridePlanningConditions.size(); i++)
+      {
+         str << (__OverridePlanningConditions[i] == nullptr ? ( ws + "   <null/>\n") : (__OverridePlanningConditions[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </OverridePlanningConditions>\n";
+      str << ws << "   <PlayID>" << __PlayID << "</PlayID>\n";
+      str << ws << "   <SolutionID>" << __SolutionID << "</SolutionID>\n";
+      str << ws << "   <Sandbox>" << (__Sandbox ? "true" : "false") << "</Sandbox>\n";
+      str << ws << "</ImpactAutomationRequest>\n";
+
+      return str.str();
+   }
+
+   bool ImpactAutomationRequest::operator==(const ImpactAutomationRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RequestID != that.__RequestID) return false;
+      if(__TrialRequest && that.__TrialRequest)
+      {
+         if(__TrialRequest->getSeriesNameAsLong() != that.__TrialRequest->getSeriesNameAsLong()) return false;
+         if(__TrialRequest->getSeriesVersion() != that.__TrialRequest->getSeriesVersion()) return false;
+         if(__TrialRequest->getLmcpType() != that.__TrialRequest->getLmcpType()) return false;
+         if( *(__TrialRequest) != *(that.__TrialRequest) ) return false;
+      }
+      else if(__TrialRequest != that.__TrialRequest) return false;
+      if(__OverridePlanningConditions.size() != that.__OverridePlanningConditions.size()) return false;
+      for (size_t i=0; i<__OverridePlanningConditions.size(); i++)
+      {
+         if(__OverridePlanningConditions[i] && that.__OverridePlanningConditions[i])
+         {
+            if(__OverridePlanningConditions[i]->getSeriesNameAsLong() != that.__OverridePlanningConditions[i]->getSeriesNameAsLong()) return false;
+            if(__OverridePlanningConditions[i]->getSeriesVersion() != that.__OverridePlanningConditions[i]->getSeriesVersion()) return false;
+            if(__OverridePlanningConditions[i]->getLmcpType() != that.__OverridePlanningConditions[i]->getLmcpType()) return false;
+            if( *(__OverridePlanningConditions[i]) != *(that.__OverridePlanningConditions[i]) ) return false;
+         }
+         else if(__OverridePlanningConditions[i] != that.__OverridePlanningConditions[i]) return false;
+      }
+      if(__PlayID != that.__PlayID) return false;
+      if(__SolutionID != that.__SolutionID) return false;
+      if(__Sandbox != that.__Sandbox) return false;
+      return true;
+
+   }
+
+   bool ImpactAutomationRequest::operator!=(const ImpactAutomationRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   ImpactAutomationRequest& ImpactAutomationRequest::setRequestID(const int64_t val)
+   {
+      __RequestID = val;
+      return *this;
+   }
+
+   ImpactAutomationRequest& ImpactAutomationRequest::setTrialRequest(const afrl::cmasi::AutomationRequest* const val)
+   {
+      if (__TrialRequest != nullptr) { delete __TrialRequest; __TrialRequest = nullptr; }
+      if (val != nullptr) { __TrialRequest = const_cast< afrl::cmasi::AutomationRequest* > (val); }
+      return *this;
+   }
+
+
+   ImpactAutomationRequest& ImpactAutomationRequest::setPlayID(const int64_t val)
+   {
+      __PlayID = val;
+      return *this;
+   }
+
+   ImpactAutomationRequest& ImpactAutomationRequest::setSolutionID(const int64_t val)
+   {
+      __SolutionID = val;
+      return *this;
+   }
+
+   ImpactAutomationRequest& ImpactAutomationRequest::setSandbox(const bool val)
+   {
+      __Sandbox = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactImpactAutomationResponse.cpp b/src/LMCP/afrl/impact/afrlimpactImpactAutomationResponse.cpp
new file mode 100644
index 0000000..f15c8cd
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactImpactAutomationResponse.cpp
@@ -0,0 +1,323 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/ImpactAutomationResponse.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string ImpactAutomationResponse::Subscription = "afrl.impact.ImpactAutomationResponse";
+   const std::string ImpactAutomationResponse::TypeName = "ImpactAutomationResponse";
+   
+   bool isImpactAutomationResponse(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 21) return false;
+      return true;
+   }
+   
+   bool isImpactAutomationResponse(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 21) return false;
+      return true;
+   }
+   
+   std::vector< std::string > ImpactAutomationResponseDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   ImpactAutomationResponse::ImpactAutomationResponse(void) : avtas::lmcp::Object()
+   {
+      __ResponseID = 0LL;
+      __TrialResponse = new afrl::cmasi::AutomationResponse();
+      __PlayID = 0LL;
+      __SolutionID = 0LL;
+      __Sandbox = false;
+
+   }
+     
+   ImpactAutomationResponse::ImpactAutomationResponse(const ImpactAutomationResponse &that) : avtas::lmcp::Object(that)
+   {
+        __ResponseID = that.__ResponseID;
+        __TrialResponse = that.__TrialResponse == nullptr ? nullptr : that.__TrialResponse->clone();
+        __PlayID = that.__PlayID;
+        __SolutionID = that.__SolutionID;
+        __Sandbox = that.__Sandbox;
+        __Summaries.clear();
+        for (size_t i=0; i< that.__Summaries.size(); i++)
+        {
+           __Summaries.push_back( that.__Summaries[i] == nullptr ? nullptr : that.__Summaries[i]->clone());
+        }
+
+   }
+   
+   ImpactAutomationResponse & ImpactAutomationResponse::operator=(const ImpactAutomationResponse &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__TrialResponse != nullptr) delete __TrialResponse;
+         for (size_t i=0; i<__Summaries.size(); i++)
+         {
+            if (__Summaries[i] != nullptr) delete __Summaries[i];
+         }
+
+         __ResponseID = that.__ResponseID;
+         __TrialResponse = that.__TrialResponse == nullptr ? nullptr : that.__TrialResponse->clone();
+         __PlayID = that.__PlayID;
+         __SolutionID = that.__SolutionID;
+         __Sandbox = that.__Sandbox;
+         __Summaries.clear();
+         for (size_t i=0; i< that.__Summaries.size(); i++)
+         {
+            __Summaries.push_back( that.__Summaries[i] == nullptr ? nullptr : that.__Summaries[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   ImpactAutomationResponse* ImpactAutomationResponse::clone() const
+   {
+        return new ImpactAutomationResponse(*this);
+   }
+   
+   ImpactAutomationResponse::~ImpactAutomationResponse(void)
+   {
+      if (__TrialResponse != nullptr) delete __TrialResponse;
+      for (size_t i=0; i<__Summaries.size(); i++)
+      {
+         if (__Summaries[i] != nullptr) delete __Summaries[i];
+      }
+
+   }
+  
+   void ImpactAutomationResponse::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ResponseID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __TrialResponse, buf);
+      buf.putLong(__PlayID);
+      buf.putLong(__SolutionID);
+      buf.putBool(__Sandbox);
+      buf.putUShort( static_cast<uint16_t>(__Summaries.size()));
+      for (size_t i=0; i<__Summaries.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Summaries[i], buf);
+      }
+
+   }
+   
+   void ImpactAutomationResponse::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ResponseID = buf.getLong();
+      {
+         if (__TrialResponse != nullptr) delete __TrialResponse;
+         __TrialResponse = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __TrialResponse = (afrl::cmasi::AutomationResponse*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__TrialResponse != nullptr) __TrialResponse->unpack(buf);
+         }
+      }
+      __PlayID = buf.getLong();
+      __SolutionID = buf.getLong();
+      __Sandbox = buf.getBool();
+      for (size_t i=0; i<__Summaries.size(); i++)
+      {
+         if (__Summaries[i] != nullptr)
+            delete __Summaries[i];
+      }
+      __Summaries.clear();
+      uint16_t __Summaries_length = buf.getUShort();
+      for (uint32_t i=0; i< __Summaries_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::impact::TaskSummary* e = (afrl::impact::TaskSummary*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Summaries.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t ImpactAutomationResponse::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__TrialResponse != nullptr ? __TrialResponse->calculatePackedSize() + 15 : 1);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(bool);
+      size += 2;
+      for (size_t i=0; i<__Summaries.size(); i++)
+      {
+         if (__Summaries[i] != nullptr)
+         {
+            size += __Summaries[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string ImpactAutomationResponse::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( ImpactAutomationResponse ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ResponseID (int64_t) = " << __ResponseID << "\n";
+      oss << indent << "TrialResponse (AutomationResponse)";
+      if (__TrialResponse == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "PlayID (int64_t) = " << __PlayID << "\n";
+      oss << indent << "SolutionID (int64_t) = " << __SolutionID << "\n";
+      oss << indent << "Sandbox (bool) = " << __Sandbox << "\n";
+      oss << indent << "Summaries (TaskSummary [ " << __Summaries.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string ImpactAutomationResponse::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<ImpactAutomationResponse Series=\"IMPACT\">\n";
+      str << ws << "   <ResponseID>" << __ResponseID << "</ResponseID>\n";
+      if (__TrialResponse != nullptr)
+      {
+         str << ws << "   <TrialResponse>";
+         str << "\n" + __TrialResponse->toXML(depth + 1) + ws + "   ";
+         str << "</TrialResponse>\n";
+      }
+      str << ws << "   <PlayID>" << __PlayID << "</PlayID>\n";
+      str << ws << "   <SolutionID>" << __SolutionID << "</SolutionID>\n";
+      str << ws << "   <Sandbox>" << (__Sandbox ? "true" : "false") << "</Sandbox>\n";
+      str << ws << "   <Summaries>\n";
+      for (size_t i=0; i<__Summaries.size(); i++)
+      {
+         str << (__Summaries[i] == nullptr ? ( ws + "   <null/>\n") : (__Summaries[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Summaries>\n";
+      str << ws << "</ImpactAutomationResponse>\n";
+
+      return str.str();
+   }
+
+   bool ImpactAutomationResponse::operator==(const ImpactAutomationResponse & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ResponseID != that.__ResponseID) return false;
+      if(__TrialResponse && that.__TrialResponse)
+      {
+         if(__TrialResponse->getSeriesNameAsLong() != that.__TrialResponse->getSeriesNameAsLong()) return false;
+         if(__TrialResponse->getSeriesVersion() != that.__TrialResponse->getSeriesVersion()) return false;
+         if(__TrialResponse->getLmcpType() != that.__TrialResponse->getLmcpType()) return false;
+         if( *(__TrialResponse) != *(that.__TrialResponse) ) return false;
+      }
+      else if(__TrialResponse != that.__TrialResponse) return false;
+      if(__PlayID != that.__PlayID) return false;
+      if(__SolutionID != that.__SolutionID) return false;
+      if(__Sandbox != that.__Sandbox) return false;
+      if(__Summaries.size() != that.__Summaries.size()) return false;
+      for (size_t i=0; i<__Summaries.size(); i++)
+      {
+         if(__Summaries[i] && that.__Summaries[i])
+         {
+            if(__Summaries[i]->getSeriesNameAsLong() != that.__Summaries[i]->getSeriesNameAsLong()) return false;
+            if(__Summaries[i]->getSeriesVersion() != that.__Summaries[i]->getSeriesVersion()) return false;
+            if(__Summaries[i]->getLmcpType() != that.__Summaries[i]->getLmcpType()) return false;
+            if( *(__Summaries[i]) != *(that.__Summaries[i]) ) return false;
+         }
+         else if(__Summaries[i] != that.__Summaries[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool ImpactAutomationResponse::operator!=(const ImpactAutomationResponse & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   ImpactAutomationResponse& ImpactAutomationResponse::setResponseID(const int64_t val)
+   {
+      __ResponseID = val;
+      return *this;
+   }
+
+   ImpactAutomationResponse& ImpactAutomationResponse::setTrialResponse(const afrl::cmasi::AutomationResponse* const val)
+   {
+      if (__TrialResponse != nullptr) { delete __TrialResponse; __TrialResponse = nullptr; }
+      if (val != nullptr) { __TrialResponse = const_cast< afrl::cmasi::AutomationResponse* > (val); }
+      return *this;
+   }
+
+   ImpactAutomationResponse& ImpactAutomationResponse::setPlayID(const int64_t val)
+   {
+      __PlayID = val;
+      return *this;
+   }
+
+   ImpactAutomationResponse& ImpactAutomationResponse::setSolutionID(const int64_t val)
+   {
+      __SolutionID = val;
+      return *this;
+   }
+
+   ImpactAutomationResponse& ImpactAutomationResponse::setSandbox(const bool val)
+   {
+      __Sandbox = val;
+      return *this;
+   }
+
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactImpactComponentJoin.cpp b/src/LMCP/afrl/impact/afrlimpactImpactComponentJoin.cpp
new file mode 100644
index 0000000..fb48a67
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactImpactComponentJoin.cpp
@@ -0,0 +1,163 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/ImpactComponentJoin.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string ImpactComponentJoin::Subscription = "afrl.impact.ImpactComponentJoin";
+   const std::string ImpactComponentJoin::TypeName = "ImpactComponentJoin";
+   
+   bool isImpactComponentJoin(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 17) return false;
+      return true;
+   }
+   
+   bool isImpactComponentJoin(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 17) return false;
+      return true;
+   }
+   
+   std::vector< std::string > ImpactComponentJoinDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   ImpactComponentJoin::ImpactComponentJoin(void) : avtas::lmcp::Object()
+   {
+      __ComponentLabel = std::string("");
+
+   }
+     
+   ImpactComponentJoin::ImpactComponentJoin(const ImpactComponentJoin &that) : avtas::lmcp::Object(that)
+   {
+        __ComponentLabel = that.__ComponentLabel;
+
+   }
+   
+   ImpactComponentJoin & ImpactComponentJoin::operator=(const ImpactComponentJoin &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __ComponentLabel = that.__ComponentLabel;
+
+      }
+      return *this;
+   }
+
+   ImpactComponentJoin* ImpactComponentJoin::clone() const
+   {
+        return new ImpactComponentJoin(*this);
+   }
+   
+   ImpactComponentJoin::~ImpactComponentJoin(void)
+   {
+
+   }
+  
+   void ImpactComponentJoin::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putString(__ComponentLabel);
+
+   }
+   
+   void ImpactComponentJoin::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ComponentLabel = buf.getString();
+
+   }
+
+   uint32_t ImpactComponentJoin::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2 + __ComponentLabel.length();
+
+      return size;
+   }
+
+   std::string ImpactComponentJoin::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( ImpactComponentJoin ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ComponentLabel (std::string) = " << __ComponentLabel << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string ImpactComponentJoin::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<ImpactComponentJoin Series=\"IMPACT\">\n";
+      str << ws << "   <ComponentLabel>" << __ComponentLabel << "</ComponentLabel>\n";
+      str << ws << "</ImpactComponentJoin>\n";
+
+      return str.str();
+   }
+
+   bool ImpactComponentJoin::operator==(const ImpactComponentJoin & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ComponentLabel != that.__ComponentLabel) return false;
+      return true;
+
+   }
+
+   bool ImpactComponentJoin::operator!=(const ImpactComponentJoin & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   ImpactComponentJoin& ImpactComponentJoin::setComponentLabel(const std::string val)
+   {
+      __ComponentLabel = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactImpactComponentLeave.cpp b/src/LMCP/afrl/impact/afrlimpactImpactComponentLeave.cpp
new file mode 100644
index 0000000..5c69ab6
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactImpactComponentLeave.cpp
@@ -0,0 +1,163 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/ImpactComponentLeave.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string ImpactComponentLeave::Subscription = "afrl.impact.ImpactComponentLeave";
+   const std::string ImpactComponentLeave::TypeName = "ImpactComponentLeave";
+   
+   bool isImpactComponentLeave(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 18) return false;
+      return true;
+   }
+   
+   bool isImpactComponentLeave(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 18) return false;
+      return true;
+   }
+   
+   std::vector< std::string > ImpactComponentLeaveDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   ImpactComponentLeave::ImpactComponentLeave(void) : avtas::lmcp::Object()
+   {
+      __ComponentLabel = std::string("");
+
+   }
+     
+   ImpactComponentLeave::ImpactComponentLeave(const ImpactComponentLeave &that) : avtas::lmcp::Object(that)
+   {
+        __ComponentLabel = that.__ComponentLabel;
+
+   }
+   
+   ImpactComponentLeave & ImpactComponentLeave::operator=(const ImpactComponentLeave &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __ComponentLabel = that.__ComponentLabel;
+
+      }
+      return *this;
+   }
+
+   ImpactComponentLeave* ImpactComponentLeave::clone() const
+   {
+        return new ImpactComponentLeave(*this);
+   }
+   
+   ImpactComponentLeave::~ImpactComponentLeave(void)
+   {
+
+   }
+  
+   void ImpactComponentLeave::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putString(__ComponentLabel);
+
+   }
+   
+   void ImpactComponentLeave::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ComponentLabel = buf.getString();
+
+   }
+
+   uint32_t ImpactComponentLeave::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2 + __ComponentLabel.length();
+
+      return size;
+   }
+
+   std::string ImpactComponentLeave::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( ImpactComponentLeave ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ComponentLabel (std::string) = " << __ComponentLabel << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string ImpactComponentLeave::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<ImpactComponentLeave Series=\"IMPACT\">\n";
+      str << ws << "   <ComponentLabel>" << __ComponentLabel << "</ComponentLabel>\n";
+      str << ws << "</ImpactComponentLeave>\n";
+
+      return str.str();
+   }
+
+   bool ImpactComponentLeave::operator==(const ImpactComponentLeave & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ComponentLabel != that.__ComponentLabel) return false;
+      return true;
+
+   }
+
+   bool ImpactComponentLeave::operator!=(const ImpactComponentLeave & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   ImpactComponentLeave& ImpactComponentLeave::setComponentLabel(const std::string val)
+   {
+      __ComponentLabel = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactImpactHeartbeat.cpp b/src/LMCP/afrl/impact/afrlimpactImpactHeartbeat.cpp
new file mode 100644
index 0000000..5ead94b
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactImpactHeartbeat.cpp
@@ -0,0 +1,178 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/ImpactHeartbeat.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string ImpactHeartbeat::Subscription = "afrl.impact.ImpactHeartbeat";
+   const std::string ImpactHeartbeat::TypeName = "ImpactHeartbeat";
+   
+   bool isImpactHeartbeat(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 16) return false;
+      return true;
+   }
+   
+   bool isImpactHeartbeat(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 16) return false;
+      return true;
+   }
+   
+   std::vector< std::string > ImpactHeartbeatDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   ImpactHeartbeat::ImpactHeartbeat(void) : avtas::lmcp::Object()
+   {
+      __ComponentLabel = std::string("");
+      __HeartbeatTime = 0LL;
+
+   }
+     
+   ImpactHeartbeat::ImpactHeartbeat(const ImpactHeartbeat &that) : avtas::lmcp::Object(that)
+   {
+        __ComponentLabel = that.__ComponentLabel;
+        __HeartbeatTime = that.__HeartbeatTime;
+
+   }
+   
+   ImpactHeartbeat & ImpactHeartbeat::operator=(const ImpactHeartbeat &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __ComponentLabel = that.__ComponentLabel;
+         __HeartbeatTime = that.__HeartbeatTime;
+
+      }
+      return *this;
+   }
+
+   ImpactHeartbeat* ImpactHeartbeat::clone() const
+   {
+        return new ImpactHeartbeat(*this);
+   }
+   
+   ImpactHeartbeat::~ImpactHeartbeat(void)
+   {
+
+   }
+  
+   void ImpactHeartbeat::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putString(__ComponentLabel);
+      buf.putLong(__HeartbeatTime);
+
+   }
+   
+   void ImpactHeartbeat::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ComponentLabel = buf.getString();
+      __HeartbeatTime = buf.getLong();
+
+   }
+
+   uint32_t ImpactHeartbeat::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2 + __ComponentLabel.length();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string ImpactHeartbeat::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( ImpactHeartbeat ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ComponentLabel (std::string) = " << __ComponentLabel << "\n";
+      oss << indent << "HeartbeatTime (int64_t) = " << __HeartbeatTime << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string ImpactHeartbeat::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<ImpactHeartbeat Series=\"IMPACT\">\n";
+      str << ws << "   <ComponentLabel>" << __ComponentLabel << "</ComponentLabel>\n";
+      str << ws << "   <HeartbeatTime>" << __HeartbeatTime << "</HeartbeatTime>\n";
+      str << ws << "</ImpactHeartbeat>\n";
+
+      return str.str();
+   }
+
+   bool ImpactHeartbeat::operator==(const ImpactHeartbeat & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ComponentLabel != that.__ComponentLabel) return false;
+      if(__HeartbeatTime != that.__HeartbeatTime) return false;
+      return true;
+
+   }
+
+   bool ImpactHeartbeat::operator!=(const ImpactHeartbeat & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   ImpactHeartbeat& ImpactHeartbeat::setComponentLabel(const std::string val)
+   {
+      __ComponentLabel = val;
+      return *this;
+   }
+
+   ImpactHeartbeat& ImpactHeartbeat::setHeartbeatTime(const int64_t val)
+   {
+      __HeartbeatTime = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactImpactLineSearchTask.cpp b/src/LMCP/afrl/impact/afrlimpactImpactLineSearchTask.cpp
new file mode 100644
index 0000000..691d546
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactImpactLineSearchTask.cpp
@@ -0,0 +1,286 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/ImpactLineSearchTask.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string ImpactLineSearchTask::Subscription = "afrl.impact.ImpactLineSearchTask";
+   const std::string ImpactLineSearchTask::TypeName = "ImpactLineSearchTask";
+   
+   bool isImpactLineSearchTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 28) return false;
+      return true;
+   }
+   
+   bool isImpactLineSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 28) return false;
+      return true;
+   }
+   
+   std::vector< std::string > ImpactLineSearchTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   ImpactLineSearchTask::ImpactLineSearchTask(void) : afrl::cmasi::SearchTask()
+   {
+      __LineID = 0LL;
+      __UseInertialViewAngles = false;
+
+   }
+     
+   ImpactLineSearchTask::ImpactLineSearchTask(const ImpactLineSearchTask &that) : afrl::cmasi::SearchTask(that)
+   {
+        __LineID = that.__LineID;
+        __ViewAngleList.clear();
+        for (size_t i=0; i< that.__ViewAngleList.size(); i++)
+        {
+           __ViewAngleList.push_back( that.__ViewAngleList[i] == nullptr ? nullptr : that.__ViewAngleList[i]->clone());
+        }
+        __UseInertialViewAngles = that.__UseInertialViewAngles;
+
+   }
+   
+   ImpactLineSearchTask & ImpactLineSearchTask::operator=(const ImpactLineSearchTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::SearchTask::operator=(that);
+         for (size_t i=0; i<__ViewAngleList.size(); i++)
+         {
+            if (__ViewAngleList[i] != nullptr) delete __ViewAngleList[i];
+         }
+
+         __LineID = that.__LineID;
+         __ViewAngleList.clear();
+         for (size_t i=0; i< that.__ViewAngleList.size(); i++)
+         {
+            __ViewAngleList.push_back( that.__ViewAngleList[i] == nullptr ? nullptr : that.__ViewAngleList[i]->clone());
+         }
+         __UseInertialViewAngles = that.__UseInertialViewAngles;
+
+      }
+      return *this;
+   }
+
+   ImpactLineSearchTask* ImpactLineSearchTask::clone() const
+   {
+        return new ImpactLineSearchTask(*this);
+   }
+   
+   ImpactLineSearchTask::~ImpactLineSearchTask(void)
+   {
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr) delete __ViewAngleList[i];
+      }
+
+   }
+  
+   void ImpactLineSearchTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::SearchTask::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__LineID);
+      buf.putUShort( static_cast<uint16_t>(__ViewAngleList.size()));
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __ViewAngleList[i], buf);
+      }
+      buf.putBool(__UseInertialViewAngles);
+
+   }
+   
+   void ImpactLineSearchTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::SearchTask::unpack(buf);
+      // Copy the buffer into the class
+      __LineID = buf.getLong();
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr)
+            delete __ViewAngleList[i];
+      }
+      __ViewAngleList.clear();
+      uint16_t __ViewAngleList_length = buf.getUShort();
+      for (uint32_t i=0; i< __ViewAngleList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Wedge* e = (afrl::cmasi::Wedge*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __ViewAngleList.push_back(e);
+         }
+      }
+      __UseInertialViewAngles = buf.getBool();
+
+   }
+
+   uint32_t ImpactLineSearchTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::SearchTask::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr)
+         {
+            size += __ViewAngleList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string ImpactLineSearchTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( ImpactLineSearchTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "DesiredWavelengthBands (WavelengthBand [ " << __DesiredWavelengthBands.size() << ", var ])\n";
+      oss << indent << "DwellTime (int64_t) = " << __DwellTime << "\n";
+      oss << indent << "GroundSampleDistance (float) = " << __GroundSampleDistance << "\n";
+
+      oss << indent << "LineID (int64_t) = " << __LineID << "\n";
+      oss << indent << "ViewAngleList (Wedge [ " << __ViewAngleList.size() << ", var ])\n";
+      oss << indent << "UseInertialViewAngles (bool) = " << __UseInertialViewAngles << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string ImpactLineSearchTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<ImpactLineSearchTask Series=\"IMPACT\">\n";
+      str << ws << "   <LineID>" << __LineID << "</LineID>\n";
+      str << ws << "   <ViewAngleList>\n";
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         str << (__ViewAngleList[i] == nullptr ? ( ws + "   <null/>\n") : (__ViewAngleList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </ViewAngleList>\n";
+      str << ws << "   <UseInertialViewAngles>" << (__UseInertialViewAngles ? "true" : "false") << "</UseInertialViewAngles>\n";
+      str << ws << "   <DesiredWavelengthBands>\n";
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         str << ws << "   <WavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__DesiredWavelengthBands[i]) << "</WavelengthBand>\n";
+      }
+      str << ws << "   </DesiredWavelengthBands>\n";
+      str << ws << "   <DwellTime>" << __DwellTime << "</DwellTime>\n";
+      str << ws << "   <GroundSampleDistance>" << __GroundSampleDistance << "</GroundSampleDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</ImpactLineSearchTask>\n";
+
+      return str.str();
+   }
+
+   bool ImpactLineSearchTask::operator==(const ImpactLineSearchTask & that)
+   {
+      if( afrl::cmasi::SearchTask::operator!=(that) )
+      {
+          return false;
+      }
+      if(__LineID != that.__LineID) return false;
+      if(__ViewAngleList.size() != that.__ViewAngleList.size()) return false;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if(__ViewAngleList[i] && that.__ViewAngleList[i])
+         {
+            if(__ViewAngleList[i]->getSeriesNameAsLong() != that.__ViewAngleList[i]->getSeriesNameAsLong()) return false;
+            if(__ViewAngleList[i]->getSeriesVersion() != that.__ViewAngleList[i]->getSeriesVersion()) return false;
+            if(__ViewAngleList[i]->getLmcpType() != that.__ViewAngleList[i]->getLmcpType()) return false;
+            if( *(__ViewAngleList[i]) != *(that.__ViewAngleList[i]) ) return false;
+         }
+         else if(__ViewAngleList[i] != that.__ViewAngleList[i]) return false;
+      }
+      if(__UseInertialViewAngles != that.__UseInertialViewAngles) return false;
+      return true;
+
+   }
+
+   bool ImpactLineSearchTask::operator!=(const ImpactLineSearchTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   ImpactLineSearchTask& ImpactLineSearchTask::setLineID(const int64_t val)
+   {
+      __LineID = val;
+      return *this;
+   }
+
+
+   ImpactLineSearchTask& ImpactLineSearchTask::setUseInertialViewAngles(const bool val)
+   {
+      __UseInertialViewAngles = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactImpactPayloadConfiguration.cpp b/src/LMCP/afrl/impact/afrlimpactImpactPayloadConfiguration.cpp
new file mode 100644
index 0000000..26391dd
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactImpactPayloadConfiguration.cpp
@@ -0,0 +1,195 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/ImpactPayloadConfiguration.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string ImpactPayloadConfiguration::Subscription = "afrl.impact.ImpactPayloadConfiguration";
+   const std::string ImpactPayloadConfiguration::TypeName = "ImpactPayloadConfiguration";
+   
+   bool isImpactPayloadConfiguration(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 6) return false;
+      return true;
+   }
+   
+   bool isImpactPayloadConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 6) return false;
+      return true;
+   }
+   
+   std::vector< std::string > ImpactPayloadConfigurationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   ImpactPayloadConfiguration::ImpactPayloadConfiguration(void) : afrl::cmasi::PayloadConfiguration()
+   {
+
+   }
+     
+   ImpactPayloadConfiguration::ImpactPayloadConfiguration(const ImpactPayloadConfiguration &that) : afrl::cmasi::PayloadConfiguration(that)
+   {
+        __AvailablePayloads.clear();
+        for (size_t i=0; i< that.__AvailablePayloads.size(); i++)
+        {
+           __AvailablePayloads.push_back( that.__AvailablePayloads[i]);
+        }
+
+   }
+   
+   ImpactPayloadConfiguration & ImpactPayloadConfiguration::operator=(const ImpactPayloadConfiguration &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadConfiguration::operator=(that);
+
+         __AvailablePayloads.clear();
+         for (size_t i=0; i< that.__AvailablePayloads.size(); i++)
+         {
+            __AvailablePayloads.push_back( that.__AvailablePayloads[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   ImpactPayloadConfiguration* ImpactPayloadConfiguration::clone() const
+   {
+        return new ImpactPayloadConfiguration(*this);
+   }
+   
+   ImpactPayloadConfiguration::~ImpactPayloadConfiguration(void)
+   {
+
+   }
+  
+   void ImpactPayloadConfiguration::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadConfiguration::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__AvailablePayloads.size()));
+      for (size_t i=0; i<__AvailablePayloads.size(); i++)
+      {
+         buf.putInt( (int32_t) __AvailablePayloads[i]);
+      }
+
+   }
+   
+   void ImpactPayloadConfiguration::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadConfiguration::unpack(buf);
+      // Copy the buffer into the class
+      __AvailablePayloads.clear();
+      uint16_t __AvailablePayloads_length = buf.getUShort();
+      for (uint32_t i=0; i< __AvailablePayloads_length; i++)
+      {
+         __AvailablePayloads.push_back( (afrl::impact::ImpactPayloadType::ImpactPayloadType) buf.getInt() );
+      }
+
+   }
+
+   uint32_t ImpactPayloadConfiguration::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadConfiguration::calculatePackedSize();
+      size += 2 + sizeof(afrl::impact::ImpactPayloadType::ImpactPayloadType) * __AvailablePayloads.size();
+
+      return size;
+   }
+
+   std::string ImpactPayloadConfiguration::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( ImpactPayloadConfiguration ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "PayloadKind (std::string) = " << __PayloadKind << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      oss << indent << "AvailablePayloads (ImpactPayloadType [ " << __AvailablePayloads.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string ImpactPayloadConfiguration::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<ImpactPayloadConfiguration Series=\"IMPACT\">\n";
+      str << ws << "   <AvailablePayloads>\n";
+      for (size_t i=0; i<__AvailablePayloads.size(); i++)
+      {
+         str << ws << "   <ImpactPayloadType>" << afrl::impact::ImpactPayloadType::get_string(__AvailablePayloads[i]) << "</ImpactPayloadType>\n";
+      }
+      str << ws << "   </AvailablePayloads>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <PayloadKind>" << __PayloadKind << "</PayloadKind>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</ImpactPayloadConfiguration>\n";
+
+      return str.str();
+   }
+
+   bool ImpactPayloadConfiguration::operator==(const ImpactPayloadConfiguration & that)
+   {
+      if( afrl::cmasi::PayloadConfiguration::operator!=(that) )
+      {
+          return false;
+      }
+      if(__AvailablePayloads.size() != that.__AvailablePayloads.size()) return false;
+      for (size_t i=0; i<__AvailablePayloads.size(); i++)
+      {
+         if(__AvailablePayloads[i] != that.__AvailablePayloads[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool ImpactPayloadConfiguration::operator!=(const ImpactPayloadConfiguration & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactImpactPointSearchTask.cpp b/src/LMCP/afrl/impact/afrlimpactImpactPointSearchTask.cpp
new file mode 100644
index 0000000..fe7c62a
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactImpactPointSearchTask.cpp
@@ -0,0 +1,376 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/ImpactPointSearchTask.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string ImpactPointSearchTask::Subscription = "afrl.impact.ImpactPointSearchTask";
+   const std::string ImpactPointSearchTask::TypeName = "ImpactPointSearchTask";
+   
+   bool isImpactPointSearchTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 25) return false;
+      return true;
+   }
+   
+   bool isImpactPointSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 25) return false;
+      return true;
+   }
+   
+   std::vector< std::string > ImpactPointSearchTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   ImpactPointSearchTask::ImpactPointSearchTask(void) : afrl::cmasi::SearchTask()
+   {
+      __SearchLocationID = 0LL;
+      __SearchLocation = new afrl::cmasi::Location3D();
+      __StandoffDistance = 0.f;
+      __DesiredAction = nullptr;
+
+   }
+     
+   ImpactPointSearchTask::ImpactPointSearchTask(const ImpactPointSearchTask &that) : afrl::cmasi::SearchTask(that)
+   {
+        __SearchLocationID = that.__SearchLocationID;
+        __SearchLocation = that.__SearchLocation == nullptr ? nullptr : that.__SearchLocation->clone();
+        __StandoffDistance = that.__StandoffDistance;
+        __ViewAngleList.clear();
+        for (size_t i=0; i< that.__ViewAngleList.size(); i++)
+        {
+           __ViewAngleList.push_back( that.__ViewAngleList[i] == nullptr ? nullptr : that.__ViewAngleList[i]->clone());
+        }
+        __DesiredAction = that.__DesiredAction == nullptr ? nullptr : that.__DesiredAction->clone();
+
+   }
+   
+   ImpactPointSearchTask & ImpactPointSearchTask::operator=(const ImpactPointSearchTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::SearchTask::operator=(that);
+         if (__SearchLocation != nullptr) delete __SearchLocation;
+         for (size_t i=0; i<__ViewAngleList.size(); i++)
+         {
+            if (__ViewAngleList[i] != nullptr) delete __ViewAngleList[i];
+         }
+         if (__DesiredAction != nullptr) delete __DesiredAction;
+
+         __SearchLocationID = that.__SearchLocationID;
+         __SearchLocation = that.__SearchLocation == nullptr ? nullptr : that.__SearchLocation->clone();
+         __StandoffDistance = that.__StandoffDistance;
+         __ViewAngleList.clear();
+         for (size_t i=0; i< that.__ViewAngleList.size(); i++)
+         {
+            __ViewAngleList.push_back( that.__ViewAngleList[i] == nullptr ? nullptr : that.__ViewAngleList[i]->clone());
+         }
+         __DesiredAction = that.__DesiredAction == nullptr ? nullptr : that.__DesiredAction->clone();
+
+      }
+      return *this;
+   }
+
+   ImpactPointSearchTask* ImpactPointSearchTask::clone() const
+   {
+        return new ImpactPointSearchTask(*this);
+   }
+   
+   ImpactPointSearchTask::~ImpactPointSearchTask(void)
+   {
+      if (__SearchLocation != nullptr) delete __SearchLocation;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr) delete __ViewAngleList[i];
+      }
+      if (__DesiredAction != nullptr) delete __DesiredAction;
+
+   }
+  
+   void ImpactPointSearchTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::SearchTask::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__SearchLocationID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __SearchLocation, buf);
+      buf.putFloat(__StandoffDistance);
+      buf.putUShort( static_cast<uint16_t>(__ViewAngleList.size()));
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __ViewAngleList[i], buf);
+      }
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __DesiredAction, buf);
+
+   }
+   
+   void ImpactPointSearchTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::SearchTask::unpack(buf);
+      // Copy the buffer into the class
+      __SearchLocationID = buf.getLong();
+      {
+         if (__SearchLocation != nullptr) delete __SearchLocation;
+         __SearchLocation = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __SearchLocation = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__SearchLocation != nullptr) __SearchLocation->unpack(buf);
+         }
+      }
+      __StandoffDistance = buf.getFloat();
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr)
+            delete __ViewAngleList[i];
+      }
+      __ViewAngleList.clear();
+      uint16_t __ViewAngleList_length = buf.getUShort();
+      for (uint32_t i=0; i< __ViewAngleList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Wedge* e = (afrl::cmasi::Wedge*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __ViewAngleList.push_back(e);
+         }
+      }
+      {
+         if (__DesiredAction != nullptr) delete __DesiredAction;
+         __DesiredAction = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __DesiredAction = (afrl::cmasi::LoiterAction*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__DesiredAction != nullptr) __DesiredAction->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t ImpactPointSearchTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::SearchTask::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__SearchLocation != nullptr ? __SearchLocation->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+      size += 2;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if (__ViewAngleList[i] != nullptr)
+         {
+            size += __ViewAngleList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += (__DesiredAction != nullptr ? __DesiredAction->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string ImpactPointSearchTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( ImpactPointSearchTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "DesiredWavelengthBands (WavelengthBand [ " << __DesiredWavelengthBands.size() << ", var ])\n";
+      oss << indent << "DwellTime (int64_t) = " << __DwellTime << "\n";
+      oss << indent << "GroundSampleDistance (float) = " << __GroundSampleDistance << "\n";
+
+      oss << indent << "SearchLocationID (int64_t) = " << __SearchLocationID << "\n";
+      oss << indent << "SearchLocation (Location3D)";
+      if (__SearchLocation == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "StandoffDistance (float) = " << __StandoffDistance << "\n";
+      oss << indent << "ViewAngleList (Wedge [ " << __ViewAngleList.size() << ", var ])\n";
+      oss << indent << "DesiredAction (LoiterAction)";
+      if (__DesiredAction == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string ImpactPointSearchTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<ImpactPointSearchTask Series=\"IMPACT\">\n";
+      str << ws << "   <SearchLocationID>" << __SearchLocationID << "</SearchLocationID>\n";
+      if (__SearchLocation != nullptr)
+      {
+         str << ws << "   <SearchLocation>";
+         str << "\n" + __SearchLocation->toXML(depth + 1) + ws + "   ";
+         str << "</SearchLocation>\n";
+      }
+      str << ws << "   <StandoffDistance>" << __StandoffDistance << "</StandoffDistance>\n";
+      str << ws << "   <ViewAngleList>\n";
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         str << (__ViewAngleList[i] == nullptr ? ( ws + "   <null/>\n") : (__ViewAngleList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </ViewAngleList>\n";
+      if (__DesiredAction != nullptr)
+      {
+         str << ws << "   <DesiredAction>";
+         str << "\n" + __DesiredAction->toXML(depth + 1) + ws + "   ";
+         str << "</DesiredAction>\n";
+      }
+      str << ws << "   <DesiredWavelengthBands>\n";
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         str << ws << "   <WavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__DesiredWavelengthBands[i]) << "</WavelengthBand>\n";
+      }
+      str << ws << "   </DesiredWavelengthBands>\n";
+      str << ws << "   <DwellTime>" << __DwellTime << "</DwellTime>\n";
+      str << ws << "   <GroundSampleDistance>" << __GroundSampleDistance << "</GroundSampleDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</ImpactPointSearchTask>\n";
+
+      return str.str();
+   }
+
+   bool ImpactPointSearchTask::operator==(const ImpactPointSearchTask & that)
+   {
+      if( afrl::cmasi::SearchTask::operator!=(that) )
+      {
+          return false;
+      }
+      if(__SearchLocationID != that.__SearchLocationID) return false;
+      if(__SearchLocation && that.__SearchLocation)
+      {
+         if(__SearchLocation->getSeriesNameAsLong() != that.__SearchLocation->getSeriesNameAsLong()) return false;
+         if(__SearchLocation->getSeriesVersion() != that.__SearchLocation->getSeriesVersion()) return false;
+         if(__SearchLocation->getLmcpType() != that.__SearchLocation->getLmcpType()) return false;
+         if( *(__SearchLocation) != *(that.__SearchLocation) ) return false;
+      }
+      else if(__SearchLocation != that.__SearchLocation) return false;
+      if(__StandoffDistance != that.__StandoffDistance) return false;
+      if(__ViewAngleList.size() != that.__ViewAngleList.size()) return false;
+      for (size_t i=0; i<__ViewAngleList.size(); i++)
+      {
+         if(__ViewAngleList[i] && that.__ViewAngleList[i])
+         {
+            if(__ViewAngleList[i]->getSeriesNameAsLong() != that.__ViewAngleList[i]->getSeriesNameAsLong()) return false;
+            if(__ViewAngleList[i]->getSeriesVersion() != that.__ViewAngleList[i]->getSeriesVersion()) return false;
+            if(__ViewAngleList[i]->getLmcpType() != that.__ViewAngleList[i]->getLmcpType()) return false;
+            if( *(__ViewAngleList[i]) != *(that.__ViewAngleList[i]) ) return false;
+         }
+         else if(__ViewAngleList[i] != that.__ViewAngleList[i]) return false;
+      }
+      if(__DesiredAction && that.__DesiredAction)
+      {
+         if(__DesiredAction->getSeriesNameAsLong() != that.__DesiredAction->getSeriesNameAsLong()) return false;
+         if(__DesiredAction->getSeriesVersion() != that.__DesiredAction->getSeriesVersion()) return false;
+         if(__DesiredAction->getLmcpType() != that.__DesiredAction->getLmcpType()) return false;
+         if( *(__DesiredAction) != *(that.__DesiredAction) ) return false;
+      }
+      else if(__DesiredAction != that.__DesiredAction) return false;
+      return true;
+
+   }
+
+   bool ImpactPointSearchTask::operator!=(const ImpactPointSearchTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   ImpactPointSearchTask& ImpactPointSearchTask::setSearchLocationID(const int64_t val)
+   {
+      __SearchLocationID = val;
+      return *this;
+   }
+
+   ImpactPointSearchTask& ImpactPointSearchTask::setSearchLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__SearchLocation != nullptr) { delete __SearchLocation; __SearchLocation = nullptr; }
+      if (val != nullptr) { __SearchLocation = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   ImpactPointSearchTask& ImpactPointSearchTask::setStandoffDistance(const float val)
+   {
+      __StandoffDistance = val;
+      return *this;
+   }
+
+
+   ImpactPointSearchTask& ImpactPointSearchTask::setDesiredAction(const afrl::cmasi::LoiterAction* const val)
+   {
+      if (__DesiredAction != nullptr) { delete __DesiredAction; __DesiredAction = nullptr; }
+      if (val != nullptr) { __DesiredAction = const_cast< afrl::cmasi::LoiterAction* > (val); }
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactLineOfInterest.cpp b/src/LMCP/afrl/impact/afrlimpactLineOfInterest.cpp
new file mode 100644
index 0000000..e183751
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactLineOfInterest.cpp
@@ -0,0 +1,236 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/LineOfInterest.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string LineOfInterest::Subscription = "afrl.impact.LineOfInterest";
+   const std::string LineOfInterest::TypeName = "LineOfInterest";
+   
+   bool isLineOfInterest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 23) return false;
+      return true;
+   }
+   
+   bool isLineOfInterest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 23) return false;
+      return true;
+   }
+   
+   std::vector< std::string > LineOfInterestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   LineOfInterest::LineOfInterest(void) : avtas::lmcp::Object()
+   {
+      __LineID = 0LL;
+
+   }
+     
+   LineOfInterest::LineOfInterest(const LineOfInterest &that) : avtas::lmcp::Object(that)
+   {
+        __LineID = that.__LineID;
+        __Line.clear();
+        for (size_t i=0; i< that.__Line.size(); i++)
+        {
+           __Line.push_back( that.__Line[i] == nullptr ? nullptr : that.__Line[i]->clone());
+        }
+
+   }
+   
+   LineOfInterest & LineOfInterest::operator=(const LineOfInterest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Line.size(); i++)
+         {
+            if (__Line[i] != nullptr) delete __Line[i];
+         }
+
+         __LineID = that.__LineID;
+         __Line.clear();
+         for (size_t i=0; i< that.__Line.size(); i++)
+         {
+            __Line.push_back( that.__Line[i] == nullptr ? nullptr : that.__Line[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   LineOfInterest* LineOfInterest::clone() const
+   {
+        return new LineOfInterest(*this);
+   }
+   
+   LineOfInterest::~LineOfInterest(void)
+   {
+      for (size_t i=0; i<__Line.size(); i++)
+      {
+         if (__Line[i] != nullptr) delete __Line[i];
+      }
+
+   }
+  
+   void LineOfInterest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__LineID);
+      buf.putUShort( static_cast<uint16_t>(__Line.size()));
+      for (size_t i=0; i<__Line.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Line[i], buf);
+      }
+
+   }
+   
+   void LineOfInterest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __LineID = buf.getLong();
+      for (size_t i=0; i<__Line.size(); i++)
+      {
+         if (__Line[i] != nullptr)
+            delete __Line[i];
+      }
+      __Line.clear();
+      uint16_t __Line_length = buf.getUShort();
+      for (uint32_t i=0; i< __Line_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Location3D* e = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Line.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t LineOfInterest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__Line.size(); i++)
+      {
+         if (__Line[i] != nullptr)
+         {
+            size += __Line[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string LineOfInterest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( LineOfInterest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "LineID (int64_t) = " << __LineID << "\n";
+      oss << indent << "Line (Location3D [ " << __Line.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string LineOfInterest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<LineOfInterest Series=\"IMPACT\">\n";
+      str << ws << "   <LineID>" << __LineID << "</LineID>\n";
+      str << ws << "   <Line>\n";
+      for (size_t i=0; i<__Line.size(); i++)
+      {
+         str << (__Line[i] == nullptr ? ( ws + "   <null/>\n") : (__Line[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Line>\n";
+      str << ws << "</LineOfInterest>\n";
+
+      return str.str();
+   }
+
+   bool LineOfInterest::operator==(const LineOfInterest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__LineID != that.__LineID) return false;
+      if(__Line.size() != that.__Line.size()) return false;
+      for (size_t i=0; i<__Line.size(); i++)
+      {
+         if(__Line[i] && that.__Line[i])
+         {
+            if(__Line[i]->getSeriesNameAsLong() != that.__Line[i]->getSeriesNameAsLong()) return false;
+            if(__Line[i]->getSeriesVersion() != that.__Line[i]->getSeriesVersion()) return false;
+            if(__Line[i]->getLmcpType() != that.__Line[i]->getLmcpType()) return false;
+            if( *(__Line[i]) != *(that.__Line[i]) ) return false;
+         }
+         else if(__Line[i] != that.__Line[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool LineOfInterest::operator!=(const LineOfInterest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   LineOfInterest& LineOfInterest::setLineID(const int64_t val)
+   {
+      __LineID = val;
+      return *this;
+   }
+
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactMultiVehicleWatchTask.cpp b/src/LMCP/afrl/impact/afrlimpactMultiVehicleWatchTask.cpp
new file mode 100644
index 0000000..5517bce
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactMultiVehicleWatchTask.cpp
@@ -0,0 +1,215 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/MultiVehicleWatchTask.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string MultiVehicleWatchTask::Subscription = "afrl.impact.MultiVehicleWatchTask";
+   const std::string MultiVehicleWatchTask::TypeName = "MultiVehicleWatchTask";
+   
+   bool isMultiVehicleWatchTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 30) return false;
+      return true;
+   }
+   
+   bool isMultiVehicleWatchTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 30) return false;
+      return true;
+   }
+   
+   std::vector< std::string > MultiVehicleWatchTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   MultiVehicleWatchTask::MultiVehicleWatchTask(void) : afrl::cmasi::SearchTask()
+   {
+      __WatchedEntityID = 0LL;
+      __NumberVehicles = 1;
+
+   }
+     
+   MultiVehicleWatchTask::MultiVehicleWatchTask(const MultiVehicleWatchTask &that) : afrl::cmasi::SearchTask(that)
+   {
+        __WatchedEntityID = that.__WatchedEntityID;
+        __NumberVehicles = that.__NumberVehicles;
+
+   }
+   
+   MultiVehicleWatchTask & MultiVehicleWatchTask::operator=(const MultiVehicleWatchTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::SearchTask::operator=(that);
+
+         __WatchedEntityID = that.__WatchedEntityID;
+         __NumberVehicles = that.__NumberVehicles;
+
+      }
+      return *this;
+   }
+
+   MultiVehicleWatchTask* MultiVehicleWatchTask::clone() const
+   {
+        return new MultiVehicleWatchTask(*this);
+   }
+   
+   MultiVehicleWatchTask::~MultiVehicleWatchTask(void)
+   {
+
+   }
+  
+   void MultiVehicleWatchTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::SearchTask::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__WatchedEntityID);
+      buf.putByte(__NumberVehicles);
+
+   }
+   
+   void MultiVehicleWatchTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::SearchTask::unpack(buf);
+      // Copy the buffer into the class
+      __WatchedEntityID = buf.getLong();
+      __NumberVehicles = buf.getByte();
+
+   }
+
+   uint32_t MultiVehicleWatchTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::SearchTask::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(uint8_t);
+
+      return size;
+   }
+
+   std::string MultiVehicleWatchTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( MultiVehicleWatchTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "DesiredWavelengthBands (WavelengthBand [ " << __DesiredWavelengthBands.size() << ", var ])\n";
+      oss << indent << "DwellTime (int64_t) = " << __DwellTime << "\n";
+      oss << indent << "GroundSampleDistance (float) = " << __GroundSampleDistance << "\n";
+
+      oss << indent << "WatchedEntityID (int64_t) = " << __WatchedEntityID << "\n";
+      oss << indent << "NumberVehicles (uint8_t) = " << __NumberVehicles << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string MultiVehicleWatchTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<MultiVehicleWatchTask Series=\"IMPACT\">\n";
+      str << ws << "   <WatchedEntityID>" << __WatchedEntityID << "</WatchedEntityID>\n";
+      str << ws << "   <NumberVehicles>" << (int32_t) __NumberVehicles << "</NumberVehicles>\n";
+      str << ws << "   <DesiredWavelengthBands>\n";
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         str << ws << "   <WavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__DesiredWavelengthBands[i]) << "</WavelengthBand>\n";
+      }
+      str << ws << "   </DesiredWavelengthBands>\n";
+      str << ws << "   <DwellTime>" << __DwellTime << "</DwellTime>\n";
+      str << ws << "   <GroundSampleDistance>" << __GroundSampleDistance << "</GroundSampleDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</MultiVehicleWatchTask>\n";
+
+      return str.str();
+   }
+
+   bool MultiVehicleWatchTask::operator==(const MultiVehicleWatchTask & that)
+   {
+      if( afrl::cmasi::SearchTask::operator!=(that) )
+      {
+          return false;
+      }
+      if(__WatchedEntityID != that.__WatchedEntityID) return false;
+      if(__NumberVehicles != that.__NumberVehicles) return false;
+      return true;
+
+   }
+
+   bool MultiVehicleWatchTask::operator!=(const MultiVehicleWatchTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   MultiVehicleWatchTask& MultiVehicleWatchTask::setWatchedEntityID(const int64_t val)
+   {
+      __WatchedEntityID = val;
+      return *this;
+   }
+
+   MultiVehicleWatchTask& MultiVehicleWatchTask::setNumberVehicles(const uint8_t val)
+   {
+      __NumberVehicles = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactPatternSearchTask.cpp b/src/LMCP/afrl/impact/afrlimpactPatternSearchTask.cpp
new file mode 100644
index 0000000..d802939
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactPatternSearchTask.cpp
@@ -0,0 +1,276 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/PatternSearchTask.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string PatternSearchTask::Subscription = "afrl.impact.PatternSearchTask";
+   const std::string PatternSearchTask::TypeName = "PatternSearchTask";
+   
+   bool isPatternSearchTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 26) return false;
+      return true;
+   }
+   
+   bool isPatternSearchTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 26) return false;
+      return true;
+   }
+   
+   std::vector< std::string > PatternSearchTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   PatternSearchTask::PatternSearchTask(void) : afrl::cmasi::SearchTask()
+   {
+      __SearchLocationID = 0LL;
+      __SearchLocation = new afrl::cmasi::Location3D();
+      __Pattern = afrl::impact::AreaSearchPattern::Spiral;
+      __Extent = 0.0f;
+
+   }
+     
+   PatternSearchTask::PatternSearchTask(const PatternSearchTask &that) : afrl::cmasi::SearchTask(that)
+   {
+        __SearchLocationID = that.__SearchLocationID;
+        __SearchLocation = that.__SearchLocation == nullptr ? nullptr : that.__SearchLocation->clone();
+        __Pattern = that.__Pattern;
+        __Extent = that.__Extent;
+
+   }
+   
+   PatternSearchTask & PatternSearchTask::operator=(const PatternSearchTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::SearchTask::operator=(that);
+         if (__SearchLocation != nullptr) delete __SearchLocation;
+
+         __SearchLocationID = that.__SearchLocationID;
+         __SearchLocation = that.__SearchLocation == nullptr ? nullptr : that.__SearchLocation->clone();
+         __Pattern = that.__Pattern;
+         __Extent = that.__Extent;
+
+      }
+      return *this;
+   }
+
+   PatternSearchTask* PatternSearchTask::clone() const
+   {
+        return new PatternSearchTask(*this);
+   }
+   
+   PatternSearchTask::~PatternSearchTask(void)
+   {
+      if (__SearchLocation != nullptr) delete __SearchLocation;
+
+   }
+  
+   void PatternSearchTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::SearchTask::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__SearchLocationID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __SearchLocation, buf);
+      buf.putInt( (int32_t) __Pattern);
+      buf.putFloat(__Extent);
+
+   }
+   
+   void PatternSearchTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::SearchTask::unpack(buf);
+      // Copy the buffer into the class
+      __SearchLocationID = buf.getLong();
+      {
+         if (__SearchLocation != nullptr) delete __SearchLocation;
+         __SearchLocation = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __SearchLocation = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__SearchLocation != nullptr) __SearchLocation->unpack(buf);
+         }
+      }
+      __Pattern = (afrl::impact::AreaSearchPattern::AreaSearchPattern) buf.getInt();
+      __Extent = buf.getFloat();
+
+   }
+
+   uint32_t PatternSearchTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::SearchTask::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__SearchLocation != nullptr ? __SearchLocation->calculatePackedSize() + 15 : 1);
+      size += sizeof(afrl::impact::AreaSearchPattern::AreaSearchPattern);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string PatternSearchTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( PatternSearchTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "DesiredWavelengthBands (WavelengthBand [ " << __DesiredWavelengthBands.size() << ", var ])\n";
+      oss << indent << "DwellTime (int64_t) = " << __DwellTime << "\n";
+      oss << indent << "GroundSampleDistance (float) = " << __GroundSampleDistance << "\n";
+
+      oss << indent << "SearchLocationID (int64_t) = " << __SearchLocationID << "\n";
+      oss << indent << "SearchLocation (Location3D)";
+      if (__SearchLocation == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "Pattern (AreaSearchPattern) = " << __Pattern << "\n";
+      oss << indent << "Extent (float) = " << __Extent << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string PatternSearchTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<PatternSearchTask Series=\"IMPACT\">\n";
+      str << ws << "   <SearchLocationID>" << __SearchLocationID << "</SearchLocationID>\n";
+      if (__SearchLocation != nullptr)
+      {
+         str << ws << "   <SearchLocation>";
+         str << "\n" + __SearchLocation->toXML(depth + 1) + ws + "   ";
+         str << "</SearchLocation>\n";
+      }
+      str << ws << "   <Pattern>" << afrl::impact::AreaSearchPattern::get_string(__Pattern) << "</Pattern>\n";
+      str << ws << "   <Extent>" << __Extent << "</Extent>\n";
+      str << ws << "   <DesiredWavelengthBands>\n";
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         str << ws << "   <WavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__DesiredWavelengthBands[i]) << "</WavelengthBand>\n";
+      }
+      str << ws << "   </DesiredWavelengthBands>\n";
+      str << ws << "   <DwellTime>" << __DwellTime << "</DwellTime>\n";
+      str << ws << "   <GroundSampleDistance>" << __GroundSampleDistance << "</GroundSampleDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</PatternSearchTask>\n";
+
+      return str.str();
+   }
+
+   bool PatternSearchTask::operator==(const PatternSearchTask & that)
+   {
+      if( afrl::cmasi::SearchTask::operator!=(that) )
+      {
+          return false;
+      }
+      if(__SearchLocationID != that.__SearchLocationID) return false;
+      if(__SearchLocation && that.__SearchLocation)
+      {
+         if(__SearchLocation->getSeriesNameAsLong() != that.__SearchLocation->getSeriesNameAsLong()) return false;
+         if(__SearchLocation->getSeriesVersion() != that.__SearchLocation->getSeriesVersion()) return false;
+         if(__SearchLocation->getLmcpType() != that.__SearchLocation->getLmcpType()) return false;
+         if( *(__SearchLocation) != *(that.__SearchLocation) ) return false;
+      }
+      else if(__SearchLocation != that.__SearchLocation) return false;
+      if(__Pattern != that.__Pattern) return false;
+      if(__Extent != that.__Extent) return false;
+      return true;
+
+   }
+
+   bool PatternSearchTask::operator!=(const PatternSearchTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   PatternSearchTask& PatternSearchTask::setSearchLocationID(const int64_t val)
+   {
+      __SearchLocationID = val;
+      return *this;
+   }
+
+   PatternSearchTask& PatternSearchTask::setSearchLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__SearchLocation != nullptr) { delete __SearchLocation; __SearchLocation = nullptr; }
+      if (val != nullptr) { __SearchLocation = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   PatternSearchTask& PatternSearchTask::setPattern(const afrl::impact::AreaSearchPattern::AreaSearchPattern val)
+   {
+      __Pattern = val;
+      return *this;
+   }
+
+   PatternSearchTask& PatternSearchTask::setExtent(const float val)
+   {
+      __Extent = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactPointOfInterest.cpp b/src/LMCP/afrl/impact/afrlimpactPointOfInterest.cpp
new file mode 100644
index 0000000..c5f6632
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactPointOfInterest.cpp
@@ -0,0 +1,209 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/PointOfInterest.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string PointOfInterest::Subscription = "afrl.impact.PointOfInterest";
+   const std::string PointOfInterest::TypeName = "PointOfInterest";
+   
+   bool isPointOfInterest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 22) return false;
+      return true;
+   }
+   
+   bool isPointOfInterest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 22) return false;
+      return true;
+   }
+   
+   std::vector< std::string > PointOfInterestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   PointOfInterest::PointOfInterest(void) : avtas::lmcp::Object()
+   {
+      __PointID = 0LL;
+      __Location = new afrl::cmasi::Location3D();
+
+   }
+     
+   PointOfInterest::PointOfInterest(const PointOfInterest &that) : avtas::lmcp::Object(that)
+   {
+        __PointID = that.__PointID;
+        __Location = that.__Location == nullptr ? nullptr : that.__Location->clone();
+
+   }
+   
+   PointOfInterest & PointOfInterest::operator=(const PointOfInterest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__Location != nullptr) delete __Location;
+
+         __PointID = that.__PointID;
+         __Location = that.__Location == nullptr ? nullptr : that.__Location->clone();
+
+      }
+      return *this;
+   }
+
+   PointOfInterest* PointOfInterest::clone() const
+   {
+        return new PointOfInterest(*this);
+   }
+   
+   PointOfInterest::~PointOfInterest(void)
+   {
+      if (__Location != nullptr) delete __Location;
+
+   }
+  
+   void PointOfInterest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__PointID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Location, buf);
+
+   }
+   
+   void PointOfInterest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __PointID = buf.getLong();
+      {
+         if (__Location != nullptr) delete __Location;
+         __Location = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Location = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Location != nullptr) __Location->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t PointOfInterest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__Location != nullptr ? __Location->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string PointOfInterest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( PointOfInterest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PointID (int64_t) = " << __PointID << "\n";
+      oss << indent << "Location (Location3D)";
+      if (__Location == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string PointOfInterest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<PointOfInterest Series=\"IMPACT\">\n";
+      str << ws << "   <PointID>" << __PointID << "</PointID>\n";
+      if (__Location != nullptr)
+      {
+         str << ws << "   <Location>";
+         str << "\n" + __Location->toXML(depth + 1) + ws + "   ";
+         str << "</Location>\n";
+      }
+      str << ws << "</PointOfInterest>\n";
+
+      return str.str();
+   }
+
+   bool PointOfInterest::operator==(const PointOfInterest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__PointID != that.__PointID) return false;
+      if(__Location && that.__Location)
+      {
+         if(__Location->getSeriesNameAsLong() != that.__Location->getSeriesNameAsLong()) return false;
+         if(__Location->getSeriesVersion() != that.__Location->getSeriesVersion()) return false;
+         if(__Location->getLmcpType() != that.__Location->getLmcpType()) return false;
+         if( *(__Location) != *(that.__Location) ) return false;
+      }
+      else if(__Location != that.__Location) return false;
+      return true;
+
+   }
+
+   bool PointOfInterest::operator!=(const PointOfInterest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   PointOfInterest& PointOfInterest::setPointID(const int64_t val)
+   {
+      __PointID = val;
+      return *this;
+   }
+
+   PointOfInterest& PointOfInterest::setLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__Location != nullptr) { delete __Location; __Location = nullptr; }
+      if (val != nullptr) { __Location = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactPowerConfiguration.cpp b/src/LMCP/afrl/impact/afrlimpactPowerConfiguration.cpp
new file mode 100644
index 0000000..73b2f19
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactPowerConfiguration.cpp
@@ -0,0 +1,175 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/PowerConfiguration.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string PowerConfiguration::Subscription = "afrl.impact.PowerConfiguration";
+   const std::string PowerConfiguration::TypeName = "PowerConfiguration";
+   
+   bool isPowerConfiguration(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 1) return false;
+      return true;
+   }
+   
+   bool isPowerConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 1) return false;
+      return true;
+   }
+   
+   std::vector< std::string > PowerConfigurationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   PowerConfiguration::PowerConfiguration(void) : afrl::cmasi::PayloadConfiguration()
+   {
+      __NominalPowerConfiguration = afrl::impact::PowerPlant::Gasoline;
+
+   }
+     
+   PowerConfiguration::PowerConfiguration(const PowerConfiguration &that) : afrl::cmasi::PayloadConfiguration(that)
+   {
+        __NominalPowerConfiguration = that.__NominalPowerConfiguration;
+
+   }
+   
+   PowerConfiguration & PowerConfiguration::operator=(const PowerConfiguration &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadConfiguration::operator=(that);
+
+         __NominalPowerConfiguration = that.__NominalPowerConfiguration;
+
+      }
+      return *this;
+   }
+
+   PowerConfiguration* PowerConfiguration::clone() const
+   {
+        return new PowerConfiguration(*this);
+   }
+   
+   PowerConfiguration::~PowerConfiguration(void)
+   {
+
+   }
+  
+   void PowerConfiguration::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadConfiguration::pack(buf);
+      // Copy the class into the buffer
+      buf.putInt( (int32_t) __NominalPowerConfiguration);
+
+   }
+   
+   void PowerConfiguration::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadConfiguration::unpack(buf);
+      // Copy the buffer into the class
+      __NominalPowerConfiguration = (afrl::impact::PowerPlant::PowerPlant) buf.getInt();
+
+   }
+
+   uint32_t PowerConfiguration::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadConfiguration::calculatePackedSize();
+      size += sizeof(afrl::impact::PowerPlant::PowerPlant);
+
+      return size;
+   }
+
+   std::string PowerConfiguration::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( PowerConfiguration ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "PayloadKind (std::string) = " << __PayloadKind << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      oss << indent << "NominalPowerConfiguration (PowerPlant) = " << __NominalPowerConfiguration << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string PowerConfiguration::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<PowerConfiguration Series=\"IMPACT\">\n";
+      str << ws << "   <NominalPowerConfiguration>" << afrl::impact::PowerPlant::get_string(__NominalPowerConfiguration) << "</NominalPowerConfiguration>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <PayloadKind>" << __PayloadKind << "</PayloadKind>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</PowerConfiguration>\n";
+
+      return str.str();
+   }
+
+   bool PowerConfiguration::operator==(const PowerConfiguration & that)
+   {
+      if( afrl::cmasi::PayloadConfiguration::operator!=(that) )
+      {
+          return false;
+      }
+      if(__NominalPowerConfiguration != that.__NominalPowerConfiguration) return false;
+      return true;
+
+   }
+
+   bool PowerConfiguration::operator!=(const PowerConfiguration & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   PowerConfiguration& PowerConfiguration::setNominalPowerConfiguration(const afrl::impact::PowerPlant::PowerPlant val)
+   {
+      __NominalPowerConfiguration = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactPowerPlantState.cpp b/src/LMCP/afrl/impact/afrlimpactPowerPlantState.cpp
new file mode 100644
index 0000000..99fb596
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactPowerPlantState.cpp
@@ -0,0 +1,173 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/PowerPlantState.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string PowerPlantState::Subscription = "afrl.impact.PowerPlantState";
+   const std::string PowerPlantState::TypeName = "PowerPlantState";
+   
+   bool isPowerPlantState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 8) return false;
+      return true;
+   }
+   
+   bool isPowerPlantState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 8) return false;
+      return true;
+   }
+   
+   std::vector< std::string > PowerPlantStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   PowerPlantState::PowerPlantState(void) : afrl::cmasi::PayloadState()
+   {
+      __ActivePowerPlant = afrl::impact::PowerPlant::Gasoline;
+
+   }
+     
+   PowerPlantState::PowerPlantState(const PowerPlantState &that) : afrl::cmasi::PayloadState(that)
+   {
+        __ActivePowerPlant = that.__ActivePowerPlant;
+
+   }
+   
+   PowerPlantState & PowerPlantState::operator=(const PowerPlantState &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadState::operator=(that);
+
+         __ActivePowerPlant = that.__ActivePowerPlant;
+
+      }
+      return *this;
+   }
+
+   PowerPlantState* PowerPlantState::clone() const
+   {
+        return new PowerPlantState(*this);
+   }
+   
+   PowerPlantState::~PowerPlantState(void)
+   {
+
+   }
+  
+   void PowerPlantState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadState::pack(buf);
+      // Copy the class into the buffer
+      buf.putInt( (int32_t) __ActivePowerPlant);
+
+   }
+   
+   void PowerPlantState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadState::unpack(buf);
+      // Copy the buffer into the class
+      __ActivePowerPlant = (afrl::impact::PowerPlant::PowerPlant) buf.getInt();
+
+   }
+
+   uint32_t PowerPlantState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadState::calculatePackedSize();
+      size += sizeof(afrl::impact::PowerPlant::PowerPlant);
+
+      return size;
+   }
+
+   std::string PowerPlantState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( PowerPlantState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      oss << indent << "ActivePowerPlant (PowerPlant) = " << __ActivePowerPlant << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string PowerPlantState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<PowerPlantState Series=\"IMPACT\">\n";
+      str << ws << "   <ActivePowerPlant>" << afrl::impact::PowerPlant::get_string(__ActivePowerPlant) << "</ActivePowerPlant>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</PowerPlantState>\n";
+
+      return str.str();
+   }
+
+   bool PowerPlantState::operator==(const PowerPlantState & that)
+   {
+      if( afrl::cmasi::PayloadState::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ActivePowerPlant != that.__ActivePowerPlant) return false;
+      return true;
+
+   }
+
+   bool PowerPlantState::operator!=(const PowerPlantState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   PowerPlantState& PowerPlantState::setActivePowerPlant(const afrl::impact::PowerPlant::PowerPlant val)
+   {
+      __ActivePowerPlant = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactRadioConfiguration.cpp b/src/LMCP/afrl/impact/afrlimpactRadioConfiguration.cpp
new file mode 100644
index 0000000..69d4eb4
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactRadioConfiguration.cpp
@@ -0,0 +1,236 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/RadioConfiguration.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RadioConfiguration::Subscription = "afrl.impact.RadioConfiguration";
+   const std::string RadioConfiguration::TypeName = "RadioConfiguration";
+   
+   bool isRadioConfiguration(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 2) return false;
+      return true;
+   }
+   
+   bool isRadioConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 2) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RadioConfigurationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RadioConfiguration::RadioConfiguration(void) : afrl::cmasi::PayloadConfiguration()
+   {
+      __Range = 1500.0f;
+      __RallyPoint = new afrl::cmasi::Location3D();
+      __Timeout = 120000LL;
+
+   }
+     
+   RadioConfiguration::RadioConfiguration(const RadioConfiguration &that) : afrl::cmasi::PayloadConfiguration(that)
+   {
+        __Range = that.__Range;
+        __RallyPoint = that.__RallyPoint == nullptr ? nullptr : that.__RallyPoint->clone();
+        __Timeout = that.__Timeout;
+
+   }
+   
+   RadioConfiguration & RadioConfiguration::operator=(const RadioConfiguration &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadConfiguration::operator=(that);
+         if (__RallyPoint != nullptr) delete __RallyPoint;
+
+         __Range = that.__Range;
+         __RallyPoint = that.__RallyPoint == nullptr ? nullptr : that.__RallyPoint->clone();
+         __Timeout = that.__Timeout;
+
+      }
+      return *this;
+   }
+
+   RadioConfiguration* RadioConfiguration::clone() const
+   {
+        return new RadioConfiguration(*this);
+   }
+   
+   RadioConfiguration::~RadioConfiguration(void)
+   {
+      if (__RallyPoint != nullptr) delete __RallyPoint;
+
+   }
+  
+   void RadioConfiguration::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadConfiguration::pack(buf);
+      // Copy the class into the buffer
+      buf.putFloat(__Range);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __RallyPoint, buf);
+      buf.putLong(__Timeout);
+
+   }
+   
+   void RadioConfiguration::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadConfiguration::unpack(buf);
+      // Copy the buffer into the class
+      __Range = buf.getFloat();
+      {
+         if (__RallyPoint != nullptr) delete __RallyPoint;
+         __RallyPoint = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __RallyPoint = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__RallyPoint != nullptr) __RallyPoint->unpack(buf);
+         }
+      }
+      __Timeout = buf.getLong();
+
+   }
+
+   uint32_t RadioConfiguration::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadConfiguration::calculatePackedSize();
+      size += sizeof(float);
+      size += (__RallyPoint != nullptr ? __RallyPoint->calculatePackedSize() + 15 : 1);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string RadioConfiguration::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RadioConfiguration ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "PayloadKind (std::string) = " << __PayloadKind << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      oss << indent << "Range (float) = " << __Range << "\n";
+      oss << indent << "RallyPoint (Location3D)";
+      if (__RallyPoint == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "Timeout (int64_t) = " << __Timeout << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RadioConfiguration::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RadioConfiguration Series=\"IMPACT\">\n";
+      str << ws << "   <Range>" << __Range << "</Range>\n";
+      if (__RallyPoint != nullptr)
+      {
+         str << ws << "   <RallyPoint>";
+         str << "\n" + __RallyPoint->toXML(depth + 1) + ws + "   ";
+         str << "</RallyPoint>\n";
+      }
+      str << ws << "   <Timeout>" << __Timeout << "</Timeout>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <PayloadKind>" << __PayloadKind << "</PayloadKind>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</RadioConfiguration>\n";
+
+      return str.str();
+   }
+
+   bool RadioConfiguration::operator==(const RadioConfiguration & that)
+   {
+      if( afrl::cmasi::PayloadConfiguration::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Range != that.__Range) return false;
+      if(__RallyPoint && that.__RallyPoint)
+      {
+         if(__RallyPoint->getSeriesNameAsLong() != that.__RallyPoint->getSeriesNameAsLong()) return false;
+         if(__RallyPoint->getSeriesVersion() != that.__RallyPoint->getSeriesVersion()) return false;
+         if(__RallyPoint->getLmcpType() != that.__RallyPoint->getLmcpType()) return false;
+         if( *(__RallyPoint) != *(that.__RallyPoint) ) return false;
+      }
+      else if(__RallyPoint != that.__RallyPoint) return false;
+      if(__Timeout != that.__Timeout) return false;
+      return true;
+
+   }
+
+   bool RadioConfiguration::operator!=(const RadioConfiguration & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   RadioConfiguration& RadioConfiguration::setRange(const float val)
+   {
+      __Range = val;
+      return *this;
+   }
+
+   RadioConfiguration& RadioConfiguration::setRallyPoint(const afrl::cmasi::Location3D* const val)
+   {
+      if (__RallyPoint != nullptr) { delete __RallyPoint; __RallyPoint = nullptr; }
+      if (val != nullptr) { __RallyPoint = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   RadioConfiguration& RadioConfiguration::setTimeout(const int64_t val)
+   {
+      __Timeout = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactRadioState.cpp b/src/LMCP/afrl/impact/afrlimpactRadioState.cpp
new file mode 100644
index 0000000..2411728
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactRadioState.cpp
@@ -0,0 +1,188 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/RadioState.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RadioState::Subscription = "afrl.impact.RadioState";
+   const std::string RadioState::TypeName = "RadioState";
+   
+   bool isRadioState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 4) return false;
+      return true;
+   }
+   
+   bool isRadioState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 4) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RadioStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RadioState::RadioState(void) : afrl::cmasi::PayloadState()
+   {
+      __Enabled = true;
+      __InRange = false;
+
+   }
+     
+   RadioState::RadioState(const RadioState &that) : afrl::cmasi::PayloadState(that)
+   {
+        __Enabled = that.__Enabled;
+        __InRange = that.__InRange;
+
+   }
+   
+   RadioState & RadioState::operator=(const RadioState &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::PayloadState::operator=(that);
+
+         __Enabled = that.__Enabled;
+         __InRange = that.__InRange;
+
+      }
+      return *this;
+   }
+
+   RadioState* RadioState::clone() const
+   {
+        return new RadioState(*this);
+   }
+   
+   RadioState::~RadioState(void)
+   {
+
+   }
+  
+   void RadioState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::PayloadState::pack(buf);
+      // Copy the class into the buffer
+      buf.putBool(__Enabled);
+      buf.putBool(__InRange);
+
+   }
+   
+   void RadioState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::PayloadState::unpack(buf);
+      // Copy the buffer into the class
+      __Enabled = buf.getBool();
+      __InRange = buf.getBool();
+
+   }
+
+   uint32_t RadioState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::PayloadState::calculatePackedSize();
+      size += sizeof(bool);
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string RadioState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RadioState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "PayloadID (int64_t) = " << __PayloadID << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+
+      oss << indent << "Enabled (bool) = " << __Enabled << "\n";
+      oss << indent << "InRange (bool) = " << __InRange << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RadioState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RadioState Series=\"IMPACT\">\n";
+      str << ws << "   <Enabled>" << (__Enabled ? "true" : "false") << "</Enabled>\n";
+      str << ws << "   <InRange>" << (__InRange ? "true" : "false") << "</InRange>\n";
+      str << ws << "   <PayloadID>" << __PayloadID << "</PayloadID>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "</RadioState>\n";
+
+      return str.str();
+   }
+
+   bool RadioState::operator==(const RadioState & that)
+   {
+      if( afrl::cmasi::PayloadState::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Enabled != that.__Enabled) return false;
+      if(__InRange != that.__InRange) return false;
+      return true;
+
+   }
+
+   bool RadioState::operator!=(const RadioState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   RadioState& RadioState::setEnabled(const bool val)
+   {
+      __Enabled = val;
+      return *this;
+   }
+
+   RadioState& RadioState::setInRange(const bool val)
+   {
+      __InRange = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactRadioTowerConfiguration.cpp b/src/LMCP/afrl/impact/afrlimpactRadioTowerConfiguration.cpp
new file mode 100644
index 0000000..95d1816
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactRadioTowerConfiguration.cpp
@@ -0,0 +1,253 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/RadioTowerConfiguration.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RadioTowerConfiguration::Subscription = "afrl.impact.RadioTowerConfiguration";
+   const std::string RadioTowerConfiguration::TypeName = "RadioTowerConfiguration";
+   
+   bool isRadioTowerConfiguration(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 3) return false;
+      return true;
+   }
+   
+   bool isRadioTowerConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 3) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RadioTowerConfigurationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RadioTowerConfiguration::RadioTowerConfiguration(void) : afrl::cmasi::EntityConfiguration()
+   {
+      __Position = new afrl::cmasi::Location3D();
+      __Range = 1500.0f;
+      __Enabled = true;
+
+   }
+     
+   RadioTowerConfiguration::RadioTowerConfiguration(const RadioTowerConfiguration &that) : afrl::cmasi::EntityConfiguration(that)
+   {
+        __Position = that.__Position == nullptr ? nullptr : that.__Position->clone();
+        __Range = that.__Range;
+        __Enabled = that.__Enabled;
+
+   }
+   
+   RadioTowerConfiguration & RadioTowerConfiguration::operator=(const RadioTowerConfiguration &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::EntityConfiguration::operator=(that);
+         if (__Position != nullptr) delete __Position;
+
+         __Position = that.__Position == nullptr ? nullptr : that.__Position->clone();
+         __Range = that.__Range;
+         __Enabled = that.__Enabled;
+
+      }
+      return *this;
+   }
+
+   RadioTowerConfiguration* RadioTowerConfiguration::clone() const
+   {
+        return new RadioTowerConfiguration(*this);
+   }
+   
+   RadioTowerConfiguration::~RadioTowerConfiguration(void)
+   {
+      if (__Position != nullptr) delete __Position;
+
+   }
+  
+   void RadioTowerConfiguration::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::EntityConfiguration::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Position, buf);
+      buf.putFloat(__Range);
+      buf.putBool(__Enabled);
+
+   }
+   
+   void RadioTowerConfiguration::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::EntityConfiguration::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__Position != nullptr) delete __Position;
+         __Position = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Position = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Position != nullptr) __Position->unpack(buf);
+         }
+      }
+      __Range = buf.getFloat();
+      __Enabled = buf.getBool();
+
+   }
+
+   uint32_t RadioTowerConfiguration::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::EntityConfiguration::calculatePackedSize();
+      size += (__Position != nullptr ? __Position->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string RadioTowerConfiguration::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RadioTowerConfiguration ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ID (int64_t) = " << __ID << "\n";
+      oss << indent << "Affiliation (std::string) = " << __Affiliation << "\n";
+      oss << indent << "EntityType (std::string) = " << __EntityType << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "NominalSpeed (float) = " << __NominalSpeed << "\n";
+      oss << indent << "NominalAltitude (float) = " << __NominalAltitude << "\n";
+      oss << indent << "NominalAltitudeType (AltitudeType) = " << __NominalAltitudeType << "\n";
+      oss << indent << "PayloadConfigurationList (PayloadConfiguration [ " << __PayloadConfigurationList.size() << ", var ])\n";
+      oss << indent << "Info (KeyValuePair [ " << __Info.size() << ", var ])\n";
+
+      oss << indent << "Position (Location3D)";
+      if (__Position == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "Range (float) = " << __Range << "\n";
+      oss << indent << "Enabled (bool) = " << __Enabled << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RadioTowerConfiguration::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RadioTowerConfiguration Series=\"IMPACT\">\n";
+      if (__Position != nullptr)
+      {
+         str << ws << "   <Position>";
+         str << "\n" + __Position->toXML(depth + 1) + ws + "   ";
+         str << "</Position>\n";
+      }
+      str << ws << "   <Range>" << __Range << "</Range>\n";
+      str << ws << "   <Enabled>" << (__Enabled ? "true" : "false") << "</Enabled>\n";
+      str << ws << "   <ID>" << __ID << "</ID>\n";
+      str << ws << "   <Affiliation>" << __Affiliation << "</Affiliation>\n";
+      str << ws << "   <EntityType>" << __EntityType << "</EntityType>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <NominalSpeed>" << __NominalSpeed << "</NominalSpeed>\n";
+      str << ws << "   <NominalAltitude>" << __NominalAltitude << "</NominalAltitude>\n";
+      str << ws << "   <NominalAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__NominalAltitudeType) << "</NominalAltitudeType>\n";
+      str << ws << "   <PayloadConfigurationList>\n";
+      for (size_t i=0; i<__PayloadConfigurationList.size(); i++)
+      {
+         str << (__PayloadConfigurationList[i] == nullptr ? ( ws + "   <null/>\n") : (__PayloadConfigurationList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PayloadConfigurationList>\n";
+      str << ws << "   <Info>\n";
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         str << (__Info[i] == nullptr ? ( ws + "   <null/>\n") : (__Info[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Info>\n";
+      str << ws << "</RadioTowerConfiguration>\n";
+
+      return str.str();
+   }
+
+   bool RadioTowerConfiguration::operator==(const RadioTowerConfiguration & that)
+   {
+      if( afrl::cmasi::EntityConfiguration::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Position && that.__Position)
+      {
+         if(__Position->getSeriesNameAsLong() != that.__Position->getSeriesNameAsLong()) return false;
+         if(__Position->getSeriesVersion() != that.__Position->getSeriesVersion()) return false;
+         if(__Position->getLmcpType() != that.__Position->getLmcpType()) return false;
+         if( *(__Position) != *(that.__Position) ) return false;
+      }
+      else if(__Position != that.__Position) return false;
+      if(__Range != that.__Range) return false;
+      if(__Enabled != that.__Enabled) return false;
+      return true;
+
+   }
+
+   bool RadioTowerConfiguration::operator!=(const RadioTowerConfiguration & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   RadioTowerConfiguration& RadioTowerConfiguration::setPosition(const afrl::cmasi::Location3D* const val)
+   {
+      if (__Position != nullptr) { delete __Position; __Position = nullptr; }
+      if (val != nullptr) { __Position = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   RadioTowerConfiguration& RadioTowerConfiguration::setRange(const float val)
+   {
+      __Range = val;
+      return *this;
+   }
+
+   RadioTowerConfiguration& RadioTowerConfiguration::setEnabled(const bool val)
+   {
+      __Enabled = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactRadioTowerState.cpp b/src/LMCP/afrl/impact/afrlimpactRadioTowerState.cpp
new file mode 100644
index 0000000..7963b09
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactRadioTowerState.cpp
@@ -0,0 +1,237 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/RadioTowerState.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RadioTowerState::Subscription = "afrl.impact.RadioTowerState";
+   const std::string RadioTowerState::TypeName = "RadioTowerState";
+   
+   bool isRadioTowerState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 5) return false;
+      return true;
+   }
+   
+   bool isRadioTowerState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 5) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RadioTowerStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RadioTowerState::RadioTowerState(void) : afrl::cmasi::EntityState()
+   {
+      __Enabled = true;
+
+   }
+     
+   RadioTowerState::RadioTowerState(const RadioTowerState &that) : afrl::cmasi::EntityState(that)
+   {
+        __Enabled = that.__Enabled;
+
+   }
+   
+   RadioTowerState & RadioTowerState::operator=(const RadioTowerState &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::EntityState::operator=(that);
+
+         __Enabled = that.__Enabled;
+
+      }
+      return *this;
+   }
+
+   RadioTowerState* RadioTowerState::clone() const
+   {
+        return new RadioTowerState(*this);
+   }
+   
+   RadioTowerState::~RadioTowerState(void)
+   {
+
+   }
+  
+   void RadioTowerState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::EntityState::pack(buf);
+      // Copy the class into the buffer
+      buf.putBool(__Enabled);
+
+   }
+   
+   void RadioTowerState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::EntityState::unpack(buf);
+      // Copy the buffer into the class
+      __Enabled = buf.getBool();
+
+   }
+
+   uint32_t RadioTowerState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::EntityState::calculatePackedSize();
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string RadioTowerState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RadioTowerState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ID (int64_t) = " << __ID << "\n";
+      oss << indent << "u (float) = " << __u << "\n";
+      oss << indent << "v (float) = " << __v << "\n";
+      oss << indent << "w (float) = " << __w << "\n";
+      oss << indent << "udot (float) = " << __udot << "\n";
+      oss << indent << "vdot (float) = " << __vdot << "\n";
+      oss << indent << "wdot (float) = " << __wdot << "\n";
+      oss << indent << "Heading (float) = " << __Heading << "\n";
+      oss << indent << "Pitch (float) = " << __Pitch << "\n";
+      oss << indent << "Roll (float) = " << __Roll << "\n";
+      oss << indent << "p (float) = " << __p << "\n";
+      oss << indent << "q (float) = " << __q << "\n";
+      oss << indent << "r (float) = " << __r << "\n";
+      oss << indent << "Course (float) = " << __Course << "\n";
+      oss << indent << "Groundspeed (float) = " << __Groundspeed << "\n";
+      oss << indent << "Location (Location3D)";
+      if (__Location == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "EnergyAvailable (float) = " << __EnergyAvailable << "\n";
+      oss << indent << "ActualEnergyRate (float) = " << __ActualEnergyRate << "\n";
+      oss << indent << "PayloadStateList (PayloadState [ " << __PayloadStateList.size() << ", var ])\n";
+      oss << indent << "CurrentWaypoint (int64_t) = " << __CurrentWaypoint << "\n";
+      oss << indent << "CurrentCommand (int64_t) = " << __CurrentCommand << "\n";
+      oss << indent << "Mode (NavigationMode) = " << __Mode << "\n";
+      oss << indent << "AssociatedTasks (int64 [ " << __AssociatedTasks.size() << ", var ])\n";
+      oss << indent << "Time (int64_t) = " << __Time << "\n";
+      oss << indent << "Info (KeyValuePair [ " << __Info.size() << ", var ])\n";
+
+      oss << indent << "Enabled (bool) = " << __Enabled << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RadioTowerState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RadioTowerState Series=\"IMPACT\">\n";
+      str << ws << "   <Enabled>" << (__Enabled ? "true" : "false") << "</Enabled>\n";
+      str << ws << "   <ID>" << __ID << "</ID>\n";
+      str << ws << "   <u>" << __u << "</u>\n";
+      str << ws << "   <v>" << __v << "</v>\n";
+      str << ws << "   <w>" << __w << "</w>\n";
+      str << ws << "   <udot>" << __udot << "</udot>\n";
+      str << ws << "   <vdot>" << __vdot << "</vdot>\n";
+      str << ws << "   <wdot>" << __wdot << "</wdot>\n";
+      str << ws << "   <Heading>" << __Heading << "</Heading>\n";
+      str << ws << "   <Pitch>" << __Pitch << "</Pitch>\n";
+      str << ws << "   <Roll>" << __Roll << "</Roll>\n";
+      str << ws << "   <p>" << __p << "</p>\n";
+      str << ws << "   <q>" << __q << "</q>\n";
+      str << ws << "   <r>" << __r << "</r>\n";
+      str << ws << "   <Course>" << __Course << "</Course>\n";
+      str << ws << "   <Groundspeed>" << __Groundspeed << "</Groundspeed>\n";
+      if (__Location != nullptr)
+      {
+         str << ws << "   <Location>";
+         str << "\n" + __Location->toXML(depth + 1) + ws + "   ";
+         str << "</Location>\n";
+      }
+      str << ws << "   <EnergyAvailable>" << __EnergyAvailable << "</EnergyAvailable>\n";
+      str << ws << "   <ActualEnergyRate>" << __ActualEnergyRate << "</ActualEnergyRate>\n";
+      str << ws << "   <PayloadStateList>\n";
+      for (size_t i=0; i<__PayloadStateList.size(); i++)
+      {
+         str << (__PayloadStateList[i] == nullptr ? ( ws + "   <null/>\n") : (__PayloadStateList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PayloadStateList>\n";
+      str << ws << "   <CurrentWaypoint>" << __CurrentWaypoint << "</CurrentWaypoint>\n";
+      str << ws << "   <CurrentCommand>" << __CurrentCommand << "</CurrentCommand>\n";
+      str << ws << "   <Mode>" << afrl::cmasi::NavigationMode::get_string(__Mode) << "</Mode>\n";
+      str << ws << "   <AssociatedTasks>\n";
+      for (size_t i=0; i<__AssociatedTasks.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTasks[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTasks>\n";
+      str << ws << "   <Time>" << __Time << "</Time>\n";
+      str << ws << "   <Info>\n";
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         str << (__Info[i] == nullptr ? ( ws + "   <null/>\n") : (__Info[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Info>\n";
+      str << ws << "</RadioTowerState>\n";
+
+      return str.str();
+   }
+
+   bool RadioTowerState::operator==(const RadioTowerState & that)
+   {
+      if( afrl::cmasi::EntityState::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Enabled != that.__Enabled) return false;
+      return true;
+
+   }
+
+   bool RadioTowerState::operator!=(const RadioTowerState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   RadioTowerState& RadioTowerState::setEnabled(const bool val)
+   {
+      __Enabled = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactSpeedAltPair.cpp b/src/LMCP/afrl/impact/afrlimpactSpeedAltPair.cpp
new file mode 100644
index 0000000..7892b72
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactSpeedAltPair.cpp
@@ -0,0 +1,208 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/SpeedAltPair.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string SpeedAltPair::Subscription = "afrl.impact.SpeedAltPair";
+   const std::string SpeedAltPair::TypeName = "SpeedAltPair";
+   
+   bool isSpeedAltPair(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 19) return false;
+      return true;
+   }
+   
+   bool isSpeedAltPair(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 19) return false;
+      return true;
+   }
+   
+   std::vector< std::string > SpeedAltPairDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   SpeedAltPair::SpeedAltPair(void) : avtas::lmcp::Object()
+   {
+      __VehicleID = 0LL;
+      __Speed = 0.f;
+      __Altitude = 0.f;
+      __AltitudeType = afrl::cmasi::AltitudeType::AGL;
+
+   }
+     
+   SpeedAltPair::SpeedAltPair(const SpeedAltPair &that) : avtas::lmcp::Object(that)
+   {
+        __VehicleID = that.__VehicleID;
+        __Speed = that.__Speed;
+        __Altitude = that.__Altitude;
+        __AltitudeType = that.__AltitudeType;
+
+   }
+   
+   SpeedAltPair & SpeedAltPair::operator=(const SpeedAltPair &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __VehicleID = that.__VehicleID;
+         __Speed = that.__Speed;
+         __Altitude = that.__Altitude;
+         __AltitudeType = that.__AltitudeType;
+
+      }
+      return *this;
+   }
+
+   SpeedAltPair* SpeedAltPair::clone() const
+   {
+        return new SpeedAltPair(*this);
+   }
+   
+   SpeedAltPair::~SpeedAltPair(void)
+   {
+
+   }
+  
+   void SpeedAltPair::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__VehicleID);
+      buf.putFloat(__Speed);
+      buf.putFloat(__Altitude);
+      buf.putInt( (int32_t) __AltitudeType);
+
+   }
+   
+   void SpeedAltPair::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __VehicleID = buf.getLong();
+      __Speed = buf.getFloat();
+      __Altitude = buf.getFloat();
+      __AltitudeType = (afrl::cmasi::AltitudeType::AltitudeType) buf.getInt();
+
+   }
+
+   uint32_t SpeedAltPair::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::AltitudeType::AltitudeType);
+
+      return size;
+   }
+
+   std::string SpeedAltPair::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( SpeedAltPair ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "Speed (float) = " << __Speed << "\n";
+      oss << indent << "Altitude (float) = " << __Altitude << "\n";
+      oss << indent << "AltitudeType (AltitudeType) = " << __AltitudeType << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string SpeedAltPair::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<SpeedAltPair Series=\"IMPACT\">\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <Speed>" << __Speed << "</Speed>\n";
+      str << ws << "   <Altitude>" << __Altitude << "</Altitude>\n";
+      str << ws << "   <AltitudeType>" << afrl::cmasi::AltitudeType::get_string(__AltitudeType) << "</AltitudeType>\n";
+      str << ws << "</SpeedAltPair>\n";
+
+      return str.str();
+   }
+
+   bool SpeedAltPair::operator==(const SpeedAltPair & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__Speed != that.__Speed) return false;
+      if(__Altitude != that.__Altitude) return false;
+      if(__AltitudeType != that.__AltitudeType) return false;
+      return true;
+
+   }
+
+   bool SpeedAltPair::operator!=(const SpeedAltPair & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   SpeedAltPair& SpeedAltPair::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+   SpeedAltPair& SpeedAltPair::setSpeed(const float val)
+   {
+      __Speed = val;
+      return *this;
+   }
+
+   SpeedAltPair& SpeedAltPair::setAltitude(const float val)
+   {
+      __Altitude = val;
+      return *this;
+   }
+
+   SpeedAltPair& SpeedAltPair::setAltitudeType(const afrl::cmasi::AltitudeType::AltitudeType val)
+   {
+      __AltitudeType = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactSurfaceVehicleConfiguration.cpp b/src/LMCP/afrl/impact/afrlimpactSurfaceVehicleConfiguration.cpp
new file mode 100644
index 0000000..9db5530
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactSurfaceVehicleConfiguration.cpp
@@ -0,0 +1,267 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/SurfaceVehicleConfiguration.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string SurfaceVehicleConfiguration::Subscription = "afrl.impact.SurfaceVehicleConfiguration";
+   const std::string SurfaceVehicleConfiguration::TypeName = "SurfaceVehicleConfiguration";
+   
+   bool isSurfaceVehicleConfiguration(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 40) return false;
+      return true;
+   }
+   
+   bool isSurfaceVehicleConfiguration(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 40) return false;
+      return true;
+   }
+   
+   std::vector< std::string > SurfaceVehicleConfigurationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   SurfaceVehicleConfiguration::SurfaceVehicleConfiguration(void) : afrl::cmasi::EntityConfiguration()
+   {
+      __WaterArea = 0LL;
+      __MinimumSpeed = 0.f;
+      __MaximumSpeed = 0.f;
+      __EnergyRate = 0.f;
+      __MaxBankAngle = 0.f;
+      __MaxBankRate = 0.f;
+
+   }
+     
+   SurfaceVehicleConfiguration::SurfaceVehicleConfiguration(const SurfaceVehicleConfiguration &that) : afrl::cmasi::EntityConfiguration(that)
+   {
+        __WaterArea = that.__WaterArea;
+        __MinimumSpeed = that.__MinimumSpeed;
+        __MaximumSpeed = that.__MaximumSpeed;
+        __EnergyRate = that.__EnergyRate;
+        __MaxBankAngle = that.__MaxBankAngle;
+        __MaxBankRate = that.__MaxBankRate;
+
+   }
+   
+   SurfaceVehicleConfiguration & SurfaceVehicleConfiguration::operator=(const SurfaceVehicleConfiguration &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::EntityConfiguration::operator=(that);
+
+         __WaterArea = that.__WaterArea;
+         __MinimumSpeed = that.__MinimumSpeed;
+         __MaximumSpeed = that.__MaximumSpeed;
+         __EnergyRate = that.__EnergyRate;
+         __MaxBankAngle = that.__MaxBankAngle;
+         __MaxBankRate = that.__MaxBankRate;
+
+      }
+      return *this;
+   }
+
+   SurfaceVehicleConfiguration* SurfaceVehicleConfiguration::clone() const
+   {
+        return new SurfaceVehicleConfiguration(*this);
+   }
+   
+   SurfaceVehicleConfiguration::~SurfaceVehicleConfiguration(void)
+   {
+
+   }
+  
+   void SurfaceVehicleConfiguration::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::EntityConfiguration::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__WaterArea);
+      buf.putFloat(__MinimumSpeed);
+      buf.putFloat(__MaximumSpeed);
+      buf.putFloat(__EnergyRate);
+      buf.putFloat(__MaxBankAngle);
+      buf.putFloat(__MaxBankRate);
+
+   }
+   
+   void SurfaceVehicleConfiguration::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::EntityConfiguration::unpack(buf);
+      // Copy the buffer into the class
+      __WaterArea = buf.getLong();
+      __MinimumSpeed = buf.getFloat();
+      __MaximumSpeed = buf.getFloat();
+      __EnergyRate = buf.getFloat();
+      __MaxBankAngle = buf.getFloat();
+      __MaxBankRate = buf.getFloat();
+
+   }
+
+   uint32_t SurfaceVehicleConfiguration::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::EntityConfiguration::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string SurfaceVehicleConfiguration::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( SurfaceVehicleConfiguration ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ID (int64_t) = " << __ID << "\n";
+      oss << indent << "Affiliation (std::string) = " << __Affiliation << "\n";
+      oss << indent << "EntityType (std::string) = " << __EntityType << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "NominalSpeed (float) = " << __NominalSpeed << "\n";
+      oss << indent << "NominalAltitude (float) = " << __NominalAltitude << "\n";
+      oss << indent << "NominalAltitudeType (AltitudeType) = " << __NominalAltitudeType << "\n";
+      oss << indent << "PayloadConfigurationList (PayloadConfiguration [ " << __PayloadConfigurationList.size() << ", var ])\n";
+      oss << indent << "Info (KeyValuePair [ " << __Info.size() << ", var ])\n";
+
+      oss << indent << "WaterArea (int64_t) = " << __WaterArea << "\n";
+      oss << indent << "MinimumSpeed (float) = " << __MinimumSpeed << "\n";
+      oss << indent << "MaximumSpeed (float) = " << __MaximumSpeed << "\n";
+      oss << indent << "EnergyRate (float) = " << __EnergyRate << "\n";
+      oss << indent << "MaxBankAngle (float) = " << __MaxBankAngle << "\n";
+      oss << indent << "MaxBankRate (float) = " << __MaxBankRate << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string SurfaceVehicleConfiguration::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<SurfaceVehicleConfiguration Series=\"IMPACT\">\n";
+      str << ws << "   <WaterArea>" << __WaterArea << "</WaterArea>\n";
+      str << ws << "   <MinimumSpeed>" << __MinimumSpeed << "</MinimumSpeed>\n";
+      str << ws << "   <MaximumSpeed>" << __MaximumSpeed << "</MaximumSpeed>\n";
+      str << ws << "   <EnergyRate>" << __EnergyRate << "</EnergyRate>\n";
+      str << ws << "   <MaxBankAngle>" << __MaxBankAngle << "</MaxBankAngle>\n";
+      str << ws << "   <MaxBankRate>" << __MaxBankRate << "</MaxBankRate>\n";
+      str << ws << "   <ID>" << __ID << "</ID>\n";
+      str << ws << "   <Affiliation>" << __Affiliation << "</Affiliation>\n";
+      str << ws << "   <EntityType>" << __EntityType << "</EntityType>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <NominalSpeed>" << __NominalSpeed << "</NominalSpeed>\n";
+      str << ws << "   <NominalAltitude>" << __NominalAltitude << "</NominalAltitude>\n";
+      str << ws << "   <NominalAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__NominalAltitudeType) << "</NominalAltitudeType>\n";
+      str << ws << "   <PayloadConfigurationList>\n";
+      for (size_t i=0; i<__PayloadConfigurationList.size(); i++)
+      {
+         str << (__PayloadConfigurationList[i] == nullptr ? ( ws + "   <null/>\n") : (__PayloadConfigurationList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PayloadConfigurationList>\n";
+      str << ws << "   <Info>\n";
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         str << (__Info[i] == nullptr ? ( ws + "   <null/>\n") : (__Info[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Info>\n";
+      str << ws << "</SurfaceVehicleConfiguration>\n";
+
+      return str.str();
+   }
+
+   bool SurfaceVehicleConfiguration::operator==(const SurfaceVehicleConfiguration & that)
+   {
+      if( afrl::cmasi::EntityConfiguration::operator!=(that) )
+      {
+          return false;
+      }
+      if(__WaterArea != that.__WaterArea) return false;
+      if(__MinimumSpeed != that.__MinimumSpeed) return false;
+      if(__MaximumSpeed != that.__MaximumSpeed) return false;
+      if(__EnergyRate != that.__EnergyRate) return false;
+      if(__MaxBankAngle != that.__MaxBankAngle) return false;
+      if(__MaxBankRate != that.__MaxBankRate) return false;
+      return true;
+
+   }
+
+   bool SurfaceVehicleConfiguration::operator!=(const SurfaceVehicleConfiguration & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   SurfaceVehicleConfiguration& SurfaceVehicleConfiguration::setWaterArea(const int64_t val)
+   {
+      __WaterArea = val;
+      return *this;
+   }
+
+   SurfaceVehicleConfiguration& SurfaceVehicleConfiguration::setMinimumSpeed(const float val)
+   {
+      __MinimumSpeed = val;
+      return *this;
+   }
+
+   SurfaceVehicleConfiguration& SurfaceVehicleConfiguration::setMaximumSpeed(const float val)
+   {
+      __MaximumSpeed = val;
+      return *this;
+   }
+
+   SurfaceVehicleConfiguration& SurfaceVehicleConfiguration::setEnergyRate(const float val)
+   {
+      __EnergyRate = val;
+      return *this;
+   }
+
+   SurfaceVehicleConfiguration& SurfaceVehicleConfiguration::setMaxBankAngle(const float val)
+   {
+      __MaxBankAngle = val;
+      return *this;
+   }
+
+   SurfaceVehicleConfiguration& SurfaceVehicleConfiguration::setMaxBankRate(const float val)
+   {
+      __MaxBankRate = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactSurfaceVehicleState.cpp b/src/LMCP/afrl/impact/afrlimpactSurfaceVehicleState.cpp
new file mode 100644
index 0000000..f4c964e
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactSurfaceVehicleState.cpp
@@ -0,0 +1,252 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/SurfaceVehicleState.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string SurfaceVehicleState::Subscription = "afrl.impact.SurfaceVehicleState";
+   const std::string SurfaceVehicleState::TypeName = "SurfaceVehicleState";
+   
+   bool isSurfaceVehicleState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 41) return false;
+      return true;
+   }
+   
+   bool isSurfaceVehicleState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 41) return false;
+      return true;
+   }
+   
+   std::vector< std::string > SurfaceVehicleStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   SurfaceVehicleState::SurfaceVehicleState(void) : afrl::cmasi::EntityState()
+   {
+      __BankAngle = 0.f;
+      __Speed = 0.f;
+
+   }
+     
+   SurfaceVehicleState::SurfaceVehicleState(const SurfaceVehicleState &that) : afrl::cmasi::EntityState(that)
+   {
+        __BankAngle = that.__BankAngle;
+        __Speed = that.__Speed;
+
+   }
+   
+   SurfaceVehicleState & SurfaceVehicleState::operator=(const SurfaceVehicleState &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::EntityState::operator=(that);
+
+         __BankAngle = that.__BankAngle;
+         __Speed = that.__Speed;
+
+      }
+      return *this;
+   }
+
+   SurfaceVehicleState* SurfaceVehicleState::clone() const
+   {
+        return new SurfaceVehicleState(*this);
+   }
+   
+   SurfaceVehicleState::~SurfaceVehicleState(void)
+   {
+
+   }
+  
+   void SurfaceVehicleState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::EntityState::pack(buf);
+      // Copy the class into the buffer
+      buf.putFloat(__BankAngle);
+      buf.putFloat(__Speed);
+
+   }
+   
+   void SurfaceVehicleState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::EntityState::unpack(buf);
+      // Copy the buffer into the class
+      __BankAngle = buf.getFloat();
+      __Speed = buf.getFloat();
+
+   }
+
+   uint32_t SurfaceVehicleState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::EntityState::calculatePackedSize();
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string SurfaceVehicleState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( SurfaceVehicleState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ID (int64_t) = " << __ID << "\n";
+      oss << indent << "u (float) = " << __u << "\n";
+      oss << indent << "v (float) = " << __v << "\n";
+      oss << indent << "w (float) = " << __w << "\n";
+      oss << indent << "udot (float) = " << __udot << "\n";
+      oss << indent << "vdot (float) = " << __vdot << "\n";
+      oss << indent << "wdot (float) = " << __wdot << "\n";
+      oss << indent << "Heading (float) = " << __Heading << "\n";
+      oss << indent << "Pitch (float) = " << __Pitch << "\n";
+      oss << indent << "Roll (float) = " << __Roll << "\n";
+      oss << indent << "p (float) = " << __p << "\n";
+      oss << indent << "q (float) = " << __q << "\n";
+      oss << indent << "r (float) = " << __r << "\n";
+      oss << indent << "Course (float) = " << __Course << "\n";
+      oss << indent << "Groundspeed (float) = " << __Groundspeed << "\n";
+      oss << indent << "Location (Location3D)";
+      if (__Location == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "EnergyAvailable (float) = " << __EnergyAvailable << "\n";
+      oss << indent << "ActualEnergyRate (float) = " << __ActualEnergyRate << "\n";
+      oss << indent << "PayloadStateList (PayloadState [ " << __PayloadStateList.size() << ", var ])\n";
+      oss << indent << "CurrentWaypoint (int64_t) = " << __CurrentWaypoint << "\n";
+      oss << indent << "CurrentCommand (int64_t) = " << __CurrentCommand << "\n";
+      oss << indent << "Mode (NavigationMode) = " << __Mode << "\n";
+      oss << indent << "AssociatedTasks (int64 [ " << __AssociatedTasks.size() << ", var ])\n";
+      oss << indent << "Time (int64_t) = " << __Time << "\n";
+      oss << indent << "Info (KeyValuePair [ " << __Info.size() << ", var ])\n";
+
+      oss << indent << "BankAngle (float) = " << __BankAngle << "\n";
+      oss << indent << "Speed (float) = " << __Speed << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string SurfaceVehicleState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<SurfaceVehicleState Series=\"IMPACT\">\n";
+      str << ws << "   <BankAngle>" << __BankAngle << "</BankAngle>\n";
+      str << ws << "   <Speed>" << __Speed << "</Speed>\n";
+      str << ws << "   <ID>" << __ID << "</ID>\n";
+      str << ws << "   <u>" << __u << "</u>\n";
+      str << ws << "   <v>" << __v << "</v>\n";
+      str << ws << "   <w>" << __w << "</w>\n";
+      str << ws << "   <udot>" << __udot << "</udot>\n";
+      str << ws << "   <vdot>" << __vdot << "</vdot>\n";
+      str << ws << "   <wdot>" << __wdot << "</wdot>\n";
+      str << ws << "   <Heading>" << __Heading << "</Heading>\n";
+      str << ws << "   <Pitch>" << __Pitch << "</Pitch>\n";
+      str << ws << "   <Roll>" << __Roll << "</Roll>\n";
+      str << ws << "   <p>" << __p << "</p>\n";
+      str << ws << "   <q>" << __q << "</q>\n";
+      str << ws << "   <r>" << __r << "</r>\n";
+      str << ws << "   <Course>" << __Course << "</Course>\n";
+      str << ws << "   <Groundspeed>" << __Groundspeed << "</Groundspeed>\n";
+      if (__Location != nullptr)
+      {
+         str << ws << "   <Location>";
+         str << "\n" + __Location->toXML(depth + 1) + ws + "   ";
+         str << "</Location>\n";
+      }
+      str << ws << "   <EnergyAvailable>" << __EnergyAvailable << "</EnergyAvailable>\n";
+      str << ws << "   <ActualEnergyRate>" << __ActualEnergyRate << "</ActualEnergyRate>\n";
+      str << ws << "   <PayloadStateList>\n";
+      for (size_t i=0; i<__PayloadStateList.size(); i++)
+      {
+         str << (__PayloadStateList[i] == nullptr ? ( ws + "   <null/>\n") : (__PayloadStateList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PayloadStateList>\n";
+      str << ws << "   <CurrentWaypoint>" << __CurrentWaypoint << "</CurrentWaypoint>\n";
+      str << ws << "   <CurrentCommand>" << __CurrentCommand << "</CurrentCommand>\n";
+      str << ws << "   <Mode>" << afrl::cmasi::NavigationMode::get_string(__Mode) << "</Mode>\n";
+      str << ws << "   <AssociatedTasks>\n";
+      for (size_t i=0; i<__AssociatedTasks.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedTasks[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedTasks>\n";
+      str << ws << "   <Time>" << __Time << "</Time>\n";
+      str << ws << "   <Info>\n";
+      for (size_t i=0; i<__Info.size(); i++)
+      {
+         str << (__Info[i] == nullptr ? ( ws + "   <null/>\n") : (__Info[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Info>\n";
+      str << ws << "</SurfaceVehicleState>\n";
+
+      return str.str();
+   }
+
+   bool SurfaceVehicleState::operator==(const SurfaceVehicleState & that)
+   {
+      if( afrl::cmasi::EntityState::operator!=(that) )
+      {
+          return false;
+      }
+      if(__BankAngle != that.__BankAngle) return false;
+      if(__Speed != that.__Speed) return false;
+      return true;
+
+   }
+
+   bool SurfaceVehicleState::operator!=(const SurfaceVehicleState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   SurfaceVehicleState& SurfaceVehicleState::setBankAngle(const float val)
+   {
+      __BankAngle = val;
+      return *this;
+   }
+
+   SurfaceVehicleState& SurfaceVehicleState::setSpeed(const float val)
+   {
+      __Speed = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactTaskSummary.cpp b/src/LMCP/afrl/impact/afrlimpactTaskSummary.cpp
new file mode 100644
index 0000000..183a88c
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactTaskSummary.cpp
@@ -0,0 +1,249 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/TaskSummary.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskSummary::Subscription = "afrl.impact.TaskSummary";
+   const std::string TaskSummary::TypeName = "TaskSummary";
+   
+   bool isTaskSummary(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 14) return false;
+      return true;
+   }
+   
+   bool isTaskSummary(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 14) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskSummaryDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskSummary::TaskSummary(void) : avtas::lmcp::Object()
+   {
+      __TaskID = 0LL;
+      __BestEffort = 100.0f;
+
+   }
+     
+   TaskSummary::TaskSummary(const TaskSummary &that) : avtas::lmcp::Object(that)
+   {
+        __TaskID = that.__TaskID;
+        __PerformingVehicles.clear();
+        for (size_t i=0; i< that.__PerformingVehicles.size(); i++)
+        {
+           __PerformingVehicles.push_back( that.__PerformingVehicles[i] == nullptr ? nullptr : that.__PerformingVehicles[i]->clone());
+        }
+        __BestEffort = that.__BestEffort;
+
+   }
+   
+   TaskSummary & TaskSummary::operator=(const TaskSummary &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__PerformingVehicles.size(); i++)
+         {
+            if (__PerformingVehicles[i] != nullptr) delete __PerformingVehicles[i];
+         }
+
+         __TaskID = that.__TaskID;
+         __PerformingVehicles.clear();
+         for (size_t i=0; i< that.__PerformingVehicles.size(); i++)
+         {
+            __PerformingVehicles.push_back( that.__PerformingVehicles[i] == nullptr ? nullptr : that.__PerformingVehicles[i]->clone());
+         }
+         __BestEffort = that.__BestEffort;
+
+      }
+      return *this;
+   }
+
+   TaskSummary* TaskSummary::clone() const
+   {
+        return new TaskSummary(*this);
+   }
+   
+   TaskSummary::~TaskSummary(void)
+   {
+      for (size_t i=0; i<__PerformingVehicles.size(); i++)
+      {
+         if (__PerformingVehicles[i] != nullptr) delete __PerformingVehicles[i];
+      }
+
+   }
+  
+   void TaskSummary::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__TaskID);
+      buf.putUShort( static_cast<uint16_t>(__PerformingVehicles.size()));
+      for (size_t i=0; i<__PerformingVehicles.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __PerformingVehicles[i], buf);
+      }
+      buf.putFloat(__BestEffort);
+
+   }
+   
+   void TaskSummary::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __TaskID = buf.getLong();
+      for (size_t i=0; i<__PerformingVehicles.size(); i++)
+      {
+         if (__PerformingVehicles[i] != nullptr)
+            delete __PerformingVehicles[i];
+      }
+      __PerformingVehicles.clear();
+      uint16_t __PerformingVehicles_length = buf.getUShort();
+      for (uint32_t i=0; i< __PerformingVehicles_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::impact::VehicleSummary* e = (afrl::impact::VehicleSummary*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __PerformingVehicles.push_back(e);
+         }
+      }
+      __BestEffort = buf.getFloat();
+
+   }
+
+   uint32_t TaskSummary::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__PerformingVehicles.size(); i++)
+      {
+         if (__PerformingVehicles[i] != nullptr)
+         {
+            size += __PerformingVehicles[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string TaskSummary::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskSummary ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "PerformingVehicles (VehicleSummary [ " << __PerformingVehicles.size() << ", var ])\n";
+      oss << indent << "BestEffort (float) = " << __BestEffort << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskSummary::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskSummary Series=\"IMPACT\">\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <PerformingVehicles>\n";
+      for (size_t i=0; i<__PerformingVehicles.size(); i++)
+      {
+         str << (__PerformingVehicles[i] == nullptr ? ( ws + "   <null/>\n") : (__PerformingVehicles[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PerformingVehicles>\n";
+      str << ws << "   <BestEffort>" << __BestEffort << "</BestEffort>\n";
+      str << ws << "</TaskSummary>\n";
+
+      return str.str();
+   }
+
+   bool TaskSummary::operator==(const TaskSummary & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__TaskID != that.__TaskID) return false;
+      if(__PerformingVehicles.size() != that.__PerformingVehicles.size()) return false;
+      for (size_t i=0; i<__PerformingVehicles.size(); i++)
+      {
+         if(__PerformingVehicles[i] && that.__PerformingVehicles[i])
+         {
+            if(__PerformingVehicles[i]->getSeriesNameAsLong() != that.__PerformingVehicles[i]->getSeriesNameAsLong()) return false;
+            if(__PerformingVehicles[i]->getSeriesVersion() != that.__PerformingVehicles[i]->getSeriesVersion()) return false;
+            if(__PerformingVehicles[i]->getLmcpType() != that.__PerformingVehicles[i]->getLmcpType()) return false;
+            if( *(__PerformingVehicles[i]) != *(that.__PerformingVehicles[i]) ) return false;
+         }
+         else if(__PerformingVehicles[i] != that.__PerformingVehicles[i]) return false;
+      }
+      if(__BestEffort != that.__BestEffort) return false;
+      return true;
+
+   }
+
+   bool TaskSummary::operator!=(const TaskSummary & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskSummary& TaskSummary::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+
+   TaskSummary& TaskSummary::setBestEffort(const float val)
+   {
+      __BestEffort = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactTaskTimingPair.cpp b/src/LMCP/afrl/impact/afrlimpactTaskTimingPair.cpp
new file mode 100644
index 0000000..8f07994
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactTaskTimingPair.cpp
@@ -0,0 +1,223 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/TaskTimingPair.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskTimingPair::Subscription = "afrl.impact.TaskTimingPair";
+   const std::string TaskTimingPair::TypeName = "TaskTimingPair";
+   
+   bool isTaskTimingPair(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 11) return false;
+      return true;
+   }
+   
+   bool isTaskTimingPair(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 11) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskTimingPairDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskTimingPair::TaskTimingPair(void) : avtas::lmcp::Object()
+   {
+      __VehicleID = 0LL;
+      __InitialTaskID = 0LL;
+      __InitialTaskPercentage = 0.f;
+      __DestinationTaskID = 0LL;
+      __TimeToGo = 0LL;
+
+   }
+     
+   TaskTimingPair::TaskTimingPair(const TaskTimingPair &that) : avtas::lmcp::Object(that)
+   {
+        __VehicleID = that.__VehicleID;
+        __InitialTaskID = that.__InitialTaskID;
+        __InitialTaskPercentage = that.__InitialTaskPercentage;
+        __DestinationTaskID = that.__DestinationTaskID;
+        __TimeToGo = that.__TimeToGo;
+
+   }
+   
+   TaskTimingPair & TaskTimingPair::operator=(const TaskTimingPair &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __VehicleID = that.__VehicleID;
+         __InitialTaskID = that.__InitialTaskID;
+         __InitialTaskPercentage = that.__InitialTaskPercentage;
+         __DestinationTaskID = that.__DestinationTaskID;
+         __TimeToGo = that.__TimeToGo;
+
+      }
+      return *this;
+   }
+
+   TaskTimingPair* TaskTimingPair::clone() const
+   {
+        return new TaskTimingPair(*this);
+   }
+   
+   TaskTimingPair::~TaskTimingPair(void)
+   {
+
+   }
+  
+   void TaskTimingPair::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__VehicleID);
+      buf.putLong(__InitialTaskID);
+      buf.putFloat(__InitialTaskPercentage);
+      buf.putLong(__DestinationTaskID);
+      buf.putLong(__TimeToGo);
+
+   }
+   
+   void TaskTimingPair::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __VehicleID = buf.getLong();
+      __InitialTaskID = buf.getLong();
+      __InitialTaskPercentage = buf.getFloat();
+      __DestinationTaskID = buf.getLong();
+      __TimeToGo = buf.getLong();
+
+   }
+
+   uint32_t TaskTimingPair::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string TaskTimingPair::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskTimingPair ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "InitialTaskID (int64_t) = " << __InitialTaskID << "\n";
+      oss << indent << "InitialTaskPercentage (float) = " << __InitialTaskPercentage << "\n";
+      oss << indent << "DestinationTaskID (int64_t) = " << __DestinationTaskID << "\n";
+      oss << indent << "TimeToGo (int64_t) = " << __TimeToGo << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskTimingPair::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskTimingPair Series=\"IMPACT\">\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <InitialTaskID>" << __InitialTaskID << "</InitialTaskID>\n";
+      str << ws << "   <InitialTaskPercentage>" << __InitialTaskPercentage << "</InitialTaskPercentage>\n";
+      str << ws << "   <DestinationTaskID>" << __DestinationTaskID << "</DestinationTaskID>\n";
+      str << ws << "   <TimeToGo>" << __TimeToGo << "</TimeToGo>\n";
+      str << ws << "</TaskTimingPair>\n";
+
+      return str.str();
+   }
+
+   bool TaskTimingPair::operator==(const TaskTimingPair & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__InitialTaskID != that.__InitialTaskID) return false;
+      if(__InitialTaskPercentage != that.__InitialTaskPercentage) return false;
+      if(__DestinationTaskID != that.__DestinationTaskID) return false;
+      if(__TimeToGo != that.__TimeToGo) return false;
+      return true;
+
+   }
+
+   bool TaskTimingPair::operator!=(const TaskTimingPair & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskTimingPair& TaskTimingPair::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+   TaskTimingPair& TaskTimingPair::setInitialTaskID(const int64_t val)
+   {
+      __InitialTaskID = val;
+      return *this;
+   }
+
+   TaskTimingPair& TaskTimingPair::setInitialTaskPercentage(const float val)
+   {
+      __InitialTaskPercentage = val;
+      return *this;
+   }
+
+   TaskTimingPair& TaskTimingPair::setDestinationTaskID(const int64_t val)
+   {
+      __DestinationTaskID = val;
+      return *this;
+   }
+
+   TaskTimingPair& TaskTimingPair::setTimeToGo(const int64_t val)
+   {
+      __TimeToGo = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactVehicleSummary.cpp b/src/LMCP/afrl/impact/afrlimpactVehicleSummary.cpp
new file mode 100644
index 0000000..77f0a42
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactVehicleSummary.cpp
@@ -0,0 +1,283 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/VehicleSummary.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string VehicleSummary::Subscription = "afrl.impact.VehicleSummary";
+   const std::string VehicleSummary::TypeName = "VehicleSummary";
+   
+   bool isVehicleSummary(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 15) return false;
+      return true;
+   }
+   
+   bool isVehicleSummary(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 15) return false;
+      return true;
+   }
+   
+   std::vector< std::string > VehicleSummaryDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   VehicleSummary::VehicleSummary(void) : avtas::lmcp::Object()
+   {
+      __VehicleID = 0LL;
+      __DestinationTaskID = 0LL;
+      __InitialTaskID = 0LL;
+      __InitialTaskPercentage = 0.f;
+      __EstimateTimeToTaskPercentage = 0LL;
+      __TimeToArrive = 0LL;
+      __TimeOnTask = 0LL;
+      __EnergyRemaining = 0.f;
+      __BeyondCommRange = false;
+
+   }
+     
+   VehicleSummary::VehicleSummary(const VehicleSummary &that) : avtas::lmcp::Object(that)
+   {
+        __VehicleID = that.__VehicleID;
+        __DestinationTaskID = that.__DestinationTaskID;
+        __InitialTaskID = that.__InitialTaskID;
+        __InitialTaskPercentage = that.__InitialTaskPercentage;
+        __EstimateTimeToTaskPercentage = that.__EstimateTimeToTaskPercentage;
+        __TimeToArrive = that.__TimeToArrive;
+        __TimeOnTask = that.__TimeOnTask;
+        __EnergyRemaining = that.__EnergyRemaining;
+        __BeyondCommRange = that.__BeyondCommRange;
+
+   }
+   
+   VehicleSummary & VehicleSummary::operator=(const VehicleSummary &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __VehicleID = that.__VehicleID;
+         __DestinationTaskID = that.__DestinationTaskID;
+         __InitialTaskID = that.__InitialTaskID;
+         __InitialTaskPercentage = that.__InitialTaskPercentage;
+         __EstimateTimeToTaskPercentage = that.__EstimateTimeToTaskPercentage;
+         __TimeToArrive = that.__TimeToArrive;
+         __TimeOnTask = that.__TimeOnTask;
+         __EnergyRemaining = that.__EnergyRemaining;
+         __BeyondCommRange = that.__BeyondCommRange;
+
+      }
+      return *this;
+   }
+
+   VehicleSummary* VehicleSummary::clone() const
+   {
+        return new VehicleSummary(*this);
+   }
+   
+   VehicleSummary::~VehicleSummary(void)
+   {
+
+   }
+  
+   void VehicleSummary::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__VehicleID);
+      buf.putLong(__DestinationTaskID);
+      buf.putLong(__InitialTaskID);
+      buf.putFloat(__InitialTaskPercentage);
+      buf.putLong(__EstimateTimeToTaskPercentage);
+      buf.putLong(__TimeToArrive);
+      buf.putLong(__TimeOnTask);
+      buf.putFloat(__EnergyRemaining);
+      buf.putBool(__BeyondCommRange);
+
+   }
+   
+   void VehicleSummary::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __VehicleID = buf.getLong();
+      __DestinationTaskID = buf.getLong();
+      __InitialTaskID = buf.getLong();
+      __InitialTaskPercentage = buf.getFloat();
+      __EstimateTimeToTaskPercentage = buf.getLong();
+      __TimeToArrive = buf.getLong();
+      __TimeOnTask = buf.getLong();
+      __EnergyRemaining = buf.getFloat();
+      __BeyondCommRange = buf.getBool();
+
+   }
+
+   uint32_t VehicleSummary::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string VehicleSummary::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( VehicleSummary ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "DestinationTaskID (int64_t) = " << __DestinationTaskID << "\n";
+      oss << indent << "InitialTaskID (int64_t) = " << __InitialTaskID << "\n";
+      oss << indent << "InitialTaskPercentage (float) = " << __InitialTaskPercentage << "\n";
+      oss << indent << "EstimateTimeToTaskPercentage (int64_t) = " << __EstimateTimeToTaskPercentage << "\n";
+      oss << indent << "TimeToArrive (int64_t) = " << __TimeToArrive << "\n";
+      oss << indent << "TimeOnTask (int64_t) = " << __TimeOnTask << "\n";
+      oss << indent << "EnergyRemaining (float) = " << __EnergyRemaining << "\n";
+      oss << indent << "BeyondCommRange (bool) = " << __BeyondCommRange << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string VehicleSummary::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<VehicleSummary Series=\"IMPACT\">\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <DestinationTaskID>" << __DestinationTaskID << "</DestinationTaskID>\n";
+      str << ws << "   <InitialTaskID>" << __InitialTaskID << "</InitialTaskID>\n";
+      str << ws << "   <InitialTaskPercentage>" << __InitialTaskPercentage << "</InitialTaskPercentage>\n";
+      str << ws << "   <EstimateTimeToTaskPercentage>" << __EstimateTimeToTaskPercentage << "</EstimateTimeToTaskPercentage>\n";
+      str << ws << "   <TimeToArrive>" << __TimeToArrive << "</TimeToArrive>\n";
+      str << ws << "   <TimeOnTask>" << __TimeOnTask << "</TimeOnTask>\n";
+      str << ws << "   <EnergyRemaining>" << __EnergyRemaining << "</EnergyRemaining>\n";
+      str << ws << "   <BeyondCommRange>" << (__BeyondCommRange ? "true" : "false") << "</BeyondCommRange>\n";
+      str << ws << "</VehicleSummary>\n";
+
+      return str.str();
+   }
+
+   bool VehicleSummary::operator==(const VehicleSummary & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__DestinationTaskID != that.__DestinationTaskID) return false;
+      if(__InitialTaskID != that.__InitialTaskID) return false;
+      if(__InitialTaskPercentage != that.__InitialTaskPercentage) return false;
+      if(__EstimateTimeToTaskPercentage != that.__EstimateTimeToTaskPercentage) return false;
+      if(__TimeToArrive != that.__TimeToArrive) return false;
+      if(__TimeOnTask != that.__TimeOnTask) return false;
+      if(__EnergyRemaining != that.__EnergyRemaining) return false;
+      if(__BeyondCommRange != that.__BeyondCommRange) return false;
+      return true;
+
+   }
+
+   bool VehicleSummary::operator!=(const VehicleSummary & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   VehicleSummary& VehicleSummary::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+   VehicleSummary& VehicleSummary::setDestinationTaskID(const int64_t val)
+   {
+      __DestinationTaskID = val;
+      return *this;
+   }
+
+   VehicleSummary& VehicleSummary::setInitialTaskID(const int64_t val)
+   {
+      __InitialTaskID = val;
+      return *this;
+   }
+
+   VehicleSummary& VehicleSummary::setInitialTaskPercentage(const float val)
+   {
+      __InitialTaskPercentage = val;
+      return *this;
+   }
+
+   VehicleSummary& VehicleSummary::setEstimateTimeToTaskPercentage(const int64_t val)
+   {
+      __EstimateTimeToTaskPercentage = val;
+      return *this;
+   }
+
+   VehicleSummary& VehicleSummary::setTimeToArrive(const int64_t val)
+   {
+      __TimeToArrive = val;
+      return *this;
+   }
+
+   VehicleSummary& VehicleSummary::setTimeOnTask(const int64_t val)
+   {
+      __TimeOnTask = val;
+      return *this;
+   }
+
+   VehicleSummary& VehicleSummary::setEnergyRemaining(const float val)
+   {
+      __EnergyRemaining = val;
+      return *this;
+   }
+
+   VehicleSummary& VehicleSummary::setBeyondCommRange(const bool val)
+   {
+      __BeyondCommRange = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactWatchTask.cpp b/src/LMCP/afrl/impact/afrlimpactWatchTask.cpp
new file mode 100644
index 0000000..36cabd5
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactWatchTask.cpp
@@ -0,0 +1,200 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/WatchTask.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string WatchTask::Subscription = "afrl.impact.WatchTask";
+   const std::string WatchTask::TypeName = "WatchTask";
+   
+   bool isWatchTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 29) return false;
+      return true;
+   }
+   
+   bool isWatchTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 29) return false;
+      return true;
+   }
+   
+   std::vector< std::string > WatchTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   WatchTask::WatchTask(void) : afrl::cmasi::SearchTask()
+   {
+      __WatchedEntityID = 0LL;
+
+   }
+     
+   WatchTask::WatchTask(const WatchTask &that) : afrl::cmasi::SearchTask(that)
+   {
+        __WatchedEntityID = that.__WatchedEntityID;
+
+   }
+   
+   WatchTask & WatchTask::operator=(const WatchTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::SearchTask::operator=(that);
+
+         __WatchedEntityID = that.__WatchedEntityID;
+
+      }
+      return *this;
+   }
+
+   WatchTask* WatchTask::clone() const
+   {
+        return new WatchTask(*this);
+   }
+   
+   WatchTask::~WatchTask(void)
+   {
+
+   }
+  
+   void WatchTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::SearchTask::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__WatchedEntityID);
+
+   }
+   
+   void WatchTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::SearchTask::unpack(buf);
+      // Copy the buffer into the class
+      __WatchedEntityID = buf.getLong();
+
+   }
+
+   uint32_t WatchTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::SearchTask::calculatePackedSize();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string WatchTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( WatchTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+      oss << indent << "DesiredWavelengthBands (WavelengthBand [ " << __DesiredWavelengthBands.size() << ", var ])\n";
+      oss << indent << "DwellTime (int64_t) = " << __DwellTime << "\n";
+      oss << indent << "GroundSampleDistance (float) = " << __GroundSampleDistance << "\n";
+
+      oss << indent << "WatchedEntityID (int64_t) = " << __WatchedEntityID << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string WatchTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<WatchTask Series=\"IMPACT\">\n";
+      str << ws << "   <WatchedEntityID>" << __WatchedEntityID << "</WatchedEntityID>\n";
+      str << ws << "   <DesiredWavelengthBands>\n";
+      for (size_t i=0; i<__DesiredWavelengthBands.size(); i++)
+      {
+         str << ws << "   <WavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__DesiredWavelengthBands[i]) << "</WavelengthBand>\n";
+      }
+      str << ws << "   </DesiredWavelengthBands>\n";
+      str << ws << "   <DwellTime>" << __DwellTime << "</DwellTime>\n";
+      str << ws << "   <GroundSampleDistance>" << __GroundSampleDistance << "</GroundSampleDistance>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</WatchTask>\n";
+
+      return str.str();
+   }
+
+   bool WatchTask::operator==(const WatchTask & that)
+   {
+      if( afrl::cmasi::SearchTask::operator!=(that) )
+      {
+          return false;
+      }
+      if(__WatchedEntityID != that.__WatchedEntityID) return false;
+      return true;
+
+   }
+
+   bool WatchTask::operator!=(const WatchTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   WatchTask& WatchTask::setWatchedEntityID(const int64_t val)
+   {
+      __WatchedEntityID = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactWaterReport.cpp b/src/LMCP/afrl/impact/afrlimpactWaterReport.cpp
new file mode 100644
index 0000000..6c9cfc5
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactWaterReport.cpp
@@ -0,0 +1,255 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/WaterReport.h"
+#include "afrl/cmasi/Circle.h"
+#include "afrl/cmasi/Polygon.h"
+#include "afrl/cmasi/Rectangle.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string WaterReport::Subscription = "afrl.impact.WaterReport";
+   const std::string WaterReport::TypeName = "WaterReport";
+   
+   bool isWaterReport(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 38) return false;
+      return true;
+   }
+   
+   bool isWaterReport(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 38) return false;
+      return true;
+   }
+   
+   std::vector< std::string > WaterReportDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   WaterReport::WaterReport(void) : avtas::lmcp::Object()
+   {
+      __Area = new afrl::cmasi::AbstractGeometry();
+      __CurrentSpeed = 0.f;
+      __CurrentDirection = 0.f;
+      __WaveDirection = 0.f;
+      __WaveHeight = 0.f;
+
+   }
+     
+   WaterReport::WaterReport(const WaterReport &that) : avtas::lmcp::Object(that)
+   {
+        __Area = that.__Area == nullptr ? nullptr : that.__Area->clone();
+        __CurrentSpeed = that.__CurrentSpeed;
+        __CurrentDirection = that.__CurrentDirection;
+        __WaveDirection = that.__WaveDirection;
+        __WaveHeight = that.__WaveHeight;
+
+   }
+   
+   WaterReport & WaterReport::operator=(const WaterReport &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__Area != nullptr) delete __Area;
+
+         __Area = that.__Area == nullptr ? nullptr : that.__Area->clone();
+         __CurrentSpeed = that.__CurrentSpeed;
+         __CurrentDirection = that.__CurrentDirection;
+         __WaveDirection = that.__WaveDirection;
+         __WaveHeight = that.__WaveHeight;
+
+      }
+      return *this;
+   }
+
+   WaterReport* WaterReport::clone() const
+   {
+        return new WaterReport(*this);
+   }
+   
+   WaterReport::~WaterReport(void)
+   {
+      if (__Area != nullptr) delete __Area;
+
+   }
+  
+   void WaterReport::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Area, buf);
+      buf.putFloat(__CurrentSpeed);
+      buf.putFloat(__CurrentDirection);
+      buf.putFloat(__WaveDirection);
+      buf.putFloat(__WaveHeight);
+
+   }
+   
+   void WaterReport::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__Area != nullptr) delete __Area;
+         __Area = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Area = (afrl::cmasi::AbstractGeometry*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Area != nullptr) __Area->unpack(buf);
+         }
+      }
+      __CurrentSpeed = buf.getFloat();
+      __CurrentDirection = buf.getFloat();
+      __WaveDirection = buf.getFloat();
+      __WaveHeight = buf.getFloat();
+
+   }
+
+   uint32_t WaterReport::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += (__Area != nullptr ? __Area->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string WaterReport::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( WaterReport ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "Area (AbstractGeometry)";
+      if (__Area == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "CurrentSpeed (float) = " << __CurrentSpeed << "\n";
+      oss << indent << "CurrentDirection (float) = " << __CurrentDirection << "\n";
+      oss << indent << "WaveDirection (float) = " << __WaveDirection << "\n";
+      oss << indent << "WaveHeight (float) = " << __WaveHeight << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string WaterReport::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<WaterReport Series=\"IMPACT\">\n";
+      if (__Area != nullptr)
+      {
+         str << ws << "   <Area>";
+         str << "\n" + __Area->toXML(depth + 1) + ws + "   ";
+         str << "</Area>\n";
+      }
+      str << ws << "   <CurrentSpeed>" << __CurrentSpeed << "</CurrentSpeed>\n";
+      str << ws << "   <CurrentDirection>" << __CurrentDirection << "</CurrentDirection>\n";
+      str << ws << "   <WaveDirection>" << __WaveDirection << "</WaveDirection>\n";
+      str << ws << "   <WaveHeight>" << __WaveHeight << "</WaveHeight>\n";
+      str << ws << "</WaterReport>\n";
+
+      return str.str();
+   }
+
+   bool WaterReport::operator==(const WaterReport & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Area && that.__Area)
+      {
+         if(__Area->getSeriesNameAsLong() != that.__Area->getSeriesNameAsLong()) return false;
+         if(__Area->getSeriesVersion() != that.__Area->getSeriesVersion()) return false;
+         if(__Area->getLmcpType() != that.__Area->getLmcpType()) return false;
+         if( *(__Area) != *(that.__Area) ) return false;
+      }
+      else if(__Area != that.__Area) return false;
+      if(__CurrentSpeed != that.__CurrentSpeed) return false;
+      if(__CurrentDirection != that.__CurrentDirection) return false;
+      if(__WaveDirection != that.__WaveDirection) return false;
+      if(__WaveHeight != that.__WaveHeight) return false;
+      return true;
+
+   }
+
+   bool WaterReport::operator!=(const WaterReport & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   WaterReport& WaterReport::setArea(const afrl::cmasi::AbstractGeometry* const val)
+   {
+      if (__Area != nullptr) { delete __Area; __Area = nullptr; }
+      if (val != nullptr) { __Area = const_cast< afrl::cmasi::AbstractGeometry* > (val); }
+      return *this;
+   }
+
+   WaterReport& WaterReport::setCurrentSpeed(const float val)
+   {
+      __CurrentSpeed = val;
+      return *this;
+   }
+
+   WaterReport& WaterReport::setCurrentDirection(const float val)
+   {
+      __CurrentDirection = val;
+      return *this;
+   }
+
+   WaterReport& WaterReport::setWaveDirection(const float val)
+   {
+      __WaveDirection = val;
+      return *this;
+   }
+
+   WaterReport& WaterReport::setWaveHeight(const float val)
+   {
+      __WaveHeight = val;
+      return *this;
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/afrl/impact/afrlimpactWaterZone.cpp b/src/LMCP/afrl/impact/afrlimpactWaterZone.cpp
new file mode 100644
index 0000000..2cf0573
--- /dev/null
+++ b/src/LMCP/afrl/impact/afrlimpactWaterZone.cpp
@@ -0,0 +1,184 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "afrl/impact/WaterZone.h"
+
+
+namespace afrl {
+namespace impact {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string WaterZone::Subscription = "afrl.impact.WaterZone";
+   const std::string WaterZone::TypeName = "WaterZone";
+   
+   bool isWaterZone(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 39) return false;
+      return true;
+   }
+   
+   bool isWaterZone(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5281966179208134656LL) return false;
+      if(obj->getSeriesVersion() != 11) return false;
+      if(obj->getLmcpType() != 39) return false;
+      return true;
+   }
+   
+   std::vector< std::string > WaterZoneDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   WaterZone::WaterZone(void) : afrl::cmasi::AbstractZone()
+   {
+
+   }
+     
+   WaterZone::WaterZone(const WaterZone &that) : afrl::cmasi::AbstractZone(that)
+   {
+
+   }
+   
+   WaterZone & WaterZone::operator=(const WaterZone &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::AbstractZone::operator=(that);
+
+
+      }
+      return *this;
+   }
+
+   WaterZone* WaterZone::clone() const
+   {
+        return new WaterZone(*this);
+   }
+   
+   WaterZone::~WaterZone(void)
+   {
+
+   }
+  
+   void WaterZone::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::AbstractZone::pack(buf);
+      // Copy the class into the buffer
+
+   }
+   
+   void WaterZone::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::AbstractZone::unpack(buf);
+      // Copy the buffer into the class
+
+   }
+
+   uint32_t WaterZone::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::AbstractZone::calculatePackedSize();
+
+      return size;
+   }
+
+   std::string WaterZone::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( WaterZone ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ZoneID (int64_t) = " << __ZoneID << "\n";
+      oss << indent << "MinAltitude (float) = " << __MinAltitude << "\n";
+      oss << indent << "MinAltitudeType (AltitudeType) = " << __MinAltitudeType << "\n";
+      oss << indent << "MaxAltitude (float) = " << __MaxAltitude << "\n";
+      oss << indent << "MaxAltitudeType (AltitudeType) = " << __MaxAltitudeType << "\n";
+      oss << indent << "AffectedAircraft (int64 [ " << __AffectedAircraft.size() << ", var ])\n";
+      oss << indent << "StartTime (int64_t) = " << __StartTime << "\n";
+      oss << indent << "EndTime (int64_t) = " << __EndTime << "\n";
+      oss << indent << "Padding (float) = " << __Padding << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "Boundary (AbstractGeometry)";
+      if (__Boundary == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string WaterZone::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<WaterZone Series=\"IMPACT\">\n";
+      str << ws << "   <ZoneID>" << __ZoneID << "</ZoneID>\n";
+      str << ws << "   <MinAltitude>" << __MinAltitude << "</MinAltitude>\n";
+      str << ws << "   <MinAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__MinAltitudeType) << "</MinAltitudeType>\n";
+      str << ws << "   <MaxAltitude>" << __MaxAltitude << "</MaxAltitude>\n";
+      str << ws << "   <MaxAltitudeType>" << afrl::cmasi::AltitudeType::get_string(__MaxAltitudeType) << "</MaxAltitudeType>\n";
+      str << ws << "   <AffectedAircraft>\n";
+      for (size_t i=0; i<__AffectedAircraft.size(); i++)
+      {
+         str << ws << "   <int64>" << __AffectedAircraft[i] << "</int64>\n";
+      }
+      str << ws << "   </AffectedAircraft>\n";
+      str << ws << "   <StartTime>" << __StartTime << "</StartTime>\n";
+      str << ws << "   <EndTime>" << __EndTime << "</EndTime>\n";
+      str << ws << "   <Padding>" << __Padding << "</Padding>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      if (__Boundary != nullptr)
+      {
+         str << ws << "   <Boundary>";
+         str << "\n" + __Boundary->toXML(depth + 1) + ws + "   ";
+         str << "</Boundary>\n";
+      }
+      str << ws << "</WaterZone>\n";
+
+      return str.str();
+   }
+
+   bool WaterZone::operator==(const WaterZone & that)
+   {
+      if( afrl::cmasi::AbstractZone::operator!=(that) )
+      {
+          return false;
+      }
+      return true;
+
+   }
+
+   bool WaterZone::operator!=(const WaterZone & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+} // end namespace impact
+} // end namespace afrl
+
diff --git a/src/LMCP/avtas/lmcp/ByteBuffer.cpp b/src/LMCP/avtas/lmcp/ByteBuffer.cpp
new file mode 100644
index 0000000..044ce98
--- /dev/null
+++ b/src/LMCP/avtas/lmcp/ByteBuffer.cpp
@@ -0,0 +1,538 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "avtas/lmcp/ByteBuffer.h"
+#include <string.h>
+#include <sstream>
+#include <iostream>
+#include <iomanip>
+
+namespace avtas {
+namespace lmcp {
+
+   ByteBuffer::ByteBuffer(ByteOrder order) :
+      _position(0),
+      _capacity(0),
+      _buf(0),
+      _byteOrder(order)
+   {
+   }
+
+   ByteBuffer::ByteBuffer(const ByteBuffer & that) :
+      _position(0),
+      _capacity(0),
+      _buf(0),
+      _byteOrder(that._byteOrder)
+   {
+      allocate(that.capacity());
+      put(that.array(), that.capacity());
+      rewind();
+   }
+
+   ByteBuffer & ByteBuffer::operator=(const ByteBuffer & that) {
+      if (this != &that) {
+         _byteOrder = that._byteOrder;
+         allocate(that.capacity());
+         put(that.array(), that.capacity());
+         rewind();
+      }
+      return *this;
+   }
+
+   ByteBuffer::~ByteBuffer(void) {
+      allocate(0);
+   }
+
+   uint8_t ByteBuffer::get(void) {
+      if (_buf && hasRemaining()) {
+         return _buf[_position++];
+      }
+      return 0;
+   }
+
+   ByteBuffer & ByteBuffer::get(uint8_t * dst, uint32_t length, uint32_t offset) {
+      if (_buf && dst && offset<length && length>0 && remaining()>=length) {
+         memcpy(&dst[offset], &_buf[_position], static_cast<size_t>(length));
+         _position += length;
+      }
+      return *this;
+   }
+
+   bool ByteBuffer::getBool(void) {
+      if (_buf && remaining()>=1) {
+         bool b = *(reinterpret_cast<bool *>(&_buf[_position]));
+         _position += 1;
+         return b;
+      }
+      return 0;
+   }
+
+   uint8_t ByteBuffer::getByte(void) {
+      if (_buf && remaining()>=1) {
+         uint8_t c = _buf[_position];
+         _position += 1;
+         return c;
+      }
+      return 0;
+   }
+
+   int16_t ByteBuffer::getShort(void) {
+      if (_buf && remaining()>=2) {
+         uint8_t b[2];
+         copyFromBuffer(b, 2);
+         return *(reinterpret_cast<int16_t *>(b));
+      }
+      return 0;
+   }
+
+   uint16_t ByteBuffer::getUShort(void) {
+      if (_buf && remaining()>=2) {
+         uint8_t b[2];
+         copyFromBuffer(b, 2);
+         return *(reinterpret_cast<uint16_t *>(b));
+      }
+      return 0;
+   }
+
+   int32_t ByteBuffer::getInt(void) {
+      if (_buf && remaining()>=4) {
+         uint8_t b[4];
+         copyFromBuffer(b, 4);
+         return *(reinterpret_cast<int32_t *>(b));
+      }
+      return 0;
+   }
+
+   uint32_t ByteBuffer::getUInt(void) {
+      if (_buf && remaining()>=4) {
+         uint8_t b[4];
+         copyFromBuffer(b, 4);
+         return *(reinterpret_cast<uint32_t *>(b));
+      }
+      return 0;
+   }
+
+   int64_t ByteBuffer::getLong(void) {
+      if (_buf && remaining()>=8) {
+         uint8_t b[8];
+         copyFromBuffer(b, 8);
+         return *(reinterpret_cast<int64_t *>(b));
+      }
+      return 0;
+   }
+
+   uint64_t ByteBuffer::getULong(void) {
+      if (_buf && remaining()>=8) {
+         uint8_t b[8];
+         copyFromBuffer(b, 8);
+         return *(reinterpret_cast<uint64_t *>(b));
+      }
+      return 0;
+   }
+
+   float ByteBuffer::getFloat(void) {
+      if (_buf && remaining()>=4) {
+         uint8_t b[4];
+         copyFromBuffer(b, 4);
+         return *(reinterpret_cast<float *>(b));
+      }
+      return 0.f;
+   }
+
+   double ByteBuffer::getDouble(void) {
+      if (_buf && remaining()>=8) {
+         uint8_t b[8];
+         copyFromBuffer(b, 8);
+         return *(reinterpret_cast<double *>(b));
+      }
+      return 0.;
+   }
+
+   ByteBuffer & ByteBuffer::getBoolArray(bool * b, uint32_t length) {
+      if (_buf && remaining()>=length) {
+         copyFromBuffer(reinterpret_cast<uint8_t *>(b), 1, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::getByteArray(uint8_t * c, uint32_t length) {
+      if (_buf && remaining()>=length) {
+         copyFromBuffer(reinterpret_cast<uint8_t *>(c), 1, length);
+      }
+      return *this;
+   }
+   
+   std::string ByteBuffer::getString(void) {
+       uint16_t len = getUShort();
+       uint8_t * c = new uint8_t[len+1];
+       c[len] = 0; // null terminate string
+       getByteArray(c, len);
+       std::string str = std::string(reinterpret_cast<char*>(c));
+       delete [] c;
+       return str;
+   }
+
+   ByteBuffer & ByteBuffer::getShortArray(int16_t * s, uint32_t length) {
+      if (_buf && remaining()>=(length*2)) {
+         copyFromBuffer(reinterpret_cast<uint8_t *>(s), 2, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::getUShortArray(uint16_t * us, uint32_t length) {
+      if (_buf && remaining()>=(length*2)) {
+         copyFromBuffer(reinterpret_cast<uint8_t *>(us), 2, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::getIntArray(int32_t * i, uint32_t length) {
+      if (_buf && remaining()>=(length*4)) {
+         copyFromBuffer(reinterpret_cast<uint8_t *>(i), 4, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::getUIntArray(uint32_t * ui, uint32_t length) {
+      if (_buf && remaining()>=(length*4)) {
+         copyFromBuffer(reinterpret_cast<uint8_t *>(ui), 4, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::getLongArray(int64_t * l, uint32_t length) {
+      if (_buf && remaining()>=(length*8)) {
+         copyFromBuffer(reinterpret_cast<uint8_t *>(l), 8, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::getULongArray(uint64_t * ul, uint32_t length) {
+      if (_buf && remaining()>=(length*8)) {
+         copyFromBuffer(reinterpret_cast<uint8_t *>(ul), 8, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::getFloatArray(float * f, uint32_t length) {
+      if (_buf && remaining()>=(length*4)) {
+         copyFromBuffer(reinterpret_cast<uint8_t *>(f), 4, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::getDoubleArray(double * d, uint32_t length) {
+      if (_buf && remaining()>=(length*8)) {
+         copyFromBuffer(reinterpret_cast<uint8_t *>(d), 8, length);
+      }
+      return *this;
+   }
+
+   uint8_t ByteBuffer::get(uint32_t index) const {
+      if (_buf && index<capacity()) {
+         return _buf[index];
+      }
+      return 0;
+   }
+
+   ByteBuffer & ByteBuffer::put(const uint8_t b) {
+      if (_buf && hasRemaining()) {
+         _buf[_position++] = b;
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::put(const uint8_t * src, uint32_t length, uint32_t offset) {
+      if (_buf && src && offset<length && length>0 && remaining()>=length) {
+         memcpy(&_buf[_position], &src[offset], static_cast<size_t>(length));
+         _position += length;
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::put(ByteBuffer & src) {
+      uint32_t length = src.remaining();
+      if (&src!=this && length<=remaining()) {
+         src.get(_buf, length, _position);
+         _position += length;
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putBool(bool b) {
+      if (_buf && remaining()>=1) {
+         memcpy(&_buf[_position], &b, 1);
+         _position += 1;
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putByte(uint8_t c) {
+      if (_buf && remaining()>=1) {
+         memcpy(&_buf[_position], &c, 1);
+         _position += 1;
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putShort(int16_t s) {
+      if (_buf && remaining()>=2) {
+         copyToBuffer(reinterpret_cast<uint8_t *>(&s), 2);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putString(std::string s) {
+      uint16_t len = 0;
+      if(s.length() >= 65536)
+      {
+         len = 65535;
+         std::cerr << "String was too long to be packed! Max string length is 65535" << std::endl;
+         std::cerr << "String that could not be packed: " << std::endl << s << std::endl;
+      }
+      else
+      {
+         len = static_cast<uint16_t>(s.length());   
+      }
+      if (_buf && remaining() >= static_cast<uint32_t>((2 + len))) {
+          putUShort(len);
+          putByteArray(reinterpret_cast<const uint8_t*>(s.c_str()), len);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putUShort(uint16_t us) {
+      if (_buf && remaining()>=2) {
+         copyToBuffer(reinterpret_cast<uint8_t *>(&us), 2);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putInt(int32_t i) {
+      if (_buf && remaining()>=4) {
+         copyToBuffer(reinterpret_cast<uint8_t *>(&i), 4);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putUInt(uint32_t ui) {
+      if (_buf && remaining()>=4) {
+         copyToBuffer(reinterpret_cast<uint8_t *>(&ui), 4);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putLong(int64_t l) {
+      if (_buf && remaining()>=8) {
+         copyToBuffer(reinterpret_cast<uint8_t *>(&l), 8);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putULong(uint64_t ul) {
+      if (_buf && remaining()>=8) {
+         copyToBuffer(reinterpret_cast<uint8_t *>(&ul), 8);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putFloat(float f) {
+      if (_buf && remaining()>=4) {
+         copyToBuffer(reinterpret_cast<uint8_t *>(&f), 4);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putDouble(double d) {
+      if (_buf && remaining()>=8) {
+         copyToBuffer(reinterpret_cast<uint8_t *>(&d), 8);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putBoolArray(const bool * b, uint32_t length) {
+      if (_buf && remaining()>=length) {
+         copyToBuffer(reinterpret_cast<const uint8_t *>(b), 1, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putByteArray(const uint8_t * c, uint32_t length) {
+      if (_buf && remaining()>=(length)) {
+         copyToBuffer(reinterpret_cast<const uint8_t *>(c), 1, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putShortArray(const int16_t * s, uint32_t length) {
+      if (_buf && remaining()>=(length*2)) {
+         copyToBuffer(reinterpret_cast<const uint8_t *>(s), 2, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putUShortArray(const uint16_t * us, uint32_t length) {
+      if (_buf && remaining()>=(length*2)) {
+         copyToBuffer(reinterpret_cast<const uint8_t *>(us), 2, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putIntArray(const int32_t * i, uint32_t length) {
+      if (_buf && remaining()>=(length*4)) {
+         copyToBuffer(reinterpret_cast<const uint8_t *>(i), 4, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putUIntArray(const uint32_t * ui, uint32_t length) {
+      if (_buf && remaining()>=(length*4)) {
+         copyToBuffer(reinterpret_cast<const uint8_t *>(ui), 4, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putLongArray(const int64_t * l, uint32_t length) {
+      if (_buf && remaining()>=(length*8)) {
+         copyToBuffer(reinterpret_cast<const uint8_t *>(l), 8, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putULongArray(const uint64_t * ul, uint32_t length) {
+      if (_buf && remaining()>=(length*8)) {
+         copyToBuffer(reinterpret_cast<const uint8_t *>(ul), 8, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putFloatArray(const float * f, uint32_t length) {
+      if (_buf && remaining()>=(length*4)) {
+         copyToBuffer(reinterpret_cast<const uint8_t *>(f), 4, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::putDoubleArray(const double * d, uint32_t length) {
+      if (_buf && remaining()>=(length*8)) {
+         copyToBuffer(reinterpret_cast<const uint8_t *>(d), 8, length);
+      }
+      return *this;
+   }
+
+   ByteBuffer & ByteBuffer::put(uint32_t index, const uint8_t b) {
+      if (_buf && index<capacity()) {
+         _buf[index] = b;
+      }
+      return *this;
+   }
+
+   
+   void ByteBuffer::allocate(uint32_t size) {
+      if (size != capacity()) {
+         if (_buf) {
+            delete [] _buf;
+            _buf = 0;
+         }
+         if (size > 0) {
+            _buf = new uint8_t[(_capacity=size)];
+         } else {
+            _capacity = 0;
+         }
+         rewind();
+      }
+   }
+
+   uint8_t * ByteBuffer::array(void) {
+      return _buf;
+   }
+
+   const uint8_t * ByteBuffer::array(void) const {
+      return _buf;
+   }
+
+   std::string ByteBuffer::toString(void) const {
+      std::ostringstream oss;
+      if (_buf) {
+         for (uint32_t i=0; i<capacity(); i++) {
+            oss << std::setw(2) << std::setfill('0') << std::hex << _buf[i];
+            if (i % 4 == 3) {
+               oss << std::endl;
+            } else {
+               oss << " ";
+            }
+         }
+         oss << std::endl;
+      }
+      return oss.str();
+   }
+
+   void ByteBuffer::copyToBuffer(const uint8_t * src, uint32_t length, uint32_t nelem) {
+      if (nelem == 0)
+         return;
+      switch (_byteOrder) {
+      case ENDIAN_BIG:
+         if (nelem == 1) {
+            // Swap the bytes
+            register uint32_t i;
+            for (i=0; i<length; i++)
+               _buf[_position+(length-1-i)] = src[i];
+            _position += length;
+         } else if (nelem > 0) {
+            // Swap the bytes on each element
+            register uint32_t i;
+            for (i=0; i<nelem; i++) {
+               copyToBuffer(&src[(length*i)], length);
+            }
+         }
+         return;
+      case ENDIAN_LITTLE:
+         // No swapping
+         if (nelem > 0) {
+            memcpy(&_buf[_position], src, static_cast<size_t>(length*nelem));
+            _position += length*nelem;
+         }
+         return;
+      }
+   }
+
+   void ByteBuffer::copyFromBuffer(uint8_t * dst, uint32_t length, uint32_t nelem) {
+      if (nelem == 0)
+         return;
+      switch (_byteOrder) {
+      case ENDIAN_BIG:
+         if (nelem == 1) {
+            // Swap the bytes
+            register uint32_t i;
+            for (i=0; i<length; i++)
+               dst[i] = _buf[_position+(length-1-i)];
+            _position += length;
+         } else if (nelem > 0) {
+            // Swap the bytes on each element
+            register uint32_t i;
+            for (i=0; i<nelem; i++) {
+               copyFromBuffer(&dst[(length*i)], length);
+            }
+         }
+         return;
+      case ENDIAN_LITTLE:
+         // No swapping
+         if (nelem > 0) {
+            memcpy(dst, &_buf[_position], static_cast<size_t>(length*nelem));
+            _position += length*nelem;
+         }
+         return;
+      }
+   }
+
+} // end namespace lmcp
+} // end namespace avtas
+
diff --git a/src/LMCP/avtas/lmcp/ByteBuffer.h b/src/LMCP/avtas/lmcp/ByteBuffer.h
new file mode 100644
index 0000000..9ee3a8d
--- /dev/null
+++ b/src/LMCP/avtas/lmcp/ByteBuffer.h
@@ -0,0 +1,148 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AVTAS_LMCP_BYTEBUFFER_H_
+#define _AVTAS_LMCP_BYTEBUFFER_H_
+
+#include <string>
+#include <cstdint>
+
+
+namespace avtas {
+    namespace lmcp {
+
+        class ByteBuffer {
+        public:
+
+            enum ByteOrder {
+                ENDIAN_BIG, ENDIAN_LITTLE
+            };
+            ByteBuffer(ByteOrder order = ENDIAN_BIG);
+            ByteBuffer(const ByteBuffer &that);
+            ByteBuffer & operator=(const ByteBuffer &that);
+            virtual ~ByteBuffer(void);
+
+			// Note: 4GB capacity limit
+            inline uint32_t capacity(void) const {
+                return _capacity;
+            }
+
+            inline ByteBuffer & clear(void) {
+                allocate(0);
+                return position(0);
+            }
+
+            inline bool hasRemaining(void) const {
+                return (remaining() > 0);
+            }
+
+            inline uint32_t position(void) const {
+                return _position;
+            }
+
+            inline ByteBuffer & position(uint32_t pos) {
+                if (pos < capacity()) {
+                    _position = pos;
+                }
+                return *this;
+            }
+
+            inline uint32_t remaining(void) const {
+                return (capacity() - position());
+            }
+
+            inline ByteBuffer & rewind(void) {
+                return position(0);
+            }
+
+            // Relative get/put
+            uint8_t get(void);
+            ByteBuffer & get(uint8_t* dst, uint32_t length, uint32_t offset = 0);
+            bool getBool(void);
+            uint8_t getByte(void);
+            int16_t getShort(void);
+            uint16_t getUShort(void);
+            int32_t getInt(void);
+            uint32_t getUInt(void);
+            int64_t getLong(void);
+            uint64_t getULong(void);
+            float getFloat(void);
+            double getDouble(void);
+            std::string getString(void);
+
+            ByteBuffer & getBoolArray(bool * b, uint32_t length);
+            ByteBuffer & getByteArray(uint8_t * c, uint32_t length);
+            ByteBuffer & getShortArray(int16_t * s, uint32_t length);
+            ByteBuffer & getUShortArray(uint16_t * us, uint32_t length);
+            ByteBuffer & getIntArray(int32_t * i, uint32_t length);
+            ByteBuffer & getUIntArray(uint32_t * ui, uint32_t length);
+            ByteBuffer & getLongArray(int64_t * l, uint32_t length);
+            ByteBuffer & getULongArray(uint64_t * ul, uint32_t length);
+            ByteBuffer & getFloatArray(float * f, uint32_t length);
+            ByteBuffer & getDoubleArray(double * d, uint32_t length);
+            ByteBuffer & put(const uint8_t b);
+            ByteBuffer & put(const uint8_t * src, uint32_t length, uint32_t offset = 0);
+            ByteBuffer & put(ByteBuffer & buf);
+            ByteBuffer & putBool(bool b);
+            ByteBuffer & putByte(uint8_t c);
+            ByteBuffer & putShort(int16_t s);
+            ByteBuffer & putUShort(uint16_t us);
+            ByteBuffer & putInt(int32_t i);
+            ByteBuffer & putUInt(uint32_t ui);
+            ByteBuffer & putLong(int64_t l);
+            ByteBuffer & putULong(uint64_t ul);
+            ByteBuffer & putFloat(float f);
+            ByteBuffer & putDouble(double d);
+            ByteBuffer & putBoolArray(const bool * b, uint32_t length);
+            ByteBuffer & putByteArray(const uint8_t * b, uint32_t length);
+            ByteBuffer & putShortArray(const int16_t * s, uint32_t length);
+            ByteBuffer & putUShortArray(const uint16_t * us, uint32_t length);
+            ByteBuffer & putIntArray(const int32_t * i, uint32_t length);
+            ByteBuffer & putUIntArray(const uint32_t * ui, uint32_t length);
+            ByteBuffer & putLongArray(const int64_t * l, uint32_t length);
+            ByteBuffer & putULongArray(const uint64_t * ul, uint32_t length);
+            ByteBuffer & putFloatArray(const float * f, uint32_t length);
+            ByteBuffer & putDoubleArray(const double * d, uint32_t length);
+            ByteBuffer & putString(std::string s);
+
+            // Absolute get/put
+            uint8_t get(uint32_t index) const;
+            ByteBuffer & put(uint32_t index, const uint8_t b);
+
+            virtual void allocate(uint32_t size);
+            uint8_t * array(void);
+            const uint8_t * array(void) const;
+
+            ByteOrder getByteOrder(void) const {
+                return _byteOrder;
+            }
+            virtual std::string toString(void) const;
+
+        protected:
+            uint32_t _position;
+            uint32_t _capacity;
+            uint8_t * _buf;
+            ByteOrder _byteOrder;
+
+        private:
+            // Copies from src to internal buffer, swapping if neccessary
+            // No bounds checking is done here, but the position is changed.
+            void copyToBuffer(const uint8_t * src, uint32_t length, uint32_t elem = 1);
+            // Copies from internal buffer to dest, swapping if neccessary
+            // No bounds checking is done here, but the position is changed.
+            void copyFromBuffer(uint8_t * dst, uint32_t length, uint32_t elem = 1);
+        };
+
+    } // end namespace lmcp
+} // end namespace avtas
+
+#endif //_AVTAS_LMCP_BYTEBUFFER_H_
+
diff --git a/src/LMCP/avtas/lmcp/Factory.cpp b/src/LMCP/avtas/lmcp/Factory.cpp
new file mode 100644
index 0000000..147357f
--- /dev/null
+++ b/src/LMCP/avtas/lmcp/Factory.cpp
@@ -0,0 +1,536 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "avtas/lmcp/Factory.h"
+#include "avtas/lmcp/Object.h"
+#include <iostream>
+#include <string>
+#include <cstdint>
+
+#include "uxas/messages/task/AssignmentCoordinatorTask.h"
+#include "uxas/messages/task/PlanningState.h"
+#include "uxas/messages/task/AssignmentCoordination.h"
+#include "uxas/messages/task/CoordinatedAutomationRequest.h"
+#include "uxas/messages/task/TaskAutomationRequest.h"
+#include "uxas/messages/task/TaskAutomationResponse.h"
+#include "uxas/messages/task/UniqueAutomationRequest.h"
+#include "uxas/messages/task/UniqueAutomationResponse.h"
+#include "uxas/messages/task/SensorFootprintRequests.h"
+#include "uxas/messages/task/FootprintRequest.h"
+#include "uxas/messages/task/SensorFootprint.h"
+#include "uxas/messages/task/SensorFootprintResponse.h"
+#include "uxas/messages/task/TaskImplementationRequest.h"
+#include "uxas/messages/task/TaskImplementationResponse.h"
+#include "uxas/messages/task/AssignmentCostMatrix.h"
+#include "uxas/messages/task/TaskOptionCost.h"
+#include "uxas/messages/task/TaskAssignment.h"
+#include "uxas/messages/task/TaskAssignmentSummary.h"
+#include "uxas/messages/task/TaskOption.h"
+#include "uxas/messages/task/TaskPlanOptions.h"
+#include "uxas/messages/task/TaskPause.h"
+#include "uxas/messages/task/TaskResume.h"
+#include "uxas/messages/task/TaskProgress.h"
+#include "uxas/messages/task/TaskProgressRequest.h"
+#include "uxas/messages/task/TaskInitialized.h"
+#include "uxas/messages/task/TaskActive.h"
+#include "uxas/messages/task/TaskComplete.h"
+#include "uxas/messages/task/CancelTask.h"
+#include "uxas/messages/task/UXTASKEnum.h"
+#include "uxas/messages/uxnative/VideoRecord.h"
+#include "uxas/messages/uxnative/StartupComplete.h"
+#include "uxas/messages/uxnative/CreateNewService.h"
+#include "uxas/messages/uxnative/KillService.h"
+#include "uxas/messages/uxnative/IncrementWaypoint.h"
+#include "uxas/messages/uxnative/EntityLocation.h"
+#include "uxas/messages/uxnative/BandwidthTest.h"
+#include "uxas/messages/uxnative/BandwidthReceiveReport.h"
+#include "uxas/messages/uxnative/SubTaskExecution.h"
+#include "uxas/messages/uxnative/SubTaskAssignment.h"
+#include "uxas/messages/uxnative/AutopilotKeepAlive.h"
+#include "uxas/messages/uxnative/OnboardProcessorIsAlive.h"
+#include "uxas/messages/uxnative/EntityJoin.h"
+#include "uxas/messages/uxnative/EntityExit.h"
+#include "uxas/messages/uxnative/UXNATIVEEnum.h"
+#include "uxas/messages/route/GraphNode.h"
+#include "uxas/messages/route/GraphEdge.h"
+#include "uxas/messages/route/GraphRegion.h"
+#include "uxas/messages/route/RouteConstraints.h"
+#include "uxas/messages/route/RouteRequest.h"
+#include "uxas/messages/route/RoutePlanRequest.h"
+#include "uxas/messages/route/RoutePlan.h"
+#include "uxas/messages/route/RoutePlanResponse.h"
+#include "uxas/messages/route/RouteResponse.h"
+#include "uxas/messages/route/EgressRouteRequest.h"
+#include "uxas/messages/route/EgressRouteResponse.h"
+#include "uxas/messages/route/ROUTEEnum.h"
+#include "afrl/cmasi/AbstractGeometry.h"
+#include "afrl/cmasi/KeyValuePair.h"
+#include "afrl/cmasi/Location3D.h"
+#include "afrl/cmasi/PayloadAction.h"
+#include "afrl/cmasi/PayloadConfiguration.h"
+#include "afrl/cmasi/PayloadState.h"
+#include "afrl/cmasi/VehicleAction.h"
+#include "afrl/cmasi/Task.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/AbstractZone.h"
+#include "afrl/cmasi/EntityConfiguration.h"
+#include "afrl/cmasi/FlightProfile.h"
+#include "afrl/cmasi/AirVehicleConfiguration.h"
+#include "afrl/cmasi/EntityState.h"
+#include "afrl/cmasi/AirVehicleState.h"
+#include "afrl/cmasi/Wedge.h"
+#include "afrl/cmasi/AreaSearchTask.h"
+#include "afrl/cmasi/CameraAction.h"
+#include "afrl/cmasi/CameraConfiguration.h"
+#include "afrl/cmasi/GimballedPayloadState.h"
+#include "afrl/cmasi/CameraState.h"
+#include "afrl/cmasi/Circle.h"
+#include "afrl/cmasi/GimbalAngleAction.h"
+#include "afrl/cmasi/GimbalConfiguration.h"
+#include "afrl/cmasi/GimbalScanAction.h"
+#include "afrl/cmasi/GimbalStareAction.h"
+#include "afrl/cmasi/GimbalState.h"
+#include "afrl/cmasi/GoToWaypointAction.h"
+#include "afrl/cmasi/KeepInZone.h"
+#include "afrl/cmasi/KeepOutZone.h"
+#include "afrl/cmasi/LineSearchTask.h"
+#include "afrl/cmasi/NavigationAction.h"
+#include "afrl/cmasi/LoiterAction.h"
+#include "afrl/cmasi/LoiterTask.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/MissionCommand.h"
+#include "afrl/cmasi/MustFlyTask.h"
+#include "afrl/cmasi/OperatorSignal.h"
+#include "afrl/cmasi/OperatingRegion.h"
+#include "afrl/cmasi/AutomationRequest.h"
+#include "afrl/cmasi/PointSearchTask.h"
+#include "afrl/cmasi/Polygon.h"
+#include "afrl/cmasi/Rectangle.h"
+#include "afrl/cmasi/RemoveTasks.h"
+#include "afrl/cmasi/ServiceStatus.h"
+#include "afrl/cmasi/SessionStatus.h"
+#include "afrl/cmasi/VehicleActionCommand.h"
+#include "afrl/cmasi/VideoStreamAction.h"
+#include "afrl/cmasi/VideoStreamConfiguration.h"
+#include "afrl/cmasi/VideoStreamState.h"
+#include "afrl/cmasi/AutomationResponse.h"
+#include "afrl/cmasi/RemoveZones.h"
+#include "afrl/cmasi/RemoveEntities.h"
+#include "afrl/cmasi/FlightDirectorAction.h"
+#include "afrl/cmasi/WeatherReport.h"
+#include "afrl/cmasi/FollowPathCommand.h"
+#include "afrl/cmasi/PathWaypoint.h"
+#include "afrl/cmasi/StopMovementAction.h"
+#include "afrl/cmasi/WaypointTransfer.h"
+#include "afrl/cmasi/PayloadStowAction.h"
+#include "afrl/cmasi/CMASIEnum.h"
+#include "afrl/impact/PowerConfiguration.h"
+#include "afrl/impact/RadioConfiguration.h"
+#include "afrl/impact/RadioTowerConfiguration.h"
+#include "afrl/impact/RadioState.h"
+#include "afrl/impact/RadioTowerState.h"
+#include "afrl/impact/ImpactPayloadConfiguration.h"
+#include "afrl/impact/DeployImpactPayload.h"
+#include "afrl/impact/PowerPlantState.h"
+#include "afrl/impact/BatchRoutePlanRequest.h"
+#include "afrl/impact/BatchRoutePlanResponse.h"
+#include "afrl/impact/TaskTimingPair.h"
+#include "afrl/impact/BatchSummaryRequest.h"
+#include "afrl/impact/BatchSummaryResponse.h"
+#include "afrl/impact/TaskSummary.h"
+#include "afrl/impact/VehicleSummary.h"
+#include "afrl/impact/ImpactHeartbeat.h"
+#include "afrl/impact/ImpactComponentJoin.h"
+#include "afrl/impact/ImpactComponentLeave.h"
+#include "afrl/impact/SpeedAltPair.h"
+#include "afrl/impact/ImpactAutomationRequest.h"
+#include "afrl/impact/ImpactAutomationResponse.h"
+#include "afrl/impact/PointOfInterest.h"
+#include "afrl/impact/LineOfInterest.h"
+#include "afrl/impact/AreaOfInterest.h"
+#include "afrl/impact/ImpactPointSearchTask.h"
+#include "afrl/impact/PatternSearchTask.h"
+#include "afrl/impact/AngledAreaSearchTask.h"
+#include "afrl/impact/ImpactLineSearchTask.h"
+#include "afrl/impact/WatchTask.h"
+#include "afrl/impact/MultiVehicleWatchTask.h"
+#include "afrl/impact/CommRelayTask.h"
+#include "afrl/impact/CordonTask.h"
+#include "afrl/impact/BlockadeTask.h"
+#include "afrl/impact/EscortTask.h"
+#include "afrl/impact/ConfigurationRequest.h"
+#include "afrl/impact/GroundVehicleConfiguration.h"
+#include "afrl/impact/GroundVehicleState.h"
+#include "afrl/impact/WaterReport.h"
+#include "afrl/impact/WaterZone.h"
+#include "afrl/impact/SurfaceVehicleConfiguration.h"
+#include "afrl/impact/SurfaceVehicleState.h"
+#include "afrl/impact/IMPACTEnum.h"
+#include "afrl/cmasi/perceive/EntityPerception.h"
+#include "afrl/cmasi/perceive/TrackEntityAction.h"
+#include "afrl/cmasi/perceive/TrackEntityTask.h"
+#include "afrl/cmasi/perceive/PERCEIVEEnum.h"
+
+
+namespace avtas {
+
+    namespace lmcp {
+
+        const uint32_t Factory::HEADER_SIZE = 8;
+        const uint32_t Factory::CHECKSUM_SIZE = 4;
+        const uint32_t Factory::SERIESNAME_SIZE = 8;
+        const int32_t Factory::LMCP_CONTROL_STR = 0x4c4d4350;
+
+        Factory::Factory(void) { }
+
+        Factory::Factory(const Factory & that) { }
+
+        Factory & Factory::operator=(const Factory & that)
+        {
+            return *this;
+        }
+
+        Factory::~Factory(void) { }
+
+        ByteBuffer* Factory::packMessage(const Object * const rootObject, const bool enableChecksum)
+        {
+            if (rootObject != nullptr)
+            {
+                // allocate space for message
+                // 15 = boolean (1 byte), series name (8 bytes), type (4 bytes) , version number (2 bytes)
+                uint32_t msgSize = rootObject->calculatePackedSize() + 15;
+                ByteBuffer* buffer = new ByteBuffer();
+                buffer->allocate(HEADER_SIZE + msgSize + CHECKSUM_SIZE);
+
+                // add header values
+                buffer->putInt(LMCP_CONTROL_STR);
+                buffer->putUInt( msgSize );
+
+                // add root object
+                Factory::putObject( rootObject, *buffer);
+
+                // add checksum
+                uint32_t cs = enableChecksum ? calculateChecksum(buffer->array(), buffer->capacity()) : 0;
+                buffer->putUInt(cs);
+                return buffer;
+            }
+            return nullptr;
+        }
+
+        void Factory::putObject(const Object* o, ByteBuffer & buffer)
+        {
+            if (!o)
+            {
+                buffer.putBool(false);
+            }
+            else
+            {
+                buffer.putBool(true);
+                buffer.putLong(o->getSeriesNameAsLong());
+                buffer.putUInt(o->getLmcpType());
+                buffer.putUShort(o->getSeriesVersion());
+                o->pack(buffer);
+            }
+        }
+
+        Object * Factory::getObject(ByteBuffer & buffer)
+        {
+            if (buffer.capacity() < HEADER_SIZE + CHECKSUM_SIZE)
+            {
+                std::cerr << "Error (Factory::getObject): buffer at least as big as"
+                        << " header + checksum (" << HEADER_SIZE + CHECKSUM_SIZE << ").\n";
+                return nullptr;
+            }
+
+            int32_t ctrl_str = buffer.getInt();
+            if ( ctrl_str != LMCP_CONTROL_STR)
+            {
+                std::cerr << "Error (Factory::getObject): Not a proper LMCP message.";
+                std::cerr << "   Expected: " << LMCP_CONTROL_STR << "   Received: " << ctrl_str << std::endl;
+                return nullptr;
+            }
+
+            uint32_t msgsize = buffer.getUInt();
+            if ( buffer.capacity() < msgsize )
+            {
+                std::cerr << "Error (Factory::getObject): Buffer size too small for packed object.";
+                std::cerr << "   MsgSize: " << msgsize << "    Capacity: " << buffer.capacity() << std::endl;
+                return nullptr;
+            }
+
+            // validate the buffer's checksum
+            if (!validate(buffer.array(), buffer.capacity()))
+            {
+                std::cerr << "Error (SeriesFactory::getObject): checksum invalid.\n";
+                return nullptr;
+            }
+
+            if(!buffer.getBool())
+            {
+                std::cerr << "Message indicated it was packed as NULL\n";
+                return nullptr;
+            }
+
+            int64_t series_id = buffer.getLong();
+            uint32_t msgtype = buffer.getUInt();
+            uint16_t version = buffer.getUShort();
+            Object* o = Factory::createObject(series_id, msgtype, version);
+
+            if (o != nullptr)
+            {
+                o->unpack(buffer);
+            }
+            else
+            {
+                std::cerr << "Buffer does not contain a recognized object type. \n";
+            }
+
+            return o;
+
+        }
+
+        Object * Factory::createObject(int64_t series_id, uint32_t type, uint16_t version)
+        {
+            if (series_id == 6149757930721443840LL)
+               if (version == 6)
+                  switch(type)
+                  {
+                     case 1: return new uxas::messages::task::AssignmentCoordinatorTask; 
+                     case 2: return new uxas::messages::task::PlanningState; 
+                     case 3: return new uxas::messages::task::AssignmentCoordination; 
+                     case 4: return new uxas::messages::task::CoordinatedAutomationRequest; 
+                     case 5: return new uxas::messages::task::TaskAutomationRequest; 
+                     case 6: return new uxas::messages::task::TaskAutomationResponse; 
+                     case 7: return new uxas::messages::task::UniqueAutomationRequest; 
+                     case 8: return new uxas::messages::task::UniqueAutomationResponse; 
+                     case 9: return new uxas::messages::task::SensorFootprintRequests; 
+                     case 10: return new uxas::messages::task::FootprintRequest; 
+                     case 11: return new uxas::messages::task::SensorFootprint; 
+                     case 12: return new uxas::messages::task::SensorFootprintResponse; 
+                     case 13: return new uxas::messages::task::TaskImplementationRequest; 
+                     case 14: return new uxas::messages::task::TaskImplementationResponse; 
+                     case 15: return new uxas::messages::task::AssignmentCostMatrix; 
+                     case 16: return new uxas::messages::task::TaskOptionCost; 
+                     case 17: return new uxas::messages::task::TaskAssignment; 
+                     case 18: return new uxas::messages::task::TaskAssignmentSummary; 
+                     case 19: return new uxas::messages::task::TaskOption; 
+                     case 20: return new uxas::messages::task::TaskPlanOptions; 
+                     case 21: return new uxas::messages::task::TaskPause; 
+                     case 22: return new uxas::messages::task::TaskResume; 
+                     case 23: return new uxas::messages::task::TaskProgress; 
+                     case 24: return new uxas::messages::task::TaskProgressRequest; 
+                     case 25: return new uxas::messages::task::TaskInitialized; 
+                     case 26: return new uxas::messages::task::TaskActive; 
+                     case 27: return new uxas::messages::task::TaskComplete; 
+                     case 28: return new uxas::messages::task::CancelTask; 
+                  }
+            if (series_id == 6149751333668345413LL)
+               if (version == 2)
+                  switch(type)
+                  {
+                     case 1: return new uxas::messages::uxnative::VideoRecord; 
+                     case 2: return new uxas::messages::uxnative::StartupComplete; 
+                     case 3: return new uxas::messages::uxnative::CreateNewService; 
+                     case 4: return new uxas::messages::uxnative::KillService; 
+                     case 5: return new uxas::messages::uxnative::IncrementWaypoint; 
+                     case 6: return new uxas::messages::uxnative::EntityLocation; 
+                     case 7: return new uxas::messages::uxnative::BandwidthTest; 
+                     case 8: return new uxas::messages::uxnative::BandwidthReceiveReport; 
+                     case 9: return new uxas::messages::uxnative::SubTaskExecution; 
+                     case 10: return new uxas::messages::uxnative::SubTaskAssignment; 
+                     case 11: return new uxas::messages::uxnative::AutopilotKeepAlive; 
+                     case 12: return new uxas::messages::uxnative::OnboardProcessorIsAlive; 
+                     case 13: return new uxas::messages::uxnative::EntityJoin; 
+                     case 14: return new uxas::messages::uxnative::EntityExit; 
+                  }
+            if (series_id == 5931053054693474304LL)
+               if (version == 3)
+                  switch(type)
+                  {
+                     case 1: return new uxas::messages::route::GraphNode; 
+                     case 2: return new uxas::messages::route::GraphEdge; 
+                     case 3: return new uxas::messages::route::GraphRegion; 
+                     case 4: return new uxas::messages::route::RouteConstraints; 
+                     case 5: return new uxas::messages::route::RouteRequest; 
+                     case 6: return new uxas::messages::route::RoutePlanRequest; 
+                     case 7: return new uxas::messages::route::RoutePlan; 
+                     case 8: return new uxas::messages::route::RoutePlanResponse; 
+                     case 9: return new uxas::messages::route::RouteResponse; 
+                     case 10: return new uxas::messages::route::EgressRouteRequest; 
+                     case 11: return new uxas::messages::route::EgressRouteResponse; 
+                  }
+            if (series_id == 4849604199710720000LL)
+               if (version == 3)
+                  switch(type)
+                  {
+                     case 1: return new afrl::cmasi::AbstractGeometry; 
+                     case 2: return new afrl::cmasi::KeyValuePair; 
+                     case 3: return new afrl::cmasi::Location3D; 
+                     case 4: return new afrl::cmasi::PayloadAction; 
+                     case 5: return new afrl::cmasi::PayloadConfiguration; 
+                     case 6: return new afrl::cmasi::PayloadState; 
+                     case 7: return new afrl::cmasi::VehicleAction; 
+                     case 8: return new afrl::cmasi::Task; 
+                     case 9: return new afrl::cmasi::SearchTask; 
+                     case 10: return new afrl::cmasi::AbstractZone; 
+                     case 11: return new afrl::cmasi::EntityConfiguration; 
+                     case 12: return new afrl::cmasi::FlightProfile; 
+                     case 13: return new afrl::cmasi::AirVehicleConfiguration; 
+                     case 14: return new afrl::cmasi::EntityState; 
+                     case 15: return new afrl::cmasi::AirVehicleState; 
+                     case 16: return new afrl::cmasi::Wedge; 
+                     case 17: return new afrl::cmasi::AreaSearchTask; 
+                     case 18: return new afrl::cmasi::CameraAction; 
+                     case 19: return new afrl::cmasi::CameraConfiguration; 
+                     case 20: return new afrl::cmasi::GimballedPayloadState; 
+                     case 21: return new afrl::cmasi::CameraState; 
+                     case 22: return new afrl::cmasi::Circle; 
+                     case 23: return new afrl::cmasi::GimbalAngleAction; 
+                     case 24: return new afrl::cmasi::GimbalConfiguration; 
+                     case 25: return new afrl::cmasi::GimbalScanAction; 
+                     case 26: return new afrl::cmasi::GimbalStareAction; 
+                     case 27: return new afrl::cmasi::GimbalState; 
+                     case 28: return new afrl::cmasi::GoToWaypointAction; 
+                     case 29: return new afrl::cmasi::KeepInZone; 
+                     case 30: return new afrl::cmasi::KeepOutZone; 
+                     case 31: return new afrl::cmasi::LineSearchTask; 
+                     case 32: return new afrl::cmasi::NavigationAction; 
+                     case 33: return new afrl::cmasi::LoiterAction; 
+                     case 34: return new afrl::cmasi::LoiterTask; 
+                     case 35: return new afrl::cmasi::Waypoint; 
+                     case 36: return new afrl::cmasi::MissionCommand; 
+                     case 37: return new afrl::cmasi::MustFlyTask; 
+                     case 38: return new afrl::cmasi::OperatorSignal; 
+                     case 39: return new afrl::cmasi::OperatingRegion; 
+                     case 40: return new afrl::cmasi::AutomationRequest; 
+                     case 41: return new afrl::cmasi::PointSearchTask; 
+                     case 42: return new afrl::cmasi::Polygon; 
+                     case 43: return new afrl::cmasi::Rectangle; 
+                     case 44: return new afrl::cmasi::RemoveTasks; 
+                     case 45: return new afrl::cmasi::ServiceStatus; 
+                     case 46: return new afrl::cmasi::SessionStatus; 
+                     case 47: return new afrl::cmasi::VehicleActionCommand; 
+                     case 48: return new afrl::cmasi::VideoStreamAction; 
+                     case 49: return new afrl::cmasi::VideoStreamConfiguration; 
+                     case 50: return new afrl::cmasi::VideoStreamState; 
+                     case 51: return new afrl::cmasi::AutomationResponse; 
+                     case 52: return new afrl::cmasi::RemoveZones; 
+                     case 53: return new afrl::cmasi::RemoveEntities; 
+                     case 54: return new afrl::cmasi::FlightDirectorAction; 
+                     case 55: return new afrl::cmasi::WeatherReport; 
+                     case 56: return new afrl::cmasi::FollowPathCommand; 
+                     case 57: return new afrl::cmasi::PathWaypoint; 
+                     case 58: return new afrl::cmasi::StopMovementAction; 
+                     case 59: return new afrl::cmasi::WaypointTransfer; 
+                     case 60: return new afrl::cmasi::PayloadStowAction; 
+                  }
+            if (series_id == 5281966179208134656LL)
+               if (version == 11)
+                  switch(type)
+                  {
+                     case 1: return new afrl::impact::PowerConfiguration; 
+                     case 2: return new afrl::impact::RadioConfiguration; 
+                     case 3: return new afrl::impact::RadioTowerConfiguration; 
+                     case 4: return new afrl::impact::RadioState; 
+                     case 5: return new afrl::impact::RadioTowerState; 
+                     case 6: return new afrl::impact::ImpactPayloadConfiguration; 
+                     case 7: return new afrl::impact::DeployImpactPayload; 
+                     case 8: return new afrl::impact::PowerPlantState; 
+                     case 9: return new afrl::impact::BatchRoutePlanRequest; 
+                     case 10: return new afrl::impact::BatchRoutePlanResponse; 
+                     case 11: return new afrl::impact::TaskTimingPair; 
+                     case 12: return new afrl::impact::BatchSummaryRequest; 
+                     case 13: return new afrl::impact::BatchSummaryResponse; 
+                     case 14: return new afrl::impact::TaskSummary; 
+                     case 15: return new afrl::impact::VehicleSummary; 
+                     case 16: return new afrl::impact::ImpactHeartbeat; 
+                     case 17: return new afrl::impact::ImpactComponentJoin; 
+                     case 18: return new afrl::impact::ImpactComponentLeave; 
+                     case 19: return new afrl::impact::SpeedAltPair; 
+                     case 20: return new afrl::impact::ImpactAutomationRequest; 
+                     case 21: return new afrl::impact::ImpactAutomationResponse; 
+                     case 22: return new afrl::impact::PointOfInterest; 
+                     case 23: return new afrl::impact::LineOfInterest; 
+                     case 24: return new afrl::impact::AreaOfInterest; 
+                     case 25: return new afrl::impact::ImpactPointSearchTask; 
+                     case 26: return new afrl::impact::PatternSearchTask; 
+                     case 27: return new afrl::impact::AngledAreaSearchTask; 
+                     case 28: return new afrl::impact::ImpactLineSearchTask; 
+                     case 29: return new afrl::impact::WatchTask; 
+                     case 30: return new afrl::impact::MultiVehicleWatchTask; 
+                     case 31: return new afrl::impact::CommRelayTask; 
+                     case 32: return new afrl::impact::CordonTask; 
+                     case 33: return new afrl::impact::BlockadeTask; 
+                     case 34: return new afrl::impact::EscortTask; 
+                     case 35: return new afrl::impact::ConfigurationRequest; 
+                     case 36: return new afrl::impact::GroundVehicleConfiguration; 
+                     case 37: return new afrl::impact::GroundVehicleState; 
+                     case 38: return new afrl::impact::WaterReport; 
+                     case 39: return new afrl::impact::WaterZone; 
+                     case 40: return new afrl::impact::SurfaceVehicleConfiguration; 
+                     case 41: return new afrl::impact::SurfaceVehicleState; 
+                  }
+            if (series_id == 5784119745305990725LL)
+               if (version == 1)
+                  switch(type)
+                  {
+                     case 1: return new afrl::cmasi::perceive::EntityPerception; 
+                     case 2: return new afrl::cmasi::perceive::TrackEntityAction; 
+                     case 3: return new afrl::cmasi::perceive::TrackEntityTask; 
+                  }
+
+            return nullptr;
+        }
+
+        uint32_t Factory::calculateChecksum(const uint8_t * bytes, const uint32_t size)
+        {
+            uint32_t sum = 0;
+            for (uint32_t i = 0; i < size - CHECKSUM_SIZE; i++)
+                sum += (uint32_t) bytes[i];
+            return sum & 0x00000000FFFFFFFF; // truncate value
+        }
+
+        uint32_t Factory::getObjectSize(const uint8_t * bytes, const uint32_t size)
+        {
+            uint32_t id = 0;
+            if (size >= HEADER_SIZE)
+            {
+                id |= (bytes[4] & 0xFF);
+                id <<= 8;
+                id |= (bytes[5] & 0xFF);
+                id <<= 8;
+                id |= (bytes[6] & 0xFF);
+                id <<= 8;
+                id |= (bytes[7] & 0xFF);
+            }
+            return id;
+        }
+
+        bool Factory::validate(const uint8_t * bytes, const uint32_t size)
+        {
+            uint32_t cs = 0;
+            if (size >= HEADER_SIZE + CHECKSUM_SIZE)
+            {
+                cs = 0;
+                cs |= (bytes[size - 4] & 0xFF);
+                cs <<= 8;
+                cs |= (bytes[size - 3] & 0xFF);
+                cs <<= 8;
+                cs |= (bytes[size - 2] & 0xFF);
+                cs <<= 8;
+                cs |= (bytes[size - 1] & 0xFF);
+                return (cs == 0) || (cs == calculateChecksum(bytes, size));
+            }
+            return false;
+        }
+
+    } // end namespace lmcp
+} // end namespace avtas
diff --git a/src/LMCP/avtas/lmcp/Factory.h b/src/LMCP/avtas/lmcp/Factory.h
new file mode 100644
index 0000000..95784b1
--- /dev/null
+++ b/src/LMCP/avtas/lmcp/Factory.h
@@ -0,0 +1,85 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AVTAS_LMCP_FACTORY_H_
+#define _AVTAS_LMCP_FACTORY_H_
+
+#include <cstdint>
+#include "avtas/lmcp/ByteBuffer.h"
+
+namespace avtas {
+namespace lmcp {
+
+   class Object;
+
+   class Factory {
+   public:
+      // Size (in bytes) of the default message header
+      static const uint32_t HEADER_SIZE;
+
+      // Size (in bytes) of the message checksum
+      static const uint32_t CHECKSUM_SIZE;
+
+      // Length in bytes of the message series name
+      static const uint32_t SERIESNAME_SIZE;
+
+      // "LMCP" control sequence, stated as a 4-byte integer
+      static const int32_t LMCP_CONTROL_STR;
+
+      // Destructor
+      virtual ~Factory(void);
+
+      // Adds an object to the buffer with all the proper header information
+      static void putObject(const Object* o, ByteBuffer & buffer);
+
+      // Should return pointer to a new message unpacked from given buffer.
+      // The buffer is assumed to be in bug endian byte order.
+      // To be implemented by subclass
+      static Object * getObject(ByteBuffer & buffer);
+
+      // Instantiates an empty object of the specified type
+      static avtas::lmcp::Object * createObject(int64_t series_id, uint32_t type, uint16_t version);
+
+      // Fills the given buffer with a message with the given instance id and 
+      // serialized root object. The checksum will be calculated if the
+      // enableChecksum flag is true. Returns true on success, false otherwise.
+      // The buffer is assumed to be in big endian byte order.
+      static ByteBuffer * packMessage(const Object * const rootObject, const bool enableChecksum = false);
+
+      // Computes the 32-bit checksum of a buffer using all but the last
+      // CHECKSUM_SIZE bytes in the buffer. Assumes the buffer is in
+      // big endian byte order.
+      static uint32_t calculateChecksum(const uint8_t * bytes, const uint32_t size);
+
+      // Returns size (in bytes) of the root object of the packed message in
+      // buffer. Assumes the buffer is in big endian byte order.
+      static uint32_t getObjectSize(const uint8_t * bytes, const uint32_t size);
+
+      // Validates a buffer by comparing the buffer's checksum with the
+      // calculated checksum value of that buffer. Assumes the buffer is
+      // in big endian byte order.
+      static bool validate(const uint8_t * bytes, const uint32_t size);
+
+   protected:
+      // Constructor
+      Factory(void);
+
+      // Copy Constructor
+      Factory(const Factory & that);
+
+      // Assignment Operator
+      Factory & operator=(const Factory & that);
+   };
+
+} // end namespace lmcp
+} // end namespace avtas
+
+#endif //_AVTAS_LMCP_FACTORY_H_
diff --git a/src/LMCP/avtas/lmcp/LmcpXMLReader.h b/src/LMCP/avtas/lmcp/LmcpXMLReader.h
new file mode 100644
index 0000000..5d591b9
--- /dev/null
+++ b/src/LMCP/avtas/lmcp/LmcpXMLReader.h
@@ -0,0 +1,104 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AVTAS_LMCP_LMCPXMLREADER_H_
+#define _AVTAS_LMCP_LMCPXMLREADER_H_
+
+#include "avtas/lmcp/Object.h"
+#include "avtas/lmcp/Node.h"
+#include "avtas/lmcp/NodeUtil.h"
+#include <vector>
+#include <string>
+#include <cstdint>
+#include <iostream>
+#include "avtas/lmcp/XMLParser.h"
+
+#include "uxas/messages/task/UXTASKXMLReader.h"
+#include "uxas/messages/uxnative/UXNATIVEXMLReader.h"
+#include "uxas/messages/route/ROUTEXMLReader.h"
+#include "afrl/cmasi/CMASIXMLReader.h"
+#include "afrl/impact/IMPACTXMLReader.h"
+#include "afrl/cmasi/perceive/PERCEIVEXMLReader.h"
+
+
+namespace avtas {
+namespace lmcp {
+namespace xml {
+
+        inline avtas::lmcp::Object* readXML(Node* node) {
+            if (node == nullptr) return nullptr;
+            if (node->getAttribute("Series") == "UXTASK") return uxas::messages::task::SeriesXMLReader::visitType(node);
+            if (node->getAttribute("Series") == "UXNATIVE") return uxas::messages::uxnative::SeriesXMLReader::visitType(node);
+            if (node->getAttribute("Series") == "ROUTE") return uxas::messages::route::SeriesXMLReader::visitType(node);
+            if (node->getAttribute("Series") == "CMASI") return afrl::cmasi::SeriesXMLReader::visitType(node);
+            if (node->getAttribute("Series") == "IMPACT") return afrl::impact::SeriesXMLReader::visitType(node);
+            if (node->getAttribute("Series") == "PERCEIVE") return afrl::cmasi::perceive::SeriesXMLReader::visitType(node);
+
+            return nullptr;
+        }
+
+        /** reads an LMCP XML string and returns an LMCP object */
+        inline avtas::lmcp::Object* readXML(std::string input) {
+            Node* el = avtas::lmcp::XMLParser::parseString(input, false);
+            return readXML(el);
+        }
+
+        inline bool get_bool(Node* node) {
+            return node->getBool(false);
+        }
+
+        inline char get_byte(Node* node) {
+            return (char) node->getInt(0);
+        }
+        
+        inline char get_char(Node* node) {
+            std::string str = node->getText();
+            return (char) str.size() == 0 ? 0 : str[0];
+        }
+
+        inline int16_t get_int16(Node* node) {
+            return (int16_t) node->getInt(0);
+        }
+
+        inline uint16_t get_uint16(Node* node) {
+            return (uint16_t) node->getInt(0);
+        }
+
+        inline int32_t get_int32(Node* node) {
+            return node->getInt(0);
+        }
+
+        inline uint32_t get_uint32(Node* node) {
+            return (uint32_t) node->getLong(0);
+        }
+
+        inline int64_t get_int64(Node* node) {
+            return node->getLong(0);
+        }
+
+        inline float get_real32(Node* node) {
+            return node->getFloat(0);
+        }
+
+        inline double get_real64(Node* node) {
+            return node->getDouble(0);
+        }
+
+        inline std::string get_string(Node* node) {
+            return node->getText();
+        }
+
+} // end namespace xml
+} // end namespace lmcp
+} // end namespace avtas
+
+#endif //_AVTAS_LMCP_LMCPXMLREADER_H
+
diff --git a/src/LMCP/avtas/lmcp/Node.cpp b/src/LMCP/avtas/lmcp/Node.cpp
new file mode 100644
index 0000000..fa4fd6a
--- /dev/null
+++ b/src/LMCP/avtas/lmcp/Node.cpp
@@ -0,0 +1,301 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "avtas/lmcp/Node.h"
+#include <algorithm>
+#include <iterator>
+#include <iostream>
+#include "avtas/lmcp/NodeUtil.h"
+
+namespace avtas {
+namespace lmcp {
+    
+    Node :: Node() {
+        this->name = "";
+        this->text = "";
+        this->parentNode = 0;
+    }
+    
+    Node :: Node(std::string tagName) {
+        this->name = tagName;
+        this->text = "";
+        this->parentNode = 0;
+    }
+    
+    Node :: Node(std::string tagName, std::string text) {
+        this->name = tagName;
+        this->text = text;
+        this->parentNode = 0;
+    }
+    
+    Node :: Node( Node& node) {
+        
+        name = node.getTagName();
+        text = node.getText();
+        
+        size_t cnt = node.getAttributeCount();
+        std::string* arry = new std::string[cnt] ;
+        node.getAttributeNames(arry);
+        
+        for(uint32_t i=0; i<cnt; i++) {
+            putAttribute(arry[i], node.getAttribute(arry[i]));
+        }
+        
+        cnt = node.getChildCount();
+        
+        for(uint32_t i=0; i<cnt; i++) {
+            Node* tmp = new Node( *node.getChild(i) );
+            addChild( tmp );
+        }
+        
+        delete [] arry;
+        
+    }
+    
+    Node :: ~Node() {
+        for(uint32_t i=0; i<childList.size(); i++)
+            delete childList[i];
+		childList.clear();
+    }
+    
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    std::string Node::getTagName(){
+        return this->name;
+    }
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    void Node::setTagName(std::string name) {
+        this->name = name;
+    }
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    Node* Node::addChild(std::string tagName) {
+        Node* child = new Node(tagName);
+        return addChild(child);
+    }
+    
+    Node* Node :: addChild(Node* child) {
+        childList.push_back(child);
+        child->setParent( this );
+        return child;
+    }
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    size_t Node :: getChildCount() {
+        return childList.size();
+    }
+    
+    Node* Node :: getChild(uint32_t index) {
+        if (index < getChildCount())
+            return childList[index];
+        
+        return 0;
+    }
+    
+    
+    /**
+     * Returns the first child encountered with specified name, or null
+     * if none is found.  To find a nested child, specify the childname
+     * as tags separated by "/"
+     */
+    Node* Node :: getChild(std::string childName) {
+        
+        Node* tmp = this;
+        
+        size_t splitPt = childName.find_first_of("/");
+        std::string tail = "";
+        
+        if (splitPt != std::string::npos) {
+            tail = childName.substr(splitPt + 1);
+            childName = childName.substr(0, splitPt);
+        }
+        
+        for(uint32_t i=0; i<tmp->childList.size(); i++) {
+            if ( tmp->childList[i]->getTagName() == childName){
+                if (tail != "")
+                    return childList[i]->getChild(tail);
+                else
+                    return childList[i];
+            }
+        }
+        return 0;
+    }
+
+    
+    /**
+     * Returns a vector containing all children encountered with specified name, or null
+     * if none are found.
+     */
+    std::vector<Node*> Node :: getChildren(std::string childName) {
+
+        std::vector <Node*> list;
+
+        Node* tmp = this;
+        
+        size_t splitPt = childName.find_first_of("/");
+        std::string tail = "";
+        
+        if (splitPt != std::string::npos) {
+            tail = childName.substr(splitPt + 1);
+            childName = childName.substr(0, splitPt);
+        }
+        
+        for(uint32_t i=0; i<tmp->childList.size(); i++) {
+            if ( tmp->childList[i]->getTagName() == childName){
+                if (tail != "") {
+                    std::vector <Node*> sublist = childList[i]->getChildren(tail);
+                    for(uint32_t j=0; j<sublist.size(); j++) {
+                        list.push_back( sublist[j]);
+                    }
+                } else {
+                    list.push_back( childList[i]);
+                }
+            }
+        }
+        
+        return list;
+        
+    }
+    
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    void Node::putAttribute(std::string name, std::string val) {
+        attrMap.insert( std::pair<std::string, std::string> (name, val) );
+    }
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    std::string Node::getAttribute(std::string name) {
+        if ( attrMap.count(name) == 1) {
+            return attrMap[name];
+        }
+        return 0;
+    }
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    void Node::getAttributeNames( std::string* storeArray ) {
+        std::map<std::string, std::string> :: const_iterator iter;
+        int i=0;
+        
+        for( iter = attrMap.begin(); iter != attrMap.end(); ++iter) {
+            storeArray[i] =  iter->first;
+            i++;
+        }
+    }
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    size_t Node :: getAttributeCount(){
+        
+        return this->attrMap.size();
+    }
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    std::string Node::getText(){
+        return this->text;
+    }
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    void Node::setText(std::string text) {
+        this->text = text;
+    }
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    Node* Node::getParent(){
+        return this->parentNode;
+    }
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    void Node::setParent(Node *parentNode) {
+        this->parentNode = parentNode;
+    }
+    
+    bool Node :: remove(Node* node) {
+        
+        std::vector <Node*> :: iterator it;
+        
+        for( it = childList.begin(); it<childList.end(); it++) {
+            
+            if ( *it == node ) {
+                childList.erase(it);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    
+    /** @brief (one liner)
+     *
+     * (documentation goes here)
+     */
+    std::string Node::toString() {
+        std::string ret = "<" + getTagName() + " ";
+        std::string* attrNames = new std::string[getAttributeCount()];
+        getAttributeNames( attrNames );
+        
+        for(uint32_t i=0; i<getAttributeCount(); i++) {
+            ret += (attrNames[i] + "=" + getAttribute(attrNames[i]) + " ");
+        }
+        ret += ">";
+        
+        for(uint32_t i=0; i<childList.size(); i++) {
+            ret += "\n";
+            ret += childList[i]->toString();
+        }
+        
+        if (getText() != "") {
+            ret += ("\n  " + getText() );
+        }
+        
+        ret += "\n</" + getTagName() + " ";
+        delete [] attrNames;
+        return ret;
+    }
+    
+    
+}
+}
diff --git a/src/LMCP/avtas/lmcp/Node.h b/src/LMCP/avtas/lmcp/Node.h
new file mode 100644
index 0000000..5d78665
--- /dev/null
+++ b/src/LMCP/avtas/lmcp/Node.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AVTAS_LMCP_NODE_H_
+#define _AVTAS_LMCP_NODE_H_
+
+#include <vector>
+#include <map>
+#include <iostream>
+#include <string>
+#include <cstdint>
+#include <cstdlib>
+
+namespace avtas {
+namespace lmcp {
+
+    class Node {
+
+    public:
+
+        Node();
+
+        Node( std::string tagName);
+
+        Node( std::string name, std::string text);
+        
+        Node( Node& );
+
+        ~Node();
+
+        std::string getTagName();
+
+        void setTagName(std::string name);
+
+        Node* addChild(std::string tagName);
+        
+        Node* addChild(Node* child);
+
+        size_t getChildCount();
+        
+        Node* getChild(std::string childName);
+
+        std::vector <Node*> getChildren(std::string childName);
+        
+        Node* getChild(unsigned int index);
+
+        void putAttribute(std::string name, std::string val);
+
+        std::string getAttribute(std::string name);
+
+        void getAttributeNames(std::string* storeArray);
+
+        size_t getAttributeCount();
+
+        std::string getText();
+
+        void setText( std::string text);
+
+        Node* getParent();
+
+        void setParent(Node *parentNode);
+
+        std::string toString();
+        
+        bool remove(Node* node);
+
+        /* convenience methods to get node text value */
+        int32_t getInt(int32_t defaultVal) { return atoi(getText().c_str()); }
+	
+        int64_t getLong(int64_t defaultVal) { return atoll(getText().c_str()); }
+	
+        float getFloat(float defaultVal) { return static_cast<float>(atof(getText().c_str())); }
+	
+        double getDouble(double defaultVal) { return atof(getText().c_str()); }
+	
+        bool getBool(bool defaultVal) {
+            std::string text = getText();
+        
+            for(unsigned int i=0; i<text.length(); i++) {
+                text[i] = toupper(text[i]);
+            }
+        
+            if ( text == "TRUE") return true;
+            if ( text == "FALSE") return false;
+        
+            return defaultVal;
+        }
+	
+        std::vector<std::string> splitString(std::string instr, char splitChar);
+
+    private:
+        
+        std::string name;
+        std::string text;
+        std::map <std::string, std::string> attrMap;
+        std::vector <Node*> childList;
+
+        Node* parentNode;
+
+    };
+
+}
+}
+
+#endif // _AVTAS_LMCP_NODE_H_
diff --git a/src/LMCP/avtas/lmcp/NodeUtil.cpp b/src/LMCP/avtas/lmcp/NodeUtil.cpp
new file mode 100644
index 0000000..db59ea0
--- /dev/null
+++ b/src/LMCP/avtas/lmcp/NodeUtil.cpp
@@ -0,0 +1,142 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "avtas/lmcp/NodeUtil.h"
+#include "avtas/lmcp/Node.h"
+#include "avtas/lmcp/XMLParser.h"
+
+#include <vector>
+#include <string>
+#include <cstdint>
+#include <iostream>
+
+namespace avtas {
+namespace lmcp {
+    
+    /** returns a list of nodes that contain the childName */
+    std::vector <Node*> NodeUtil :: getList(Node* parent, std::string childName) {
+        
+        if (parent == 0 ) return std::vector <Node*> ();
+        
+        return parent->getChildren(childName);
+    }
+    
+    std::string NodeUtil :: get( Node* parent, std::string pathName, std::string defaultVal) {
+        
+        if ( parent == 0 ) return defaultVal;
+        
+        Node* node = parent->getChild(pathName);
+        
+        if ( node == 0 ) return defaultVal;
+        
+        return node->getText();
+    }
+    
+    int NodeUtil :: getInt(Node* parent, std::string pathName, int32_t defaultVal) {
+        
+        if ( parent == 0 ) return defaultVal;
+        
+        Node* node = parent->getChild(pathName);
+        
+        if ( node == 0 ) return defaultVal;
+        
+        return atoi(node->getText().c_str());
+    }
+    
+    int64_t NodeUtil :: getLong(Node* parent, std::string pathName, int64_t defaultVal) {
+        
+        if ( parent == 0 ) return defaultVal;
+        
+        Node* node = parent->getChild(pathName);
+        
+        if ( node == 0 ) return defaultVal;
+        
+        return atoll(node->getText().c_str());
+    }
+    
+    double NodeUtil :: getDouble(Node* parent, std::string pathName, double defaultVal) {
+        
+        if ( parent == 0 ) return defaultVal;
+        
+        Node* node = parent->getChild(pathName);
+        
+        if ( node == 0 ) return defaultVal;
+        
+        return atof(node->getText().c_str());
+    }
+    
+    float NodeUtil :: getFloat(Node* parent, std::string pathName, float defaultVal) {
+        
+        if ( parent == 0 ) return defaultVal;
+        
+        Node* node = parent->getChild(pathName);
+        
+        if ( node == 0 ) return defaultVal;
+        
+        return (float) atof(node->getText().c_str());
+    }
+    
+    bool NodeUtil :: getBool(Node* parent, std::string pathName, bool defaultVal) {
+        
+        if ( parent == 0 ) return defaultVal;
+        
+        Node* node = parent->getChild(pathName);
+        if ( node == 0 ) return defaultVal;
+        
+        std::string text = node->getText();
+        
+        for(size_t i=0; i<text.length(); i++) {
+            text[i] = toupper(text[i]);
+        }
+        
+        if ( text == "TRUE") return true;
+        if ( text == "FALSE") return false;
+        
+        return defaultVal;
+    }
+    
+    std::vector<std::string> NodeUtil :: splitString(std::string inStr, char splitChar) {
+        
+        std::vector<std::string> retV;
+        
+        size_t startLoc = 0;
+        
+        const char* charStr = inStr.c_str();
+        size_t len = inStr.length();
+        
+        size_t i = 0;
+        while( i < len ) {
+            
+            //trim leading delimeters
+            while( i < len && ( charStr[i] == splitChar || XMLParser::isWhitespace(charStr[i])) ) {
+                i++;
+            }
+            
+            startLoc = i;
+            i++;
+            
+            while( i < len && charStr[i] != splitChar && !XMLParser::isWhitespace(charStr[i]) ) {
+                i++;
+            }
+            
+            if ( i > len) break;
+            
+            retV.push_back( inStr.substr(startLoc, i - startLoc));
+            
+        }
+        
+        return retV;
+        
+    }
+    
+}
+}
+
diff --git a/src/LMCP/avtas/lmcp/NodeUtil.h b/src/LMCP/avtas/lmcp/NodeUtil.h
new file mode 100644
index 0000000..cfe5edf
--- /dev/null
+++ b/src/LMCP/avtas/lmcp/NodeUtil.h
@@ -0,0 +1,45 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AVTAS_LMCP_NODEUTIL_H_
+#define _AVTAS_LMCP_NODEUTIL_H_
+
+#include <string>
+#include <cstdint>
+#include <vector>
+#include "avtas/lmcp/Node.h"
+
+namespace avtas {
+namespace lmcp {
+
+	class NodeUtil {
+		
+		public:
+		
+		/** traverses the parent's childList and returns a new Node
+		 *  that contains only the children that have the specified pathName.
+		 *  All children are added to the root of the childList
+		 */
+		static std::vector<Node*> getList(Node* parent, std::string childName);
+		
+		static std::string get(Node* node, std::string pathName, std::string defaultVal);
+		static int32_t getInt(Node* node, std::string pathName, int32_t defaultVal);
+		static int64_t getLong(Node* node, std::string pathName, int64_t defaultVal);
+		static float getFloat(Node* node, std::string pathName, float defaultVal);
+		static double getDouble(Node* node, std::string pathName, double defaultVal);
+		static bool getBool(Node* node, std::string pathName, bool defaultVal);
+		static std::vector<std::string> splitString(std::string instr, char splitChar);		
+	};	
+	
+}
+}
+
+#endif /* _AVTAS_LMCP_NODEUTIL_H_ */
diff --git a/src/LMCP/avtas/lmcp/Object.h b/src/LMCP/avtas/lmcp/Object.h
new file mode 100644
index 0000000..c74cb16
--- /dev/null
+++ b/src/LMCP/avtas/lmcp/Object.h
@@ -0,0 +1,98 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+// This class defines the base class for all LMCP objects
+
+#ifndef _AVTAS_LMCP_OBJECT_H_
+#define _AVTAS_LMCP_OBJECT_H_
+
+#include <string>
+#include <cstdint>
+#include "avtas/lmcp/ByteBuffer.h"
+
+namespace avtas {
+namespace lmcp {
+
+   class Factory;
+
+   class Object {
+   public:
+      // Destructor
+      virtual ~Object(void) {}
+
+      // Equals operators
+      bool operator==(const Object & that) { return true; };
+      bool operator!=(const Object & that) { return false; };
+
+      // Serializes calling object into a ByteBuffer.
+      // To be implemented by subclass.
+      virtual void pack(ByteBuffer & buf) const {}
+
+      // Deserializes ByteBuffer into calling object.
+      // To be implemented by subclass.
+      virtual void unpack(ByteBuffer & buf) {}
+
+      // Returns packed size, in bytes, of the object
+      // To be implemented by subclass.
+      virtual uint32_t calculatePackedSize(void) const { return 0; }
+
+      // Prints the object contents in a human readable format to a string.
+      // To be implemented by subclass.
+      virtual std::string toString(int32_t depth=0) const { return ""; }
+
+      // Prints the Object contents as an XML String.
+      // To be implemented by subclass.
+      virtual std::string toXML(int32_t depth =0) { return ""; }
+
+      // Returns the object type id corresponding to MDM
+      // To be implemented by subclass.
+      virtual uint32_t getLmcpType(void) const = 0;
+
+      // To be implemented by subclass.
+      virtual std::string getLmcpTypeName(void) const {
+         static std::string s_string("Object");
+         return s_string;
+      }
+	  
+      // To be implemented by subclass.
+      virtual std::string getFullLmcpTypeName(void) const {
+         static std::string s_string("avtas.lmcp.Object");
+         return s_string;
+      }
+
+      // creates a copy of this object and returns a pointer to it.
+      // To be implemented by subclass.
+      virtual Object* clone() const { return 0; }
+
+      // To be implemented by subclass.
+      virtual std::string getSeriesName(void) const = 0;
+      
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const = 0;
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const = 0;
+
+   protected:
+      // Constructor
+      Object(void) {}
+
+      // Copy Constructor
+      Object(const Object & that) {};
+
+      // Assignment Operator
+      Object & operator=(const Object & that) { return *this; }
+   };
+
+} // end namespace lmcp
+} // end namespace avtas
+
+#endif // _AVTAS_LMCP_OBJECT_H_
diff --git a/src/LMCP/avtas/lmcp/XMLParser.cpp b/src/LMCP/avtas/lmcp/XMLParser.cpp
new file mode 100644
index 0000000..0a67a8e
--- /dev/null
+++ b/src/LMCP/avtas/lmcp/XMLParser.cpp
@@ -0,0 +1,284 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "avtas/lmcp/XMLParser.h"
+#include <fstream>
+#include <sstream>
+#include <iostream>
+#include <stdlib.h>
+#include <string>
+#include <cstdint>
+
+namespace avtas {
+namespace lmcp {
+
+    XMLParser :: XMLParser() {}
+
+    XMLParser :: ~XMLParser() {}
+
+    /** @brief (one liner)
+      *
+      * (documentation goes here)
+      */
+    Node* XMLParser :: parse( std::string filename, bool treatAttributesAsChildren) {
+        std::ifstream fin( filename.c_str() );
+
+        if ( !fin ) {
+            std::cerr << "could not read file" << filename << std::endl;
+            return new Node("");
+        }
+
+        Node* node = parse( fin, treatAttributesAsChildren );
+        fin.close();
+        return node;
+    }
+    
+    Node* XMLParser :: parseString( std::string xmlString, bool treatAttributesAsChildren) {
+        std::istringstream fin( xmlString );
+
+        if ( !fin ) {
+            std::cerr << "could not read string" << xmlString << std::endl;
+            return new Node("");
+        }
+
+        Node* node = parse( fin, treatAttributesAsChildren );
+        return node;
+    }
+
+
+    /** @brief (one liner)
+      *
+      * (documentation goes here)
+      */
+    Node* XMLParser::parse( std::istream &r, bool treatAttributesAsChildren ) {
+
+        Node* rootNode = 0;
+        Node* node = 0;
+
+        std::string str = "";
+
+        while ( true) {
+            str = readChunk(r);
+
+            if (str == "")
+                break;
+
+            // declaration
+            if ( startsWith(str, "<?") ) {
+                while ( !endsWith(str, "?") ) {
+                    str += readChunk(r);
+                }
+                continue;
+            }
+
+            // comment
+            if ( startsWith(str, "<!--")) {
+                while ( !endsWith(str, "--")) {
+                    str += readChunk(r);
+                }
+                continue;
+            }
+
+            // instruction
+            if ( startsWith(str, "<!")) {
+                continue;
+            }
+
+            // cdata node
+            if ( startsWith(str, "<![CDATA[") ) {
+                while ( !endsWith(str, "]]") ) {
+                    str += readChunk(r);
+                }
+                continue;
+            }
+
+            // if this is a text node or close tag, set the element text
+            size_t i = str.find("</");
+            if ( i != std::string::npos && node != 0) {
+                node->setText( str.substr(0, i));
+                str = str.substr(i + 1);
+
+                    if ( (str.substr(1) == node->getTagName()) && node->getParent() != 0) {
+                        node = node->getParent();
+                    }
+
+                continue;
+            }
+
+            // regular element node
+            if ( startsWith(str, "<") ) {
+
+                str = str.substr(1);
+                if (rootNode == 0) {
+                    rootNode = new Node("");
+                    node = rootNode;
+                }
+                else {
+                    Node* tmpNode = node->addChild("");
+                    node = tmpNode;
+                }
+
+                size_t splitPt = str.find(" ");
+                if ( splitPt != std::string::npos) {
+                    std::string tag = str.substr(0, splitPt);
+                    node->setTagName(tag);
+                    putAttributes( str.substr(splitPt), node, treatAttributesAsChildren);
+                }
+                else {
+                    node->setTagName(str);
+                }
+
+                if ( str.rfind("/") == str.length() - 1 && node->getParent() != 0) {
+                    node = node->getParent();
+                }
+            }
+
+        }
+
+        return rootNode;
+
+    }
+
+    /** @brief (one liner)
+      *
+      * (documentation goes here)
+      */
+    std::string XMLParser::readChunk( std::istream &r ) {
+
+        std::string buf;
+        try {
+            int ch = r.get();
+            while ( ((char) ch) != '>') {
+                if ( ch == -1) {
+                    if (buf.length() > 0) {
+                        throw 0;
+                    }
+                    return "";
+                }
+                if ( !isWhitespace( (char) ch) || buf.length() > 0 ) {
+                    buf += (char) ch;
+                }
+                ch = r.get();
+            }
+
+        } catch (...) {
+            return "";
+        }
+
+        return buf;
+    }
+
+    /** @brief (one liner)
+      *
+      * (documentation goes here)
+      */
+    void XMLParser::subChars( std::string &srcStr ) {
+
+        size_t loc = srcStr.find( "&lt" );
+        while ( loc != std::string::npos ) {
+            srcStr.replace( loc, 3, "<" );
+            loc = srcStr.find( "&lt" );
+        }
+
+        loc = srcStr.find( "&gt" );
+        while ( loc != std::string::npos ) {
+            srcStr.replace( loc, 3, ">" );
+            loc = srcStr.find( "&gt" );
+        }
+
+        loc = srcStr.find( "&amp" );
+        while ( loc != std::string::npos ) {
+            srcStr.replace( loc, 4, "&" );
+            loc = srcStr.find( "&amp" );
+        }
+
+        loc = srcStr.find( "&apos" );
+        while ( loc != std::string::npos ) {
+            srcStr.replace( loc, 5, "'" );
+            loc = srcStr.find( "&apos" );
+        }
+
+        loc = srcStr.find( "&quot" );
+        while ( loc != std::string::npos ) {
+            srcStr.replace( loc, 5, "\"" );
+            loc = srcStr.find( "&quot" );
+        }
+
+    }
+
+    /** @brief (one liner)
+      *
+      * (documentation goes here)
+      */
+    std::string XMLParser::putAttributes( std::string str, Node* node, bool treatAsChildren ) {
+
+        try {
+            while ( str.length() > 0 ) {
+
+                while ( isWhitespace( str[ 0 ] ) ) {
+                    str = str.substr( 1, str.length() - 1 );
+                }
+                size_t nameEnd = str.find( "=\"", 0 );
+                if ( nameEnd == std::string::npos )
+                    return str;
+
+                size_t attrEnd = str.find( "\"", nameEnd + 3 );
+                if ( attrEnd == std::string::npos )
+                    throw 1;
+
+                std::string name = str.substr( 0, nameEnd );
+                std::string attr = str.substr( nameEnd + 2, attrEnd - nameEnd - 2 );
+
+                //subChars( name );
+                //subChars( attr );
+				if (treatAsChildren) {
+					Node* tmp = node->addChild(name);
+					tmp->setText(attr);	
+				} 
+				else {
+                	node->putAttribute( name, attr );
+				}
+                str = str.substr( attrEnd + 1 );
+
+            }
+        }
+        catch ( ... ) {
+            std::cerr << "error" << std::endl;
+        }
+        return str;
+
+    }
+
+
+    /** @brief (one liner)
+    *
+    * (documentation goes here)
+    */
+    bool XMLParser :: isWhitespace( char ch ) {
+
+        if ( ch == '\t' || ch == '\n' || ch == '\r' || ch == ' ' ) {
+            return true;
+        }
+        return false;
+    }
+
+    bool XMLParser :: startsWith(std::string str, std::string search) {
+
+            return  (str.find(search, 0) == 0);
+    }
+
+    bool XMLParser :: endsWith(std::string str, std::string search) {
+            size_t searchLimit = str.length() - search.length();
+            return ( str.rfind(search, searchLimit) == searchLimit );
+    }
+
+}
+}
diff --git a/src/LMCP/avtas/lmcp/XMLParser.h b/src/LMCP/avtas/lmcp/XMLParser.h
new file mode 100644
index 0000000..ae83bb0
--- /dev/null
+++ b/src/LMCP/avtas/lmcp/XMLParser.h
@@ -0,0 +1,54 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _AVTAS_LMCP_XMLPARSER_H_
+#define _AVTAS_LMCP_XMLPARSER_H_
+
+#include "Node.h"
+
+namespace avtas {
+namespace lmcp {
+
+
+    class XMLParser {
+
+    public:
+
+        XMLParser();
+        ~XMLParser();
+
+
+        static Node* parse (std::istream &reader, bool treatAttributesAsChildren);
+        static Node* parse (std::string filename, bool treatAttributesAsChildren);
+        static Node* parseString (std::string xmlString, bool treatAttributesAsChildren);
+        static bool isWhitespace(char ch);
+
+    private:
+
+        static std::string readChunk(std::istream &reader);
+
+        static void subChars(std::string &srcStr);
+
+        static std::string putAttributes(std::string str, Node* node, bool treatAsChildren);
+
+        static bool startsWith(std::string str, std::string search);
+
+        static bool endsWith(std::string str, std::string search);
+
+
+
+    };
+
+
+
+}
+}
+#endif //_AVTAS_LMCP_XMLPARSER_H_
diff --git a/src/LMCP/meson.build b/src/LMCP/meson.build
new file mode 100644
index 0000000..7b37232
--- /dev/null
+++ b/src/LMCP/meson.build
@@ -0,0 +1,180 @@
+incs_lmcp = include_directories('.')
+
+lib_lmcp = static_library(
+  'lmcp',
+  [
+    'avtas/lmcp/ByteBuffer.cpp',
+    'avtas/lmcp/Factory.cpp',
+    'avtas/lmcp/Node.cpp',
+    'avtas/lmcp/NodeUtil.cpp',
+    'avtas/lmcp/XMLParser.cpp',
+		'uxas/messages/task/uxasmessagestaskAssignmentCoordinatorTask.cpp',
+		'uxas/messages/task/uxasmessagestaskPlanningState.cpp',
+		'uxas/messages/task/uxasmessagestaskAssignmentCoordination.cpp',
+		'uxas/messages/task/uxasmessagestaskCoordinatedAutomationRequest.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskAutomationRequest.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskAutomationResponse.cpp',
+		'uxas/messages/task/uxasmessagestaskUniqueAutomationRequest.cpp',
+		'uxas/messages/task/uxasmessagestaskUniqueAutomationResponse.cpp',
+		'uxas/messages/task/uxasmessagestaskSensorFootprintRequests.cpp',
+		'uxas/messages/task/uxasmessagestaskFootprintRequest.cpp',
+		'uxas/messages/task/uxasmessagestaskSensorFootprint.cpp',
+		'uxas/messages/task/uxasmessagestaskSensorFootprintResponse.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskImplementationRequest.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskImplementationResponse.cpp',
+		'uxas/messages/task/uxasmessagestaskAssignmentCostMatrix.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskOptionCost.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskAssignment.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskAssignmentSummary.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskOption.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskPlanOptions.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskPause.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskResume.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskProgress.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskProgressRequest.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskInitialized.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskActive.cpp',
+		'uxas/messages/task/uxasmessagestaskTaskComplete.cpp',
+		'uxas/messages/task/uxasmessagestaskCancelTask.cpp',
+		'uxas/messages/task/UXTASKXMLReader.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeVideoRecord.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeStartupComplete.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeCreateNewService.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeKillService.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeIncrementWaypoint.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeEntityLocation.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeBandwidthTest.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeBandwidthReceiveReport.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeSubTaskExecution.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeSubTaskAssignment.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeAutopilotKeepAlive.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeOnboardProcessorIsAlive.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeEntityJoin.cpp',
+		'uxas/messages/uxnative/uxasmessagesuxnativeEntityExit.cpp',
+		'uxas/messages/uxnative/UXNATIVEXMLReader.cpp',
+		'uxas/messages/route/uxasmessagesrouteGraphNode.cpp',
+		'uxas/messages/route/uxasmessagesrouteGraphEdge.cpp',
+		'uxas/messages/route/uxasmessagesrouteGraphRegion.cpp',
+		'uxas/messages/route/uxasmessagesrouteRouteConstraints.cpp',
+		'uxas/messages/route/uxasmessagesrouteRouteRequest.cpp',
+		'uxas/messages/route/uxasmessagesrouteRoutePlanRequest.cpp',
+		'uxas/messages/route/uxasmessagesrouteRoutePlan.cpp',
+		'uxas/messages/route/uxasmessagesrouteRoutePlanResponse.cpp',
+		'uxas/messages/route/uxasmessagesrouteRouteResponse.cpp',
+		'uxas/messages/route/uxasmessagesrouteEgressRouteRequest.cpp',
+		'uxas/messages/route/uxasmessagesrouteEgressRouteResponse.cpp',
+		'uxas/messages/route/ROUTEXMLReader.cpp',
+		'afrl/cmasi/afrlcmasiAbstractGeometry.cpp',
+		'afrl/cmasi/afrlcmasiKeyValuePair.cpp',
+		'afrl/cmasi/afrlcmasiLocation3D.cpp',
+		'afrl/cmasi/afrlcmasiPayloadAction.cpp',
+		'afrl/cmasi/afrlcmasiPayloadConfiguration.cpp',
+		'afrl/cmasi/afrlcmasiPayloadState.cpp',
+		'afrl/cmasi/afrlcmasiVehicleAction.cpp',
+		'afrl/cmasi/afrlcmasiTask.cpp',
+		'afrl/cmasi/afrlcmasiSearchTask.cpp',
+		'afrl/cmasi/afrlcmasiAbstractZone.cpp',
+		'afrl/cmasi/afrlcmasiEntityConfiguration.cpp',
+		'afrl/cmasi/afrlcmasiFlightProfile.cpp',
+		'afrl/cmasi/afrlcmasiAirVehicleConfiguration.cpp',
+		'afrl/cmasi/afrlcmasiEntityState.cpp',
+		'afrl/cmasi/afrlcmasiAirVehicleState.cpp',
+		'afrl/cmasi/afrlcmasiWedge.cpp',
+		'afrl/cmasi/afrlcmasiAreaSearchTask.cpp',
+		'afrl/cmasi/afrlcmasiCameraAction.cpp',
+		'afrl/cmasi/afrlcmasiCameraConfiguration.cpp',
+		'afrl/cmasi/afrlcmasiGimballedPayloadState.cpp',
+		'afrl/cmasi/afrlcmasiCameraState.cpp',
+		'afrl/cmasi/afrlcmasiCircle.cpp',
+		'afrl/cmasi/afrlcmasiGimbalAngleAction.cpp',
+		'afrl/cmasi/afrlcmasiGimbalConfiguration.cpp',
+		'afrl/cmasi/afrlcmasiGimbalScanAction.cpp',
+		'afrl/cmasi/afrlcmasiGimbalStareAction.cpp',
+		'afrl/cmasi/afrlcmasiGimbalState.cpp',
+		'afrl/cmasi/afrlcmasiGoToWaypointAction.cpp',
+		'afrl/cmasi/afrlcmasiKeepInZone.cpp',
+		'afrl/cmasi/afrlcmasiKeepOutZone.cpp',
+		'afrl/cmasi/afrlcmasiLineSearchTask.cpp',
+		'afrl/cmasi/afrlcmasiNavigationAction.cpp',
+		'afrl/cmasi/afrlcmasiLoiterAction.cpp',
+		'afrl/cmasi/afrlcmasiLoiterTask.cpp',
+		'afrl/cmasi/afrlcmasiWaypoint.cpp',
+		'afrl/cmasi/afrlcmasiMissionCommand.cpp',
+		'afrl/cmasi/afrlcmasiMustFlyTask.cpp',
+		'afrl/cmasi/afrlcmasiOperatorSignal.cpp',
+		'afrl/cmasi/afrlcmasiOperatingRegion.cpp',
+		'afrl/cmasi/afrlcmasiAutomationRequest.cpp',
+		'afrl/cmasi/afrlcmasiPointSearchTask.cpp',
+		'afrl/cmasi/afrlcmasiPolygon.cpp',
+		'afrl/cmasi/afrlcmasiRectangle.cpp',
+		'afrl/cmasi/afrlcmasiRemoveTasks.cpp',
+		'afrl/cmasi/afrlcmasiServiceStatus.cpp',
+		'afrl/cmasi/afrlcmasiSessionStatus.cpp',
+		'afrl/cmasi/afrlcmasiVehicleActionCommand.cpp',
+		'afrl/cmasi/afrlcmasiVideoStreamAction.cpp',
+		'afrl/cmasi/afrlcmasiVideoStreamConfiguration.cpp',
+		'afrl/cmasi/afrlcmasiVideoStreamState.cpp',
+		'afrl/cmasi/afrlcmasiAutomationResponse.cpp',
+		'afrl/cmasi/afrlcmasiRemoveZones.cpp',
+		'afrl/cmasi/afrlcmasiRemoveEntities.cpp',
+		'afrl/cmasi/afrlcmasiFlightDirectorAction.cpp',
+		'afrl/cmasi/afrlcmasiWeatherReport.cpp',
+		'afrl/cmasi/afrlcmasiFollowPathCommand.cpp',
+		'afrl/cmasi/afrlcmasiPathWaypoint.cpp',
+		'afrl/cmasi/afrlcmasiStopMovementAction.cpp',
+		'afrl/cmasi/afrlcmasiWaypointTransfer.cpp',
+		'afrl/cmasi/afrlcmasiPayloadStowAction.cpp',
+		'afrl/cmasi/CMASIXMLReader.cpp',
+		'afrl/impact/afrlimpactPowerConfiguration.cpp',
+		'afrl/impact/afrlimpactRadioConfiguration.cpp',
+		'afrl/impact/afrlimpactRadioTowerConfiguration.cpp',
+		'afrl/impact/afrlimpactRadioState.cpp',
+		'afrl/impact/afrlimpactRadioTowerState.cpp',
+		'afrl/impact/afrlimpactImpactPayloadConfiguration.cpp',
+		'afrl/impact/afrlimpactDeployImpactPayload.cpp',
+		'afrl/impact/afrlimpactPowerPlantState.cpp',
+		'afrl/impact/afrlimpactBatchRoutePlanRequest.cpp',
+		'afrl/impact/afrlimpactBatchRoutePlanResponse.cpp',
+		'afrl/impact/afrlimpactTaskTimingPair.cpp',
+		'afrl/impact/afrlimpactBatchSummaryRequest.cpp',
+		'afrl/impact/afrlimpactBatchSummaryResponse.cpp',
+		'afrl/impact/afrlimpactTaskSummary.cpp',
+		'afrl/impact/afrlimpactVehicleSummary.cpp',
+		'afrl/impact/afrlimpactImpactHeartbeat.cpp',
+		'afrl/impact/afrlimpactImpactComponentJoin.cpp',
+		'afrl/impact/afrlimpactImpactComponentLeave.cpp',
+		'afrl/impact/afrlimpactSpeedAltPair.cpp',
+		'afrl/impact/afrlimpactImpactAutomationRequest.cpp',
+		'afrl/impact/afrlimpactImpactAutomationResponse.cpp',
+		'afrl/impact/afrlimpactPointOfInterest.cpp',
+		'afrl/impact/afrlimpactLineOfInterest.cpp',
+		'afrl/impact/afrlimpactAreaOfInterest.cpp',
+		'afrl/impact/afrlimpactImpactPointSearchTask.cpp',
+		'afrl/impact/afrlimpactPatternSearchTask.cpp',
+		'afrl/impact/afrlimpactAngledAreaSearchTask.cpp',
+		'afrl/impact/afrlimpactImpactLineSearchTask.cpp',
+		'afrl/impact/afrlimpactWatchTask.cpp',
+		'afrl/impact/afrlimpactMultiVehicleWatchTask.cpp',
+		'afrl/impact/afrlimpactCommRelayTask.cpp',
+		'afrl/impact/afrlimpactCordonTask.cpp',
+		'afrl/impact/afrlimpactBlockadeTask.cpp',
+		'afrl/impact/afrlimpactEscortTask.cpp',
+		'afrl/impact/afrlimpactConfigurationRequest.cpp',
+		'afrl/impact/afrlimpactGroundVehicleConfiguration.cpp',
+		'afrl/impact/afrlimpactGroundVehicleState.cpp',
+		'afrl/impact/afrlimpactWaterReport.cpp',
+		'afrl/impact/afrlimpactWaterZone.cpp',
+		'afrl/impact/afrlimpactSurfaceVehicleConfiguration.cpp',
+		'afrl/impact/afrlimpactSurfaceVehicleState.cpp',
+		'afrl/impact/IMPACTXMLReader.cpp',
+		'afrl/cmasi/perceive/afrlcmasiperceiveEntityPerception.cpp',
+		'afrl/cmasi/perceive/afrlcmasiperceiveTrackEntityAction.cpp',
+		'afrl/cmasi/perceive/afrlcmasiperceiveTrackEntityTask.cpp',
+		'afrl/cmasi/perceive/PERCEIVEXMLReader.cpp',
+
+  ],
+  cpp_args: [
+    '-std=c++11',
+    '-Wall',
+  ]
+)
diff --git a/src/LMCP/test/client/Makefile b/src/LMCP/test/client/Makefile
new file mode 100644
index 0000000..2c0e831
--- /dev/null
+++ b/src/LMCP/test/client/Makefile
@@ -0,0 +1,39 @@
+## This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+SRCFILES=main.cpp
+
+CC=g++
+
+CFLAGS=-DLINUX -std=c++11 -Wall
+
+LDFLAGS=-static
+
+SRC=$(SRCFILES)
+
+LIBS=-L../..
+LIBS+=-llmcp
+
+INCS=-I../.. 
+
+OBJ=$(SRC:.cpp=.o)
+
+EXE=test_client
+
+RM=rm -f
+
+.PHONY: all 
+.PHONY: clean
+.PHONY: invoker 
+
+all: $(LIB) $(EXE)
+
+exe: $(EXE)
+	
+%.o: %.cpp 
+	$(CC) $(CFLAGS) $(INCS) -o $@ -c $<
+
+$(EXE): $(OBJ)
+	$(CC) $(OBJ) -o $@ $(LDFLAGS) $(LIBS)
+
+clean: 
+	-$(RM) $(OBJ) $(EXE)
diff --git a/src/LMCP/test/client/TestClient.vcproj b/src/LMCP/test/client/TestClient.vcproj
new file mode 100644
index 0000000..a5f8079
--- /dev/null
+++ b/src/LMCP/test/client/TestClient.vcproj
@@ -0,0 +1,185 @@
+<!-- This file was auto-created by LmcpGen. Modifications will be overwritten. -->
+<?xml version="1.0" encoding="UTF-8"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="TestClient"
+	ProjectGUID="{DAF2C1E8-EBFA-416F-BE77-2CEF06264CFD}"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="0"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+                                AdditionalIncludeDirectories="..\..\"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib wsock32.lib ..\..\Debug/LMCPBuild.lib"
+				LinkIncremental="2"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+                                AdditionalIncludeDirectories="..\..\"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib wsock32.lib ..\..\Release\LMCPBuild.lib"
+				LinkIncremental="1"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{28F0AC9A-A0DC-4F46-A5E9-9E68031EE48E}"
+			>
+		</Filter>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{90589DA6-1C4E-42B7-880D-031AAA5377D6}"
+			>
+			<File
+				RelativePath=".\main.cpp"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/src/LMCP/test/client/TestClient.vcxproj b/src/LMCP/test/client/TestClient.vcxproj
new file mode 100644
index 0000000..10ce7d3
--- /dev/null
+++ b/src/LMCP/test/client/TestClient.vcxproj
@@ -0,0 +1,93 @@
+<!-- This file was auto-created by LmcpGen. Modifications will be overwritten. -->
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{EF9AE7C3-DA6C-4644-8D0E-73AAB0200089}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <PlatformToolset>v120</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <PlatformToolset>v120</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>12.0.21005.1</_ProjectFileVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>Debug\</OutDir>
+    <IntDir>Debug\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>Release\</OutDir>
+    <IntDir>Release\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\..\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader />
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>ws2_32.lib;wsock32.lib;..\..\Debug/LMCPBuild.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <AdditionalIncludeDirectories>..\..\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <PrecompiledHeader />
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>ws2_32.lib;wsock32.lib;..\..\Release\LMCPBuild.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="main.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
diff --git a/src/LMCP/test/client/main.cpp b/src/LMCP/test/client/main.cpp
new file mode 100644
index 0000000..3c9c67f
--- /dev/null
+++ b/src/LMCP/test/client/main.cpp
@@ -0,0 +1,1556 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+// Utility libraries from standard c++
+# ifdef LINUX
+#include <arpa/inet.h>
+#include <cstring> // memcpy
+#endif
+#include <string>
+#include <cstdint>
+#include <iostream>
+#include <vector>
+
+// Include appropriate socket implementation headers.
+# ifdef WIN32
+#include <winsock.h>
+#endif
+#define socklen_t int
+
+#include "avtas/lmcp/ByteBuffer.h"
+#include "avtas/lmcp/Factory.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/task/UXTASK.h"
+#include "uxas/messages/uxnative/UXNATIVE.h"
+#include "uxas/messages/route/ROUTE.h"
+#include "afrl/cmasi/CMASI.h"
+#include "afrl/impact/IMPACT.h"
+#include "afrl/cmasi/perceive/PERCEIVE.h"
+
+
+# ifdef LINUX
+typedef int SOCKET;
+int SOCKET_ERROR = -1;  // error return code for socket()
+int INVALID_SOCKET = -1;  // error return code for connect()
+#endif
+
+void SendMessages(SOCKET);
+bool EstablishConnection(SOCKET&, int, std::string&);
+
+// Define the main method.
+int main(int argc, char* argv[])
+{
+	int port = 11041;
+	std::string host = "127.0.0.1";
+  
+	// create connection
+	SOCKET connectionSocket;
+	while( !EstablishConnection(connectionSocket,port,host) )
+	{
+		std::cout << "Could not establish connection!" << std::endl;
+	}
+
+	// send initial messages
+	SendMessages(connectionSocket);
+
+	// Create the buffer to hold incoming messages. Choosing an arbitrarily large sized
+	// buffer big enough to hold any message we want to receive.
+	uint32_t bufferSize = 1048576;
+	char* buffer = new char[bufferSize];
+
+	// display any messages coming across network
+	avtas::lmcp::ByteBuffer buf;
+	avtas::lmcp::Object* obj;
+	for(;;)
+	{
+		int bytesReceived = recv(connectionSocket, buffer, bufferSize, 0);
+
+		if(bytesReceived <= 0)
+		{
+			std::cout << "Connection closed or message receive error. Reconnecting ..." << std::endl;
+			while( !EstablishConnection(connectionSocket,port,host) )
+			{
+				std::cout << "Could not establish connection!" << std::endl;
+			}
+			SendMessages(connectionSocket);
+			continue;
+		}
+		
+		// potentially received multiple messages back-to-back
+		int offsetindex = 0;
+		while(bytesReceived > static_cast<int>(avtas::lmcp::Factory::HEADER_SIZE))
+		{
+			uint8_t* startByte = (uint8_t*) &buffer[offsetindex];
+			uint32_t objsize = avtas::lmcp::Factory::getObjectSize(startByte, avtas::lmcp::Factory::HEADER_SIZE);
+			objsize += avtas::lmcp::Factory::HEADER_SIZE + avtas::lmcp::Factory::CHECKSUM_SIZE;
+				
+			// process message
+			buf.allocate(objsize);
+                        buf.rewind();
+			memcpy(buf.array(),startByte,objsize);
+			bytesReceived -= objsize;
+			offsetindex += objsize;
+			obj = avtas::lmcp::Factory::getObject(buf);
+			if(!obj)
+			{
+				std::cout << "Invalid message format" << std::endl;
+				continue;
+			}
+			std::cout << obj->toString() << std::endl;
+			delete obj;
+		}
+	}
+}
+
+
+void SendMessages(SOCKET connectionSocket)
+{
+	// send out all of messages
+	avtas::lmcp::ByteBuffer* sendBuf = nullptr;
+	uint8_t* pBuf = nullptr;
+
+	uxas::messages::task::AssignmentCoordinatorTask* _uxasmessagestaskassignmentcoordinatortask = new uxas::messages::task::AssignmentCoordinatorTask();
+	std::cout << "Sending uxas::messages::task::AssignmentCoordinatorTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestaskassignmentcoordinatortask, true);
+	delete _uxasmessagestaskassignmentcoordinatortask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::PlanningState* _uxasmessagestaskplanningstate = new uxas::messages::task::PlanningState();
+	std::cout << "Sending uxas::messages::task::PlanningState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestaskplanningstate, true);
+	delete _uxasmessagestaskplanningstate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::AssignmentCoordination* _uxasmessagestaskassignmentcoordination = new uxas::messages::task::AssignmentCoordination();
+	std::cout << "Sending uxas::messages::task::AssignmentCoordination" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestaskassignmentcoordination, true);
+	delete _uxasmessagestaskassignmentcoordination;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::CoordinatedAutomationRequest* _uxasmessagestaskcoordinatedautomationrequest = new uxas::messages::task::CoordinatedAutomationRequest();
+	std::cout << "Sending uxas::messages::task::CoordinatedAutomationRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestaskcoordinatedautomationrequest, true);
+	delete _uxasmessagestaskcoordinatedautomationrequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskAutomationRequest* _uxasmessagestasktaskautomationrequest = new uxas::messages::task::TaskAutomationRequest();
+	std::cout << "Sending uxas::messages::task::TaskAutomationRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskautomationrequest, true);
+	delete _uxasmessagestasktaskautomationrequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskAutomationResponse* _uxasmessagestasktaskautomationresponse = new uxas::messages::task::TaskAutomationResponse();
+	std::cout << "Sending uxas::messages::task::TaskAutomationResponse" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskautomationresponse, true);
+	delete _uxasmessagestasktaskautomationresponse;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::UniqueAutomationRequest* _uxasmessagestaskuniqueautomationrequest = new uxas::messages::task::UniqueAutomationRequest();
+	std::cout << "Sending uxas::messages::task::UniqueAutomationRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestaskuniqueautomationrequest, true);
+	delete _uxasmessagestaskuniqueautomationrequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::UniqueAutomationResponse* _uxasmessagestaskuniqueautomationresponse = new uxas::messages::task::UniqueAutomationResponse();
+	std::cout << "Sending uxas::messages::task::UniqueAutomationResponse" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestaskuniqueautomationresponse, true);
+	delete _uxasmessagestaskuniqueautomationresponse;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::SensorFootprintRequests* _uxasmessagestasksensorfootprintrequests = new uxas::messages::task::SensorFootprintRequests();
+	std::cout << "Sending uxas::messages::task::SensorFootprintRequests" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasksensorfootprintrequests, true);
+	delete _uxasmessagestasksensorfootprintrequests;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::FootprintRequest* _uxasmessagestaskfootprintrequest = new uxas::messages::task::FootprintRequest();
+	std::cout << "Sending uxas::messages::task::FootprintRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestaskfootprintrequest, true);
+	delete _uxasmessagestaskfootprintrequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::SensorFootprint* _uxasmessagestasksensorfootprint = new uxas::messages::task::SensorFootprint();
+	std::cout << "Sending uxas::messages::task::SensorFootprint" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasksensorfootprint, true);
+	delete _uxasmessagestasksensorfootprint;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::SensorFootprintResponse* _uxasmessagestasksensorfootprintresponse = new uxas::messages::task::SensorFootprintResponse();
+	std::cout << "Sending uxas::messages::task::SensorFootprintResponse" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasksensorfootprintresponse, true);
+	delete _uxasmessagestasksensorfootprintresponse;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskImplementationRequest* _uxasmessagestasktaskimplementationrequest = new uxas::messages::task::TaskImplementationRequest();
+	std::cout << "Sending uxas::messages::task::TaskImplementationRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskimplementationrequest, true);
+	delete _uxasmessagestasktaskimplementationrequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskImplementationResponse* _uxasmessagestasktaskimplementationresponse = new uxas::messages::task::TaskImplementationResponse();
+	std::cout << "Sending uxas::messages::task::TaskImplementationResponse" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskimplementationresponse, true);
+	delete _uxasmessagestasktaskimplementationresponse;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::AssignmentCostMatrix* _uxasmessagestaskassignmentcostmatrix = new uxas::messages::task::AssignmentCostMatrix();
+	std::cout << "Sending uxas::messages::task::AssignmentCostMatrix" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestaskassignmentcostmatrix, true);
+	delete _uxasmessagestaskassignmentcostmatrix;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskOptionCost* _uxasmessagestasktaskoptioncost = new uxas::messages::task::TaskOptionCost();
+	std::cout << "Sending uxas::messages::task::TaskOptionCost" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskoptioncost, true);
+	delete _uxasmessagestasktaskoptioncost;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskAssignment* _uxasmessagestasktaskassignment = new uxas::messages::task::TaskAssignment();
+	std::cout << "Sending uxas::messages::task::TaskAssignment" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskassignment, true);
+	delete _uxasmessagestasktaskassignment;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskAssignmentSummary* _uxasmessagestasktaskassignmentsummary = new uxas::messages::task::TaskAssignmentSummary();
+	std::cout << "Sending uxas::messages::task::TaskAssignmentSummary" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskassignmentsummary, true);
+	delete _uxasmessagestasktaskassignmentsummary;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskOption* _uxasmessagestasktaskoption = new uxas::messages::task::TaskOption();
+	std::cout << "Sending uxas::messages::task::TaskOption" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskoption, true);
+	delete _uxasmessagestasktaskoption;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskPlanOptions* _uxasmessagestasktaskplanoptions = new uxas::messages::task::TaskPlanOptions();
+	std::cout << "Sending uxas::messages::task::TaskPlanOptions" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskplanoptions, true);
+	delete _uxasmessagestasktaskplanoptions;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskPause* _uxasmessagestasktaskpause = new uxas::messages::task::TaskPause();
+	std::cout << "Sending uxas::messages::task::TaskPause" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskpause, true);
+	delete _uxasmessagestasktaskpause;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskResume* _uxasmessagestasktaskresume = new uxas::messages::task::TaskResume();
+	std::cout << "Sending uxas::messages::task::TaskResume" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskresume, true);
+	delete _uxasmessagestasktaskresume;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskProgress* _uxasmessagestasktaskprogress = new uxas::messages::task::TaskProgress();
+	std::cout << "Sending uxas::messages::task::TaskProgress" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskprogress, true);
+	delete _uxasmessagestasktaskprogress;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskProgressRequest* _uxasmessagestasktaskprogressrequest = new uxas::messages::task::TaskProgressRequest();
+	std::cout << "Sending uxas::messages::task::TaskProgressRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskprogressrequest, true);
+	delete _uxasmessagestasktaskprogressrequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskInitialized* _uxasmessagestasktaskinitialized = new uxas::messages::task::TaskInitialized();
+	std::cout << "Sending uxas::messages::task::TaskInitialized" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskinitialized, true);
+	delete _uxasmessagestasktaskinitialized;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskActive* _uxasmessagestasktaskactive = new uxas::messages::task::TaskActive();
+	std::cout << "Sending uxas::messages::task::TaskActive" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskactive, true);
+	delete _uxasmessagestasktaskactive;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::TaskComplete* _uxasmessagestasktaskcomplete = new uxas::messages::task::TaskComplete();
+	std::cout << "Sending uxas::messages::task::TaskComplete" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestasktaskcomplete, true);
+	delete _uxasmessagestasktaskcomplete;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::task::CancelTask* _uxasmessagestaskcanceltask = new uxas::messages::task::CancelTask();
+	std::cout << "Sending uxas::messages::task::CancelTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagestaskcanceltask, true);
+	delete _uxasmessagestaskcanceltask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::VideoRecord* _uxasmessagesuxnativevideorecord = new uxas::messages::uxnative::VideoRecord();
+	std::cout << "Sending uxas::messages::uxnative::VideoRecord" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativevideorecord, true);
+	delete _uxasmessagesuxnativevideorecord;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::StartupComplete* _uxasmessagesuxnativestartupcomplete = new uxas::messages::uxnative::StartupComplete();
+	std::cout << "Sending uxas::messages::uxnative::StartupComplete" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativestartupcomplete, true);
+	delete _uxasmessagesuxnativestartupcomplete;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::CreateNewService* _uxasmessagesuxnativecreatenewservice = new uxas::messages::uxnative::CreateNewService();
+	std::cout << "Sending uxas::messages::uxnative::CreateNewService" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativecreatenewservice, true);
+	delete _uxasmessagesuxnativecreatenewservice;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::KillService* _uxasmessagesuxnativekillservice = new uxas::messages::uxnative::KillService();
+	std::cout << "Sending uxas::messages::uxnative::KillService" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativekillservice, true);
+	delete _uxasmessagesuxnativekillservice;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::IncrementWaypoint* _uxasmessagesuxnativeincrementwaypoint = new uxas::messages::uxnative::IncrementWaypoint();
+	std::cout << "Sending uxas::messages::uxnative::IncrementWaypoint" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativeincrementwaypoint, true);
+	delete _uxasmessagesuxnativeincrementwaypoint;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::EntityLocation* _uxasmessagesuxnativeentitylocation = new uxas::messages::uxnative::EntityLocation();
+	std::cout << "Sending uxas::messages::uxnative::EntityLocation" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativeentitylocation, true);
+	delete _uxasmessagesuxnativeentitylocation;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::BandwidthTest* _uxasmessagesuxnativebandwidthtest = new uxas::messages::uxnative::BandwidthTest();
+	std::cout << "Sending uxas::messages::uxnative::BandwidthTest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativebandwidthtest, true);
+	delete _uxasmessagesuxnativebandwidthtest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::BandwidthReceiveReport* _uxasmessagesuxnativebandwidthreceivereport = new uxas::messages::uxnative::BandwidthReceiveReport();
+	std::cout << "Sending uxas::messages::uxnative::BandwidthReceiveReport" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativebandwidthreceivereport, true);
+	delete _uxasmessagesuxnativebandwidthreceivereport;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::SubTaskExecution* _uxasmessagesuxnativesubtaskexecution = new uxas::messages::uxnative::SubTaskExecution();
+	std::cout << "Sending uxas::messages::uxnative::SubTaskExecution" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativesubtaskexecution, true);
+	delete _uxasmessagesuxnativesubtaskexecution;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::SubTaskAssignment* _uxasmessagesuxnativesubtaskassignment = new uxas::messages::uxnative::SubTaskAssignment();
+	std::cout << "Sending uxas::messages::uxnative::SubTaskAssignment" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativesubtaskassignment, true);
+	delete _uxasmessagesuxnativesubtaskassignment;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::AutopilotKeepAlive* _uxasmessagesuxnativeautopilotkeepalive = new uxas::messages::uxnative::AutopilotKeepAlive();
+	std::cout << "Sending uxas::messages::uxnative::AutopilotKeepAlive" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativeautopilotkeepalive, true);
+	delete _uxasmessagesuxnativeautopilotkeepalive;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::OnboardProcessorIsAlive* _uxasmessagesuxnativeonboardprocessorisalive = new uxas::messages::uxnative::OnboardProcessorIsAlive();
+	std::cout << "Sending uxas::messages::uxnative::OnboardProcessorIsAlive" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativeonboardprocessorisalive, true);
+	delete _uxasmessagesuxnativeonboardprocessorisalive;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::EntityJoin* _uxasmessagesuxnativeentityjoin = new uxas::messages::uxnative::EntityJoin();
+	std::cout << "Sending uxas::messages::uxnative::EntityJoin" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativeentityjoin, true);
+	delete _uxasmessagesuxnativeentityjoin;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::uxnative::EntityExit* _uxasmessagesuxnativeentityexit = new uxas::messages::uxnative::EntityExit();
+	std::cout << "Sending uxas::messages::uxnative::EntityExit" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesuxnativeentityexit, true);
+	delete _uxasmessagesuxnativeentityexit;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::route::GraphNode* _uxasmessagesroutegraphnode = new uxas::messages::route::GraphNode();
+	std::cout << "Sending uxas::messages::route::GraphNode" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesroutegraphnode, true);
+	delete _uxasmessagesroutegraphnode;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::route::GraphEdge* _uxasmessagesroutegraphedge = new uxas::messages::route::GraphEdge();
+	std::cout << "Sending uxas::messages::route::GraphEdge" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesroutegraphedge, true);
+	delete _uxasmessagesroutegraphedge;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::route::GraphRegion* _uxasmessagesroutegraphregion = new uxas::messages::route::GraphRegion();
+	std::cout << "Sending uxas::messages::route::GraphRegion" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesroutegraphregion, true);
+	delete _uxasmessagesroutegraphregion;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::route::RouteConstraints* _uxasmessagesrouterouteconstraints = new uxas::messages::route::RouteConstraints();
+	std::cout << "Sending uxas::messages::route::RouteConstraints" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesrouterouteconstraints, true);
+	delete _uxasmessagesrouterouteconstraints;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::route::RouteRequest* _uxasmessagesrouterouterequest = new uxas::messages::route::RouteRequest();
+	std::cout << "Sending uxas::messages::route::RouteRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesrouterouterequest, true);
+	delete _uxasmessagesrouterouterequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::route::RoutePlanRequest* _uxasmessagesrouterouteplanrequest = new uxas::messages::route::RoutePlanRequest();
+	std::cout << "Sending uxas::messages::route::RoutePlanRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesrouterouteplanrequest, true);
+	delete _uxasmessagesrouterouteplanrequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::route::RoutePlan* _uxasmessagesrouterouteplan = new uxas::messages::route::RoutePlan();
+	std::cout << "Sending uxas::messages::route::RoutePlan" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesrouterouteplan, true);
+	delete _uxasmessagesrouterouteplan;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::route::RoutePlanResponse* _uxasmessagesrouterouteplanresponse = new uxas::messages::route::RoutePlanResponse();
+	std::cout << "Sending uxas::messages::route::RoutePlanResponse" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesrouterouteplanresponse, true);
+	delete _uxasmessagesrouterouteplanresponse;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::route::RouteResponse* _uxasmessagesrouterouteresponse = new uxas::messages::route::RouteResponse();
+	std::cout << "Sending uxas::messages::route::RouteResponse" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesrouterouteresponse, true);
+	delete _uxasmessagesrouterouteresponse;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::route::EgressRouteRequest* _uxasmessagesrouteegressrouterequest = new uxas::messages::route::EgressRouteRequest();
+	std::cout << "Sending uxas::messages::route::EgressRouteRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesrouteegressrouterequest, true);
+	delete _uxasmessagesrouteegressrouterequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	uxas::messages::route::EgressRouteResponse* _uxasmessagesrouteegressrouteresponse = new uxas::messages::route::EgressRouteResponse();
+	std::cout << "Sending uxas::messages::route::EgressRouteResponse" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_uxasmessagesrouteegressrouteresponse, true);
+	delete _uxasmessagesrouteegressrouteresponse;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::AbstractGeometry* _afrlcmasiabstractgeometry = new afrl::cmasi::AbstractGeometry();
+	std::cout << "Sending afrl::cmasi::AbstractGeometry" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiabstractgeometry, true);
+	delete _afrlcmasiabstractgeometry;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::KeyValuePair* _afrlcmasikeyvaluepair = new afrl::cmasi::KeyValuePair();
+	std::cout << "Sending afrl::cmasi::KeyValuePair" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasikeyvaluepair, true);
+	delete _afrlcmasikeyvaluepair;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::Location3D* _afrlcmasilocation3d = new afrl::cmasi::Location3D();
+	std::cout << "Sending afrl::cmasi::Location3D" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasilocation3d, true);
+	delete _afrlcmasilocation3d;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::PayloadAction* _afrlcmasipayloadaction = new afrl::cmasi::PayloadAction();
+	std::cout << "Sending afrl::cmasi::PayloadAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasipayloadaction, true);
+	delete _afrlcmasipayloadaction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::PayloadConfiguration* _afrlcmasipayloadconfiguration = new afrl::cmasi::PayloadConfiguration();
+	std::cout << "Sending afrl::cmasi::PayloadConfiguration" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasipayloadconfiguration, true);
+	delete _afrlcmasipayloadconfiguration;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::PayloadState* _afrlcmasipayloadstate = new afrl::cmasi::PayloadState();
+	std::cout << "Sending afrl::cmasi::PayloadState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasipayloadstate, true);
+	delete _afrlcmasipayloadstate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::VehicleAction* _afrlcmasivehicleaction = new afrl::cmasi::VehicleAction();
+	std::cout << "Sending afrl::cmasi::VehicleAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasivehicleaction, true);
+	delete _afrlcmasivehicleaction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::Task* _afrlcmasitask = new afrl::cmasi::Task();
+	std::cout << "Sending afrl::cmasi::Task" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasitask, true);
+	delete _afrlcmasitask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::SearchTask* _afrlcmasisearchtask = new afrl::cmasi::SearchTask();
+	std::cout << "Sending afrl::cmasi::SearchTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasisearchtask, true);
+	delete _afrlcmasisearchtask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::AbstractZone* _afrlcmasiabstractzone = new afrl::cmasi::AbstractZone();
+	std::cout << "Sending afrl::cmasi::AbstractZone" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiabstractzone, true);
+	delete _afrlcmasiabstractzone;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::EntityConfiguration* _afrlcmasientityconfiguration = new afrl::cmasi::EntityConfiguration();
+	std::cout << "Sending afrl::cmasi::EntityConfiguration" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasientityconfiguration, true);
+	delete _afrlcmasientityconfiguration;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::FlightProfile* _afrlcmasiflightprofile = new afrl::cmasi::FlightProfile();
+	std::cout << "Sending afrl::cmasi::FlightProfile" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiflightprofile, true);
+	delete _afrlcmasiflightprofile;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::AirVehicleConfiguration* _afrlcmasiairvehicleconfiguration = new afrl::cmasi::AirVehicleConfiguration();
+	std::cout << "Sending afrl::cmasi::AirVehicleConfiguration" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiairvehicleconfiguration, true);
+	delete _afrlcmasiairvehicleconfiguration;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::EntityState* _afrlcmasientitystate = new afrl::cmasi::EntityState();
+	std::cout << "Sending afrl::cmasi::EntityState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasientitystate, true);
+	delete _afrlcmasientitystate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::AirVehicleState* _afrlcmasiairvehiclestate = new afrl::cmasi::AirVehicleState();
+	std::cout << "Sending afrl::cmasi::AirVehicleState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiairvehiclestate, true);
+	delete _afrlcmasiairvehiclestate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::Wedge* _afrlcmasiwedge = new afrl::cmasi::Wedge();
+	std::cout << "Sending afrl::cmasi::Wedge" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiwedge, true);
+	delete _afrlcmasiwedge;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::AreaSearchTask* _afrlcmasiareasearchtask = new afrl::cmasi::AreaSearchTask();
+	std::cout << "Sending afrl::cmasi::AreaSearchTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiareasearchtask, true);
+	delete _afrlcmasiareasearchtask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::CameraAction* _afrlcmasicameraaction = new afrl::cmasi::CameraAction();
+	std::cout << "Sending afrl::cmasi::CameraAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasicameraaction, true);
+	delete _afrlcmasicameraaction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::CameraConfiguration* _afrlcmasicameraconfiguration = new afrl::cmasi::CameraConfiguration();
+	std::cout << "Sending afrl::cmasi::CameraConfiguration" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasicameraconfiguration, true);
+	delete _afrlcmasicameraconfiguration;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::GimballedPayloadState* _afrlcmasigimballedpayloadstate = new afrl::cmasi::GimballedPayloadState();
+	std::cout << "Sending afrl::cmasi::GimballedPayloadState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasigimballedpayloadstate, true);
+	delete _afrlcmasigimballedpayloadstate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::CameraState* _afrlcmasicamerastate = new afrl::cmasi::CameraState();
+	std::cout << "Sending afrl::cmasi::CameraState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasicamerastate, true);
+	delete _afrlcmasicamerastate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::Circle* _afrlcmasicircle = new afrl::cmasi::Circle();
+	std::cout << "Sending afrl::cmasi::Circle" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasicircle, true);
+	delete _afrlcmasicircle;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::GimbalAngleAction* _afrlcmasigimbalangleaction = new afrl::cmasi::GimbalAngleAction();
+	std::cout << "Sending afrl::cmasi::GimbalAngleAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasigimbalangleaction, true);
+	delete _afrlcmasigimbalangleaction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::GimbalConfiguration* _afrlcmasigimbalconfiguration = new afrl::cmasi::GimbalConfiguration();
+	std::cout << "Sending afrl::cmasi::GimbalConfiguration" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasigimbalconfiguration, true);
+	delete _afrlcmasigimbalconfiguration;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::GimbalScanAction* _afrlcmasigimbalscanaction = new afrl::cmasi::GimbalScanAction();
+	std::cout << "Sending afrl::cmasi::GimbalScanAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasigimbalscanaction, true);
+	delete _afrlcmasigimbalscanaction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::GimbalStareAction* _afrlcmasigimbalstareaction = new afrl::cmasi::GimbalStareAction();
+	std::cout << "Sending afrl::cmasi::GimbalStareAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasigimbalstareaction, true);
+	delete _afrlcmasigimbalstareaction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::GimbalState* _afrlcmasigimbalstate = new afrl::cmasi::GimbalState();
+	std::cout << "Sending afrl::cmasi::GimbalState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasigimbalstate, true);
+	delete _afrlcmasigimbalstate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::GoToWaypointAction* _afrlcmasigotowaypointaction = new afrl::cmasi::GoToWaypointAction();
+	std::cout << "Sending afrl::cmasi::GoToWaypointAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasigotowaypointaction, true);
+	delete _afrlcmasigotowaypointaction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::KeepInZone* _afrlcmasikeepinzone = new afrl::cmasi::KeepInZone();
+	std::cout << "Sending afrl::cmasi::KeepInZone" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasikeepinzone, true);
+	delete _afrlcmasikeepinzone;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::KeepOutZone* _afrlcmasikeepoutzone = new afrl::cmasi::KeepOutZone();
+	std::cout << "Sending afrl::cmasi::KeepOutZone" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasikeepoutzone, true);
+	delete _afrlcmasikeepoutzone;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::LineSearchTask* _afrlcmasilinesearchtask = new afrl::cmasi::LineSearchTask();
+	std::cout << "Sending afrl::cmasi::LineSearchTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasilinesearchtask, true);
+	delete _afrlcmasilinesearchtask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::NavigationAction* _afrlcmasinavigationaction = new afrl::cmasi::NavigationAction();
+	std::cout << "Sending afrl::cmasi::NavigationAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasinavigationaction, true);
+	delete _afrlcmasinavigationaction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::LoiterAction* _afrlcmasiloiteraction = new afrl::cmasi::LoiterAction();
+	std::cout << "Sending afrl::cmasi::LoiterAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiloiteraction, true);
+	delete _afrlcmasiloiteraction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::LoiterTask* _afrlcmasiloitertask = new afrl::cmasi::LoiterTask();
+	std::cout << "Sending afrl::cmasi::LoiterTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiloitertask, true);
+	delete _afrlcmasiloitertask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::Waypoint* _afrlcmasiwaypoint = new afrl::cmasi::Waypoint();
+	std::cout << "Sending afrl::cmasi::Waypoint" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiwaypoint, true);
+	delete _afrlcmasiwaypoint;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::MissionCommand* _afrlcmasimissioncommand = new afrl::cmasi::MissionCommand();
+	std::cout << "Sending afrl::cmasi::MissionCommand" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasimissioncommand, true);
+	delete _afrlcmasimissioncommand;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::MustFlyTask* _afrlcmasimustflytask = new afrl::cmasi::MustFlyTask();
+	std::cout << "Sending afrl::cmasi::MustFlyTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasimustflytask, true);
+	delete _afrlcmasimustflytask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::OperatorSignal* _afrlcmasioperatorsignal = new afrl::cmasi::OperatorSignal();
+	std::cout << "Sending afrl::cmasi::OperatorSignal" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasioperatorsignal, true);
+	delete _afrlcmasioperatorsignal;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::OperatingRegion* _afrlcmasioperatingregion = new afrl::cmasi::OperatingRegion();
+	std::cout << "Sending afrl::cmasi::OperatingRegion" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasioperatingregion, true);
+	delete _afrlcmasioperatingregion;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::AutomationRequest* _afrlcmasiautomationrequest = new afrl::cmasi::AutomationRequest();
+	std::cout << "Sending afrl::cmasi::AutomationRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiautomationrequest, true);
+	delete _afrlcmasiautomationrequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::PointSearchTask* _afrlcmasipointsearchtask = new afrl::cmasi::PointSearchTask();
+	std::cout << "Sending afrl::cmasi::PointSearchTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasipointsearchtask, true);
+	delete _afrlcmasipointsearchtask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::Polygon* _afrlcmasipolygon = new afrl::cmasi::Polygon();
+	std::cout << "Sending afrl::cmasi::Polygon" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasipolygon, true);
+	delete _afrlcmasipolygon;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::Rectangle* _afrlcmasirectangle = new afrl::cmasi::Rectangle();
+	std::cout << "Sending afrl::cmasi::Rectangle" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasirectangle, true);
+	delete _afrlcmasirectangle;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::RemoveTasks* _afrlcmasiremovetasks = new afrl::cmasi::RemoveTasks();
+	std::cout << "Sending afrl::cmasi::RemoveTasks" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiremovetasks, true);
+	delete _afrlcmasiremovetasks;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::ServiceStatus* _afrlcmasiservicestatus = new afrl::cmasi::ServiceStatus();
+	std::cout << "Sending afrl::cmasi::ServiceStatus" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiservicestatus, true);
+	delete _afrlcmasiservicestatus;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::SessionStatus* _afrlcmasisessionstatus = new afrl::cmasi::SessionStatus();
+	std::cout << "Sending afrl::cmasi::SessionStatus" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasisessionstatus, true);
+	delete _afrlcmasisessionstatus;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::VehicleActionCommand* _afrlcmasivehicleactioncommand = new afrl::cmasi::VehicleActionCommand();
+	std::cout << "Sending afrl::cmasi::VehicleActionCommand" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasivehicleactioncommand, true);
+	delete _afrlcmasivehicleactioncommand;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::VideoStreamAction* _afrlcmasivideostreamaction = new afrl::cmasi::VideoStreamAction();
+	std::cout << "Sending afrl::cmasi::VideoStreamAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasivideostreamaction, true);
+	delete _afrlcmasivideostreamaction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::VideoStreamConfiguration* _afrlcmasivideostreamconfiguration = new afrl::cmasi::VideoStreamConfiguration();
+	std::cout << "Sending afrl::cmasi::VideoStreamConfiguration" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasivideostreamconfiguration, true);
+	delete _afrlcmasivideostreamconfiguration;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::VideoStreamState* _afrlcmasivideostreamstate = new afrl::cmasi::VideoStreamState();
+	std::cout << "Sending afrl::cmasi::VideoStreamState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasivideostreamstate, true);
+	delete _afrlcmasivideostreamstate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::AutomationResponse* _afrlcmasiautomationresponse = new afrl::cmasi::AutomationResponse();
+	std::cout << "Sending afrl::cmasi::AutomationResponse" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiautomationresponse, true);
+	delete _afrlcmasiautomationresponse;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::RemoveZones* _afrlcmasiremovezones = new afrl::cmasi::RemoveZones();
+	std::cout << "Sending afrl::cmasi::RemoveZones" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiremovezones, true);
+	delete _afrlcmasiremovezones;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::RemoveEntities* _afrlcmasiremoveentities = new afrl::cmasi::RemoveEntities();
+	std::cout << "Sending afrl::cmasi::RemoveEntities" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiremoveentities, true);
+	delete _afrlcmasiremoveentities;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::FlightDirectorAction* _afrlcmasiflightdirectoraction = new afrl::cmasi::FlightDirectorAction();
+	std::cout << "Sending afrl::cmasi::FlightDirectorAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiflightdirectoraction, true);
+	delete _afrlcmasiflightdirectoraction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::WeatherReport* _afrlcmasiweatherreport = new afrl::cmasi::WeatherReport();
+	std::cout << "Sending afrl::cmasi::WeatherReport" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiweatherreport, true);
+	delete _afrlcmasiweatherreport;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::FollowPathCommand* _afrlcmasifollowpathcommand = new afrl::cmasi::FollowPathCommand();
+	std::cout << "Sending afrl::cmasi::FollowPathCommand" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasifollowpathcommand, true);
+	delete _afrlcmasifollowpathcommand;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::PathWaypoint* _afrlcmasipathwaypoint = new afrl::cmasi::PathWaypoint();
+	std::cout << "Sending afrl::cmasi::PathWaypoint" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasipathwaypoint, true);
+	delete _afrlcmasipathwaypoint;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::StopMovementAction* _afrlcmasistopmovementaction = new afrl::cmasi::StopMovementAction();
+	std::cout << "Sending afrl::cmasi::StopMovementAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasistopmovementaction, true);
+	delete _afrlcmasistopmovementaction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::WaypointTransfer* _afrlcmasiwaypointtransfer = new afrl::cmasi::WaypointTransfer();
+	std::cout << "Sending afrl::cmasi::WaypointTransfer" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiwaypointtransfer, true);
+	delete _afrlcmasiwaypointtransfer;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::PayloadStowAction* _afrlcmasipayloadstowaction = new afrl::cmasi::PayloadStowAction();
+	std::cout << "Sending afrl::cmasi::PayloadStowAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasipayloadstowaction, true);
+	delete _afrlcmasipayloadstowaction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::PowerConfiguration* _afrlimpactpowerconfiguration = new afrl::impact::PowerConfiguration();
+	std::cout << "Sending afrl::impact::PowerConfiguration" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactpowerconfiguration, true);
+	delete _afrlimpactpowerconfiguration;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::RadioConfiguration* _afrlimpactradioconfiguration = new afrl::impact::RadioConfiguration();
+	std::cout << "Sending afrl::impact::RadioConfiguration" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactradioconfiguration, true);
+	delete _afrlimpactradioconfiguration;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::RadioTowerConfiguration* _afrlimpactradiotowerconfiguration = new afrl::impact::RadioTowerConfiguration();
+	std::cout << "Sending afrl::impact::RadioTowerConfiguration" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactradiotowerconfiguration, true);
+	delete _afrlimpactradiotowerconfiguration;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::RadioState* _afrlimpactradiostate = new afrl::impact::RadioState();
+	std::cout << "Sending afrl::impact::RadioState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactradiostate, true);
+	delete _afrlimpactradiostate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::RadioTowerState* _afrlimpactradiotowerstate = new afrl::impact::RadioTowerState();
+	std::cout << "Sending afrl::impact::RadioTowerState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactradiotowerstate, true);
+	delete _afrlimpactradiotowerstate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::ImpactPayloadConfiguration* _afrlimpactimpactpayloadconfiguration = new afrl::impact::ImpactPayloadConfiguration();
+	std::cout << "Sending afrl::impact::ImpactPayloadConfiguration" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactimpactpayloadconfiguration, true);
+	delete _afrlimpactimpactpayloadconfiguration;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::DeployImpactPayload* _afrlimpactdeployimpactpayload = new afrl::impact::DeployImpactPayload();
+	std::cout << "Sending afrl::impact::DeployImpactPayload" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactdeployimpactpayload, true);
+	delete _afrlimpactdeployimpactpayload;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::PowerPlantState* _afrlimpactpowerplantstate = new afrl::impact::PowerPlantState();
+	std::cout << "Sending afrl::impact::PowerPlantState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactpowerplantstate, true);
+	delete _afrlimpactpowerplantstate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::BatchRoutePlanRequest* _afrlimpactbatchrouteplanrequest = new afrl::impact::BatchRoutePlanRequest();
+	std::cout << "Sending afrl::impact::BatchRoutePlanRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactbatchrouteplanrequest, true);
+	delete _afrlimpactbatchrouteplanrequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::BatchRoutePlanResponse* _afrlimpactbatchrouteplanresponse = new afrl::impact::BatchRoutePlanResponse();
+	std::cout << "Sending afrl::impact::BatchRoutePlanResponse" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactbatchrouteplanresponse, true);
+	delete _afrlimpactbatchrouteplanresponse;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::TaskTimingPair* _afrlimpacttasktimingpair = new afrl::impact::TaskTimingPair();
+	std::cout << "Sending afrl::impact::TaskTimingPair" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpacttasktimingpair, true);
+	delete _afrlimpacttasktimingpair;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::BatchSummaryRequest* _afrlimpactbatchsummaryrequest = new afrl::impact::BatchSummaryRequest();
+	std::cout << "Sending afrl::impact::BatchSummaryRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactbatchsummaryrequest, true);
+	delete _afrlimpactbatchsummaryrequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::BatchSummaryResponse* _afrlimpactbatchsummaryresponse = new afrl::impact::BatchSummaryResponse();
+	std::cout << "Sending afrl::impact::BatchSummaryResponse" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactbatchsummaryresponse, true);
+	delete _afrlimpactbatchsummaryresponse;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::TaskSummary* _afrlimpacttasksummary = new afrl::impact::TaskSummary();
+	std::cout << "Sending afrl::impact::TaskSummary" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpacttasksummary, true);
+	delete _afrlimpacttasksummary;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::VehicleSummary* _afrlimpactvehiclesummary = new afrl::impact::VehicleSummary();
+	std::cout << "Sending afrl::impact::VehicleSummary" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactvehiclesummary, true);
+	delete _afrlimpactvehiclesummary;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::ImpactHeartbeat* _afrlimpactimpactheartbeat = new afrl::impact::ImpactHeartbeat();
+	std::cout << "Sending afrl::impact::ImpactHeartbeat" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactimpactheartbeat, true);
+	delete _afrlimpactimpactheartbeat;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::ImpactComponentJoin* _afrlimpactimpactcomponentjoin = new afrl::impact::ImpactComponentJoin();
+	std::cout << "Sending afrl::impact::ImpactComponentJoin" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactimpactcomponentjoin, true);
+	delete _afrlimpactimpactcomponentjoin;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::ImpactComponentLeave* _afrlimpactimpactcomponentleave = new afrl::impact::ImpactComponentLeave();
+	std::cout << "Sending afrl::impact::ImpactComponentLeave" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactimpactcomponentleave, true);
+	delete _afrlimpactimpactcomponentleave;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::SpeedAltPair* _afrlimpactspeedaltpair = new afrl::impact::SpeedAltPair();
+	std::cout << "Sending afrl::impact::SpeedAltPair" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactspeedaltpair, true);
+	delete _afrlimpactspeedaltpair;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::ImpactAutomationRequest* _afrlimpactimpactautomationrequest = new afrl::impact::ImpactAutomationRequest();
+	std::cout << "Sending afrl::impact::ImpactAutomationRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactimpactautomationrequest, true);
+	delete _afrlimpactimpactautomationrequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::ImpactAutomationResponse* _afrlimpactimpactautomationresponse = new afrl::impact::ImpactAutomationResponse();
+	std::cout << "Sending afrl::impact::ImpactAutomationResponse" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactimpactautomationresponse, true);
+	delete _afrlimpactimpactautomationresponse;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::PointOfInterest* _afrlimpactpointofinterest = new afrl::impact::PointOfInterest();
+	std::cout << "Sending afrl::impact::PointOfInterest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactpointofinterest, true);
+	delete _afrlimpactpointofinterest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::LineOfInterest* _afrlimpactlineofinterest = new afrl::impact::LineOfInterest();
+	std::cout << "Sending afrl::impact::LineOfInterest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactlineofinterest, true);
+	delete _afrlimpactlineofinterest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::AreaOfInterest* _afrlimpactareaofinterest = new afrl::impact::AreaOfInterest();
+	std::cout << "Sending afrl::impact::AreaOfInterest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactareaofinterest, true);
+	delete _afrlimpactareaofinterest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::ImpactPointSearchTask* _afrlimpactimpactpointsearchtask = new afrl::impact::ImpactPointSearchTask();
+	std::cout << "Sending afrl::impact::ImpactPointSearchTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactimpactpointsearchtask, true);
+	delete _afrlimpactimpactpointsearchtask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::PatternSearchTask* _afrlimpactpatternsearchtask = new afrl::impact::PatternSearchTask();
+	std::cout << "Sending afrl::impact::PatternSearchTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactpatternsearchtask, true);
+	delete _afrlimpactpatternsearchtask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::AngledAreaSearchTask* _afrlimpactangledareasearchtask = new afrl::impact::AngledAreaSearchTask();
+	std::cout << "Sending afrl::impact::AngledAreaSearchTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactangledareasearchtask, true);
+	delete _afrlimpactangledareasearchtask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::ImpactLineSearchTask* _afrlimpactimpactlinesearchtask = new afrl::impact::ImpactLineSearchTask();
+	std::cout << "Sending afrl::impact::ImpactLineSearchTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactimpactlinesearchtask, true);
+	delete _afrlimpactimpactlinesearchtask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::WatchTask* _afrlimpactwatchtask = new afrl::impact::WatchTask();
+	std::cout << "Sending afrl::impact::WatchTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactwatchtask, true);
+	delete _afrlimpactwatchtask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::MultiVehicleWatchTask* _afrlimpactmultivehiclewatchtask = new afrl::impact::MultiVehicleWatchTask();
+	std::cout << "Sending afrl::impact::MultiVehicleWatchTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactmultivehiclewatchtask, true);
+	delete _afrlimpactmultivehiclewatchtask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::CommRelayTask* _afrlimpactcommrelaytask = new afrl::impact::CommRelayTask();
+	std::cout << "Sending afrl::impact::CommRelayTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactcommrelaytask, true);
+	delete _afrlimpactcommrelaytask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::CordonTask* _afrlimpactcordontask = new afrl::impact::CordonTask();
+	std::cout << "Sending afrl::impact::CordonTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactcordontask, true);
+	delete _afrlimpactcordontask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::BlockadeTask* _afrlimpactblockadetask = new afrl::impact::BlockadeTask();
+	std::cout << "Sending afrl::impact::BlockadeTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactblockadetask, true);
+	delete _afrlimpactblockadetask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::EscortTask* _afrlimpactescorttask = new afrl::impact::EscortTask();
+	std::cout << "Sending afrl::impact::EscortTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactescorttask, true);
+	delete _afrlimpactescorttask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::ConfigurationRequest* _afrlimpactconfigurationrequest = new afrl::impact::ConfigurationRequest();
+	std::cout << "Sending afrl::impact::ConfigurationRequest" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactconfigurationrequest, true);
+	delete _afrlimpactconfigurationrequest;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::GroundVehicleConfiguration* _afrlimpactgroundvehicleconfiguration = new afrl::impact::GroundVehicleConfiguration();
+	std::cout << "Sending afrl::impact::GroundVehicleConfiguration" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactgroundvehicleconfiguration, true);
+	delete _afrlimpactgroundvehicleconfiguration;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::GroundVehicleState* _afrlimpactgroundvehiclestate = new afrl::impact::GroundVehicleState();
+	std::cout << "Sending afrl::impact::GroundVehicleState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactgroundvehiclestate, true);
+	delete _afrlimpactgroundvehiclestate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::WaterReport* _afrlimpactwaterreport = new afrl::impact::WaterReport();
+	std::cout << "Sending afrl::impact::WaterReport" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactwaterreport, true);
+	delete _afrlimpactwaterreport;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::WaterZone* _afrlimpactwaterzone = new afrl::impact::WaterZone();
+	std::cout << "Sending afrl::impact::WaterZone" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactwaterzone, true);
+	delete _afrlimpactwaterzone;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::SurfaceVehicleConfiguration* _afrlimpactsurfacevehicleconfiguration = new afrl::impact::SurfaceVehicleConfiguration();
+	std::cout << "Sending afrl::impact::SurfaceVehicleConfiguration" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactsurfacevehicleconfiguration, true);
+	delete _afrlimpactsurfacevehicleconfiguration;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::impact::SurfaceVehicleState* _afrlimpactsurfacevehiclestate = new afrl::impact::SurfaceVehicleState();
+	std::cout << "Sending afrl::impact::SurfaceVehicleState" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlimpactsurfacevehiclestate, true);
+	delete _afrlimpactsurfacevehiclestate;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::perceive::EntityPerception* _afrlcmasiperceiveentityperception = new afrl::cmasi::perceive::EntityPerception();
+	std::cout << "Sending afrl::cmasi::perceive::EntityPerception" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiperceiveentityperception, true);
+	delete _afrlcmasiperceiveentityperception;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::perceive::TrackEntityAction* _afrlcmasiperceivetrackentityaction = new afrl::cmasi::perceive::TrackEntityAction();
+	std::cout << "Sending afrl::cmasi::perceive::TrackEntityAction" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiperceivetrackentityaction, true);
+	delete _afrlcmasiperceivetrackentityaction;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+	afrl::cmasi::perceive::TrackEntityTask* _afrlcmasiperceivetrackentitytask = new afrl::cmasi::perceive::TrackEntityTask();
+	std::cout << "Sending afrl::cmasi::perceive::TrackEntityTask" << std::endl;
+	sendBuf = avtas::lmcp::Factory::packMessage(_afrlcmasiperceivetrackentitytask, true);
+	delete _afrlcmasiperceivetrackentitytask;
+	std::cout << sendBuf->toString() << std::endl;
+	pBuf = sendBuf->array();
+	send(connectionSocket, (char*) pBuf, sendBuf->position(), 0);
+	delete sendBuf;
+
+}
+
+bool EstablishConnection(SOCKET& connectionSocket, int port, std::string& host)
+{
+# ifdef WIN32
+	// Start Winsock
+	WSAData wsaData;
+	WSAStartup(MAKEWORD(1, 1), &wsaData);
+#endif
+
+	connectionSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	if(connectionSocket == INVALID_SOCKET) 
+		return false;
+	sockaddr_in source;
+	source.sin_family = AF_INET;
+	source.sin_addr.s_addr = inet_addr(host.c_str());
+	source.sin_port = htons((u_short)port);
+	memset(&(source.sin_zero), '\0', 8);
+	socklen_t source_len = sizeof(source);
+	if( connect(connectionSocket, (sockaddr*)&source, source_len) == SOCKET_ERROR)
+		return false;
+
+	return true;
+}
diff --git a/src/LMCP/test/server/Makefile b/src/LMCP/test/server/Makefile
new file mode 100644
index 0000000..fe64042
--- /dev/null
+++ b/src/LMCP/test/server/Makefile
@@ -0,0 +1,39 @@
+## This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+SRCFILES=main.cpp
+
+CC=g++
+
+CFLAGS=-DLINUX -std=c++11 -Wall
+
+LDFLAGS=-static
+
+SRC=$(SRCFILES)
+
+LIBS=-L../..
+LIBS+=-llmcp
+
+INCS=-I../.. 
+
+OBJ=$(SRC:.cpp=.o)
+
+EXE=test_server
+
+RM=rm -f
+
+.PHONY: all 
+.PHONY: clean
+.PHONY: invoker 
+
+all: $(LIB) $(EXE)
+
+exe: $(EXE)
+	
+%.o: %.cpp 
+	$(CC) $(CFLAGS) $(INCS) -o $@ -c $<
+
+$(EXE): $(OBJ)
+	$(CC) $(OBJ) -o $@ $(LDFLAGS) $(LIBS)
+
+clean: 
+	-$(RM) $(OBJ) $(EXE)
diff --git a/src/LMCP/test/server/TestServer.vcproj b/src/LMCP/test/server/TestServer.vcproj
new file mode 100644
index 0000000..a902631
--- /dev/null
+++ b/src/LMCP/test/server/TestServer.vcproj
@@ -0,0 +1,185 @@
+<!-- This file was auto-created by LmcpGen. Modifications will be overwritten. -->
+<?xml version="1.0" encoding="UTF-8"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="TestServer"
+	ProjectGUID="{34466ACF-01A8-4E4B-AF88-6CA1207E1663}"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="0"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+                                AdditionalIncludeDirectories="..\..\"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib wsock32.lib ..\..\Debug/LMCPBuild.lib"
+				LinkIncremental="2"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+                                AdditionalIncludeDirectories="..\..\"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib wsock32.lib ..\..\Release\LMCPBuild.lib"
+				LinkIncremental="1"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{6B347E83-DDD5-42D4-9FBE-B0C87DFD89C0}"
+			>
+		</Filter>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{7A70F2FC-EE41-4E58-A154-347033B00856}"
+			>
+			<File
+				RelativePath=".\main.cpp"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/src/LMCP/test/server/TestServer.vcxproj b/src/LMCP/test/server/TestServer.vcxproj
new file mode 100644
index 0000000..46a2d02
--- /dev/null
+++ b/src/LMCP/test/server/TestServer.vcxproj
@@ -0,0 +1,93 @@
+<!-- This file was auto-created by LmcpGen. Modifications will be overwritten. -->
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{A06F6D5B-629A-41F7-89AF-1559292A5F1B}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <PlatformToolset>v120</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <PlatformToolset>v120</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>12.0.21005.1</_ProjectFileVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>Debug\</OutDir>
+    <IntDir>Debug\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>Release\</OutDir>
+    <IntDir>Release\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\..\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader />
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>ws2_32.lib;wsock32.lib;..\..\Debug/LMCPBuild.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <AdditionalIncludeDirectories>..\..\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <PrecompiledHeader />
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>ws2_32.lib;wsock32.lib;..\..\Release\LMCPBuild.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="main.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
diff --git a/src/LMCP/test/server/main.cpp b/src/LMCP/test/server/main.cpp
new file mode 100644
index 0000000..d209549
--- /dev/null
+++ b/src/LMCP/test/server/main.cpp
@@ -0,0 +1,136 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+// Utility libraries from standard c++
+# ifdef LINUX
+#include <arpa/inet.h>
+#include <cstring>
+#endif
+#include <string>
+#include <cstdint>
+#include <iostream>
+#include <vector>
+
+// Include appropriate socket implementation headers.
+# ifdef WIN32
+#include <winsock.h>
+#endif
+#define socklen_t int
+
+#include "avtas/lmcp/ByteBuffer.h"
+#include "avtas/lmcp/Factory.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/task/UXTASK.h"
+#include "uxas/messages/uxnative/UXNATIVE.h"
+#include "uxas/messages/route/ROUTE.h"
+#include "afrl/cmasi/CMASI.h"
+#include "afrl/impact/IMPACT.h"
+#include "afrl/cmasi/perceive/PERCEIVE.h"
+
+
+# ifdef LINUX
+typedef int SOCKET;
+int SOCKET_ERROR = -1;  // error return code for socket()
+int INVALID_SOCKET = -1;  // error return code for connect()
+#endif
+
+bool EstablishConnection(SOCKET&, int);
+
+// Define the main method.
+int main(int argc, char* argv[])
+{
+	int port = 11041;
+  
+	// create connection
+	SOCKET connectionSocket;
+	while( !EstablishConnection(connectionSocket,port) )
+	{
+		std::cout << "Could not establish connection!" << std::endl;
+	}
+
+	// Create the buffer to hold incoming messages. Choosing an arbitrarily large sized
+	// buffer big enough to hold any message we want to receive.
+	int bufferSize = 1048576;
+	char* buffer = new char[bufferSize];
+
+	// display any messages coming across network
+	avtas::lmcp::ByteBuffer buf;
+	avtas::lmcp::Object* obj;
+	for(;;)
+	{
+		int bytesReceived = recv(connectionSocket, buffer, bufferSize, 0);
+
+		if(bytesReceived <= 0)
+		{
+			std::cout << "Connection closed or message receive error. Waiting for new connection ..." << std::endl;
+			while( !EstablishConnection(connectionSocket,port) )
+			{
+				std::cout << "Could not establish connection!" << std::endl;
+			}
+			continue;
+		}
+		
+		// potentially received multiple messages back-to-back
+		int offsetindex = 0;
+		while(bytesReceived > static_cast<int>(avtas::lmcp::Factory::HEADER_SIZE))
+		{
+			uint8_t* startByte = (uint8_t*) &buffer[offsetindex];
+			uint32_t objsize = avtas::lmcp::Factory::getObjectSize(startByte, avtas::lmcp::Factory::HEADER_SIZE);
+			objsize += avtas::lmcp::Factory::HEADER_SIZE + avtas::lmcp::Factory::CHECKSUM_SIZE;
+				
+			// process message
+			buf.allocate(objsize);
+                        buf.rewind();
+			memcpy(buf.array(),startByte,objsize);
+			//std::cout << "Received: " << std::endl;
+			//std::cout << buf.toString() << std::endl;
+			bytesReceived -= objsize;
+			offsetindex += objsize;
+			obj = avtas::lmcp::Factory::getObject(buf);
+			if(!obj)
+			{
+				//std::cout << "Invalid message format" << std::endl;
+                                std::cout << buf.toString() << std::endl;
+				continue;
+			}
+
+			std::cout << obj->toXML() << std::endl;
+			delete obj;
+		}
+	}
+}
+
+bool EstablishConnection(SOCKET& connectionSocket, int port)
+{
+# ifdef WIN32
+	// Start Winsock
+	WSAData wsaData;
+	WSAStartup(MAKEWORD(1, 1), &wsaData);
+#endif
+  
+	// wait for connection
+	SOCKET listeningSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	if(listeningSocket == INVALID_SOCKET) 
+		return false;
+	sockaddr_in source;
+	source.sin_family = AF_INET;
+	source.sin_addr.s_addr = htonl(INADDR_ANY);
+	source.sin_port = htons((u_short)port);
+	memset(&(source.sin_zero), '\0', 8);
+	socklen_t source_len = sizeof(source);
+	bind(listeningSocket, (sockaddr*)&source, source_len);
+	listen(listeningSocket, SOMAXCONN);
+	connectionSocket = accept(listeningSocket, NULL, NULL);
+	if(connectionSocket == INVALID_SOCKET)
+		return false;
+
+	return true;
+}
diff --git a/src/LMCP/uxas/messages/route/EgressRouteRequest.h b/src/LMCP/uxas/messages/route/EgressRouteRequest.h
new file mode 100644
index 0000000..f74d2f8
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/EgressRouteRequest.h
@@ -0,0 +1,121 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_EGRESSROUTEREQUEST_H_
+#define _UXAS_MESSAGES_ROUTE_EGRESSROUTEREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "ROUTEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   bool isEgressRouteRequest(avtas::lmcp::Object* obj);
+   bool isEgressRouteRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > EgressRouteRequestDescendants();
+   
+   class EgressRouteRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      EgressRouteRequest(void);
+
+      // Copy Constructor
+      EgressRouteRequest(const EgressRouteRequest &that);
+
+      // Assignment Operator
+      EgressRouteRequest & operator=(const EgressRouteRequest &that);
+
+      // Destructor
+      virtual ~EgressRouteRequest(void);
+
+      // Equals overload
+      bool operator==(const EgressRouteRequest & that);
+      bool operator!=(const EgressRouteRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual EgressRouteRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 10; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("ROUTE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5931053054693474304LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Request ID for correlating with response (Units: None)*/
+      int64_t getRequestID(void) const { return __RequestID; }
+      EgressRouteRequest& setRequestID(const int64_t val);
+
+      /** Location from which to calculate the routes (Units: None)*/
+      afrl::cmasi::Location3D* const getStartLocation(void) { return __StartLocation; }
+      EgressRouteRequest& setStartLocation(const afrl::cmasi::Location3D* const val);
+
+      /** The radius of the area of concern (Units: meters)*/
+      float getRadius(void) const { return __Radius; }
+      EgressRouteRequest& setRadius(const float val);
+
+
+
+   protected:
+      /** Request ID for correlating with response */
+      int64_t __RequestID;
+      /** Location from which to calculate the routes */
+      afrl::cmasi::Location3D* __StartLocation;
+      /** The radius of the area of concern */
+      float __Radius;
+
+   };
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_ROUTE_EGRESSROUTEREQUEST_H_
diff --git a/src/LMCP/uxas/messages/route/EgressRouteRequestDescendants.h b/src/LMCP/uxas/messages/route/EgressRouteRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/EgressRouteRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/route/EgressRouteResponse.h b/src/LMCP/uxas/messages/route/EgressRouteResponse.h
new file mode 100644
index 0000000..e70d8b4
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/EgressRouteResponse.h
@@ -0,0 +1,120 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_EGRESSROUTERESPONSE_H_
+#define _UXAS_MESSAGES_ROUTE_EGRESSROUTERESPONSE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "ROUTEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   bool isEgressRouteResponse(avtas::lmcp::Object* obj);
+   bool isEgressRouteResponse(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > EgressRouteResponseDescendants();
+   
+   class EgressRouteResponse : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      EgressRouteResponse(void);
+
+      // Copy Constructor
+      EgressRouteResponse(const EgressRouteResponse &that);
+
+      // Assignment Operator
+      EgressRouteResponse & operator=(const EgressRouteResponse &that);
+
+      // Destructor
+      virtual ~EgressRouteResponse(void);
+
+      // Equals overload
+      bool operator==(const EgressRouteResponse & that);
+      bool operator!=(const EgressRouteResponse & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual EgressRouteResponse* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 11; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("ROUTE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5931053054693474304LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Response ID matching ID from request ({@link EgressRouteRequest}) (Units: None)*/
+      int64_t getResponseID(void) const { return __ResponseID; }
+      EgressRouteResponse& setResponseID(const int64_t val);
+
+      /** The route locations (Units: None)*/
+      std::vector<afrl::cmasi::Location3D*> & getNodeLocations(void) { return __NodeLocations; }
+
+      /** The orientations (Units: degrees)*/
+      std::vector<float> & getHeadings(void) { return __Headings; }
+
+
+
+   protected:
+      /** Response ID matching ID from request ({@link EgressRouteRequest}) */
+      int64_t __ResponseID;
+      /** The route locations */
+      std::vector< afrl::cmasi::Location3D* > __NodeLocations;
+      /** The orientations */
+      std::vector< float > __Headings;
+
+   };
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_ROUTE_EGRESSROUTERESPONSE_H_
diff --git a/src/LMCP/uxas/messages/route/EgressRouteResponseDescendants.h b/src/LMCP/uxas/messages/route/EgressRouteResponseDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/EgressRouteResponseDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/route/GraphEdge.h b/src/LMCP/uxas/messages/route/GraphEdge.h
new file mode 100644
index 0000000..6d8b5d5
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/GraphEdge.h
@@ -0,0 +1,127 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_GRAPHEDGE_H_
+#define _UXAS_MESSAGES_ROUTE_GRAPHEDGE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "ROUTEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   bool isGraphEdge(avtas::lmcp::Object* obj);
+   bool isGraphEdge(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > GraphEdgeDescendants();
+   
+   class GraphEdge : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      GraphEdge(void);
+
+      // Copy Constructor
+      GraphEdge(const GraphEdge &that);
+
+      // Assignment Operator
+      GraphEdge & operator=(const GraphEdge &that);
+
+      // Destructor
+      virtual ~GraphEdge(void);
+
+      // Equals overload
+      bool operator==(const GraphEdge & that);
+      bool operator!=(const GraphEdge & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual GraphEdge* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 2; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("ROUTE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5931053054693474304LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Unique ID for the edge (Units: None)*/
+      int64_t getEdgeID(void) const { return __EdgeID; }
+      GraphEdge& setEdgeID(const int64_t val);
+
+      /** GraphNode ID which defines the start point of the edge (Units: None)*/
+      int64_t getStartNode(void) const { return __StartNode; }
+      GraphEdge& setStartNode(const int64_t val);
+
+      /** GraphNode ID which defines the end point of the edge (Units: None)*/
+      int64_t getEndNode(void) const { return __EndNode; }
+      GraphEdge& setEndNode(const int64_t val);
+
+      /** Optional waypoints describing physical edge in lat/lon coordinates (Units: None)*/
+      std::vector<afrl::cmasi::Location3D*> & getWaypoints(void) { return __Waypoints; }
+
+
+
+   protected:
+      /** Unique ID for the edge */
+      int64_t __EdgeID;
+      /** GraphNode ID which defines the start point of the edge */
+      int64_t __StartNode;
+      /** GraphNode ID which defines the end point of the edge */
+      int64_t __EndNode;
+      /** Optional waypoints describing physical edge in lat/lon coordinates */
+      std::vector< afrl::cmasi::Location3D* > __Waypoints;
+
+   };
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_ROUTE_GRAPHEDGE_H_
diff --git a/src/LMCP/uxas/messages/route/GraphEdgeDescendants.h b/src/LMCP/uxas/messages/route/GraphEdgeDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/GraphEdgeDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/route/GraphNode.h b/src/LMCP/uxas/messages/route/GraphNode.h
new file mode 100644
index 0000000..848ec9d
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/GraphNode.h
@@ -0,0 +1,121 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_GRAPHNODE_H_
+#define _UXAS_MESSAGES_ROUTE_GRAPHNODE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "ROUTEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   bool isGraphNode(avtas::lmcp::Object* obj);
+   bool isGraphNode(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > GraphNodeDescendants();
+   
+   class GraphNode : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      GraphNode(void);
+
+      // Copy Constructor
+      GraphNode(const GraphNode &that);
+
+      // Assignment Operator
+      GraphNode & operator=(const GraphNode &that);
+
+      // Destructor
+      virtual ~GraphNode(void);
+
+      // Equals overload
+      bool operator==(const GraphNode & that);
+      bool operator!=(const GraphNode & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual GraphNode* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 1; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("ROUTE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5931053054693474304LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Unique ID for the node, used to build edges between nodes (Units: None)*/
+      int64_t getNodeID(void) const { return __NodeID; }
+      GraphNode& setNodeID(const int64_t val);
+
+      /** Lat/Lon coordinates of node (Units: None)*/
+      afrl::cmasi::Location3D* const getCoordinates(void) { return __Coordinates; }
+      GraphNode& setCoordinates(const afrl::cmasi::Location3D* const val);
+
+      /** IDs of edges that have this node as an endpoint (Units: None)*/
+      std::vector<int64_t> & getAssociatedEdges(void) { return __AssociatedEdges; }
+
+
+
+   protected:
+      /** Unique ID for the node, used to build edges between nodes */
+      int64_t __NodeID;
+      /** Lat/Lon coordinates of node */
+      afrl::cmasi::Location3D* __Coordinates;
+      /** IDs of edges that have this node as an endpoint */
+      std::vector< int64_t > __AssociatedEdges;
+
+   };
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_ROUTE_GRAPHNODE_H_
diff --git a/src/LMCP/uxas/messages/route/GraphNodeDescendants.h b/src/LMCP/uxas/messages/route/GraphNodeDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/GraphNodeDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/route/GraphRegion.h b/src/LMCP/uxas/messages/route/GraphRegion.h
new file mode 100644
index 0000000..e14e9d0
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/GraphRegion.h
@@ -0,0 +1,121 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_GRAPHREGION_H_
+#define _UXAS_MESSAGES_ROUTE_GRAPHREGION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "ROUTEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/route/GraphNode.h"
+#include "uxas/messages/route/GraphEdge.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   bool isGraphRegion(avtas::lmcp::Object* obj);
+   bool isGraphRegion(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > GraphRegionDescendants();
+   
+   class GraphRegion : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      GraphRegion(void);
+
+      // Copy Constructor
+      GraphRegion(const GraphRegion &that);
+
+      // Assignment Operator
+      GraphRegion & operator=(const GraphRegion &that);
+
+      // Destructor
+      virtual ~GraphRegion(void);
+
+      // Equals overload
+      bool operator==(const GraphRegion & that);
+      bool operator!=(const GraphRegion & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual GraphRegion* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 3; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("ROUTE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5931053054693474304LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** ID for full region data structure (Units: None)*/
+      int64_t getID(void) const { return __ID; }
+      GraphRegion& setID(const int64_t val);
+
+      /** List of all nodes that represent the network (Units: None)*/
+      std::vector<uxas::messages::route::GraphNode*> & getNodeList(void) { return __NodeList; }
+
+      /** List of all edges that represent the network (Units: None)*/
+      std::vector<uxas::messages::route::GraphEdge*> & getEdgeList(void) { return __EdgeList; }
+
+
+
+   protected:
+      /** ID for full region data structure */
+      int64_t __ID;
+      /** List of all nodes that represent the network */
+      std::vector< uxas::messages::route::GraphNode* > __NodeList;
+      /** List of all edges that represent the network */
+      std::vector< uxas::messages::route::GraphEdge* > __EdgeList;
+
+   };
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_ROUTE_GRAPHREGION_H_
diff --git a/src/LMCP/uxas/messages/route/GraphRegionDescendants.h b/src/LMCP/uxas/messages/route/GraphRegionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/GraphRegionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/route/ROUTE.h b/src/LMCP/uxas/messages/route/ROUTE.h
new file mode 100644
index 0000000..c59882e
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/ROUTE.h
@@ -0,0 +1,29 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_ENTIRESERIESHEADER_H_
+#define _UXAS_MESSAGES_ROUTE_ENTIRESERIESHEADER_H_
+
+#include "uxas/messages/route/GraphNode.h"
+#include "uxas/messages/route/GraphEdge.h"
+#include "uxas/messages/route/GraphRegion.h"
+#include "uxas/messages/route/RouteConstraints.h"
+#include "uxas/messages/route/RouteRequest.h"
+#include "uxas/messages/route/RoutePlanRequest.h"
+#include "uxas/messages/route/RoutePlan.h"
+#include "uxas/messages/route/RoutePlanResponse.h"
+#include "uxas/messages/route/RouteResponse.h"
+#include "uxas/messages/route/EgressRouteRequest.h"
+#include "uxas/messages/route/EgressRouteResponse.h"
+#include "uxas/messages/route/ROUTEEnum.h"
+
+
+#endif //_UXAS_MESSAGES_ROUTE_ENTIRESERIESHEADER_H_
diff --git a/src/LMCP/uxas/messages/route/ROUTEEnum.h b/src/LMCP/uxas/messages/route/ROUTEEnum.h
new file mode 100644
index 0000000..20ccf63
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/ROUTEEnum.h
@@ -0,0 +1,44 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_ROUTEENUM_H_
+#define _UXAS_MESSAGES_ROUTE_ROUTEENUM_H_
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   namespace ROUTEEnum {
+
+      enum LmcpType {
+         GRAPHNODE = 1,
+         GRAPHEDGE = 2,
+         GRAPHREGION = 3,
+         ROUTECONSTRAINTS = 4,
+         ROUTEREQUEST = 5,
+         ROUTEPLANREQUEST = 6,
+         ROUTEPLAN = 7,
+         ROUTEPLANRESPONSE = 8,
+         ROUTERESPONSE = 9,
+         EGRESSROUTEREQUEST = 10,
+         EGRESSROUTERESPONSE = 11
+      };
+
+   }
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif //_UXAS_MESSAGES_ROUTE_ROUTEENUM_H_
diff --git a/src/LMCP/uxas/messages/route/ROUTEXMLReader.cpp b/src/LMCP/uxas/messages/route/ROUTEXMLReader.cpp
new file mode 100644
index 0000000..b5793ae
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/ROUTEXMLReader.cpp
@@ -0,0 +1,473 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "uxas/messages/route/ROUTEXMLReader.h"
+#include "avtas/lmcp/XMLParser.h"
+#include <vector>
+#include <string>
+#include "avtas/lmcp/LmcpXMLReader.h"
+
+#include "uxas/messages/route/GraphNode.h"
+#include "uxas/messages/route/GraphEdge.h"
+#include "uxas/messages/route/GraphRegion.h"
+#include "uxas/messages/route/RouteConstraints.h"
+#include "uxas/messages/route/RouteRequest.h"
+#include "uxas/messages/route/RoutePlanRequest.h"
+#include "uxas/messages/route/RoutePlan.h"
+#include "uxas/messages/route/RoutePlanResponse.h"
+#include "uxas/messages/route/RouteResponse.h"
+#include "uxas/messages/route/EgressRouteRequest.h"
+#include "uxas/messages/route/EgressRouteResponse.h"
+#include "uxas/messages/route/ROUTEEnum.h"
+
+
+using namespace avtas::lmcp;
+using namespace avtas::lmcp::xml;
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+    avtas::lmcp::Object* SeriesXMLReader :: visitType(avtas::lmcp::Node* el){
+
+        if (el == NULL) return NULL;
+        
+        std::string type = el->getTagName();
+            
+        if (type == "GraphNode"){
+           GraphNode* o = new GraphNode();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "NodeID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setNodeID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Coordinates")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setCoordinates((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "AssociatedEdges")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAssociatedEdges().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "GraphEdge"){
+           GraphEdge* o = new GraphEdge();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "EdgeID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEdgeID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "StartNode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartNode( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "EndNode")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEndNode( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Waypoints")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getWaypoints().push_back( (afrl::cmasi::Location3D*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "GraphRegion"){
+           GraphRegion* o = new GraphRegion();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "NodeList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getNodeList().push_back( (uxas::messages::route::GraphNode*) oo);
+                 }
+                 continue;
+              }
+              if(name == "EdgeList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getEdgeList().push_back( (uxas::messages::route::GraphEdge*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RouteConstraints"){
+           RouteConstraints* o = new RouteConstraints();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RouteID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRouteID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "StartLocation")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setStartLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "StartHeading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartHeading( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "UseStartHeading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setUseStartHeading( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "EndLocation")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setEndLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "EndHeading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEndHeading( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "UseEndHeading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setUseEndHeading( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RouteRequest"){
+           RouteRequest* o = new RouteRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAssociatedTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getVehicleID().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "OperatingRegion")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setOperatingRegion( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "RouteRequests")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getRouteRequests().push_back( (uxas::messages::route::RouteConstraints*) oo);
+                 }
+                 continue;
+              }
+              if(name == "IsCostOnlyRequest")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setIsCostOnlyRequest( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RoutePlanRequest"){
+           RoutePlanRequest* o = new RoutePlanRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAssociatedTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "OperatingRegion")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setOperatingRegion( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "RouteRequests")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getRouteRequests().push_back( (uxas::messages::route::RouteConstraints*) oo);
+                 }
+                 continue;
+              }
+              if(name == "IsCostOnlyRequest")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setIsCostOnlyRequest( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RoutePlan"){
+           RoutePlan* o = new RoutePlan();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RouteID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRouteID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Waypoints")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getWaypoints().push_back( (afrl::cmasi::Waypoint*) oo);
+                 }
+                 continue;
+              }
+              if(name == "RouteCost")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRouteCost( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "RouteError")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getRouteError().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RoutePlanResponse"){
+           RoutePlanResponse* o = new RoutePlanResponse();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ResponseID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setResponseID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssociatedTaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAssociatedTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "OperatingRegion")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setOperatingRegion( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "RouteResponses")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getRouteResponses().push_back( (uxas::messages::route::RoutePlan*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "RouteResponse"){
+           RouteResponse* o = new RouteResponse();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ResponseID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setResponseID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Routes")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getRoutes().push_back( (uxas::messages::route::RoutePlanResponse*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "EgressRouteRequest"){
+           EgressRouteRequest* o = new EgressRouteRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "StartLocation")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setStartLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "Radius")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRadius( get_real32( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "EgressRouteResponse"){
+           EgressRouteResponse* o = new EgressRouteResponse();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ResponseID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setResponseID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "NodeLocations")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getNodeLocations().push_back( (afrl::cmasi::Location3D*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Headings")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getHeadings().push_back( get_real32( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+
+
+         return NULL;
+        
+    }
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/route/ROUTEXMLReader.h b/src/LMCP/uxas/messages/route/ROUTEXMLReader.h
new file mode 100644
index 0000000..d569b49
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/ROUTEXMLReader.h
@@ -0,0 +1,47 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef ROUTE_SERIESXMLREADER_H_
+#define ROUTE_SERIESXMLREADER_H_
+
+#include "avtas/lmcp/Object.h"
+#include "avtas/lmcp/Node.h"
+#include "avtas/lmcp/NodeUtil.h"
+
+#include <iostream>
+
+
+using namespace avtas::lmcp;
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+class SeriesXMLReader {
+
+    /** reads an LMCP XML Storage file and returns a list of LMCPObjects */
+    public:
+
+        SeriesXMLReader(void) {}
+
+        virtual ~SeriesXMLReader(){}  
+
+        static avtas::lmcp::Object * visitType(avtas::lmcp::Node* el );
+
+};
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif 
diff --git a/src/LMCP/uxas/messages/route/RouteConstraints.h b/src/LMCP/uxas/messages/route/RouteConstraints.h
new file mode 100644
index 0000000..b1974a1
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/RouteConstraints.h
@@ -0,0 +1,146 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_ROUTECONSTRAINTS_H_
+#define _UXAS_MESSAGES_ROUTE_ROUTECONSTRAINTS_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "ROUTEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   bool isRouteConstraints(avtas::lmcp::Object* obj);
+   bool isRouteConstraints(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RouteConstraintsDescendants();
+   
+   class RouteConstraints : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RouteConstraints(void);
+
+      // Copy Constructor
+      RouteConstraints(const RouteConstraints &that);
+
+      // Assignment Operator
+      RouteConstraints & operator=(const RouteConstraints &that);
+
+      // Destructor
+      virtual ~RouteConstraints(void);
+
+      // Equals overload
+      bool operator==(const RouteConstraints & that);
+      bool operator!=(const RouteConstraints & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RouteConstraints* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 4; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("ROUTE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5931053054693474304LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** ID denoting this set of route constraints (Units: None)*/
+      int64_t getRouteID(void) const { return __RouteID; }
+      RouteConstraints& setRouteID(const int64_t val);
+
+      /** Location from which the planned route will start (Units: None)*/
+      afrl::cmasi::Location3D* const getStartLocation(void) { return __StartLocation; }
+      RouteConstraints& setStartLocation(const afrl::cmasi::Location3D* const val);
+
+      /** Heading of entity at the start of the route (Units: degrees)*/
+      float getStartHeading(void) const { return __StartHeading; }
+      RouteConstraints& setStartHeading(const float val);
+
+      /** If "true" the heading value in StartHeading must be used to start the route. If not, any starting heading can be used. (Units: None)*/
+      bool getUseStartHeading(void) const { return __UseStartHeading; }
+      RouteConstraints& setUseStartHeading(const bool val);
+
+      /** Location to which the planned route will end (Units: None)*/
+      afrl::cmasi::Location3D* const getEndLocation(void) { return __EndLocation; }
+      RouteConstraints& setEndLocation(const afrl::cmasi::Location3D* const val);
+
+      /** Heading of entity at the end of the route (Units: degrees)*/
+      float getEndHeading(void) const { return __EndHeading; }
+      RouteConstraints& setEndHeading(const float val);
+
+      /** If "true" the heading value in EndHeading must be used to end the route. If not, ant ending heading can be used. (Units: None)*/
+      bool getUseEndHeading(void) const { return __UseEndHeading; }
+      RouteConstraints& setUseEndHeading(const bool val);
+
+
+
+   protected:
+      /** ID denoting this set of route constraints */
+      int64_t __RouteID;
+      /** Location from which the planned route will start */
+      afrl::cmasi::Location3D* __StartLocation;
+      /** Heading of entity at the start of the route */
+      float __StartHeading;
+      /** If "true" the heading value in StartHeading must be used to start the route. If not, any starting heading can be used. */
+      bool __UseStartHeading;
+      /** Location to which the planned route will end */
+      afrl::cmasi::Location3D* __EndLocation;
+      /** Heading of entity at the end of the route */
+      float __EndHeading;
+      /** If "true" the heading value in EndHeading must be used to end the route. If not, ant ending heading can be used. */
+      bool __UseEndHeading;
+
+   };
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_ROUTE_ROUTECONSTRAINTS_H_
diff --git a/src/LMCP/uxas/messages/route/RouteConstraintsDescendants.h b/src/LMCP/uxas/messages/route/RouteConstraintsDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/RouteConstraintsDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/route/RoutePlan.h b/src/LMCP/uxas/messages/route/RoutePlan.h
new file mode 100644
index 0000000..29a6cce
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/RoutePlan.h
@@ -0,0 +1,127 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_ROUTEPLAN_H_
+#define _UXAS_MESSAGES_ROUTE_ROUTEPLAN_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "ROUTEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/KeyValuePair.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   bool isRoutePlan(avtas::lmcp::Object* obj);
+   bool isRoutePlan(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RoutePlanDescendants();
+   
+   class RoutePlan : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RoutePlan(void);
+
+      // Copy Constructor
+      RoutePlan(const RoutePlan &that);
+
+      // Assignment Operator
+      RoutePlan & operator=(const RoutePlan &that);
+
+      // Destructor
+      virtual ~RoutePlan(void);
+
+      // Equals overload
+      bool operator==(const RoutePlan & that);
+      bool operator!=(const RoutePlan & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RoutePlan* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 7; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("ROUTE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5931053054693474304LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** ID denoting this plan corresponding with requested route constraint pair (Units: None)*/
+      int64_t getRouteID(void) const { return __RouteID; }
+      RoutePlan& setRouteID(const int64_t val);
+
+      /** Waypoints that connect the start location with the end location. Empty if only costs were requested (Units: None)*/
+      std::vector<afrl::cmasi::Waypoint*> & getWaypoints(void) { return __Waypoints; }
+
+      /** Time cost of route. If less than zero, a planning error has occurred (Units: milliseconds)*/
+      int64_t getRouteCost(void) const { return __RouteCost; }
+      RoutePlan& setRouteCost(const int64_t val);
+
+      /** Error messages, if applicable (Units: None)*/
+      std::vector<afrl::cmasi::KeyValuePair*> & getRouteError(void) { return __RouteError; }
+
+
+
+   protected:
+      /** ID denoting this plan corresponding with requested route constraint pair */
+      int64_t __RouteID;
+      /** Waypoints that connect the start location with the end location. Empty if only costs were requested */
+      std::vector< afrl::cmasi::Waypoint* > __Waypoints;
+      /** Time cost of route. If less than zero, a planning error has occurred */
+      int64_t __RouteCost;
+      /** Error messages, if applicable */
+      std::vector< afrl::cmasi::KeyValuePair* > __RouteError;
+
+   };
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_ROUTE_ROUTEPLAN_H_
diff --git a/src/LMCP/uxas/messages/route/RoutePlanDescendants.h b/src/LMCP/uxas/messages/route/RoutePlanDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/RoutePlanDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/route/RoutePlanRequest.h b/src/LMCP/uxas/messages/route/RoutePlanRequest.h
new file mode 100644
index 0000000..81d61a8
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/RoutePlanRequest.h
@@ -0,0 +1,139 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_ROUTEPLANREQUEST_H_
+#define _UXAS_MESSAGES_ROUTE_ROUTEPLANREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "ROUTEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/route/RouteConstraints.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   bool isRoutePlanRequest(avtas::lmcp::Object* obj);
+   bool isRoutePlanRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RoutePlanRequestDescendants();
+   
+   class RoutePlanRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RoutePlanRequest(void);
+
+      // Copy Constructor
+      RoutePlanRequest(const RoutePlanRequest &that);
+
+      // Assignment Operator
+      RoutePlanRequest & operator=(const RoutePlanRequest &that);
+
+      // Destructor
+      virtual ~RoutePlanRequest(void);
+
+      // Equals overload
+      bool operator==(const RoutePlanRequest & that);
+      bool operator!=(const RoutePlanRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RoutePlanRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 6; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("ROUTE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5931053054693474304LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Request ID for correlating with response (Units: None)*/
+      int64_t getRequestID(void) const { return __RequestID; }
+      RoutePlanRequest& setRequestID(const int64_t val);
+
+      /** Associated Task ID (0 if no associated task) for this set of requests (Units: None)*/
+      int64_t getAssociatedTaskID(void) const { return __AssociatedTaskID; }
+      RoutePlanRequest& setAssociatedTaskID(const int64_t val);
+
+      /** Vehicle to consider when planning (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      RoutePlanRequest& setVehicleID(const int64_t val);
+
+      /** Operating region to be considered during planning (Units: None)*/
+      int64_t getOperatingRegion(void) const { return __OperatingRegion; }
+      RoutePlanRequest& setOperatingRegion(const int64_t val);
+
+      /** List of all requests for this vehicle + operating region situation (Units: None)*/
+      std::vector<uxas::messages::route::RouteConstraints*> & getRouteRequests(void) { return __RouteRequests; }
+
+      /** Request that planner only return costs of routes rather than complete waypoint plans (Units: None)*/
+      bool getIsCostOnlyRequest(void) const { return __IsCostOnlyRequest; }
+      RoutePlanRequest& setIsCostOnlyRequest(const bool val);
+
+
+
+   protected:
+      /** Request ID for correlating with response */
+      int64_t __RequestID;
+      /** Associated Task ID (0 if no associated task) for this set of requests */
+      int64_t __AssociatedTaskID;
+      /** Vehicle to consider when planning */
+      int64_t __VehicleID;
+      /** Operating region to be considered during planning */
+      int64_t __OperatingRegion;
+      /** List of all requests for this vehicle + operating region situation */
+      std::vector< uxas::messages::route::RouteConstraints* > __RouteRequests;
+      /** Request that planner only return costs of routes rather than complete waypoint plans */
+      bool __IsCostOnlyRequest;
+
+   };
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_ROUTE_ROUTEPLANREQUEST_H_
diff --git a/src/LMCP/uxas/messages/route/RoutePlanRequestDescendants.h b/src/LMCP/uxas/messages/route/RoutePlanRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/RoutePlanRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/route/RoutePlanResponse.h b/src/LMCP/uxas/messages/route/RoutePlanResponse.h
new file mode 100644
index 0000000..e2b62fd
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/RoutePlanResponse.h
@@ -0,0 +1,133 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_ROUTEPLANRESPONSE_H_
+#define _UXAS_MESSAGES_ROUTE_ROUTEPLANRESPONSE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "ROUTEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/route/RoutePlan.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   bool isRoutePlanResponse(avtas::lmcp::Object* obj);
+   bool isRoutePlanResponse(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RoutePlanResponseDescendants();
+   
+   class RoutePlanResponse : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RoutePlanResponse(void);
+
+      // Copy Constructor
+      RoutePlanResponse(const RoutePlanResponse &that);
+
+      // Assignment Operator
+      RoutePlanResponse & operator=(const RoutePlanResponse &that);
+
+      // Destructor
+      virtual ~RoutePlanResponse(void);
+
+      // Equals overload
+      bool operator==(const RoutePlanResponse & that);
+      bool operator!=(const RoutePlanResponse & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RoutePlanResponse* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 8; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("ROUTE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5931053054693474304LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Response ID matching ID from request ({@link RoutePlanRequest})(Units: None)*/
+      int64_t getResponseID(void) const { return __ResponseID; }
+      RoutePlanResponse& setResponseID(const int64_t val);
+
+      /** Associated Task ID (0 if no associated task) that this set of responses corresponds to (Units: None)*/
+      int64_t getAssociatedTaskID(void) const { return __AssociatedTaskID; }
+      RoutePlanResponse& setAssociatedTaskID(const int64_t val);
+
+      /** Vehicle that was considered during planning (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      RoutePlanResponse& setVehicleID(const int64_t val);
+
+      /** Operating region that was considered during planning (Units: None)*/
+      int64_t getOperatingRegion(void) const { return __OperatingRegion; }
+      RoutePlanResponse& setOperatingRegion(const int64_t val);
+
+      /** List of all responses for this vehicle + operating region situation (Units: None)*/
+      std::vector<uxas::messages::route::RoutePlan*> & getRouteResponses(void) { return __RouteResponses; }
+
+
+
+   protected:
+      /** Response ID matching ID from request ({@link RoutePlanRequest})*/
+      int64_t __ResponseID;
+      /** Associated Task ID (0 if no associated task) that this set of responses corresponds to */
+      int64_t __AssociatedTaskID;
+      /** Vehicle that was considered during planning */
+      int64_t __VehicleID;
+      /** Operating region that was considered during planning */
+      int64_t __OperatingRegion;
+      /** List of all responses for this vehicle + operating region situation */
+      std::vector< uxas::messages::route::RoutePlan* > __RouteResponses;
+
+   };
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_ROUTE_ROUTEPLANRESPONSE_H_
diff --git a/src/LMCP/uxas/messages/route/RoutePlanResponseDescendants.h b/src/LMCP/uxas/messages/route/RoutePlanResponseDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/RoutePlanResponseDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/route/RouteRequest.h b/src/LMCP/uxas/messages/route/RouteRequest.h
new file mode 100644
index 0000000..12d4e3b
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/RouteRequest.h
@@ -0,0 +1,138 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_ROUTEREQUEST_H_
+#define _UXAS_MESSAGES_ROUTE_ROUTEREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "ROUTEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/route/RouteConstraints.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   bool isRouteRequest(avtas::lmcp::Object* obj);
+   bool isRouteRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RouteRequestDescendants();
+   
+   class RouteRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RouteRequest(void);
+
+      // Copy Constructor
+      RouteRequest(const RouteRequest &that);
+
+      // Assignment Operator
+      RouteRequest & operator=(const RouteRequest &that);
+
+      // Destructor
+      virtual ~RouteRequest(void);
+
+      // Equals overload
+      bool operator==(const RouteRequest & that);
+      bool operator!=(const RouteRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RouteRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 5; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("ROUTE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5931053054693474304LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Request ID for correlating with response (Units: None)*/
+      int64_t getRequestID(void) const { return __RequestID; }
+      RouteRequest& setRequestID(const int64_t val);
+
+      /** Associated Task ID (0 if no associated task) for this set of requests (Units: None)*/
+      int64_t getAssociatedTaskID(void) const { return __AssociatedTaskID; }
+      RouteRequest& setAssociatedTaskID(const int64_t val);
+
+      /** Vehicles to consider when planning. If list is empty, route planner plans for all known vehicles. (Units: None)*/
+      std::vector<int64_t> & getVehicleID(void) { return __VehicleID; }
+
+      /** Operating region to be considered during planning (Units: None)*/
+      int64_t getOperatingRegion(void) const { return __OperatingRegion; }
+      RouteRequest& setOperatingRegion(const int64_t val);
+
+      /** List of all requests for this vehicle set + operating region situation (Units: None)*/
+      std::vector<uxas::messages::route::RouteConstraints*> & getRouteRequests(void) { return __RouteRequests; }
+
+      /** Request that planner only return costs of routes rather than complete waypoint plans (Units: None)*/
+      bool getIsCostOnlyRequest(void) const { return __IsCostOnlyRequest; }
+      RouteRequest& setIsCostOnlyRequest(const bool val);
+
+
+
+   protected:
+      /** Request ID for correlating with response */
+      int64_t __RequestID;
+      /** Associated Task ID (0 if no associated task) for this set of requests */
+      int64_t __AssociatedTaskID;
+      /** Vehicles to consider when planning. If list is empty, route planner plans for all known vehicles. */
+      std::vector< int64_t > __VehicleID;
+      /** Operating region to be considered during planning */
+      int64_t __OperatingRegion;
+      /** List of all requests for this vehicle set + operating region situation */
+      std::vector< uxas::messages::route::RouteConstraints* > __RouteRequests;
+      /** Request that planner only return costs of routes rather than complete waypoint plans */
+      bool __IsCostOnlyRequest;
+
+   };
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_ROUTE_ROUTEREQUEST_H_
diff --git a/src/LMCP/uxas/messages/route/RouteRequestDescendants.h b/src/LMCP/uxas/messages/route/RouteRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/RouteRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/route/RouteResponse.h b/src/LMCP/uxas/messages/route/RouteResponse.h
new file mode 100644
index 0000000..eb98297
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/RouteResponse.h
@@ -0,0 +1,115 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_ROUTE_ROUTERESPONSE_H_
+#define _UXAS_MESSAGES_ROUTE_ROUTERESPONSE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "ROUTEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/route/RoutePlanResponse.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   bool isRouteResponse(avtas::lmcp::Object* obj);
+   bool isRouteResponse(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > RouteResponseDescendants();
+   
+   class RouteResponse : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      RouteResponse(void);
+
+      // Copy Constructor
+      RouteResponse(const RouteResponse &that);
+
+      // Assignment Operator
+      RouteResponse & operator=(const RouteResponse &that);
+
+      // Destructor
+      virtual ~RouteResponse(void);
+
+      // Equals overload
+      bool operator==(const RouteResponse & that);
+      bool operator!=(const RouteResponse & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual RouteResponse* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 9; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("ROUTE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 5931053054693474304LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 3; }
+
+      // Accessors and Modifiers
+      /** Response ID matching ID from request ({@link RouteRequest}) (Units: None)*/
+      int64_t getResponseID(void) const { return __ResponseID; }
+      RouteResponse& setResponseID(const int64_t val);
+
+      /** Corresponding route responses for all requested vehicles (Units: None)*/
+      std::vector<uxas::messages::route::RoutePlanResponse*> & getRoutes(void) { return __Routes; }
+
+
+
+   protected:
+      /** Response ID matching ID from request ({@link RouteRequest}) */
+      int64_t __ResponseID;
+      /** Corresponding route responses for all requested vehicles */
+      std::vector< uxas::messages::route::RoutePlanResponse* > __Routes;
+
+   };
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_ROUTE_ROUTERESPONSE_H_
diff --git a/src/LMCP/uxas/messages/route/RouteResponseDescendants.h b/src/LMCP/uxas/messages/route/RouteResponseDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/RouteResponseDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/route/uxasmessagesrouteEgressRouteRequest.cpp b/src/LMCP/uxas/messages/route/uxasmessagesrouteEgressRouteRequest.cpp
new file mode 100644
index 0000000..9c93765
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/uxasmessagesrouteEgressRouteRequest.cpp
@@ -0,0 +1,226 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/route/EgressRouteRequest.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string EgressRouteRequest::Subscription = "uxas.messages.route.EgressRouteRequest";
+   const std::string EgressRouteRequest::TypeName = "EgressRouteRequest";
+   
+   bool isEgressRouteRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 10) return false;
+      return true;
+   }
+   
+   bool isEgressRouteRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 10) return false;
+      return true;
+   }
+   
+   std::vector< std::string > EgressRouteRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   EgressRouteRequest::EgressRouteRequest(void) : avtas::lmcp::Object()
+   {
+      __RequestID = 0LL;
+      __StartLocation = new afrl::cmasi::Location3D();
+      __Radius = 60.f;
+
+   }
+     
+   EgressRouteRequest::EgressRouteRequest(const EgressRouteRequest &that) : avtas::lmcp::Object(that)
+   {
+        __RequestID = that.__RequestID;
+        __StartLocation = that.__StartLocation == nullptr ? nullptr : that.__StartLocation->clone();
+        __Radius = that.__Radius;
+
+   }
+   
+   EgressRouteRequest & EgressRouteRequest::operator=(const EgressRouteRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__StartLocation != nullptr) delete __StartLocation;
+
+         __RequestID = that.__RequestID;
+         __StartLocation = that.__StartLocation == nullptr ? nullptr : that.__StartLocation->clone();
+         __Radius = that.__Radius;
+
+      }
+      return *this;
+   }
+
+   EgressRouteRequest* EgressRouteRequest::clone() const
+   {
+        return new EgressRouteRequest(*this);
+   }
+   
+   EgressRouteRequest::~EgressRouteRequest(void)
+   {
+      if (__StartLocation != nullptr) delete __StartLocation;
+
+   }
+  
+   void EgressRouteRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RequestID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __StartLocation, buf);
+      buf.putFloat(__Radius);
+
+   }
+   
+   void EgressRouteRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RequestID = buf.getLong();
+      {
+         if (__StartLocation != nullptr) delete __StartLocation;
+         __StartLocation = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __StartLocation = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__StartLocation != nullptr) __StartLocation->unpack(buf);
+         }
+      }
+      __Radius = buf.getFloat();
+
+   }
+
+   uint32_t EgressRouteRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__StartLocation != nullptr ? __StartLocation->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string EgressRouteRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( EgressRouteRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RequestID (int64_t) = " << __RequestID << "\n";
+      oss << indent << "StartLocation (Location3D)";
+      if (__StartLocation == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "Radius (float) = " << __Radius << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string EgressRouteRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<EgressRouteRequest Series=\"ROUTE\">\n";
+      str << ws << "   <RequestID>" << __RequestID << "</RequestID>\n";
+      if (__StartLocation != nullptr)
+      {
+         str << ws << "   <StartLocation>";
+         str << "\n" + __StartLocation->toXML(depth + 1) + ws + "   ";
+         str << "</StartLocation>\n";
+      }
+      str << ws << "   <Radius>" << __Radius << "</Radius>\n";
+      str << ws << "</EgressRouteRequest>\n";
+
+      return str.str();
+   }
+
+   bool EgressRouteRequest::operator==(const EgressRouteRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RequestID != that.__RequestID) return false;
+      if(__StartLocation && that.__StartLocation)
+      {
+         if(__StartLocation->getSeriesNameAsLong() != that.__StartLocation->getSeriesNameAsLong()) return false;
+         if(__StartLocation->getSeriesVersion() != that.__StartLocation->getSeriesVersion()) return false;
+         if(__StartLocation->getLmcpType() != that.__StartLocation->getLmcpType()) return false;
+         if( *(__StartLocation) != *(that.__StartLocation) ) return false;
+      }
+      else if(__StartLocation != that.__StartLocation) return false;
+      if(__Radius != that.__Radius) return false;
+      return true;
+
+   }
+
+   bool EgressRouteRequest::operator!=(const EgressRouteRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   EgressRouteRequest& EgressRouteRequest::setRequestID(const int64_t val)
+   {
+      __RequestID = val;
+      return *this;
+   }
+
+   EgressRouteRequest& EgressRouteRequest::setStartLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__StartLocation != nullptr) { delete __StartLocation; __StartLocation = nullptr; }
+      if (val != nullptr) { __StartLocation = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   EgressRouteRequest& EgressRouteRequest::setRadius(const float val)
+   {
+      __Radius = val;
+      return *this;
+   }
+
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/route/uxasmessagesrouteEgressRouteResponse.cpp b/src/LMCP/uxas/messages/route/uxasmessagesrouteEgressRouteResponse.cpp
new file mode 100644
index 0000000..7f44052
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/uxasmessagesrouteEgressRouteResponse.cpp
@@ -0,0 +1,273 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/route/EgressRouteResponse.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string EgressRouteResponse::Subscription = "uxas.messages.route.EgressRouteResponse";
+   const std::string EgressRouteResponse::TypeName = "EgressRouteResponse";
+   
+   bool isEgressRouteResponse(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 11) return false;
+      return true;
+   }
+   
+   bool isEgressRouteResponse(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 11) return false;
+      return true;
+   }
+   
+   std::vector< std::string > EgressRouteResponseDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   EgressRouteResponse::EgressRouteResponse(void) : avtas::lmcp::Object()
+   {
+      __ResponseID = 0LL;
+
+   }
+     
+   EgressRouteResponse::EgressRouteResponse(const EgressRouteResponse &that) : avtas::lmcp::Object(that)
+   {
+        __ResponseID = that.__ResponseID;
+        __NodeLocations.clear();
+        for (size_t i=0; i< that.__NodeLocations.size(); i++)
+        {
+           __NodeLocations.push_back( that.__NodeLocations[i] == nullptr ? nullptr : that.__NodeLocations[i]->clone());
+        }
+        __Headings.clear();
+        for (size_t i=0; i< that.__Headings.size(); i++)
+        {
+           __Headings.push_back( that.__Headings[i]);
+        }
+
+   }
+   
+   EgressRouteResponse & EgressRouteResponse::operator=(const EgressRouteResponse &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__NodeLocations.size(); i++)
+         {
+            if (__NodeLocations[i] != nullptr) delete __NodeLocations[i];
+         }
+
+         __ResponseID = that.__ResponseID;
+         __NodeLocations.clear();
+         for (size_t i=0; i< that.__NodeLocations.size(); i++)
+         {
+            __NodeLocations.push_back( that.__NodeLocations[i] == nullptr ? nullptr : that.__NodeLocations[i]->clone());
+         }
+         __Headings.clear();
+         for (size_t i=0; i< that.__Headings.size(); i++)
+         {
+            __Headings.push_back( that.__Headings[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   EgressRouteResponse* EgressRouteResponse::clone() const
+   {
+        return new EgressRouteResponse(*this);
+   }
+   
+   EgressRouteResponse::~EgressRouteResponse(void)
+   {
+      for (size_t i=0; i<__NodeLocations.size(); i++)
+      {
+         if (__NodeLocations[i] != nullptr) delete __NodeLocations[i];
+      }
+
+   }
+  
+   void EgressRouteResponse::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ResponseID);
+      buf.putUShort( static_cast<uint16_t>(__NodeLocations.size()));
+      for (size_t i=0; i<__NodeLocations.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __NodeLocations[i], buf);
+      }
+      buf.putUShort( static_cast<uint16_t>(__Headings.size()));
+      for (size_t i=0; i<__Headings.size(); i++)
+      {
+         buf.putFloat(__Headings[i]);
+      }
+
+   }
+   
+   void EgressRouteResponse::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ResponseID = buf.getLong();
+      for (size_t i=0; i<__NodeLocations.size(); i++)
+      {
+         if (__NodeLocations[i] != nullptr)
+            delete __NodeLocations[i];
+      }
+      __NodeLocations.clear();
+      uint16_t __NodeLocations_length = buf.getUShort();
+      for (uint32_t i=0; i< __NodeLocations_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Location3D* e = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __NodeLocations.push_back(e);
+         }
+      }
+      __Headings.clear();
+      uint16_t __Headings_length = buf.getUShort();
+      for (uint32_t i=0; i< __Headings_length; i++)
+      {
+         __Headings.push_back(buf.getFloat() );
+      }
+
+   }
+
+   uint32_t EgressRouteResponse::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__NodeLocations.size(); i++)
+      {
+         if (__NodeLocations[i] != nullptr)
+         {
+            size += __NodeLocations[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += 2 + sizeof(float) * __Headings.size();
+
+      return size;
+   }
+
+   std::string EgressRouteResponse::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( EgressRouteResponse ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ResponseID (int64_t) = " << __ResponseID << "\n";
+      oss << indent << "NodeLocations (Location3D [ " << __NodeLocations.size() << ", var ])\n";
+      oss << indent << "Headings (real32 [ " << __Headings.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string EgressRouteResponse::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<EgressRouteResponse Series=\"ROUTE\">\n";
+      str << ws << "   <ResponseID>" << __ResponseID << "</ResponseID>\n";
+      str << ws << "   <NodeLocations>\n";
+      for (size_t i=0; i<__NodeLocations.size(); i++)
+      {
+         str << (__NodeLocations[i] == nullptr ? ( ws + "   <null/>\n") : (__NodeLocations[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </NodeLocations>\n";
+      str << ws << "   <Headings>\n";
+      for (size_t i=0; i<__Headings.size(); i++)
+      {
+         str << ws << "   <real32>" << __Headings[i] << "</real32>\n";
+      }
+      str << ws << "   </Headings>\n";
+      str << ws << "</EgressRouteResponse>\n";
+
+      return str.str();
+   }
+
+   bool EgressRouteResponse::operator==(const EgressRouteResponse & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ResponseID != that.__ResponseID) return false;
+      if(__NodeLocations.size() != that.__NodeLocations.size()) return false;
+      for (size_t i=0; i<__NodeLocations.size(); i++)
+      {
+         if(__NodeLocations[i] && that.__NodeLocations[i])
+         {
+            if(__NodeLocations[i]->getSeriesNameAsLong() != that.__NodeLocations[i]->getSeriesNameAsLong()) return false;
+            if(__NodeLocations[i]->getSeriesVersion() != that.__NodeLocations[i]->getSeriesVersion()) return false;
+            if(__NodeLocations[i]->getLmcpType() != that.__NodeLocations[i]->getLmcpType()) return false;
+            if( *(__NodeLocations[i]) != *(that.__NodeLocations[i]) ) return false;
+         }
+         else if(__NodeLocations[i] != that.__NodeLocations[i]) return false;
+      }
+      if(__Headings.size() != that.__Headings.size()) return false;
+      for (size_t i=0; i<__Headings.size(); i++)
+      {
+         if(__Headings[i] != that.__Headings[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool EgressRouteResponse::operator!=(const EgressRouteResponse & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   EgressRouteResponse& EgressRouteResponse::setResponseID(const int64_t val)
+   {
+      __ResponseID = val;
+      return *this;
+   }
+
+
+
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/route/uxasmessagesrouteGraphEdge.cpp b/src/LMCP/uxas/messages/route/uxasmessagesrouteGraphEdge.cpp
new file mode 100644
index 0000000..56bb55f
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/uxasmessagesrouteGraphEdge.cpp
@@ -0,0 +1,268 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/route/GraphEdge.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string GraphEdge::Subscription = "uxas.messages.route.GraphEdge";
+   const std::string GraphEdge::TypeName = "GraphEdge";
+   
+   bool isGraphEdge(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 2) return false;
+      return true;
+   }
+   
+   bool isGraphEdge(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 2) return false;
+      return true;
+   }
+   
+   std::vector< std::string > GraphEdgeDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   GraphEdge::GraphEdge(void) : avtas::lmcp::Object()
+   {
+      __EdgeID = 0LL;
+      __StartNode = 0LL;
+      __EndNode = 0LL;
+
+   }
+     
+   GraphEdge::GraphEdge(const GraphEdge &that) : avtas::lmcp::Object(that)
+   {
+        __EdgeID = that.__EdgeID;
+        __StartNode = that.__StartNode;
+        __EndNode = that.__EndNode;
+        __Waypoints.clear();
+        for (size_t i=0; i< that.__Waypoints.size(); i++)
+        {
+           __Waypoints.push_back( that.__Waypoints[i] == nullptr ? nullptr : that.__Waypoints[i]->clone());
+        }
+
+   }
+   
+   GraphEdge & GraphEdge::operator=(const GraphEdge &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Waypoints.size(); i++)
+         {
+            if (__Waypoints[i] != nullptr) delete __Waypoints[i];
+         }
+
+         __EdgeID = that.__EdgeID;
+         __StartNode = that.__StartNode;
+         __EndNode = that.__EndNode;
+         __Waypoints.clear();
+         for (size_t i=0; i< that.__Waypoints.size(); i++)
+         {
+            __Waypoints.push_back( that.__Waypoints[i] == nullptr ? nullptr : that.__Waypoints[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   GraphEdge* GraphEdge::clone() const
+   {
+        return new GraphEdge(*this);
+   }
+   
+   GraphEdge::~GraphEdge(void)
+   {
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         if (__Waypoints[i] != nullptr) delete __Waypoints[i];
+      }
+
+   }
+  
+   void GraphEdge::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__EdgeID);
+      buf.putLong(__StartNode);
+      buf.putLong(__EndNode);
+      buf.putUShort( static_cast<uint16_t>(__Waypoints.size()));
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Waypoints[i], buf);
+      }
+
+   }
+   
+   void GraphEdge::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __EdgeID = buf.getLong();
+      __StartNode = buf.getLong();
+      __EndNode = buf.getLong();
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         if (__Waypoints[i] != nullptr)
+            delete __Waypoints[i];
+      }
+      __Waypoints.clear();
+      uint16_t __Waypoints_length = buf.getUShort();
+      for (uint32_t i=0; i< __Waypoints_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Location3D* e = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Waypoints.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t GraphEdge::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         if (__Waypoints[i] != nullptr)
+         {
+            size += __Waypoints[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string GraphEdge::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( GraphEdge ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "EdgeID (int64_t) = " << __EdgeID << "\n";
+      oss << indent << "StartNode (int64_t) = " << __StartNode << "\n";
+      oss << indent << "EndNode (int64_t) = " << __EndNode << "\n";
+      oss << indent << "Waypoints (Location3D [ " << __Waypoints.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string GraphEdge::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<GraphEdge Series=\"ROUTE\">\n";
+      str << ws << "   <EdgeID>" << __EdgeID << "</EdgeID>\n";
+      str << ws << "   <StartNode>" << __StartNode << "</StartNode>\n";
+      str << ws << "   <EndNode>" << __EndNode << "</EndNode>\n";
+      str << ws << "   <Waypoints>\n";
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         str << (__Waypoints[i] == nullptr ? ( ws + "   <null/>\n") : (__Waypoints[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Waypoints>\n";
+      str << ws << "</GraphEdge>\n";
+
+      return str.str();
+   }
+
+   bool GraphEdge::operator==(const GraphEdge & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__EdgeID != that.__EdgeID) return false;
+      if(__StartNode != that.__StartNode) return false;
+      if(__EndNode != that.__EndNode) return false;
+      if(__Waypoints.size() != that.__Waypoints.size()) return false;
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         if(__Waypoints[i] && that.__Waypoints[i])
+         {
+            if(__Waypoints[i]->getSeriesNameAsLong() != that.__Waypoints[i]->getSeriesNameAsLong()) return false;
+            if(__Waypoints[i]->getSeriesVersion() != that.__Waypoints[i]->getSeriesVersion()) return false;
+            if(__Waypoints[i]->getLmcpType() != that.__Waypoints[i]->getLmcpType()) return false;
+            if( *(__Waypoints[i]) != *(that.__Waypoints[i]) ) return false;
+         }
+         else if(__Waypoints[i] != that.__Waypoints[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool GraphEdge::operator!=(const GraphEdge & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   GraphEdge& GraphEdge::setEdgeID(const int64_t val)
+   {
+      __EdgeID = val;
+      return *this;
+   }
+
+   GraphEdge& GraphEdge::setStartNode(const int64_t val)
+   {
+      __StartNode = val;
+      return *this;
+   }
+
+   GraphEdge& GraphEdge::setEndNode(const int64_t val)
+   {
+      __EndNode = val;
+      return *this;
+   }
+
+
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/route/uxasmessagesrouteGraphNode.cpp b/src/LMCP/uxas/messages/route/uxasmessagesrouteGraphNode.cpp
new file mode 100644
index 0000000..ab296fc
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/uxasmessagesrouteGraphNode.cpp
@@ -0,0 +1,246 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/route/GraphNode.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string GraphNode::Subscription = "uxas.messages.route.GraphNode";
+   const std::string GraphNode::TypeName = "GraphNode";
+   
+   bool isGraphNode(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 1) return false;
+      return true;
+   }
+   
+   bool isGraphNode(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 1) return false;
+      return true;
+   }
+   
+   std::vector< std::string > GraphNodeDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   GraphNode::GraphNode(void) : avtas::lmcp::Object()
+   {
+      __NodeID = 0LL;
+      __Coordinates = new afrl::cmasi::Location3D();
+
+   }
+     
+   GraphNode::GraphNode(const GraphNode &that) : avtas::lmcp::Object(that)
+   {
+        __NodeID = that.__NodeID;
+        __Coordinates = that.__Coordinates == nullptr ? nullptr : that.__Coordinates->clone();
+        __AssociatedEdges.clear();
+        for (size_t i=0; i< that.__AssociatedEdges.size(); i++)
+        {
+           __AssociatedEdges.push_back( that.__AssociatedEdges[i]);
+        }
+
+   }
+   
+   GraphNode & GraphNode::operator=(const GraphNode &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__Coordinates != nullptr) delete __Coordinates;
+
+         __NodeID = that.__NodeID;
+         __Coordinates = that.__Coordinates == nullptr ? nullptr : that.__Coordinates->clone();
+         __AssociatedEdges.clear();
+         for (size_t i=0; i< that.__AssociatedEdges.size(); i++)
+         {
+            __AssociatedEdges.push_back( that.__AssociatedEdges[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   GraphNode* GraphNode::clone() const
+   {
+        return new GraphNode(*this);
+   }
+   
+   GraphNode::~GraphNode(void)
+   {
+      if (__Coordinates != nullptr) delete __Coordinates;
+
+   }
+  
+   void GraphNode::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__NodeID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Coordinates, buf);
+      buf.putUShort( static_cast<uint16_t>(__AssociatedEdges.size()));
+      for (size_t i=0; i<__AssociatedEdges.size(); i++)
+      {
+         buf.putLong(__AssociatedEdges[i]);
+      }
+
+   }
+   
+   void GraphNode::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __NodeID = buf.getLong();
+      {
+         if (__Coordinates != nullptr) delete __Coordinates;
+         __Coordinates = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Coordinates = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Coordinates != nullptr) __Coordinates->unpack(buf);
+         }
+      }
+      __AssociatedEdges.clear();
+      uint16_t __AssociatedEdges_length = buf.getUShort();
+      for (uint32_t i=0; i< __AssociatedEdges_length; i++)
+      {
+         __AssociatedEdges.push_back(buf.getLong() );
+      }
+
+   }
+
+   uint32_t GraphNode::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__Coordinates != nullptr ? __Coordinates->calculatePackedSize() + 15 : 1);
+      size += 2 + sizeof(int64_t) * __AssociatedEdges.size();
+
+      return size;
+   }
+
+   std::string GraphNode::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( GraphNode ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "NodeID (int64_t) = " << __NodeID << "\n";
+      oss << indent << "Coordinates (Location3D)";
+      if (__Coordinates == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "AssociatedEdges (int64 [ " << __AssociatedEdges.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string GraphNode::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<GraphNode Series=\"ROUTE\">\n";
+      str << ws << "   <NodeID>" << __NodeID << "</NodeID>\n";
+      if (__Coordinates != nullptr)
+      {
+         str << ws << "   <Coordinates>";
+         str << "\n" + __Coordinates->toXML(depth + 1) + ws + "   ";
+         str << "</Coordinates>\n";
+      }
+      str << ws << "   <AssociatedEdges>\n";
+      for (size_t i=0; i<__AssociatedEdges.size(); i++)
+      {
+         str << ws << "   <int64>" << __AssociatedEdges[i] << "</int64>\n";
+      }
+      str << ws << "   </AssociatedEdges>\n";
+      str << ws << "</GraphNode>\n";
+
+      return str.str();
+   }
+
+   bool GraphNode::operator==(const GraphNode & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__NodeID != that.__NodeID) return false;
+      if(__Coordinates && that.__Coordinates)
+      {
+         if(__Coordinates->getSeriesNameAsLong() != that.__Coordinates->getSeriesNameAsLong()) return false;
+         if(__Coordinates->getSeriesVersion() != that.__Coordinates->getSeriesVersion()) return false;
+         if(__Coordinates->getLmcpType() != that.__Coordinates->getLmcpType()) return false;
+         if( *(__Coordinates) != *(that.__Coordinates) ) return false;
+      }
+      else if(__Coordinates != that.__Coordinates) return false;
+      if(__AssociatedEdges.size() != that.__AssociatedEdges.size()) return false;
+      for (size_t i=0; i<__AssociatedEdges.size(); i++)
+      {
+         if(__AssociatedEdges[i] != that.__AssociatedEdges[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool GraphNode::operator!=(const GraphNode & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   GraphNode& GraphNode::setNodeID(const int64_t val)
+   {
+      __NodeID = val;
+      return *this;
+   }
+
+   GraphNode& GraphNode::setCoordinates(const afrl::cmasi::Location3D* const val)
+   {
+      if (__Coordinates != nullptr) { delete __Coordinates; __Coordinates = nullptr; }
+      if (val != nullptr) { __Coordinates = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/route/uxasmessagesrouteGraphRegion.cpp b/src/LMCP/uxas/messages/route/uxasmessagesrouteGraphRegion.cpp
new file mode 100644
index 0000000..dc81ef5
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/uxasmessagesrouteGraphRegion.cpp
@@ -0,0 +1,307 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/route/GraphRegion.h"
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string GraphRegion::Subscription = "uxas.messages.route.GraphRegion";
+   const std::string GraphRegion::TypeName = "GraphRegion";
+   
+   bool isGraphRegion(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 3) return false;
+      return true;
+   }
+   
+   bool isGraphRegion(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 3) return false;
+      return true;
+   }
+   
+   std::vector< std::string > GraphRegionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   GraphRegion::GraphRegion(void) : avtas::lmcp::Object()
+   {
+      __ID = 0LL;
+
+   }
+     
+   GraphRegion::GraphRegion(const GraphRegion &that) : avtas::lmcp::Object(that)
+   {
+        __ID = that.__ID;
+        __NodeList.clear();
+        for (size_t i=0; i< that.__NodeList.size(); i++)
+        {
+           __NodeList.push_back( that.__NodeList[i] == nullptr ? nullptr : that.__NodeList[i]->clone());
+        }
+        __EdgeList.clear();
+        for (size_t i=0; i< that.__EdgeList.size(); i++)
+        {
+           __EdgeList.push_back( that.__EdgeList[i] == nullptr ? nullptr : that.__EdgeList[i]->clone());
+        }
+
+   }
+   
+   GraphRegion & GraphRegion::operator=(const GraphRegion &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__NodeList.size(); i++)
+         {
+            if (__NodeList[i] != nullptr) delete __NodeList[i];
+         }
+         for (size_t i=0; i<__EdgeList.size(); i++)
+         {
+            if (__EdgeList[i] != nullptr) delete __EdgeList[i];
+         }
+
+         __ID = that.__ID;
+         __NodeList.clear();
+         for (size_t i=0; i< that.__NodeList.size(); i++)
+         {
+            __NodeList.push_back( that.__NodeList[i] == nullptr ? nullptr : that.__NodeList[i]->clone());
+         }
+         __EdgeList.clear();
+         for (size_t i=0; i< that.__EdgeList.size(); i++)
+         {
+            __EdgeList.push_back( that.__EdgeList[i] == nullptr ? nullptr : that.__EdgeList[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   GraphRegion* GraphRegion::clone() const
+   {
+        return new GraphRegion(*this);
+   }
+   
+   GraphRegion::~GraphRegion(void)
+   {
+      for (size_t i=0; i<__NodeList.size(); i++)
+      {
+         if (__NodeList[i] != nullptr) delete __NodeList[i];
+      }
+      for (size_t i=0; i<__EdgeList.size(); i++)
+      {
+         if (__EdgeList[i] != nullptr) delete __EdgeList[i];
+      }
+
+   }
+  
+   void GraphRegion::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ID);
+      buf.putUInt( static_cast<uint32_t>(__NodeList.size()));
+      for (size_t i=0; i<__NodeList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __NodeList[i], buf);
+      }
+      buf.putUInt( static_cast<uint32_t>(__EdgeList.size()));
+      for (size_t i=0; i<__EdgeList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __EdgeList[i], buf);
+      }
+
+   }
+   
+   void GraphRegion::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ID = buf.getLong();
+      for (size_t i=0; i<__NodeList.size(); i++)
+      {
+         if (__NodeList[i] != nullptr)
+            delete __NodeList[i];
+      }
+      __NodeList.clear();
+      uint32_t __NodeList_length = buf.getUInt();
+      for (uint32_t i=0; i< __NodeList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::route::GraphNode* e = (uxas::messages::route::GraphNode*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __NodeList.push_back(e);
+         }
+      }
+      for (size_t i=0; i<__EdgeList.size(); i++)
+      {
+         if (__EdgeList[i] != nullptr)
+            delete __EdgeList[i];
+      }
+      __EdgeList.clear();
+      uint32_t __EdgeList_length = buf.getUInt();
+      for (uint32_t i=0; i< __EdgeList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::route::GraphEdge* e = (uxas::messages::route::GraphEdge*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __EdgeList.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t GraphRegion::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 4;
+      for (size_t i=0; i<__NodeList.size(); i++)
+      {
+         if (__NodeList[i] != nullptr)
+         {
+            size += __NodeList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += 4;
+      for (size_t i=0; i<__EdgeList.size(); i++)
+      {
+         if (__EdgeList[i] != nullptr)
+         {
+            size += __EdgeList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string GraphRegion::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( GraphRegion ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ID (int64_t) = " << __ID << "\n";
+      oss << indent << "NodeList (GraphNode [ " << __NodeList.size() << ", var ])\n";
+      oss << indent << "EdgeList (GraphEdge [ " << __EdgeList.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string GraphRegion::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<GraphRegion Series=\"ROUTE\">\n";
+      str << ws << "   <ID>" << __ID << "</ID>\n";
+      str << ws << "   <NodeList>\n";
+      for (size_t i=0; i<__NodeList.size(); i++)
+      {
+         str << (__NodeList[i] == nullptr ? ( ws + "   <null/>\n") : (__NodeList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </NodeList>\n";
+      str << ws << "   <EdgeList>\n";
+      for (size_t i=0; i<__EdgeList.size(); i++)
+      {
+         str << (__EdgeList[i] == nullptr ? ( ws + "   <null/>\n") : (__EdgeList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </EdgeList>\n";
+      str << ws << "</GraphRegion>\n";
+
+      return str.str();
+   }
+
+   bool GraphRegion::operator==(const GraphRegion & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ID != that.__ID) return false;
+      if(__NodeList.size() != that.__NodeList.size()) return false;
+      for (size_t i=0; i<__NodeList.size(); i++)
+      {
+         if(__NodeList[i] && that.__NodeList[i])
+         {
+            if(__NodeList[i]->getSeriesNameAsLong() != that.__NodeList[i]->getSeriesNameAsLong()) return false;
+            if(__NodeList[i]->getSeriesVersion() != that.__NodeList[i]->getSeriesVersion()) return false;
+            if(__NodeList[i]->getLmcpType() != that.__NodeList[i]->getLmcpType()) return false;
+            if( *(__NodeList[i]) != *(that.__NodeList[i]) ) return false;
+         }
+         else if(__NodeList[i] != that.__NodeList[i]) return false;
+      }
+      if(__EdgeList.size() != that.__EdgeList.size()) return false;
+      for (size_t i=0; i<__EdgeList.size(); i++)
+      {
+         if(__EdgeList[i] && that.__EdgeList[i])
+         {
+            if(__EdgeList[i]->getSeriesNameAsLong() != that.__EdgeList[i]->getSeriesNameAsLong()) return false;
+            if(__EdgeList[i]->getSeriesVersion() != that.__EdgeList[i]->getSeriesVersion()) return false;
+            if(__EdgeList[i]->getLmcpType() != that.__EdgeList[i]->getLmcpType()) return false;
+            if( *(__EdgeList[i]) != *(that.__EdgeList[i]) ) return false;
+         }
+         else if(__EdgeList[i] != that.__EdgeList[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool GraphRegion::operator!=(const GraphRegion & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   GraphRegion& GraphRegion::setID(const int64_t val)
+   {
+      __ID = val;
+      return *this;
+   }
+
+
+
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/route/uxasmessagesrouteRouteConstraints.cpp b/src/LMCP/uxas/messages/route/uxasmessagesrouteRouteConstraints.cpp
new file mode 100644
index 0000000..96cebe0
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/uxasmessagesrouteRouteConstraints.cpp
@@ -0,0 +1,317 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/route/RouteConstraints.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RouteConstraints::Subscription = "uxas.messages.route.RouteConstraints";
+   const std::string RouteConstraints::TypeName = "RouteConstraints";
+   
+   bool isRouteConstraints(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 4) return false;
+      return true;
+   }
+   
+   bool isRouteConstraints(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 4) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RouteConstraintsDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RouteConstraints::RouteConstraints(void) : avtas::lmcp::Object()
+   {
+      __RouteID = 0LL;
+      __StartLocation = new afrl::cmasi::Location3D();
+      __StartHeading = 0.f;
+      __UseStartHeading = true;
+      __EndLocation = new afrl::cmasi::Location3D();
+      __EndHeading = 0.f;
+      __UseEndHeading = true;
+
+   }
+     
+   RouteConstraints::RouteConstraints(const RouteConstraints &that) : avtas::lmcp::Object(that)
+   {
+        __RouteID = that.__RouteID;
+        __StartLocation = that.__StartLocation == nullptr ? nullptr : that.__StartLocation->clone();
+        __StartHeading = that.__StartHeading;
+        __UseStartHeading = that.__UseStartHeading;
+        __EndLocation = that.__EndLocation == nullptr ? nullptr : that.__EndLocation->clone();
+        __EndHeading = that.__EndHeading;
+        __UseEndHeading = that.__UseEndHeading;
+
+   }
+   
+   RouteConstraints & RouteConstraints::operator=(const RouteConstraints &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__StartLocation != nullptr) delete __StartLocation;
+         if (__EndLocation != nullptr) delete __EndLocation;
+
+         __RouteID = that.__RouteID;
+         __StartLocation = that.__StartLocation == nullptr ? nullptr : that.__StartLocation->clone();
+         __StartHeading = that.__StartHeading;
+         __UseStartHeading = that.__UseStartHeading;
+         __EndLocation = that.__EndLocation == nullptr ? nullptr : that.__EndLocation->clone();
+         __EndHeading = that.__EndHeading;
+         __UseEndHeading = that.__UseEndHeading;
+
+      }
+      return *this;
+   }
+
+   RouteConstraints* RouteConstraints::clone() const
+   {
+        return new RouteConstraints(*this);
+   }
+   
+   RouteConstraints::~RouteConstraints(void)
+   {
+      if (__StartLocation != nullptr) delete __StartLocation;
+      if (__EndLocation != nullptr) delete __EndLocation;
+
+   }
+  
+   void RouteConstraints::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RouteID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __StartLocation, buf);
+      buf.putFloat(__StartHeading);
+      buf.putBool(__UseStartHeading);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __EndLocation, buf);
+      buf.putFloat(__EndHeading);
+      buf.putBool(__UseEndHeading);
+
+   }
+   
+   void RouteConstraints::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RouteID = buf.getLong();
+      {
+         if (__StartLocation != nullptr) delete __StartLocation;
+         __StartLocation = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __StartLocation = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__StartLocation != nullptr) __StartLocation->unpack(buf);
+         }
+      }
+      __StartHeading = buf.getFloat();
+      __UseStartHeading = buf.getBool();
+      {
+         if (__EndLocation != nullptr) delete __EndLocation;
+         __EndLocation = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __EndLocation = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__EndLocation != nullptr) __EndLocation->unpack(buf);
+         }
+      }
+      __EndHeading = buf.getFloat();
+      __UseEndHeading = buf.getBool();
+
+   }
+
+   uint32_t RouteConstraints::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__StartLocation != nullptr ? __StartLocation->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+      size += sizeof(bool);
+      size += (__EndLocation != nullptr ? __EndLocation->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string RouteConstraints::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RouteConstraints ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RouteID (int64_t) = " << __RouteID << "\n";
+      oss << indent << "StartLocation (Location3D)";
+      if (__StartLocation == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "StartHeading (float) = " << __StartHeading << "\n";
+      oss << indent << "UseStartHeading (bool) = " << __UseStartHeading << "\n";
+      oss << indent << "EndLocation (Location3D)";
+      if (__EndLocation == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "EndHeading (float) = " << __EndHeading << "\n";
+      oss << indent << "UseEndHeading (bool) = " << __UseEndHeading << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RouteConstraints::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RouteConstraints Series=\"ROUTE\">\n";
+      str << ws << "   <RouteID>" << __RouteID << "</RouteID>\n";
+      if (__StartLocation != nullptr)
+      {
+         str << ws << "   <StartLocation>";
+         str << "\n" + __StartLocation->toXML(depth + 1) + ws + "   ";
+         str << "</StartLocation>\n";
+      }
+      str << ws << "   <StartHeading>" << __StartHeading << "</StartHeading>\n";
+      str << ws << "   <UseStartHeading>" << (__UseStartHeading ? "true" : "false") << "</UseStartHeading>\n";
+      if (__EndLocation != nullptr)
+      {
+         str << ws << "   <EndLocation>";
+         str << "\n" + __EndLocation->toXML(depth + 1) + ws + "   ";
+         str << "</EndLocation>\n";
+      }
+      str << ws << "   <EndHeading>" << __EndHeading << "</EndHeading>\n";
+      str << ws << "   <UseEndHeading>" << (__UseEndHeading ? "true" : "false") << "</UseEndHeading>\n";
+      str << ws << "</RouteConstraints>\n";
+
+      return str.str();
+   }
+
+   bool RouteConstraints::operator==(const RouteConstraints & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RouteID != that.__RouteID) return false;
+      if(__StartLocation && that.__StartLocation)
+      {
+         if(__StartLocation->getSeriesNameAsLong() != that.__StartLocation->getSeriesNameAsLong()) return false;
+         if(__StartLocation->getSeriesVersion() != that.__StartLocation->getSeriesVersion()) return false;
+         if(__StartLocation->getLmcpType() != that.__StartLocation->getLmcpType()) return false;
+         if( *(__StartLocation) != *(that.__StartLocation) ) return false;
+      }
+      else if(__StartLocation != that.__StartLocation) return false;
+      if(__StartHeading != that.__StartHeading) return false;
+      if(__UseStartHeading != that.__UseStartHeading) return false;
+      if(__EndLocation && that.__EndLocation)
+      {
+         if(__EndLocation->getSeriesNameAsLong() != that.__EndLocation->getSeriesNameAsLong()) return false;
+         if(__EndLocation->getSeriesVersion() != that.__EndLocation->getSeriesVersion()) return false;
+         if(__EndLocation->getLmcpType() != that.__EndLocation->getLmcpType()) return false;
+         if( *(__EndLocation) != *(that.__EndLocation) ) return false;
+      }
+      else if(__EndLocation != that.__EndLocation) return false;
+      if(__EndHeading != that.__EndHeading) return false;
+      if(__UseEndHeading != that.__UseEndHeading) return false;
+      return true;
+
+   }
+
+   bool RouteConstraints::operator!=(const RouteConstraints & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   RouteConstraints& RouteConstraints::setRouteID(const int64_t val)
+   {
+      __RouteID = val;
+      return *this;
+   }
+
+   RouteConstraints& RouteConstraints::setStartLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__StartLocation != nullptr) { delete __StartLocation; __StartLocation = nullptr; }
+      if (val != nullptr) { __StartLocation = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   RouteConstraints& RouteConstraints::setStartHeading(const float val)
+   {
+      __StartHeading = val;
+      return *this;
+   }
+
+   RouteConstraints& RouteConstraints::setUseStartHeading(const bool val)
+   {
+      __UseStartHeading = val;
+      return *this;
+   }
+
+   RouteConstraints& RouteConstraints::setEndLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__EndLocation != nullptr) { delete __EndLocation; __EndLocation = nullptr; }
+      if (val != nullptr) { __EndLocation = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   RouteConstraints& RouteConstraints::setEndHeading(const float val)
+   {
+      __EndHeading = val;
+      return *this;
+   }
+
+   RouteConstraints& RouteConstraints::setUseEndHeading(const bool val)
+   {
+      __UseEndHeading = val;
+      return *this;
+   }
+
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/route/uxasmessagesrouteRoutePlan.cpp b/src/LMCP/uxas/messages/route/uxasmessagesrouteRoutePlan.cpp
new file mode 100644
index 0000000..b45e04e
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/uxasmessagesrouteRoutePlan.cpp
@@ -0,0 +1,323 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/route/RoutePlan.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RoutePlan::Subscription = "uxas.messages.route.RoutePlan";
+   const std::string RoutePlan::TypeName = "RoutePlan";
+   
+   bool isRoutePlan(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 7) return false;
+      return true;
+   }
+   
+   bool isRoutePlan(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 7) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RoutePlanDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RoutePlan::RoutePlan(void) : avtas::lmcp::Object()
+   {
+      __RouteID = 0LL;
+      __RouteCost = -1LL;
+
+   }
+     
+   RoutePlan::RoutePlan(const RoutePlan &that) : avtas::lmcp::Object(that)
+   {
+        __RouteID = that.__RouteID;
+        __Waypoints.clear();
+        for (size_t i=0; i< that.__Waypoints.size(); i++)
+        {
+           __Waypoints.push_back( that.__Waypoints[i] == nullptr ? nullptr : that.__Waypoints[i]->clone());
+        }
+        __RouteCost = that.__RouteCost;
+        __RouteError.clear();
+        for (size_t i=0; i< that.__RouteError.size(); i++)
+        {
+           __RouteError.push_back( that.__RouteError[i] == nullptr ? nullptr : that.__RouteError[i]->clone());
+        }
+
+   }
+   
+   RoutePlan & RoutePlan::operator=(const RoutePlan &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Waypoints.size(); i++)
+         {
+            if (__Waypoints[i] != nullptr) delete __Waypoints[i];
+         }
+         for (size_t i=0; i<__RouteError.size(); i++)
+         {
+            if (__RouteError[i] != nullptr) delete __RouteError[i];
+         }
+
+         __RouteID = that.__RouteID;
+         __Waypoints.clear();
+         for (size_t i=0; i< that.__Waypoints.size(); i++)
+         {
+            __Waypoints.push_back( that.__Waypoints[i] == nullptr ? nullptr : that.__Waypoints[i]->clone());
+         }
+         __RouteCost = that.__RouteCost;
+         __RouteError.clear();
+         for (size_t i=0; i< that.__RouteError.size(); i++)
+         {
+            __RouteError.push_back( that.__RouteError[i] == nullptr ? nullptr : that.__RouteError[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   RoutePlan* RoutePlan::clone() const
+   {
+        return new RoutePlan(*this);
+   }
+   
+   RoutePlan::~RoutePlan(void)
+   {
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         if (__Waypoints[i] != nullptr) delete __Waypoints[i];
+      }
+      for (size_t i=0; i<__RouteError.size(); i++)
+      {
+         if (__RouteError[i] != nullptr) delete __RouteError[i];
+      }
+
+   }
+  
+   void RoutePlan::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RouteID);
+      buf.putUShort( static_cast<uint16_t>(__Waypoints.size()));
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Waypoints[i], buf);
+      }
+      buf.putLong(__RouteCost);
+      buf.putUShort( static_cast<uint16_t>(__RouteError.size()));
+      for (size_t i=0; i<__RouteError.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __RouteError[i], buf);
+      }
+
+   }
+   
+   void RoutePlan::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RouteID = buf.getLong();
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         if (__Waypoints[i] != nullptr)
+            delete __Waypoints[i];
+      }
+      __Waypoints.clear();
+      uint16_t __Waypoints_length = buf.getUShort();
+      for (uint32_t i=0; i< __Waypoints_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Waypoint* e = (afrl::cmasi::Waypoint*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Waypoints.push_back(e);
+         }
+      }
+      __RouteCost = buf.getLong();
+      for (size_t i=0; i<__RouteError.size(); i++)
+      {
+         if (__RouteError[i] != nullptr)
+            delete __RouteError[i];
+      }
+      __RouteError.clear();
+      uint16_t __RouteError_length = buf.getUShort();
+      for (uint32_t i=0; i< __RouteError_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::KeyValuePair* e = (afrl::cmasi::KeyValuePair*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __RouteError.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t RoutePlan::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         if (__Waypoints[i] != nullptr)
+         {
+            size += __Waypoints[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__RouteError.size(); i++)
+      {
+         if (__RouteError[i] != nullptr)
+         {
+            size += __RouteError[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string RoutePlan::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RoutePlan ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RouteID (int64_t) = " << __RouteID << "\n";
+      oss << indent << "Waypoints (Waypoint [ " << __Waypoints.size() << ", var ])\n";
+      oss << indent << "RouteCost (int64_t) = " << __RouteCost << "\n";
+      oss << indent << "RouteError (KeyValuePair [ " << __RouteError.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RoutePlan::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RoutePlan Series=\"ROUTE\">\n";
+      str << ws << "   <RouteID>" << __RouteID << "</RouteID>\n";
+      str << ws << "   <Waypoints>\n";
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         str << (__Waypoints[i] == nullptr ? ( ws + "   <null/>\n") : (__Waypoints[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Waypoints>\n";
+      str << ws << "   <RouteCost>" << __RouteCost << "</RouteCost>\n";
+      str << ws << "   <RouteError>\n";
+      for (size_t i=0; i<__RouteError.size(); i++)
+      {
+         str << (__RouteError[i] == nullptr ? ( ws + "   <null/>\n") : (__RouteError[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </RouteError>\n";
+      str << ws << "</RoutePlan>\n";
+
+      return str.str();
+   }
+
+   bool RoutePlan::operator==(const RoutePlan & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RouteID != that.__RouteID) return false;
+      if(__Waypoints.size() != that.__Waypoints.size()) return false;
+      for (size_t i=0; i<__Waypoints.size(); i++)
+      {
+         if(__Waypoints[i] && that.__Waypoints[i])
+         {
+            if(__Waypoints[i]->getSeriesNameAsLong() != that.__Waypoints[i]->getSeriesNameAsLong()) return false;
+            if(__Waypoints[i]->getSeriesVersion() != that.__Waypoints[i]->getSeriesVersion()) return false;
+            if(__Waypoints[i]->getLmcpType() != that.__Waypoints[i]->getLmcpType()) return false;
+            if( *(__Waypoints[i]) != *(that.__Waypoints[i]) ) return false;
+         }
+         else if(__Waypoints[i] != that.__Waypoints[i]) return false;
+      }
+      if(__RouteCost != that.__RouteCost) return false;
+      if(__RouteError.size() != that.__RouteError.size()) return false;
+      for (size_t i=0; i<__RouteError.size(); i++)
+      {
+         if(__RouteError[i] && that.__RouteError[i])
+         {
+            if(__RouteError[i]->getSeriesNameAsLong() != that.__RouteError[i]->getSeriesNameAsLong()) return false;
+            if(__RouteError[i]->getSeriesVersion() != that.__RouteError[i]->getSeriesVersion()) return false;
+            if(__RouteError[i]->getLmcpType() != that.__RouteError[i]->getLmcpType()) return false;
+            if( *(__RouteError[i]) != *(that.__RouteError[i]) ) return false;
+         }
+         else if(__RouteError[i] != that.__RouteError[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool RoutePlan::operator!=(const RoutePlan & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   RoutePlan& RoutePlan::setRouteID(const int64_t val)
+   {
+      __RouteID = val;
+      return *this;
+   }
+
+
+   RoutePlan& RoutePlan::setRouteCost(const int64_t val)
+   {
+      __RouteCost = val;
+      return *this;
+   }
+
+
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/route/uxasmessagesrouteRoutePlanRequest.cpp b/src/LMCP/uxas/messages/route/uxasmessagesrouteRoutePlanRequest.cpp
new file mode 100644
index 0000000..8a681c8
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/uxasmessagesrouteRoutePlanRequest.cpp
@@ -0,0 +1,296 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/route/RoutePlanRequest.h"
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RoutePlanRequest::Subscription = "uxas.messages.route.RoutePlanRequest";
+   const std::string RoutePlanRequest::TypeName = "RoutePlanRequest";
+   
+   bool isRoutePlanRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 6) return false;
+      return true;
+   }
+   
+   bool isRoutePlanRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 6) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RoutePlanRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RoutePlanRequest::RoutePlanRequest(void) : avtas::lmcp::Object()
+   {
+      __RequestID = 0LL;
+      __AssociatedTaskID = 0LL;
+      __VehicleID = 0LL;
+      __OperatingRegion = 0LL;
+      __IsCostOnlyRequest = true;
+
+   }
+     
+   RoutePlanRequest::RoutePlanRequest(const RoutePlanRequest &that) : avtas::lmcp::Object(that)
+   {
+        __RequestID = that.__RequestID;
+        __AssociatedTaskID = that.__AssociatedTaskID;
+        __VehicleID = that.__VehicleID;
+        __OperatingRegion = that.__OperatingRegion;
+        __RouteRequests.clear();
+        for (size_t i=0; i< that.__RouteRequests.size(); i++)
+        {
+           __RouteRequests.push_back( that.__RouteRequests[i] == nullptr ? nullptr : that.__RouteRequests[i]->clone());
+        }
+        __IsCostOnlyRequest = that.__IsCostOnlyRequest;
+
+   }
+   
+   RoutePlanRequest & RoutePlanRequest::operator=(const RoutePlanRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__RouteRequests.size(); i++)
+         {
+            if (__RouteRequests[i] != nullptr) delete __RouteRequests[i];
+         }
+
+         __RequestID = that.__RequestID;
+         __AssociatedTaskID = that.__AssociatedTaskID;
+         __VehicleID = that.__VehicleID;
+         __OperatingRegion = that.__OperatingRegion;
+         __RouteRequests.clear();
+         for (size_t i=0; i< that.__RouteRequests.size(); i++)
+         {
+            __RouteRequests.push_back( that.__RouteRequests[i] == nullptr ? nullptr : that.__RouteRequests[i]->clone());
+         }
+         __IsCostOnlyRequest = that.__IsCostOnlyRequest;
+
+      }
+      return *this;
+   }
+
+   RoutePlanRequest* RoutePlanRequest::clone() const
+   {
+        return new RoutePlanRequest(*this);
+   }
+   
+   RoutePlanRequest::~RoutePlanRequest(void)
+   {
+      for (size_t i=0; i<__RouteRequests.size(); i++)
+      {
+         if (__RouteRequests[i] != nullptr) delete __RouteRequests[i];
+      }
+
+   }
+  
+   void RoutePlanRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RequestID);
+      buf.putLong(__AssociatedTaskID);
+      buf.putLong(__VehicleID);
+      buf.putLong(__OperatingRegion);
+      buf.putUShort( static_cast<uint16_t>(__RouteRequests.size()));
+      for (size_t i=0; i<__RouteRequests.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __RouteRequests[i], buf);
+      }
+      buf.putBool(__IsCostOnlyRequest);
+
+   }
+   
+   void RoutePlanRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RequestID = buf.getLong();
+      __AssociatedTaskID = buf.getLong();
+      __VehicleID = buf.getLong();
+      __OperatingRegion = buf.getLong();
+      for (size_t i=0; i<__RouteRequests.size(); i++)
+      {
+         if (__RouteRequests[i] != nullptr)
+            delete __RouteRequests[i];
+      }
+      __RouteRequests.clear();
+      uint16_t __RouteRequests_length = buf.getUShort();
+      for (uint32_t i=0; i< __RouteRequests_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::route::RouteConstraints* e = (uxas::messages::route::RouteConstraints*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __RouteRequests.push_back(e);
+         }
+      }
+      __IsCostOnlyRequest = buf.getBool();
+
+   }
+
+   uint32_t RoutePlanRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__RouteRequests.size(); i++)
+      {
+         if (__RouteRequests[i] != nullptr)
+         {
+            size += __RouteRequests[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string RoutePlanRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RoutePlanRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RequestID (int64_t) = " << __RequestID << "\n";
+      oss << indent << "AssociatedTaskID (int64_t) = " << __AssociatedTaskID << "\n";
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "OperatingRegion (int64_t) = " << __OperatingRegion << "\n";
+      oss << indent << "RouteRequests (RouteConstraints [ " << __RouteRequests.size() << ", var ])\n";
+      oss << indent << "IsCostOnlyRequest (bool) = " << __IsCostOnlyRequest << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RoutePlanRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RoutePlanRequest Series=\"ROUTE\">\n";
+      str << ws << "   <RequestID>" << __RequestID << "</RequestID>\n";
+      str << ws << "   <AssociatedTaskID>" << __AssociatedTaskID << "</AssociatedTaskID>\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <OperatingRegion>" << __OperatingRegion << "</OperatingRegion>\n";
+      str << ws << "   <RouteRequests>\n";
+      for (size_t i=0; i<__RouteRequests.size(); i++)
+      {
+         str << (__RouteRequests[i] == nullptr ? ( ws + "   <null/>\n") : (__RouteRequests[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </RouteRequests>\n";
+      str << ws << "   <IsCostOnlyRequest>" << (__IsCostOnlyRequest ? "true" : "false") << "</IsCostOnlyRequest>\n";
+      str << ws << "</RoutePlanRequest>\n";
+
+      return str.str();
+   }
+
+   bool RoutePlanRequest::operator==(const RoutePlanRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RequestID != that.__RequestID) return false;
+      if(__AssociatedTaskID != that.__AssociatedTaskID) return false;
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__OperatingRegion != that.__OperatingRegion) return false;
+      if(__RouteRequests.size() != that.__RouteRequests.size()) return false;
+      for (size_t i=0; i<__RouteRequests.size(); i++)
+      {
+         if(__RouteRequests[i] && that.__RouteRequests[i])
+         {
+            if(__RouteRequests[i]->getSeriesNameAsLong() != that.__RouteRequests[i]->getSeriesNameAsLong()) return false;
+            if(__RouteRequests[i]->getSeriesVersion() != that.__RouteRequests[i]->getSeriesVersion()) return false;
+            if(__RouteRequests[i]->getLmcpType() != that.__RouteRequests[i]->getLmcpType()) return false;
+            if( *(__RouteRequests[i]) != *(that.__RouteRequests[i]) ) return false;
+         }
+         else if(__RouteRequests[i] != that.__RouteRequests[i]) return false;
+      }
+      if(__IsCostOnlyRequest != that.__IsCostOnlyRequest) return false;
+      return true;
+
+   }
+
+   bool RoutePlanRequest::operator!=(const RoutePlanRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   RoutePlanRequest& RoutePlanRequest::setRequestID(const int64_t val)
+   {
+      __RequestID = val;
+      return *this;
+   }
+
+   RoutePlanRequest& RoutePlanRequest::setAssociatedTaskID(const int64_t val)
+   {
+      __AssociatedTaskID = val;
+      return *this;
+   }
+
+   RoutePlanRequest& RoutePlanRequest::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+   RoutePlanRequest& RoutePlanRequest::setOperatingRegion(const int64_t val)
+   {
+      __OperatingRegion = val;
+      return *this;
+   }
+
+
+   RoutePlanRequest& RoutePlanRequest::setIsCostOnlyRequest(const bool val)
+   {
+      __IsCostOnlyRequest = val;
+      return *this;
+   }
+
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/route/uxasmessagesrouteRoutePlanResponse.cpp b/src/LMCP/uxas/messages/route/uxasmessagesrouteRoutePlanResponse.cpp
new file mode 100644
index 0000000..5eefb89
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/uxasmessagesrouteRoutePlanResponse.cpp
@@ -0,0 +1,281 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/route/RoutePlanResponse.h"
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RoutePlanResponse::Subscription = "uxas.messages.route.RoutePlanResponse";
+   const std::string RoutePlanResponse::TypeName = "RoutePlanResponse";
+   
+   bool isRoutePlanResponse(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 8) return false;
+      return true;
+   }
+   
+   bool isRoutePlanResponse(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 8) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RoutePlanResponseDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RoutePlanResponse::RoutePlanResponse(void) : avtas::lmcp::Object()
+   {
+      __ResponseID = 0LL;
+      __AssociatedTaskID = 0LL;
+      __VehicleID = 0LL;
+      __OperatingRegion = 0LL;
+
+   }
+     
+   RoutePlanResponse::RoutePlanResponse(const RoutePlanResponse &that) : avtas::lmcp::Object(that)
+   {
+        __ResponseID = that.__ResponseID;
+        __AssociatedTaskID = that.__AssociatedTaskID;
+        __VehicleID = that.__VehicleID;
+        __OperatingRegion = that.__OperatingRegion;
+        __RouteResponses.clear();
+        for (size_t i=0; i< that.__RouteResponses.size(); i++)
+        {
+           __RouteResponses.push_back( that.__RouteResponses[i] == nullptr ? nullptr : that.__RouteResponses[i]->clone());
+        }
+
+   }
+   
+   RoutePlanResponse & RoutePlanResponse::operator=(const RoutePlanResponse &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__RouteResponses.size(); i++)
+         {
+            if (__RouteResponses[i] != nullptr) delete __RouteResponses[i];
+         }
+
+         __ResponseID = that.__ResponseID;
+         __AssociatedTaskID = that.__AssociatedTaskID;
+         __VehicleID = that.__VehicleID;
+         __OperatingRegion = that.__OperatingRegion;
+         __RouteResponses.clear();
+         for (size_t i=0; i< that.__RouteResponses.size(); i++)
+         {
+            __RouteResponses.push_back( that.__RouteResponses[i] == nullptr ? nullptr : that.__RouteResponses[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   RoutePlanResponse* RoutePlanResponse::clone() const
+   {
+        return new RoutePlanResponse(*this);
+   }
+   
+   RoutePlanResponse::~RoutePlanResponse(void)
+   {
+      for (size_t i=0; i<__RouteResponses.size(); i++)
+      {
+         if (__RouteResponses[i] != nullptr) delete __RouteResponses[i];
+      }
+
+   }
+  
+   void RoutePlanResponse::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ResponseID);
+      buf.putLong(__AssociatedTaskID);
+      buf.putLong(__VehicleID);
+      buf.putLong(__OperatingRegion);
+      buf.putUShort( static_cast<uint16_t>(__RouteResponses.size()));
+      for (size_t i=0; i<__RouteResponses.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __RouteResponses[i], buf);
+      }
+
+   }
+   
+   void RoutePlanResponse::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ResponseID = buf.getLong();
+      __AssociatedTaskID = buf.getLong();
+      __VehicleID = buf.getLong();
+      __OperatingRegion = buf.getLong();
+      for (size_t i=0; i<__RouteResponses.size(); i++)
+      {
+         if (__RouteResponses[i] != nullptr)
+            delete __RouteResponses[i];
+      }
+      __RouteResponses.clear();
+      uint16_t __RouteResponses_length = buf.getUShort();
+      for (uint32_t i=0; i< __RouteResponses_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::route::RoutePlan* e = (uxas::messages::route::RoutePlan*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __RouteResponses.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t RoutePlanResponse::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__RouteResponses.size(); i++)
+      {
+         if (__RouteResponses[i] != nullptr)
+         {
+            size += __RouteResponses[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string RoutePlanResponse::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RoutePlanResponse ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ResponseID (int64_t) = " << __ResponseID << "\n";
+      oss << indent << "AssociatedTaskID (int64_t) = " << __AssociatedTaskID << "\n";
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "OperatingRegion (int64_t) = " << __OperatingRegion << "\n";
+      oss << indent << "RouteResponses (RoutePlan [ " << __RouteResponses.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RoutePlanResponse::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RoutePlanResponse Series=\"ROUTE\">\n";
+      str << ws << "   <ResponseID>" << __ResponseID << "</ResponseID>\n";
+      str << ws << "   <AssociatedTaskID>" << __AssociatedTaskID << "</AssociatedTaskID>\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <OperatingRegion>" << __OperatingRegion << "</OperatingRegion>\n";
+      str << ws << "   <RouteResponses>\n";
+      for (size_t i=0; i<__RouteResponses.size(); i++)
+      {
+         str << (__RouteResponses[i] == nullptr ? ( ws + "   <null/>\n") : (__RouteResponses[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </RouteResponses>\n";
+      str << ws << "</RoutePlanResponse>\n";
+
+      return str.str();
+   }
+
+   bool RoutePlanResponse::operator==(const RoutePlanResponse & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ResponseID != that.__ResponseID) return false;
+      if(__AssociatedTaskID != that.__AssociatedTaskID) return false;
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__OperatingRegion != that.__OperatingRegion) return false;
+      if(__RouteResponses.size() != that.__RouteResponses.size()) return false;
+      for (size_t i=0; i<__RouteResponses.size(); i++)
+      {
+         if(__RouteResponses[i] && that.__RouteResponses[i])
+         {
+            if(__RouteResponses[i]->getSeriesNameAsLong() != that.__RouteResponses[i]->getSeriesNameAsLong()) return false;
+            if(__RouteResponses[i]->getSeriesVersion() != that.__RouteResponses[i]->getSeriesVersion()) return false;
+            if(__RouteResponses[i]->getLmcpType() != that.__RouteResponses[i]->getLmcpType()) return false;
+            if( *(__RouteResponses[i]) != *(that.__RouteResponses[i]) ) return false;
+         }
+         else if(__RouteResponses[i] != that.__RouteResponses[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool RoutePlanResponse::operator!=(const RoutePlanResponse & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   RoutePlanResponse& RoutePlanResponse::setResponseID(const int64_t val)
+   {
+      __ResponseID = val;
+      return *this;
+   }
+
+   RoutePlanResponse& RoutePlanResponse::setAssociatedTaskID(const int64_t val)
+   {
+      __AssociatedTaskID = val;
+      return *this;
+   }
+
+   RoutePlanResponse& RoutePlanResponse::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+   RoutePlanResponse& RoutePlanResponse::setOperatingRegion(const int64_t val)
+   {
+      __OperatingRegion = val;
+      return *this;
+   }
+
+
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/route/uxasmessagesrouteRouteRequest.cpp b/src/LMCP/uxas/messages/route/uxasmessagesrouteRouteRequest.cpp
new file mode 100644
index 0000000..13b4f67
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/uxasmessagesrouteRouteRequest.cpp
@@ -0,0 +1,316 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/route/RouteRequest.h"
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RouteRequest::Subscription = "uxas.messages.route.RouteRequest";
+   const std::string RouteRequest::TypeName = "RouteRequest";
+   
+   bool isRouteRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 5) return false;
+      return true;
+   }
+   
+   bool isRouteRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 5) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RouteRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RouteRequest::RouteRequest(void) : avtas::lmcp::Object()
+   {
+      __RequestID = 0LL;
+      __AssociatedTaskID = 0LL;
+      __OperatingRegion = 0LL;
+      __IsCostOnlyRequest = true;
+
+   }
+     
+   RouteRequest::RouteRequest(const RouteRequest &that) : avtas::lmcp::Object(that)
+   {
+        __RequestID = that.__RequestID;
+        __AssociatedTaskID = that.__AssociatedTaskID;
+        __VehicleID.clear();
+        for (size_t i=0; i< that.__VehicleID.size(); i++)
+        {
+           __VehicleID.push_back( that.__VehicleID[i]);
+        }
+        __OperatingRegion = that.__OperatingRegion;
+        __RouteRequests.clear();
+        for (size_t i=0; i< that.__RouteRequests.size(); i++)
+        {
+           __RouteRequests.push_back( that.__RouteRequests[i] == nullptr ? nullptr : that.__RouteRequests[i]->clone());
+        }
+        __IsCostOnlyRequest = that.__IsCostOnlyRequest;
+
+   }
+   
+   RouteRequest & RouteRequest::operator=(const RouteRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__RouteRequests.size(); i++)
+         {
+            if (__RouteRequests[i] != nullptr) delete __RouteRequests[i];
+         }
+
+         __RequestID = that.__RequestID;
+         __AssociatedTaskID = that.__AssociatedTaskID;
+         __VehicleID.clear();
+         for (size_t i=0; i< that.__VehicleID.size(); i++)
+         {
+            __VehicleID.push_back( that.__VehicleID[i]);
+         }
+         __OperatingRegion = that.__OperatingRegion;
+         __RouteRequests.clear();
+         for (size_t i=0; i< that.__RouteRequests.size(); i++)
+         {
+            __RouteRequests.push_back( that.__RouteRequests[i] == nullptr ? nullptr : that.__RouteRequests[i]->clone());
+         }
+         __IsCostOnlyRequest = that.__IsCostOnlyRequest;
+
+      }
+      return *this;
+   }
+
+   RouteRequest* RouteRequest::clone() const
+   {
+        return new RouteRequest(*this);
+   }
+   
+   RouteRequest::~RouteRequest(void)
+   {
+      for (size_t i=0; i<__RouteRequests.size(); i++)
+      {
+         if (__RouteRequests[i] != nullptr) delete __RouteRequests[i];
+      }
+
+   }
+  
+   void RouteRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RequestID);
+      buf.putLong(__AssociatedTaskID);
+      buf.putUShort( static_cast<uint16_t>(__VehicleID.size()));
+      for (size_t i=0; i<__VehicleID.size(); i++)
+      {
+         buf.putLong(__VehicleID[i]);
+      }
+      buf.putLong(__OperatingRegion);
+      buf.putUShort( static_cast<uint16_t>(__RouteRequests.size()));
+      for (size_t i=0; i<__RouteRequests.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __RouteRequests[i], buf);
+      }
+      buf.putBool(__IsCostOnlyRequest);
+
+   }
+   
+   void RouteRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RequestID = buf.getLong();
+      __AssociatedTaskID = buf.getLong();
+      __VehicleID.clear();
+      uint16_t __VehicleID_length = buf.getUShort();
+      for (uint32_t i=0; i< __VehicleID_length; i++)
+      {
+         __VehicleID.push_back(buf.getLong() );
+      }
+      __OperatingRegion = buf.getLong();
+      for (size_t i=0; i<__RouteRequests.size(); i++)
+      {
+         if (__RouteRequests[i] != nullptr)
+            delete __RouteRequests[i];
+      }
+      __RouteRequests.clear();
+      uint16_t __RouteRequests_length = buf.getUShort();
+      for (uint32_t i=0; i< __RouteRequests_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::route::RouteConstraints* e = (uxas::messages::route::RouteConstraints*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __RouteRequests.push_back(e);
+         }
+      }
+      __IsCostOnlyRequest = buf.getBool();
+
+   }
+
+   uint32_t RouteRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += 2 + sizeof(int64_t) * __VehicleID.size();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__RouteRequests.size(); i++)
+      {
+         if (__RouteRequests[i] != nullptr)
+         {
+            size += __RouteRequests[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string RouteRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RouteRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RequestID (int64_t) = " << __RequestID << "\n";
+      oss << indent << "AssociatedTaskID (int64_t) = " << __AssociatedTaskID << "\n";
+      oss << indent << "VehicleID (int64 [ " << __VehicleID.size() << ", var ])\n";
+      oss << indent << "OperatingRegion (int64_t) = " << __OperatingRegion << "\n";
+      oss << indent << "RouteRequests (RouteConstraints [ " << __RouteRequests.size() << ", var ])\n";
+      oss << indent << "IsCostOnlyRequest (bool) = " << __IsCostOnlyRequest << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RouteRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RouteRequest Series=\"ROUTE\">\n";
+      str << ws << "   <RequestID>" << __RequestID << "</RequestID>\n";
+      str << ws << "   <AssociatedTaskID>" << __AssociatedTaskID << "</AssociatedTaskID>\n";
+      str << ws << "   <VehicleID>\n";
+      for (size_t i=0; i<__VehicleID.size(); i++)
+      {
+         str << ws << "   <int64>" << __VehicleID[i] << "</int64>\n";
+      }
+      str << ws << "   </VehicleID>\n";
+      str << ws << "   <OperatingRegion>" << __OperatingRegion << "</OperatingRegion>\n";
+      str << ws << "   <RouteRequests>\n";
+      for (size_t i=0; i<__RouteRequests.size(); i++)
+      {
+         str << (__RouteRequests[i] == nullptr ? ( ws + "   <null/>\n") : (__RouteRequests[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </RouteRequests>\n";
+      str << ws << "   <IsCostOnlyRequest>" << (__IsCostOnlyRequest ? "true" : "false") << "</IsCostOnlyRequest>\n";
+      str << ws << "</RouteRequest>\n";
+
+      return str.str();
+   }
+
+   bool RouteRequest::operator==(const RouteRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RequestID != that.__RequestID) return false;
+      if(__AssociatedTaskID != that.__AssociatedTaskID) return false;
+      if(__VehicleID.size() != that.__VehicleID.size()) return false;
+      for (size_t i=0; i<__VehicleID.size(); i++)
+      {
+         if(__VehicleID[i] != that.__VehicleID[i]) return false;
+      }
+      if(__OperatingRegion != that.__OperatingRegion) return false;
+      if(__RouteRequests.size() != that.__RouteRequests.size()) return false;
+      for (size_t i=0; i<__RouteRequests.size(); i++)
+      {
+         if(__RouteRequests[i] && that.__RouteRequests[i])
+         {
+            if(__RouteRequests[i]->getSeriesNameAsLong() != that.__RouteRequests[i]->getSeriesNameAsLong()) return false;
+            if(__RouteRequests[i]->getSeriesVersion() != that.__RouteRequests[i]->getSeriesVersion()) return false;
+            if(__RouteRequests[i]->getLmcpType() != that.__RouteRequests[i]->getLmcpType()) return false;
+            if( *(__RouteRequests[i]) != *(that.__RouteRequests[i]) ) return false;
+         }
+         else if(__RouteRequests[i] != that.__RouteRequests[i]) return false;
+      }
+      if(__IsCostOnlyRequest != that.__IsCostOnlyRequest) return false;
+      return true;
+
+   }
+
+   bool RouteRequest::operator!=(const RouteRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   RouteRequest& RouteRequest::setRequestID(const int64_t val)
+   {
+      __RequestID = val;
+      return *this;
+   }
+
+   RouteRequest& RouteRequest::setAssociatedTaskID(const int64_t val)
+   {
+      __AssociatedTaskID = val;
+      return *this;
+   }
+
+
+   RouteRequest& RouteRequest::setOperatingRegion(const int64_t val)
+   {
+      __OperatingRegion = val;
+      return *this;
+   }
+
+
+   RouteRequest& RouteRequest::setIsCostOnlyRequest(const bool val)
+   {
+      __IsCostOnlyRequest = val;
+      return *this;
+   }
+
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/route/uxasmessagesrouteRouteResponse.cpp b/src/LMCP/uxas/messages/route/uxasmessagesrouteRouteResponse.cpp
new file mode 100644
index 0000000..742a0f9
--- /dev/null
+++ b/src/LMCP/uxas/messages/route/uxasmessagesrouteRouteResponse.cpp
@@ -0,0 +1,236 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/route/RouteResponse.h"
+
+
+namespace uxas {
+namespace messages {
+namespace route {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string RouteResponse::Subscription = "uxas.messages.route.RouteResponse";
+   const std::string RouteResponse::TypeName = "RouteResponse";
+   
+   bool isRouteResponse(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 9) return false;
+      return true;
+   }
+   
+   bool isRouteResponse(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 5931053054693474304LL) return false;
+      if(obj->getSeriesVersion() != 3) return false;
+      if(obj->getLmcpType() != 9) return false;
+      return true;
+   }
+   
+   std::vector< std::string > RouteResponseDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   RouteResponse::RouteResponse(void) : avtas::lmcp::Object()
+   {
+      __ResponseID = 0LL;
+
+   }
+     
+   RouteResponse::RouteResponse(const RouteResponse &that) : avtas::lmcp::Object(that)
+   {
+        __ResponseID = that.__ResponseID;
+        __Routes.clear();
+        for (size_t i=0; i< that.__Routes.size(); i++)
+        {
+           __Routes.push_back( that.__Routes[i] == nullptr ? nullptr : that.__Routes[i]->clone());
+        }
+
+   }
+   
+   RouteResponse & RouteResponse::operator=(const RouteResponse &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Routes.size(); i++)
+         {
+            if (__Routes[i] != nullptr) delete __Routes[i];
+         }
+
+         __ResponseID = that.__ResponseID;
+         __Routes.clear();
+         for (size_t i=0; i< that.__Routes.size(); i++)
+         {
+            __Routes.push_back( that.__Routes[i] == nullptr ? nullptr : that.__Routes[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   RouteResponse* RouteResponse::clone() const
+   {
+        return new RouteResponse(*this);
+   }
+   
+   RouteResponse::~RouteResponse(void)
+   {
+      for (size_t i=0; i<__Routes.size(); i++)
+      {
+         if (__Routes[i] != nullptr) delete __Routes[i];
+      }
+
+   }
+  
+   void RouteResponse::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ResponseID);
+      buf.putUShort( static_cast<uint16_t>(__Routes.size()));
+      for (size_t i=0; i<__Routes.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Routes[i], buf);
+      }
+
+   }
+   
+   void RouteResponse::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ResponseID = buf.getLong();
+      for (size_t i=0; i<__Routes.size(); i++)
+      {
+         if (__Routes[i] != nullptr)
+            delete __Routes[i];
+      }
+      __Routes.clear();
+      uint16_t __Routes_length = buf.getUShort();
+      for (uint32_t i=0; i< __Routes_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::route::RoutePlanResponse* e = (uxas::messages::route::RoutePlanResponse*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Routes.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t RouteResponse::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__Routes.size(); i++)
+      {
+         if (__Routes[i] != nullptr)
+         {
+            size += __Routes[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string RouteResponse::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( RouteResponse ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ResponseID (int64_t) = " << __ResponseID << "\n";
+      oss << indent << "Routes (RoutePlanResponse [ " << __Routes.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string RouteResponse::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<RouteResponse Series=\"ROUTE\">\n";
+      str << ws << "   <ResponseID>" << __ResponseID << "</ResponseID>\n";
+      str << ws << "   <Routes>\n";
+      for (size_t i=0; i<__Routes.size(); i++)
+      {
+         str << (__Routes[i] == nullptr ? ( ws + "   <null/>\n") : (__Routes[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Routes>\n";
+      str << ws << "</RouteResponse>\n";
+
+      return str.str();
+   }
+
+   bool RouteResponse::operator==(const RouteResponse & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ResponseID != that.__ResponseID) return false;
+      if(__Routes.size() != that.__Routes.size()) return false;
+      for (size_t i=0; i<__Routes.size(); i++)
+      {
+         if(__Routes[i] && that.__Routes[i])
+         {
+            if(__Routes[i]->getSeriesNameAsLong() != that.__Routes[i]->getSeriesNameAsLong()) return false;
+            if(__Routes[i]->getSeriesVersion() != that.__Routes[i]->getSeriesVersion()) return false;
+            if(__Routes[i]->getLmcpType() != that.__Routes[i]->getLmcpType()) return false;
+            if( *(__Routes[i]) != *(that.__Routes[i]) ) return false;
+         }
+         else if(__Routes[i] != that.__Routes[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool RouteResponse::operator!=(const RouteResponse & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   RouteResponse& RouteResponse::setResponseID(const int64_t val)
+   {
+      __ResponseID = val;
+      return *this;
+   }
+
+
+
+} // end namespace route
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/AssignmentCoordination.h b/src/LMCP/uxas/messages/task/AssignmentCoordination.h
new file mode 100644
index 0000000..bcc6849
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/AssignmentCoordination.h
@@ -0,0 +1,115 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_ASSIGNMENTCOORDINATION_H_
+#define _UXAS_MESSAGES_TASK_ASSIGNMENTCOORDINATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/task/PlanningState.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isAssignmentCoordination(avtas::lmcp::Object* obj);
+   bool isAssignmentCoordination(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AssignmentCoordinationDescendants();
+   
+   class AssignmentCoordination : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AssignmentCoordination(void);
+
+      // Copy Constructor
+      AssignmentCoordination(const AssignmentCoordination &that);
+
+      // Assignment Operator
+      AssignmentCoordination & operator=(const AssignmentCoordination &that);
+
+      // Destructor
+      virtual ~AssignmentCoordination(void);
+
+      // Equals overload
+      bool operator==(const AssignmentCoordination & that);
+      bool operator!=(const AssignmentCoordination & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AssignmentCoordination* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 3; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Identifier of the associated CoordinatedAutomationRequest (Units: None)*/
+      int64_t getCoordinatedAutomationRequestID(void) const { return __CoordinatedAutomationRequestID; }
+      AssignmentCoordination& setCoordinatedAutomationRequestID(const int64_t val);
+
+      /** The state of the entity that will used for planning/assignment of the given automation request. (Units: None)*/
+      uxas::messages::task::PlanningState* const getPlanningState(void) { return __PlanningState; }
+      AssignmentCoordination& setPlanningState(const uxas::messages::task::PlanningState* const val);
+
+
+
+   protected:
+      /** Identifier of the associated CoordinatedAutomationRequest */
+      int64_t __CoordinatedAutomationRequestID;
+      /** The state of the entity that will used for planning/assignment of the given automation request. */
+      uxas::messages::task::PlanningState* __PlanningState;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_ASSIGNMENTCOORDINATION_H_
diff --git a/src/LMCP/uxas/messages/task/AssignmentCoordinationDescendants.h b/src/LMCP/uxas/messages/task/AssignmentCoordinationDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/AssignmentCoordinationDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/AssignmentCoordinatorTask.h b/src/LMCP/uxas/messages/task/AssignmentCoordinatorTask.h
new file mode 100644
index 0000000..8946bf7
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/AssignmentCoordinatorTask.h
@@ -0,0 +1,102 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_ASSIGNMENTCOORDINATORTASK_H_
+#define _UXAS_MESSAGES_TASK_ASSIGNMENTCOORDINATORTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "afrl/cmasi/Task.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isAssignmentCoordinatorTask(avtas::lmcp::Object* obj);
+   bool isAssignmentCoordinatorTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AssignmentCoordinatorTaskDescendants();
+   
+   class AssignmentCoordinatorTask : public afrl::cmasi::Task {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AssignmentCoordinatorTask(void);
+
+      // Copy Constructor
+      AssignmentCoordinatorTask(const AssignmentCoordinatorTask &that);
+
+      // Assignment Operator
+      AssignmentCoordinatorTask & operator=(const AssignmentCoordinatorTask &that);
+
+      // Destructor
+      virtual ~AssignmentCoordinatorTask(void);
+
+      // Equals overload
+      bool operator==(const AssignmentCoordinatorTask & that);
+      bool operator!=(const AssignmentCoordinatorTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AssignmentCoordinatorTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 1; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+
+
+   protected:
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_ASSIGNMENTCOORDINATORTASK_H_
diff --git a/src/LMCP/uxas/messages/task/AssignmentCoordinatorTaskDescendants.h b/src/LMCP/uxas/messages/task/AssignmentCoordinatorTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/AssignmentCoordinatorTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/AssignmentCostMatrix.h b/src/LMCP/uxas/messages/task/AssignmentCostMatrix.h
new file mode 100644
index 0000000..701e66b
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/AssignmentCostMatrix.h
@@ -0,0 +1,132 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_ASSIGNMENTCOSTMATRIX_H_
+#define _UXAS_MESSAGES_TASK_ASSIGNMENTCOSTMATRIX_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/task/TaskOptionCost.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isAssignmentCostMatrix(avtas::lmcp::Object* obj);
+   bool isAssignmentCostMatrix(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AssignmentCostMatrixDescendants();
+   
+   class AssignmentCostMatrix : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AssignmentCostMatrix(void);
+
+      // Copy Constructor
+      AssignmentCostMatrix(const AssignmentCostMatrix &that);
+
+      // Assignment Operator
+      AssignmentCostMatrix & operator=(const AssignmentCostMatrix &that);
+
+      // Destructor
+      virtual ~AssignmentCostMatrix(void);
+
+      // Equals overload
+      bool operator==(const AssignmentCostMatrix & that);
+      bool operator!=(const AssignmentCostMatrix & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AssignmentCostMatrix* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 15; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** ID that matches this cost matrix with the appropriate unique automation request (Units: None)*/
+      int64_t getCorrespondingAutomationRequestID(void) const { return __CorrespondingAutomationRequestID; }
+      AssignmentCostMatrix& setCorrespondingAutomationRequestID(const int64_t val);
+
+      /** Over-arching task relationship description (directly from automation request). A process algebra string with only task IDs. (Units: None)*/
+      std::string getTaskLevelRelationship(void) const { return __TaskLevelRelationship; }
+      AssignmentCostMatrix& setTaskLevelRelationship(const std::string val);
+
+      /** List of all tasks that this cost matrix includes (Units: None)*/
+      std::vector<int64_t> & getTaskList(void) { return __TaskList; }
+
+      /** Operating region that was used during matrix calculation (Units: None)*/
+      int64_t getOperatingRegion(void) const { return __OperatingRegion; }
+      AssignmentCostMatrix& setOperatingRegion(const int64_t val);
+
+      /** Set of task-to-task timings for each requested vehicle (Units: None)*/
+      std::vector<uxas::messages::task::TaskOptionCost*> & getCostMatrix(void) { return __CostMatrix; }
+
+
+
+   protected:
+      /** ID that matches this cost matrix with the appropriate unique automation request */
+      int64_t __CorrespondingAutomationRequestID;
+      /** Over-arching task relationship description (directly from automation request). A process algebra string with only task IDs. */
+      std::string __TaskLevelRelationship;
+      /** List of all tasks that this cost matrix includes */
+      std::vector< int64_t > __TaskList;
+      /** Operating region that was used during matrix calculation */
+      int64_t __OperatingRegion;
+      /** Set of task-to-task timings for each requested vehicle */
+      std::vector< uxas::messages::task::TaskOptionCost* > __CostMatrix;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_ASSIGNMENTCOSTMATRIX_H_
diff --git a/src/LMCP/uxas/messages/task/AssignmentCostMatrixDescendants.h b/src/LMCP/uxas/messages/task/AssignmentCostMatrixDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/AssignmentCostMatrixDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/CancelTask.h b/src/LMCP/uxas/messages/task/CancelTask.h
new file mode 100644
index 0000000..d69ae1a
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/CancelTask.h
@@ -0,0 +1,113 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_CANCELTASK_H_
+#define _UXAS_MESSAGES_TASK_CANCELTASK_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isCancelTask(avtas::lmcp::Object* obj);
+   bool isCancelTask(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > CancelTaskDescendants();
+   
+   class CancelTask : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      CancelTask(void);
+
+      // Copy Constructor
+      CancelTask(const CancelTask &that);
+
+      // Assignment Operator
+      CancelTask & operator=(const CancelTask &that);
+
+      // Destructor
+      virtual ~CancelTask(void);
+
+      // Equals overload
+      bool operator==(const CancelTask & that);
+      bool operator!=(const CancelTask & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual CancelTask* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 28; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** List of vehicle IDs that are directed to cancel tasks. If empty, all vehicles currently on a listed task will be directed to cancel. (Units: None)*/
+      std::vector<int64_t> & getVehicles(void) { return __Vehicles; }
+
+      /** Task ID(s) to be removed from task lists of indicated vehicles. If empty, then only the current task is removed. (Units: None)*/
+      std::vector<int64_t> & getCanceledTasks(void) { return __CanceledTasks; }
+
+
+
+   protected:
+      /** List of vehicle IDs that are directed to cancel tasks. If empty, all vehicles currently on a listed task will be directed to cancel. */
+      std::vector< int64_t > __Vehicles;
+      /** Task ID(s) to be removed from task lists of indicated vehicles. If empty, then only the current task is removed. */
+      std::vector< int64_t > __CanceledTasks;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_CANCELTASK_H_
diff --git a/src/LMCP/uxas/messages/task/CancelTaskDescendants.h b/src/LMCP/uxas/messages/task/CancelTaskDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/CancelTaskDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/CoordinatedAutomationRequest.h b/src/LMCP/uxas/messages/task/CoordinatedAutomationRequest.h
new file mode 100644
index 0000000..1ef4b63
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/CoordinatedAutomationRequest.h
@@ -0,0 +1,128 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_COORDINATEDAUTOMATIONREQUEST_H_
+#define _UXAS_MESSAGES_TASK_COORDINATEDAUTOMATIONREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AutomationRequest.h"
+#include "uxas/messages/task/PlanningState.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isCoordinatedAutomationRequest(avtas::lmcp::Object* obj);
+   bool isCoordinatedAutomationRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > CoordinatedAutomationRequestDescendants();
+   
+   class CoordinatedAutomationRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      CoordinatedAutomationRequest(void);
+
+      // Copy Constructor
+      CoordinatedAutomationRequest(const CoordinatedAutomationRequest &that);
+
+      // Assignment Operator
+      CoordinatedAutomationRequest & operator=(const CoordinatedAutomationRequest &that);
+
+      // Destructor
+      virtual ~CoordinatedAutomationRequest(void);
+
+      // Equals overload
+      bool operator==(const CoordinatedAutomationRequest & that);
+      bool operator!=(const CoordinatedAutomationRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual CoordinatedAutomationRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 4; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Identifier for tracking requests and coordination (Units: None)*/
+      int64_t getRequestID(void) const { return __RequestID; }
+      CoordinatedAutomationRequest& setRequestID(const int64_t val);
+
+      /** This is the maximum time to wait for {@link AssignmentCoordination} messages from the other eligible entities, before proceeding with the assignment. Note: the value of -1 indicates that there is no limit. If there are no eligble entites listed in the {@link CoordinatedAutomationRequest}, then {@link MaximumResponseTime} is the amount of time the {@link AssignmentCoordinatorTask} waits for {@link AssignmentCoordination} messages before proceeding with the assignment. Note: if there are no eligble entities and the {@link MaximumResponseTime} is -1, then the {@link AssignmentCoordination} proceeds with the assignment immediately. (Units: milliseconds)*/
+      int64_t getMaximumResponseTime(void) const { return __MaximumResponseTime; }
+      CoordinatedAutomationRequest& setMaximumResponseTime(const int64_t val);
+
+      /** Original automation request without a unique identifier (Units: None)*/
+      afrl::cmasi::AutomationRequest* const getOriginalRequest(void) { return __OriginalRequest; }
+      CoordinatedAutomationRequest& setOriginalRequest(const afrl::cmasi::AutomationRequest* const val);
+
+      /** The initial states of entities used in planning. Note: if an eligible entity does not have a PlanningState, then it must be obtained from the entity in an {@link AssignmentCoordination} message. (Units: None)*/
+      std::vector<uxas::messages::task::PlanningState*> & getPlanningStates(void) { return __PlanningStates; }
+
+
+
+   protected:
+      /** Identifier for tracking requests and coordination */
+      int64_t __RequestID;
+      /** This is the maximum time to wait for {@link AssignmentCoordination} messages from the other eligible entities, before proceeding with the assignment. Note: the value of -1 indicates that there is no limit. If there are no eligble entites listed in the {@link CoordinatedAutomationRequest}, then {@link MaximumResponseTime} is the amount of time the {@link AssignmentCoordinatorTask} waits for {@link AssignmentCoordination} messages before proceeding with the assignment. Note: if there are no eligble entities and the {@link MaximumResponseTime} is -1, then the {@link AssignmentCoordination} proceeds with the assignment immediately. */
+      int64_t __MaximumResponseTime;
+      /** Original automation request without a unique identifier */
+      afrl::cmasi::AutomationRequest* __OriginalRequest;
+      /** The initial states of entities used in planning. Note: if an eligible entity does not have a PlanningState, then it must be obtained from the entity in an {@link AssignmentCoordination} message. */
+      std::vector< uxas::messages::task::PlanningState* > __PlanningStates;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_COORDINATEDAUTOMATIONREQUEST_H_
diff --git a/src/LMCP/uxas/messages/task/CoordinatedAutomationRequestDescendants.h b/src/LMCP/uxas/messages/task/CoordinatedAutomationRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/CoordinatedAutomationRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/FootprintRequest.h b/src/LMCP/uxas/messages/task/FootprintRequest.h
new file mode 100644
index 0000000..f1ac369
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/FootprintRequest.h
@@ -0,0 +1,136 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_FOOTPRINTREQUEST_H_
+#define _UXAS_MESSAGES_TASK_FOOTPRINTREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/WavelengthBand.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isFootprintRequest(avtas::lmcp::Object* obj);
+   bool isFootprintRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > FootprintRequestDescendants();
+   
+   class FootprintRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      FootprintRequest(void);
+
+      // Copy Constructor
+      FootprintRequest(const FootprintRequest &that);
+
+      // Assignment Operator
+      FootprintRequest & operator=(const FootprintRequest &that);
+
+      // Destructor
+      virtual ~FootprintRequest(void);
+
+      // Equals overload
+      bool operator==(const FootprintRequest & that);
+      bool operator!=(const FootprintRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual FootprintRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 10; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** ID corresponding to this specific footprint request (Units: None)*/
+      int64_t getFootprintRequestID(void) const { return __FootprintRequestID; }
+      FootprintRequest& setFootprintRequestID(const int64_t val);
+
+      /** Single vehicle to be considered for sensor request. (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      FootprintRequest& setVehicleID(const int64_t val);
+
+      /** Camera wavelength to be considered. If list is empty, planner should plan for all available sensors on each entity (Units: None)*/
+      std::vector<afrl::cmasi::WavelengthBand::WavelengthBand> & getEligibleWavelengths(void) { return __EligibleWavelengths; }
+
+      /** Desired ground sample distance for an eligible sensor. If list is empty, then footprint calculation uses the max ground sample distance for the specified altitude. (Units: None)*/
+      std::vector<float> & getGroundSampleDistances(void) { return __GroundSampleDistances; }
+
+      /** AGL Altitude to consider during sensor information calculation. If 'AglAltitudes' list is empty, sensor planner should use nominal altitude from entity configurations (Units: meters)*/
+      std::vector<float> & getAglAltitudes(void) { return __AglAltitudes; }
+
+      /** Desired camera elevation angles. If list is empty, then uses an optimal elevation angle for achieving max GSD (Units: deg)*/
+      std::vector<float> & getElevationAngles(void) { return __ElevationAngles; }
+
+
+
+   protected:
+      /** ID corresponding to this specific footprint request */
+      int64_t __FootprintRequestID;
+      /** Single vehicle to be considered for sensor request. */
+      int64_t __VehicleID;
+      /** Camera wavelength to be considered. If list is empty, planner should plan for all available sensors on each entity */
+      std::vector< afrl::cmasi::WavelengthBand::WavelengthBand > __EligibleWavelengths;
+      /** Desired ground sample distance for an eligible sensor. If list is empty, then footprint calculation uses the max ground sample distance for the specified altitude. */
+      std::vector< float > __GroundSampleDistances;
+      /** AGL Altitude to consider during sensor information calculation. If 'AglAltitudes' list is empty, sensor planner should use nominal altitude from entity configurations */
+      std::vector< float > __AglAltitudes;
+      /** Desired camera elevation angles. If list is empty, then uses an optimal elevation angle for achieving max GSD */
+      std::vector< float > __ElevationAngles;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_FOOTPRINTREQUEST_H_
diff --git a/src/LMCP/uxas/messages/task/FootprintRequestDescendants.h b/src/LMCP/uxas/messages/task/FootprintRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/FootprintRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/PlanningState.h b/src/LMCP/uxas/messages/task/PlanningState.h
new file mode 100644
index 0000000..d53e368
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/PlanningState.h
@@ -0,0 +1,121 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_PLANNINGSTATE_H_
+#define _UXAS_MESSAGES_TASK_PLANNINGSTATE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isPlanningState(avtas::lmcp::Object* obj);
+   bool isPlanningState(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > PlanningStateDescendants();
+   
+   class PlanningState : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      PlanningState(void);
+
+      // Copy Constructor
+      PlanningState(const PlanningState &that);
+
+      // Assignment Operator
+      PlanningState & operator=(const PlanningState &that);
+
+      // Destructor
+      virtual ~PlanningState(void);
+
+      // Equals overload
+      bool operator==(const PlanningState & that);
+      bool operator!=(const PlanningState & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual PlanningState* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 2; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Identifier of the entitiy (Units: None)*/
+      int64_t getEntityID(void) const { return __EntityID; }
+      PlanningState& setEntityID(const int64_t val);
+
+      /** Initial position of this entity for the plan (Units: None)*/
+      afrl::cmasi::Location3D* const getPlanningPosition(void) { return __PlanningPosition; }
+      PlanningState& setPlanningPosition(const afrl::cmasi::Location3D* const val);
+
+      /** Initial heading of this entity for the plan (Units: None)*/
+      float getPlanningHeading(void) const { return __PlanningHeading; }
+      PlanningState& setPlanningHeading(const float val);
+
+
+
+   protected:
+      /** Identifier of the entitiy */
+      int64_t __EntityID;
+      /** Initial position of this entity for the plan */
+      afrl::cmasi::Location3D* __PlanningPosition;
+      /** Initial heading of this entity for the plan */
+      float __PlanningHeading;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_PLANNINGSTATE_H_
diff --git a/src/LMCP/uxas/messages/task/PlanningStateDescendants.h b/src/LMCP/uxas/messages/task/PlanningStateDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/PlanningStateDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/SensorFootprint.h b/src/LMCP/uxas/messages/task/SensorFootprint.h
new file mode 100644
index 0000000..51d68f6
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/SensorFootprint.h
@@ -0,0 +1,193 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_SENSORFOOTPRINT_H_
+#define _UXAS_MESSAGES_TASK_SENSORFOOTPRINT_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/WavelengthBand.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isSensorFootprint(avtas::lmcp::Object* obj);
+   bool isSensorFootprint(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > SensorFootprintDescendants();
+   
+   class SensorFootprint : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      SensorFootprint(void);
+
+      // Copy Constructor
+      SensorFootprint(const SensorFootprint &that);
+
+      // Assignment Operator
+      SensorFootprint & operator=(const SensorFootprint &that);
+
+      // Destructor
+      virtual ~SensorFootprint(void);
+
+      // Equals overload
+      bool operator==(const SensorFootprint & that);
+      bool operator!=(const SensorFootprint & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual SensorFootprint* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 11; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Response ID that matches corresponding request ID. Note that multiple responses may be generated from a single request (such as multiple cameras which all meet the specification). Each response must contain the matching request ID in it's FootprintResponseID field. (Units: None)*/
+      int64_t getFootprintResponseID(void) const { return __FootprintResponseID; }
+      SensorFootprint& setFootprintResponseID(const int64_t val);
+
+      /** Vehicle for which the footprint calculation applies (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      SensorFootprint& setVehicleID(const int64_t val);
+
+      /** Camera from which settings (such as zoom and field of view) were used in the footprint calculation (Units: None)*/
+      int64_t getCameraID(void) const { return __CameraID; }
+      SensorFootprint& setCameraID(const int64_t val);
+
+      /** Gimbal from which parameters such as allowable steering angles were used in the footprint calculation (Units: None)*/
+      int64_t getGimbalID(void) const { return __GimbalID; }
+      SensorFootprint& setGimbalID(const int64_t val);
+
+      /** The selected horizontal field of view of the camera necessary to get the reported footprint (equivalent to zoom) (Units: degrees)*/
+      float getHorizontalFOV(void) const { return __HorizontalFOV; }
+      SensorFootprint& setHorizontalFOV(const float val);
+
+      /** Altitude above ground level for which the footprint was calculated (Units: meters)*/
+      float getAglAltitude(void) const { return __AglAltitude; }
+      SensorFootprint& setAglAltitude(const float val);
+
+      /** Commanded gimbal elevation to achieve sensor footprint (Units: degrees)*/
+      float getGimbalElevation(void) const { return __GimbalElevation; }
+      SensorFootprint& setGimbalElevation(const float val);
+
+      /** Aspect ratio (width/height) of the camera image used for footprint calculation. Note: combine with horizontal field of view to determine camera vertical field of view. (Units: None)*/
+      float getAspectRatio(void) const { return __AspectRatio; }
+      SensorFootprint& setAspectRatio(const float val);
+
+      /** Ground sample distance obtained with this sensor footprint (Units: meters/pixel)*/
+      float getAchievedGSD(void) const { return __AchievedGSD; }
+      SensorFootprint& setAchievedGSD(const float val);
+
+      /** Sensor wavelength used applicable to this footprint calculation (Units: None)*/
+      afrl::cmasi::WavelengthBand::WavelengthBand getCameraWavelength(void) const { return __CameraWavelength; }
+      SensorFootprint& setCameraWavelength(const afrl::cmasi::WavelengthBand::WavelengthBand val);
+
+      /** Distance out front of the entity to the leading edge (Units: meters)*/
+      float getHorizontalToLeadingEdge(void) const { return __HorizontalToLeadingEdge; }
+      SensorFootprint& setHorizontalToLeadingEdge(const float val);
+
+      /** Distance out front of the entity to the trailing edge (Units: meters)*/
+      float getHorizontalToTrailingEdge(void) const { return __HorizontalToTrailingEdge; }
+      SensorFootprint& setHorizontalToTrailingEdge(const float val);
+
+      /** Distance out front of the entity to the center of the footprint (Units: meters)*/
+      float getHorizontalToCenter(void) const { return __HorizontalToCenter; }
+      SensorFootprint& setHorizontalToCenter(const float val);
+
+      /** Width of the footprint at the vertical center (Units: meters)*/
+      float getWidthCenter(void) const { return __WidthCenter; }
+      SensorFootprint& setWidthCenter(const float val);
+
+      /** At the prescribed settings (e.g. altitude, elevation angle, etc) the distance from the camera to the center of the footprint (Units: meters)*/
+      float getSlantRangeToCenter(void) const { return __SlantRangeToCenter; }
+      SensorFootprint& setSlantRangeToCenter(const float val);
+
+
+
+   protected:
+      /** Response ID that matches corresponding request ID. Note that multiple responses may be generated from a single request (such as multiple cameras which all meet the specification). Each response must contain the matching request ID in it's FootprintResponseID field. */
+      int64_t __FootprintResponseID;
+      /** Vehicle for which the footprint calculation applies */
+      int64_t __VehicleID;
+      /** Camera from which settings (such as zoom and field of view) were used in the footprint calculation */
+      int64_t __CameraID;
+      /** Gimbal from which parameters such as allowable steering angles were used in the footprint calculation */
+      int64_t __GimbalID;
+      /** The selected horizontal field of view of the camera necessary to get the reported footprint (equivalent to zoom) */
+      float __HorizontalFOV;
+      /** Altitude above ground level for which the footprint was calculated */
+      float __AglAltitude;
+      /** Commanded gimbal elevation to achieve sensor footprint */
+      float __GimbalElevation;
+      /** Aspect ratio (width/height) of the camera image used for footprint calculation. Note: combine with horizontal field of view to determine camera vertical field of view. */
+      float __AspectRatio;
+      /** Ground sample distance obtained with this sensor footprint */
+      float __AchievedGSD;
+      /** Sensor wavelength used applicable to this footprint calculation */
+      afrl::cmasi::WavelengthBand::WavelengthBand __CameraWavelength;
+      /** Distance out front of the entity to the leading edge */
+      float __HorizontalToLeadingEdge;
+      /** Distance out front of the entity to the trailing edge */
+      float __HorizontalToTrailingEdge;
+      /** Distance out front of the entity to the center of the footprint */
+      float __HorizontalToCenter;
+      /** Width of the footprint at the vertical center */
+      float __WidthCenter;
+      /** At the prescribed settings (e.g. altitude, elevation angle, etc) the distance from the camera to the center of the footprint */
+      float __SlantRangeToCenter;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_SENSORFOOTPRINT_H_
diff --git a/src/LMCP/uxas/messages/task/SensorFootprintDescendants.h b/src/LMCP/uxas/messages/task/SensorFootprintDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/SensorFootprintDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/SensorFootprintRequests.h b/src/LMCP/uxas/messages/task/SensorFootprintRequests.h
new file mode 100644
index 0000000..d35efd0
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/SensorFootprintRequests.h
@@ -0,0 +1,115 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_SENSORFOOTPRINTREQUESTS_H_
+#define _UXAS_MESSAGES_TASK_SENSORFOOTPRINTREQUESTS_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/task/FootprintRequest.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isSensorFootprintRequests(avtas::lmcp::Object* obj);
+   bool isSensorFootprintRequests(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > SensorFootprintRequestsDescendants();
+   
+   class SensorFootprintRequests : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      SensorFootprintRequests(void);
+
+      // Copy Constructor
+      SensorFootprintRequests(const SensorFootprintRequests &that);
+
+      // Assignment Operator
+      SensorFootprintRequests & operator=(const SensorFootprintRequests &that);
+
+      // Destructor
+      virtual ~SensorFootprintRequests(void);
+
+      // Equals overload
+      bool operator==(const SensorFootprintRequests & that);
+      bool operator!=(const SensorFootprintRequests & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual SensorFootprintRequests* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 9; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Request ID for correlating to response (Units: None)*/
+      int64_t getRequestID(void) const { return __RequestID; }
+      SensorFootprintRequests& setRequestID(const int64_t val);
+
+      /** Request ID for correlating to response (Units: None)*/
+      std::vector<uxas::messages::task::FootprintRequest*> & getFootprints(void) { return __Footprints; }
+
+
+
+   protected:
+      /** Request ID for correlating to response */
+      int64_t __RequestID;
+      /** Request ID for correlating to response */
+      std::vector< uxas::messages::task::FootprintRequest* > __Footprints;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_SENSORFOOTPRINTREQUESTS_H_
diff --git a/src/LMCP/uxas/messages/task/SensorFootprintRequestsDescendants.h b/src/LMCP/uxas/messages/task/SensorFootprintRequestsDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/SensorFootprintRequestsDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/SensorFootprintResponse.h b/src/LMCP/uxas/messages/task/SensorFootprintResponse.h
new file mode 100644
index 0000000..3c6632a
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/SensorFootprintResponse.h
@@ -0,0 +1,115 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_SENSORFOOTPRINTRESPONSE_H_
+#define _UXAS_MESSAGES_TASK_SENSORFOOTPRINTRESPONSE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/task/SensorFootprint.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isSensorFootprintResponse(avtas::lmcp::Object* obj);
+   bool isSensorFootprintResponse(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > SensorFootprintResponseDescendants();
+   
+   class SensorFootprintResponse : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      SensorFootprintResponse(void);
+
+      // Copy Constructor
+      SensorFootprintResponse(const SensorFootprintResponse &that);
+
+      // Assignment Operator
+      SensorFootprintResponse & operator=(const SensorFootprintResponse &that);
+
+      // Destructor
+      virtual ~SensorFootprintResponse(void);
+
+      // Equals overload
+      bool operator==(const SensorFootprintResponse & that);
+      bool operator!=(const SensorFootprintResponse & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual SensorFootprintResponse* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 12; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** ID matching initial request ID (Units: None)*/
+      int64_t getResponseID(void) const { return __ResponseID; }
+      SensorFootprintResponse& setResponseID(const int64_t val);
+
+      /** All sensor footprints calculated during request (Units: None)*/
+      std::vector<uxas::messages::task::SensorFootprint*> & getFootprints(void) { return __Footprints; }
+
+
+
+   protected:
+      /** ID matching initial request ID */
+      int64_t __ResponseID;
+      /** All sensor footprints calculated during request */
+      std::vector< uxas::messages::task::SensorFootprint* > __Footprints;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_SENSORFOOTPRINTRESPONSE_H_
diff --git a/src/LMCP/uxas/messages/task/SensorFootprintResponseDescendants.h b/src/LMCP/uxas/messages/task/SensorFootprintResponseDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/SensorFootprintResponseDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskActive.h b/src/LMCP/uxas/messages/task/TaskActive.h
new file mode 100644
index 0000000..14e57f8
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskActive.h
@@ -0,0 +1,120 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKACTIVE_H_
+#define _UXAS_MESSAGES_TASK_TASKACTIVE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskActive(avtas::lmcp::Object* obj);
+   bool isTaskActive(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskActiveDescendants();
+   
+   class TaskActive : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskActive(void);
+
+      // Copy Constructor
+      TaskActive(const TaskActive &that);
+
+      // Assignment Operator
+      TaskActive & operator=(const TaskActive &that);
+
+      // Destructor
+      virtual ~TaskActive(void);
+
+      // Equals overload
+      bool operator==(const TaskActive & that);
+      bool operator!=(const TaskActive & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskActive* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 26; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Task ID that was just activated (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskActive& setTaskID(const int64_t val);
+
+      /** Entity ID that activated the task (Units: None)*/
+      int64_t getEntityID(void) const { return __EntityID; }
+      TaskActive& setEntityID(const int64_t val);
+
+      /** Time that this task was activated. (Units: milliseconds since 1 Jan 1970)*/
+      int64_t getTimeTaskActivated(void) const { return __TimeTaskActivated; }
+      TaskActive& setTimeTaskActivated(const int64_t val);
+
+
+
+   protected:
+      /** Task ID that was just activated */
+      int64_t __TaskID;
+      /** Entity ID that activated the task */
+      int64_t __EntityID;
+      /** Time that this task was activated. */
+      int64_t __TimeTaskActivated;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKACTIVE_H_
diff --git a/src/LMCP/uxas/messages/task/TaskActiveDescendants.h b/src/LMCP/uxas/messages/task/TaskActiveDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskActiveDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskAssignment.h b/src/LMCP/uxas/messages/task/TaskAssignment.h
new file mode 100644
index 0000000..2da8033
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskAssignment.h
@@ -0,0 +1,132 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKASSIGNMENT_H_
+#define _UXAS_MESSAGES_TASK_TASKASSIGNMENT_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskAssignment(avtas::lmcp::Object* obj);
+   bool isTaskAssignment(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskAssignmentDescendants();
+   
+   class TaskAssignment : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskAssignment(void);
+
+      // Copy Constructor
+      TaskAssignment(const TaskAssignment &that);
+
+      // Assignment Operator
+      TaskAssignment & operator=(const TaskAssignment &that);
+
+      // Destructor
+      virtual ~TaskAssignment(void);
+
+      // Equals overload
+      bool operator==(const TaskAssignment & that);
+      bool operator!=(const TaskAssignment & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskAssignment* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 17; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Task ID (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskAssignment& setTaskID(const int64_t val);
+
+      /** Option ID that was selected for this task (Units: None)*/
+      int64_t getOptionID(void) const { return __OptionID; }
+      TaskAssignment& setOptionID(const int64_t val);
+
+      /** Vehicle that is assigned to this task (Units: None)*/
+      int64_t getAssignedVehicle(void) const { return __AssignedVehicle; }
+      TaskAssignment& setAssignedVehicle(const int64_t val);
+
+      /** Time before which this task cannot begin (Units: milliseconds since 1 Jan 1970)*/
+      int64_t getTimeThreshold(void) const { return __TimeThreshold; }
+      TaskAssignment& setTimeThreshold(const int64_t val);
+
+      /** Time that this task is assigned to be completed. (Units: milliseconds since 1 Jan 1970)*/
+      int64_t getTimeTaskCompleted(void) const { return __TimeTaskCompleted; }
+      TaskAssignment& setTimeTaskCompleted(const int64_t val);
+
+
+
+   protected:
+      /** Task ID */
+      int64_t __TaskID;
+      /** Option ID that was selected for this task */
+      int64_t __OptionID;
+      /** Vehicle that is assigned to this task */
+      int64_t __AssignedVehicle;
+      /** Time before which this task cannot begin */
+      int64_t __TimeThreshold;
+      /** Time that this task is assigned to be completed. */
+      int64_t __TimeTaskCompleted;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKASSIGNMENT_H_
diff --git a/src/LMCP/uxas/messages/task/TaskAssignmentDescendants.h b/src/LMCP/uxas/messages/task/TaskAssignmentDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskAssignmentDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskAssignmentSummary.h b/src/LMCP/uxas/messages/task/TaskAssignmentSummary.h
new file mode 100644
index 0000000..844dd42
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskAssignmentSummary.h
@@ -0,0 +1,121 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKASSIGNMENTSUMMARY_H_
+#define _UXAS_MESSAGES_TASK_TASKASSIGNMENTSUMMARY_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/task/TaskAssignment.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskAssignmentSummary(avtas::lmcp::Object* obj);
+   bool isTaskAssignmentSummary(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskAssignmentSummaryDescendants();
+   
+   class TaskAssignmentSummary : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskAssignmentSummary(void);
+
+      // Copy Constructor
+      TaskAssignmentSummary(const TaskAssignmentSummary &that);
+
+      // Assignment Operator
+      TaskAssignmentSummary & operator=(const TaskAssignmentSummary &that);
+
+      // Destructor
+      virtual ~TaskAssignmentSummary(void);
+
+      // Equals overload
+      bool operator==(const TaskAssignmentSummary & that);
+      bool operator!=(const TaskAssignmentSummary & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskAssignmentSummary* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 18; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** ID that matches this summary with the appropriate unique automation request (Units: None)*/
+      int64_t getCorrespondingAutomationRequestID(void) const { return __CorrespondingAutomationRequestID; }
+      TaskAssignmentSummary& setCorrespondingAutomationRequestID(const int64_t val);
+
+      /** Operating region which was considered during this assignment (Units: None)*/
+      int64_t getOperatingRegion(void) const { return __OperatingRegion; }
+      TaskAssignmentSummary& setOperatingRegion(const int64_t val);
+
+      /** Ordered list of tasks to be completed (Units: None)*/
+      std::vector<uxas::messages::task::TaskAssignment*> & getTaskList(void) { return __TaskList; }
+
+
+
+   protected:
+      /** ID that matches this summary with the appropriate unique automation request */
+      int64_t __CorrespondingAutomationRequestID;
+      /** Operating region which was considered during this assignment */
+      int64_t __OperatingRegion;
+      /** Ordered list of tasks to be completed */
+      std::vector< uxas::messages::task::TaskAssignment* > __TaskList;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKASSIGNMENTSUMMARY_H_
diff --git a/src/LMCP/uxas/messages/task/TaskAssignmentSummaryDescendants.h b/src/LMCP/uxas/messages/task/TaskAssignmentSummaryDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskAssignmentSummaryDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskAutomationRequest.h b/src/LMCP/uxas/messages/task/TaskAutomationRequest.h
new file mode 100644
index 0000000..b10ef0c
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskAutomationRequest.h
@@ -0,0 +1,128 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKAUTOMATIONREQUEST_H_
+#define _UXAS_MESSAGES_TASK_TASKAUTOMATIONREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AutomationRequest.h"
+#include "uxas/messages/task/PlanningState.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskAutomationRequest(avtas::lmcp::Object* obj);
+   bool isTaskAutomationRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskAutomationRequestDescendants();
+   
+   class TaskAutomationRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskAutomationRequest(void);
+
+      // Copy Constructor
+      TaskAutomationRequest(const TaskAutomationRequest &that);
+
+      // Assignment Operator
+      TaskAutomationRequest & operator=(const TaskAutomationRequest &that);
+
+      // Destructor
+      virtual ~TaskAutomationRequest(void);
+
+      // Equals overload
+      bool operator==(const TaskAutomationRequest & that);
+      bool operator!=(const TaskAutomationRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskAutomationRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 5; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Identifier for tracking requests and responses (Units: None)*/
+      int64_t getRequestID(void) const { return __RequestID; }
+      TaskAutomationRequest& setRequestID(const int64_t val);
+
+      /** Original automation request without a unique identifier (Units: None)*/
+      afrl::cmasi::AutomationRequest* const getOriginalRequest(void) { return __OriginalRequest; }
+      TaskAutomationRequest& setOriginalRequest(const afrl::cmasi::AutomationRequest* const val);
+
+      /** If this boolean is true, then the resulting plans based on this automation request will not be directly implemented, for example, tasks should not expect the waypoints generated for this request to be active (Units: None)*/
+      bool getSandBoxRequest(void) const { return __SandBoxRequest; }
+      TaskAutomationRequest& setSandBoxRequest(const bool val);
+
+      /** The initial states of entities used in planning. Note: if an eligible entity does not have a PlanningState, then it's most recent EntityState is used for plannning. (Units: None)*/
+      std::vector<uxas::messages::task::PlanningState*> & getPlanningStates(void) { return __PlanningStates; }
+
+
+
+   protected:
+      /** Identifier for tracking requests and responses */
+      int64_t __RequestID;
+      /** Original automation request without a unique identifier */
+      afrl::cmasi::AutomationRequest* __OriginalRequest;
+      /** If this boolean is true, then the resulting plans based on this automation request will not be directly implemented, for example, tasks should not expect the waypoints generated for this request to be active */
+      bool __SandBoxRequest;
+      /** The initial states of entities used in planning. Note: if an eligible entity does not have a PlanningState, then it's most recent EntityState is used for plannning. */
+      std::vector< uxas::messages::task::PlanningState* > __PlanningStates;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKAUTOMATIONREQUEST_H_
diff --git a/src/LMCP/uxas/messages/task/TaskAutomationRequestDescendants.h b/src/LMCP/uxas/messages/task/TaskAutomationRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskAutomationRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskAutomationResponse.h b/src/LMCP/uxas/messages/task/TaskAutomationResponse.h
new file mode 100644
index 0000000..de08d6e
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskAutomationResponse.h
@@ -0,0 +1,115 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKAUTOMATIONRESPONSE_H_
+#define _UXAS_MESSAGES_TASK_TASKAUTOMATIONRESPONSE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AutomationResponse.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskAutomationResponse(avtas::lmcp::Object* obj);
+   bool isTaskAutomationResponse(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskAutomationResponseDescendants();
+   
+   class TaskAutomationResponse : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskAutomationResponse(void);
+
+      // Copy Constructor
+      TaskAutomationResponse(const TaskAutomationResponse &that);
+
+      // Assignment Operator
+      TaskAutomationResponse & operator=(const TaskAutomationResponse &that);
+
+      // Destructor
+      virtual ~TaskAutomationResponse(void);
+
+      // Equals overload
+      bool operator==(const TaskAutomationResponse & that);
+      bool operator!=(const TaskAutomationResponse & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskAutomationResponse* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 6; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Identifier for tracking requests and responses. Must match RequestID from corresponding TaskAutomationRequest (Units: None)*/
+      int64_t getResponseID(void) const { return __ResponseID; }
+      TaskAutomationResponse& setResponseID(const int64_t val);
+
+      /** Original automation request without a unique identifier (Units: None)*/
+      afrl::cmasi::AutomationResponse* const getOriginalResponse(void) { return __OriginalResponse; }
+      TaskAutomationResponse& setOriginalResponse(const afrl::cmasi::AutomationResponse* const val);
+
+
+
+   protected:
+      /** Identifier for tracking requests and responses. Must match RequestID from corresponding TaskAutomationRequest */
+      int64_t __ResponseID;
+      /** Original automation request without a unique identifier */
+      afrl::cmasi::AutomationResponse* __OriginalResponse;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKAUTOMATIONRESPONSE_H_
diff --git a/src/LMCP/uxas/messages/task/TaskAutomationResponseDescendants.h b/src/LMCP/uxas/messages/task/TaskAutomationResponseDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskAutomationResponseDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskComplete.h b/src/LMCP/uxas/messages/task/TaskComplete.h
new file mode 100644
index 0000000..308a80e
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskComplete.h
@@ -0,0 +1,120 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKCOMPLETE_H_
+#define _UXAS_MESSAGES_TASK_TASKCOMPLETE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskComplete(avtas::lmcp::Object* obj);
+   bool isTaskComplete(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskCompleteDescendants();
+   
+   class TaskComplete : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskComplete(void);
+
+      // Copy Constructor
+      TaskComplete(const TaskComplete &that);
+
+      // Assignment Operator
+      TaskComplete & operator=(const TaskComplete &that);
+
+      // Destructor
+      virtual ~TaskComplete(void);
+
+      // Equals overload
+      bool operator==(const TaskComplete & that);
+      bool operator!=(const TaskComplete & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskComplete* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 27; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Task ID that was just completed (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskComplete& setTaskID(const int64_t val);
+
+      /** Entity IDs that completed the task (Units: None)*/
+      std::vector<int64_t> & getEntitiesInvolved(void) { return __EntitiesInvolved; }
+
+      /** Time that this task was completed. (Units: milliseconds since 1 Jan 1970)*/
+      int64_t getTimeTaskCompleted(void) const { return __TimeTaskCompleted; }
+      TaskComplete& setTimeTaskCompleted(const int64_t val);
+
+
+
+   protected:
+      /** Task ID that was just completed */
+      int64_t __TaskID;
+      /** Entity IDs that completed the task */
+      std::vector< int64_t > __EntitiesInvolved;
+      /** Time that this task was completed. */
+      int64_t __TimeTaskCompleted;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKCOMPLETE_H_
diff --git a/src/LMCP/uxas/messages/task/TaskCompleteDescendants.h b/src/LMCP/uxas/messages/task/TaskCompleteDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskCompleteDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskImplementationRequest.h b/src/LMCP/uxas/messages/task/TaskImplementationRequest.h
new file mode 100644
index 0000000..cb4b915
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskImplementationRequest.h
@@ -0,0 +1,163 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKIMPLEMENTATIONREQUEST_H_
+#define _UXAS_MESSAGES_TASK_TASKIMPLEMENTATIONREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskImplementationRequest(avtas::lmcp::Object* obj);
+   bool isTaskImplementationRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskImplementationRequestDescendants();
+   
+   class TaskImplementationRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskImplementationRequest(void);
+
+      // Copy Constructor
+      TaskImplementationRequest(const TaskImplementationRequest &that);
+
+      // Assignment Operator
+      TaskImplementationRequest & operator=(const TaskImplementationRequest &that);
+
+      // Destructor
+      virtual ~TaskImplementationRequest(void);
+
+      // Equals overload
+      bool operator==(const TaskImplementationRequest & that);
+      bool operator!=(const TaskImplementationRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskImplementationRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 13; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Request ID for correlating to matching response (Units: None)*/
+      int64_t getRequestID(void) const { return __RequestID; }
+      TaskImplementationRequest& setRequestID(const int64_t val);
+
+      /** Starting waypoint ID that task must use when building response. Note that Plan Builder reserves all values greater than 1,000,000,000. Therefore all *internal* task waypoints must be less than 1e9 and can be obtained from the reported waypoint number by "waypoint->getNumber()%1e9" .(Units: None)*/
+      int64_t getStartingWaypointID(void) const { return __StartingWaypointID; }
+      TaskImplementationRequest& setStartingWaypointID(const int64_t val);
+
+      /** Assigned vehicle ID (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      TaskImplementationRequest& setVehicleID(const int64_t val);
+
+      /** Initial position of entity before task (Units: None)*/
+      afrl::cmasi::Location3D* const getStartPosition(void) { return __StartPosition; }
+      TaskImplementationRequest& setStartPosition(const afrl::cmasi::Location3D* const val);
+
+      /** Initial heading of entity before task (Units: degrees)*/
+      float getStartHeading(void) const { return __StartHeading; }
+      TaskImplementationRequest& setStartHeading(const float val);
+
+      /** Time when vehicle is at the starting location (Units: milliseconds since 1 Jan 1970)*/
+      int64_t getStartTime(void) const { return __StartTime; }
+      TaskImplementationRequest& setStartTime(const int64_t val);
+
+      /** ID for full region in which entity should plan (Units: None)*/
+      int64_t getRegionID(void) const { return __RegionID; }
+      TaskImplementationRequest& setRegionID(const int64_t val);
+
+      /** Task ID to be completed (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskImplementationRequest& setTaskID(const int64_t val);
+
+      /** Using option ID to complete this task (Units: None)*/
+      int64_t getOptionID(void) const { return __OptionID; }
+      TaskImplementationRequest& setOptionID(const int64_t val);
+
+      /** Time before which this task cannot begin (Units: milliseconds since 1 Jan 1970)*/
+      int64_t getTimeThreshold(void) const { return __TimeThreshold; }
+      TaskImplementationRequest& setTimeThreshold(const int64_t val);
+
+
+
+   protected:
+      /** Request ID for correlating to matching response */
+      int64_t __RequestID;
+      /** Starting waypoint ID that task must use when building response. Note that Plan Builder reserves all values greater than 1,000,000,000. Therefore all *internal* task waypoints must be less than 1e9 and can be obtained from the reported waypoint number by "waypoint->getNumber()%1e9" .*/
+      int64_t __StartingWaypointID;
+      /** Assigned vehicle ID */
+      int64_t __VehicleID;
+      /** Initial position of entity before task */
+      afrl::cmasi::Location3D* __StartPosition;
+      /** Initial heading of entity before task */
+      float __StartHeading;
+      /** Time when vehicle is at the starting location */
+      int64_t __StartTime;
+      /** ID for full region in which entity should plan */
+      int64_t __RegionID;
+      /** Task ID to be completed */
+      int64_t __TaskID;
+      /** Using option ID to complete this task */
+      int64_t __OptionID;
+      /** Time before which this task cannot begin */
+      int64_t __TimeThreshold;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKIMPLEMENTATIONREQUEST_H_
diff --git a/src/LMCP/uxas/messages/task/TaskImplementationRequestDescendants.h b/src/LMCP/uxas/messages/task/TaskImplementationRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskImplementationRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskImplementationResponse.h b/src/LMCP/uxas/messages/task/TaskImplementationResponse.h
new file mode 100644
index 0000000..be29b9f
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskImplementationResponse.h
@@ -0,0 +1,152 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKIMPLEMENTATIONRESPONSE_H_
+#define _UXAS_MESSAGES_TASK_TASKIMPLEMENTATIONRESPONSE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/Location3D.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskImplementationResponse(avtas::lmcp::Object* obj);
+   bool isTaskImplementationResponse(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskImplementationResponseDescendants();
+   
+   class TaskImplementationResponse : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskImplementationResponse(void);
+
+      // Copy Constructor
+      TaskImplementationResponse(const TaskImplementationResponse &that);
+
+      // Assignment Operator
+      TaskImplementationResponse & operator=(const TaskImplementationResponse &that);
+
+      // Destructor
+      virtual ~TaskImplementationResponse(void);
+
+      // Equals overload
+      bool operator==(const TaskImplementationResponse & that);
+      bool operator!=(const TaskImplementationResponse & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskImplementationResponse* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 14; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Response ID that matches the initial request (Units: None)*/
+      int64_t getResponseID(void) const { return __ResponseID; }
+      TaskImplementationResponse& setResponseID(const int64_t val);
+
+      /** Task ID (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskImplementationResponse& setTaskID(const int64_t val);
+
+      /** Option ID that was selected for this task (Units: None)*/
+      int64_t getOptionID(void) const { return __OptionID; }
+      TaskImplementationResponse& setOptionID(const int64_t val);
+
+      /** Vehicle ID (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      TaskImplementationResponse& setVehicleID(const int64_t val);
+
+      /** Waypoints that implement this task for the indicated vehicle (Units: None)*/
+      std::vector<afrl::cmasi::Waypoint*> & getTaskWaypoints(void) { return __TaskWaypoints; }
+
+      /** Vehicle location when this task is complete (Units: None)*/
+      afrl::cmasi::Location3D* const getFinalLocation(void) { return __FinalLocation; }
+      TaskImplementationResponse& setFinalLocation(const afrl::cmasi::Location3D* const val);
+
+      /** Vehicle heading when this task is complete (Units: degrees)*/
+      float getFinalHeading(void) const { return __FinalHeading; }
+      TaskImplementationResponse& setFinalHeading(const float val);
+
+      /** Time when vehicle is at the final location (Units: milliseconds since 1 Jan 1970)*/
+      int64_t getFinalTime(void) const { return __FinalTime; }
+      TaskImplementationResponse& setFinalTime(const int64_t val);
+
+
+
+   protected:
+      /** Response ID that matches the initial request */
+      int64_t __ResponseID;
+      /** Task ID */
+      int64_t __TaskID;
+      /** Option ID that was selected for this task */
+      int64_t __OptionID;
+      /** Vehicle ID */
+      int64_t __VehicleID;
+      /** Waypoints that implement this task for the indicated vehicle */
+      std::vector< afrl::cmasi::Waypoint* > __TaskWaypoints;
+      /** Vehicle location when this task is complete */
+      afrl::cmasi::Location3D* __FinalLocation;
+      /** Vehicle heading when this task is complete */
+      float __FinalHeading;
+      /** Time when vehicle is at the final location */
+      int64_t __FinalTime;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKIMPLEMENTATIONRESPONSE_H_
diff --git a/src/LMCP/uxas/messages/task/TaskImplementationResponseDescendants.h b/src/LMCP/uxas/messages/task/TaskImplementationResponseDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskImplementationResponseDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskInitialized.h b/src/LMCP/uxas/messages/task/TaskInitialized.h
new file mode 100644
index 0000000..7171713
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskInitialized.h
@@ -0,0 +1,108 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKINITIALIZED_H_
+#define _UXAS_MESSAGES_TASK_TASKINITIALIZED_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskInitialized(avtas::lmcp::Object* obj);
+   bool isTaskInitialized(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskInitializedDescendants();
+   
+   class TaskInitialized : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskInitialized(void);
+
+      // Copy Constructor
+      TaskInitialized(const TaskInitialized &that);
+
+      // Assignment Operator
+      TaskInitialized & operator=(const TaskInitialized &that);
+
+      // Destructor
+      virtual ~TaskInitialized(void);
+
+      // Equals overload
+      bool operator==(const TaskInitialized & that);
+      bool operator!=(const TaskInitialized & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskInitialized* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 25; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Task ID is initialized and ready for use in automation requests (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskInitialized& setTaskID(const int64_t val);
+
+
+
+   protected:
+      /** Task ID is initialized and ready for use in automation requests */
+      int64_t __TaskID;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKINITIALIZED_H_
diff --git a/src/LMCP/uxas/messages/task/TaskInitializedDescendants.h b/src/LMCP/uxas/messages/task/TaskInitializedDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskInitializedDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskOption.h b/src/LMCP/uxas/messages/task/TaskOption.h
new file mode 100644
index 0000000..58d9943
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskOption.h
@@ -0,0 +1,152 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKOPTION_H_
+#define _UXAS_MESSAGES_TASK_TASKOPTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+#include "afrl/cmasi/Location3D.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskOption(avtas::lmcp::Object* obj);
+   bool isTaskOption(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskOptionDescendants();
+   
+   class TaskOption : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskOption(void);
+
+      // Copy Constructor
+      TaskOption(const TaskOption &that);
+
+      // Assignment Operator
+      TaskOption & operator=(const TaskOption &that);
+
+      // Destructor
+      virtual ~TaskOption(void);
+
+      // Equals overload
+      bool operator==(const TaskOption & that);
+      bool operator!=(const TaskOption & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskOption* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 19; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Task ID (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskOption& setTaskID(const int64_t val);
+
+      /** ID for this option (Units: None)*/
+      int64_t getOptionID(void) const { return __OptionID; }
+      TaskOption& setOptionID(const int64_t val);
+
+      /** Eligible entities for completing this option with identical cost to complete. If list is empty, then all vehicles are assumed to be eligible. (Units: None)*/
+      std::vector<int64_t> & getEligibleEntities(void) { return __EligibleEntities; }
+
+      /** Cost to complete option in terms of time (given in milliseconds) (Units: milliseconds)*/
+      int64_t getCost(void) const { return __Cost; }
+      TaskOption& setCost(const int64_t val);
+
+      /** Start location entering the option (Units: None)*/
+      afrl::cmasi::Location3D* const getStartLocation(void) { return __StartLocation; }
+      TaskOption& setStartLocation(const afrl::cmasi::Location3D* const val);
+
+      /** Start heading entering the option (Units: degrees)*/
+      float getStartHeading(void) const { return __StartHeading; }
+      TaskOption& setStartHeading(const float val);
+
+      /** Ending location for this option (Units: None)*/
+      afrl::cmasi::Location3D* const getEndLocation(void) { return __EndLocation; }
+      TaskOption& setEndLocation(const afrl::cmasi::Location3D* const val);
+
+      /** Ending heading for this option (Units: degrees)*/
+      float getEndHeading(void) const { return __EndHeading; }
+      TaskOption& setEndHeading(const float val);
+
+
+
+   protected:
+      /** Task ID */
+      int64_t __TaskID;
+      /** ID for this option */
+      int64_t __OptionID;
+      /** Eligible entities for completing this option with identical cost to complete. If list is empty, then all vehicles are assumed to be eligible. */
+      std::vector< int64_t > __EligibleEntities;
+      /** Cost to complete option in terms of time (given in milliseconds) */
+      int64_t __Cost;
+      /** Start location entering the option */
+      afrl::cmasi::Location3D* __StartLocation;
+      /** Start heading entering the option */
+      float __StartHeading;
+      /** Ending location for this option */
+      afrl::cmasi::Location3D* __EndLocation;
+      /** Ending heading for this option */
+      float __EndHeading;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKOPTION_H_
diff --git a/src/LMCP/uxas/messages/task/TaskOptionCost.h b/src/LMCP/uxas/messages/task/TaskOptionCost.h
new file mode 100644
index 0000000..e33a8cb
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskOptionCost.h
@@ -0,0 +1,138 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKOPTIONCOST_H_
+#define _UXAS_MESSAGES_TASK_TASKOPTIONCOST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskOptionCost(avtas::lmcp::Object* obj);
+   bool isTaskOptionCost(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskOptionCostDescendants();
+   
+   class TaskOptionCost : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskOptionCost(void);
+
+      // Copy Constructor
+      TaskOptionCost(const TaskOptionCost &that);
+
+      // Assignment Operator
+      TaskOptionCost & operator=(const TaskOptionCost &that);
+
+      // Destructor
+      virtual ~TaskOptionCost(void);
+
+      // Equals overload
+      bool operator==(const TaskOptionCost & that);
+      bool operator!=(const TaskOptionCost & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskOptionCost* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 16; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Corresponding Vehicle ID (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      TaskOptionCost& setVehicleID(const int64_t val);
+
+      /** Initial task ID (if zero, corresponds to current vehicle location) (Units: None)*/
+      int64_t getIntialTaskID(void) const { return __IntialTaskID; }
+      TaskOptionCost& setIntialTaskID(const int64_t val);
+
+      /** Initial task option (Units: None)*/
+      int64_t getIntialTaskOption(void) const { return __IntialTaskOption; }
+      TaskOptionCost& setIntialTaskOption(const int64_t val);
+
+      /** Destination task ID (Units: None)*/
+      int64_t getDestinationTaskID(void) const { return __DestinationTaskID; }
+      TaskOptionCost& setDestinationTaskID(const int64_t val);
+
+      /** Destination task option (Units: None)*/
+      int64_t getDestinationTaskOption(void) const { return __DestinationTaskOption; }
+      TaskOptionCost& setDestinationTaskOption(const int64_t val);
+
+      /** Timing corresponding to travel between ('InitialTask' using 'InitialTaskOption') and ('DestinationTask' using 'DestinationTaskOption'). If time is less than zero, no feasible path exists between tasks. (Units: milliseconds)*/
+      int64_t getTimeToGo(void) const { return __TimeToGo; }
+      TaskOptionCost& setTimeToGo(const int64_t val);
+
+
+
+   protected:
+      /** Corresponding Vehicle ID */
+      int64_t __VehicleID;
+      /** Initial task ID (if zero, corresponds to current vehicle location) */
+      int64_t __IntialTaskID;
+      /** Initial task option */
+      int64_t __IntialTaskOption;
+      /** Destination task ID */
+      int64_t __DestinationTaskID;
+      /** Destination task option */
+      int64_t __DestinationTaskOption;
+      /** Timing corresponding to travel between ('InitialTask' using 'InitialTaskOption') and ('DestinationTask' using 'DestinationTaskOption'). If time is less than zero, no feasible path exists between tasks. */
+      int64_t __TimeToGo;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKOPTIONCOST_H_
diff --git a/src/LMCP/uxas/messages/task/TaskOptionCostDescendants.h b/src/LMCP/uxas/messages/task/TaskOptionCostDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskOptionCostDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskOptionDescendants.h b/src/LMCP/uxas/messages/task/TaskOptionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskOptionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskPause.h b/src/LMCP/uxas/messages/task/TaskPause.h
new file mode 100644
index 0000000..a0272af
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskPause.h
@@ -0,0 +1,108 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKPAUSE_H_
+#define _UXAS_MESSAGES_TASK_TASKPAUSE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskPause(avtas::lmcp::Object* obj);
+   bool isTaskPause(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskPauseDescendants();
+   
+   class TaskPause : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskPause(void);
+
+      // Copy Constructor
+      TaskPause(const TaskPause &that);
+
+      // Assignment Operator
+      TaskPause & operator=(const TaskPause &that);
+
+      // Destructor
+      virtual ~TaskPause(void);
+
+      // Equals overload
+      bool operator==(const TaskPause & that);
+      bool operator!=(const TaskPause & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskPause* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 21; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Task ID (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskPause& setTaskID(const int64_t val);
+
+
+
+   protected:
+      /** Task ID */
+      int64_t __TaskID;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKPAUSE_H_
diff --git a/src/LMCP/uxas/messages/task/TaskPauseDescendants.h b/src/LMCP/uxas/messages/task/TaskPauseDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskPauseDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskPlanOptions.h b/src/LMCP/uxas/messages/task/TaskPlanOptions.h
new file mode 100644
index 0000000..e47afbf
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskPlanOptions.h
@@ -0,0 +1,127 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKPLANOPTIONS_H_
+#define _UXAS_MESSAGES_TASK_TASKPLANOPTIONS_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/task/TaskOption.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskPlanOptions(avtas::lmcp::Object* obj);
+   bool isTaskPlanOptions(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskPlanOptionsDescendants();
+   
+   class TaskPlanOptions : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskPlanOptions(void);
+
+      // Copy Constructor
+      TaskPlanOptions(const TaskPlanOptions &that);
+
+      // Assignment Operator
+      TaskPlanOptions & operator=(const TaskPlanOptions &that);
+
+      // Destructor
+      virtual ~TaskPlanOptions(void);
+
+      // Equals overload
+      bool operator==(const TaskPlanOptions & that);
+      bool operator!=(const TaskPlanOptions & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskPlanOptions* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 20; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** ID that matches this message with the appropriate unique automation request (Units: None)*/
+      int64_t getCorrespondingAutomationRequestID(void) const { return __CorrespondingAutomationRequestID; }
+      TaskPlanOptions& setCorrespondingAutomationRequestID(const int64_t val);
+
+      /** Task ID (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskPlanOptions& setTaskID(const int64_t val);
+
+      /** Process algebra string encoding all of the different options (Units: None)*/
+      std::string getComposition(void) const { return __Composition; }
+      TaskPlanOptions& setComposition(const std::string val);
+
+      /** List of options (Units: None)*/
+      std::vector<uxas::messages::task::TaskOption*> & getOptions(void) { return __Options; }
+
+
+
+   protected:
+      /** ID that matches this message with the appropriate unique automation request */
+      int64_t __CorrespondingAutomationRequestID;
+      /** Task ID */
+      int64_t __TaskID;
+      /** Process algebra string encoding all of the different options */
+      std::string __Composition;
+      /** List of options */
+      std::vector< uxas::messages::task::TaskOption* > __Options;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKPLANOPTIONS_H_
diff --git a/src/LMCP/uxas/messages/task/TaskPlanOptionsDescendants.h b/src/LMCP/uxas/messages/task/TaskPlanOptionsDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskPlanOptionsDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskProgress.h b/src/LMCP/uxas/messages/task/TaskProgress.h
new file mode 100644
index 0000000..aad4a74
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskProgress.h
@@ -0,0 +1,126 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKPROGRESS_H_
+#define _UXAS_MESSAGES_TASK_TASKPROGRESS_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskProgress(avtas::lmcp::Object* obj);
+   bool isTaskProgress(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskProgressDescendants();
+   
+   class TaskProgress : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskProgress(void);
+
+      // Copy Constructor
+      TaskProgress(const TaskProgress &that);
+
+      // Assignment Operator
+      TaskProgress & operator=(const TaskProgress &that);
+
+      // Destructor
+      virtual ~TaskProgress(void);
+
+      // Equals overload
+      bool operator==(const TaskProgress & that);
+      bool operator!=(const TaskProgress & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskProgress* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 23; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Response ID that matches the task progress request (Units: None)*/
+      int64_t getResponseID(void) const { return __ResponseID; }
+      TaskProgress& setResponseID(const int64_t val);
+
+      /** Task ID (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskProgress& setTaskID(const int64_t val);
+
+      /** Percentage of progress on task (Units: None)*/
+      float getPercentComplete(void) const { return __PercentComplete; }
+      TaskProgress& setPercentComplete(const float val);
+
+      /** Entities that are working this task (Units: None)*/
+      std::vector<int64_t> & getEntitiesEngaged(void) { return __EntitiesEngaged; }
+
+
+
+   protected:
+      /** Response ID that matches the task progress request */
+      int64_t __ResponseID;
+      /** Task ID */
+      int64_t __TaskID;
+      /** Percentage of progress on task */
+      float __PercentComplete;
+      /** Entities that are working this task */
+      std::vector< int64_t > __EntitiesEngaged;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKPROGRESS_H_
diff --git a/src/LMCP/uxas/messages/task/TaskProgressDescendants.h b/src/LMCP/uxas/messages/task/TaskProgressDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskProgressDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskProgressRequest.h b/src/LMCP/uxas/messages/task/TaskProgressRequest.h
new file mode 100644
index 0000000..871bdb6
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskProgressRequest.h
@@ -0,0 +1,114 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKPROGRESSREQUEST_H_
+#define _UXAS_MESSAGES_TASK_TASKPROGRESSREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskProgressRequest(avtas::lmcp::Object* obj);
+   bool isTaskProgressRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskProgressRequestDescendants();
+   
+   class TaskProgressRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskProgressRequest(void);
+
+      // Copy Constructor
+      TaskProgressRequest(const TaskProgressRequest &that);
+
+      // Assignment Operator
+      TaskProgressRequest & operator=(const TaskProgressRequest &that);
+
+      // Destructor
+      virtual ~TaskProgressRequest(void);
+
+      // Equals overload
+      bool operator==(const TaskProgressRequest & that);
+      bool operator!=(const TaskProgressRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskProgressRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 24; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Task progress request ID for properly matching corresponding response (Units: None)*/
+      int64_t getRequestID(void) const { return __RequestID; }
+      TaskProgressRequest& setRequestID(const int64_t val);
+
+      /** Task ID to report current progress (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskProgressRequest& setTaskID(const int64_t val);
+
+
+
+   protected:
+      /** Task progress request ID for properly matching corresponding response */
+      int64_t __RequestID;
+      /** Task ID to report current progress */
+      int64_t __TaskID;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKPROGRESSREQUEST_H_
diff --git a/src/LMCP/uxas/messages/task/TaskProgressRequestDescendants.h b/src/LMCP/uxas/messages/task/TaskProgressRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskProgressRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/TaskResume.h b/src/LMCP/uxas/messages/task/TaskResume.h
new file mode 100644
index 0000000..d80a5da
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskResume.h
@@ -0,0 +1,121 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_TASKRESUME_H_
+#define _UXAS_MESSAGES_TASK_TASKRESUME_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/task/TaskAssignment.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isTaskResume(avtas::lmcp::Object* obj);
+   bool isTaskResume(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > TaskResumeDescendants();
+   
+   class TaskResume : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      TaskResume(void);
+
+      // Copy Constructor
+      TaskResume(const TaskResume &that);
+
+      // Assignment Operator
+      TaskResume & operator=(const TaskResume &that);
+
+      // Destructor
+      virtual ~TaskResume(void);
+
+      // Equals overload
+      bool operator==(const TaskResume & that);
+      bool operator!=(const TaskResume & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual TaskResume* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 22; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Task ID (Units: None)*/
+      int64_t getTaskID(void) const { return __TaskID; }
+      TaskResume& setTaskID(const int64_t val);
+
+      /** Instead of resuming from paused task state, re-start the complete task (Units: None)*/
+      bool getRestartCompletely(void) const { return __RestartCompletely; }
+      TaskResume& setRestartCompletely(const bool val);
+
+      /** Instead of resuming from paused task state with the previously assigned entities, resume task with new assignment options (Units: None)*/
+      uxas::messages::task::TaskAssignment* const getReAssign(void) { return __ReAssign; }
+      TaskResume& setReAssign(const uxas::messages::task::TaskAssignment* const val);
+
+
+
+   protected:
+      /** Task ID */
+      int64_t __TaskID;
+      /** Instead of resuming from paused task state, re-start the complete task */
+      bool __RestartCompletely;
+      /** Instead of resuming from paused task state with the previously assigned entities, resume task with new assignment options */
+      uxas::messages::task::TaskAssignment* __ReAssign;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_TASKRESUME_H_
diff --git a/src/LMCP/uxas/messages/task/TaskResumeDescendants.h b/src/LMCP/uxas/messages/task/TaskResumeDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/TaskResumeDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/UXTASK.h b/src/LMCP/uxas/messages/task/UXTASK.h
new file mode 100644
index 0000000..21d8a2c
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/UXTASK.h
@@ -0,0 +1,46 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_ENTIRESERIESHEADER_H_
+#define _UXAS_MESSAGES_TASK_ENTIRESERIESHEADER_H_
+
+#include "uxas/messages/task/AssignmentCoordinatorTask.h"
+#include "uxas/messages/task/PlanningState.h"
+#include "uxas/messages/task/AssignmentCoordination.h"
+#include "uxas/messages/task/CoordinatedAutomationRequest.h"
+#include "uxas/messages/task/TaskAutomationRequest.h"
+#include "uxas/messages/task/TaskAutomationResponse.h"
+#include "uxas/messages/task/UniqueAutomationRequest.h"
+#include "uxas/messages/task/UniqueAutomationResponse.h"
+#include "uxas/messages/task/SensorFootprintRequests.h"
+#include "uxas/messages/task/FootprintRequest.h"
+#include "uxas/messages/task/SensorFootprint.h"
+#include "uxas/messages/task/SensorFootprintResponse.h"
+#include "uxas/messages/task/TaskImplementationRequest.h"
+#include "uxas/messages/task/TaskImplementationResponse.h"
+#include "uxas/messages/task/AssignmentCostMatrix.h"
+#include "uxas/messages/task/TaskOptionCost.h"
+#include "uxas/messages/task/TaskAssignment.h"
+#include "uxas/messages/task/TaskAssignmentSummary.h"
+#include "uxas/messages/task/TaskOption.h"
+#include "uxas/messages/task/TaskPlanOptions.h"
+#include "uxas/messages/task/TaskPause.h"
+#include "uxas/messages/task/TaskResume.h"
+#include "uxas/messages/task/TaskProgress.h"
+#include "uxas/messages/task/TaskProgressRequest.h"
+#include "uxas/messages/task/TaskInitialized.h"
+#include "uxas/messages/task/TaskActive.h"
+#include "uxas/messages/task/TaskComplete.h"
+#include "uxas/messages/task/CancelTask.h"
+#include "uxas/messages/task/UXTASKEnum.h"
+
+
+#endif //_UXAS_MESSAGES_TASK_ENTIRESERIESHEADER_H_
diff --git a/src/LMCP/uxas/messages/task/UXTASKEnum.h b/src/LMCP/uxas/messages/task/UXTASKEnum.h
new file mode 100644
index 0000000..3353178
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/UXTASKEnum.h
@@ -0,0 +1,61 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_UXTASKENUM_H_
+#define _UXAS_MESSAGES_TASK_UXTASKENUM_H_
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   namespace UXTASKEnum {
+
+      enum LmcpType {
+         ASSIGNMENTCOORDINATORTASK = 1,
+         PLANNINGSTATE = 2,
+         ASSIGNMENTCOORDINATION = 3,
+         COORDINATEDAUTOMATIONREQUEST = 4,
+         TASKAUTOMATIONREQUEST = 5,
+         TASKAUTOMATIONRESPONSE = 6,
+         UNIQUEAUTOMATIONREQUEST = 7,
+         UNIQUEAUTOMATIONRESPONSE = 8,
+         SENSORFOOTPRINTREQUESTS = 9,
+         FOOTPRINTREQUEST = 10,
+         SENSORFOOTPRINT = 11,
+         SENSORFOOTPRINTRESPONSE = 12,
+         TASKIMPLEMENTATIONREQUEST = 13,
+         TASKIMPLEMENTATIONRESPONSE = 14,
+         ASSIGNMENTCOSTMATRIX = 15,
+         TASKOPTIONCOST = 16,
+         TASKASSIGNMENT = 17,
+         TASKASSIGNMENTSUMMARY = 18,
+         TASKOPTION = 19,
+         TASKPLANOPTIONS = 20,
+         TASKPAUSE = 21,
+         TASKRESUME = 22,
+         TASKPROGRESS = 23,
+         TASKPROGRESSREQUEST = 24,
+         TASKINITIALIZED = 25,
+         TASKACTIVE = 26,
+         TASKCOMPLETE = 27,
+         CANCELTASK = 28
+      };
+
+   }
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif //_UXAS_MESSAGES_TASK_UXTASKENUM_H_
diff --git a/src/LMCP/uxas/messages/task/UXTASKXMLReader.cpp b/src/LMCP/uxas/messages/task/UXTASKXMLReader.cpp
new file mode 100644
index 0000000..03dc97b
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/UXTASKXMLReader.cpp
@@ -0,0 +1,1108 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "uxas/messages/task/UXTASKXMLReader.h"
+#include "avtas/lmcp/XMLParser.h"
+#include <vector>
+#include <string>
+#include "avtas/lmcp/LmcpXMLReader.h"
+
+#include "uxas/messages/task/AssignmentCoordinatorTask.h"
+#include "uxas/messages/task/PlanningState.h"
+#include "uxas/messages/task/AssignmentCoordination.h"
+#include "uxas/messages/task/CoordinatedAutomationRequest.h"
+#include "uxas/messages/task/TaskAutomationRequest.h"
+#include "uxas/messages/task/TaskAutomationResponse.h"
+#include "uxas/messages/task/UniqueAutomationRequest.h"
+#include "uxas/messages/task/UniqueAutomationResponse.h"
+#include "uxas/messages/task/SensorFootprintRequests.h"
+#include "uxas/messages/task/FootprintRequest.h"
+#include "uxas/messages/task/SensorFootprint.h"
+#include "uxas/messages/task/SensorFootprintResponse.h"
+#include "uxas/messages/task/TaskImplementationRequest.h"
+#include "uxas/messages/task/TaskImplementationResponse.h"
+#include "uxas/messages/task/AssignmentCostMatrix.h"
+#include "uxas/messages/task/TaskOptionCost.h"
+#include "uxas/messages/task/TaskAssignment.h"
+#include "uxas/messages/task/TaskAssignmentSummary.h"
+#include "uxas/messages/task/TaskOption.h"
+#include "uxas/messages/task/TaskPlanOptions.h"
+#include "uxas/messages/task/TaskPause.h"
+#include "uxas/messages/task/TaskResume.h"
+#include "uxas/messages/task/TaskProgress.h"
+#include "uxas/messages/task/TaskProgressRequest.h"
+#include "uxas/messages/task/TaskInitialized.h"
+#include "uxas/messages/task/TaskActive.h"
+#include "uxas/messages/task/TaskComplete.h"
+#include "uxas/messages/task/CancelTask.h"
+#include "uxas/messages/task/UXTASKEnum.h"
+
+
+using namespace avtas::lmcp;
+using namespace avtas::lmcp::xml;
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+    avtas::lmcp::Object* SeriesXMLReader :: visitType(avtas::lmcp::Node* el){
+
+        if (el == NULL) return NULL;
+        
+        std::string type = el->getTagName();
+            
+        if (type == "AssignmentCoordinatorTask"){
+           AssignmentCoordinatorTask* o = new AssignmentCoordinatorTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "RevisitRate")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRevisitRate( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "Parameters")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getParameters().push_back( (afrl::cmasi::KeyValuePair*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Priority")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPriority( get_byte( tmp ));
+                 continue;
+              }
+              if(name == "Required")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequired( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "PlanningState"){
+           PlanningState* o = new PlanningState();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "EntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PlanningPosition")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setPlanningPosition((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "PlanningHeading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPlanningHeading( get_real32( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "AssignmentCoordination"){
+           AssignmentCoordination* o = new AssignmentCoordination();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "CoordinatedAutomationRequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCoordinatedAutomationRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PlanningState")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setPlanningState((uxas::messages::task::PlanningState*) oo );
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "CoordinatedAutomationRequest"){
+           CoordinatedAutomationRequest* o = new CoordinatedAutomationRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "MaximumResponseTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMaximumResponseTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "OriginalRequest")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setOriginalRequest((afrl::cmasi::AutomationRequest*) oo );
+                 continue;
+              }
+              if(name == "PlanningStates")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPlanningStates().push_back( (uxas::messages::task::PlanningState*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskAutomationRequest"){
+           TaskAutomationRequest* o = new TaskAutomationRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "OriginalRequest")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setOriginalRequest((afrl::cmasi::AutomationRequest*) oo );
+                 continue;
+              }
+              if(name == "SandBoxRequest")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSandBoxRequest( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "PlanningStates")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPlanningStates().push_back( (uxas::messages::task::PlanningState*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskAutomationResponse"){
+           TaskAutomationResponse* o = new TaskAutomationResponse();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ResponseID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setResponseID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "OriginalResponse")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setOriginalResponse((afrl::cmasi::AutomationResponse*) oo );
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "UniqueAutomationRequest"){
+           UniqueAutomationRequest* o = new UniqueAutomationRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "OriginalRequest")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setOriginalRequest((afrl::cmasi::AutomationRequest*) oo );
+                 continue;
+              }
+              if(name == "SandBoxRequest")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSandBoxRequest( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "PlanningStates")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getPlanningStates().push_back( (uxas::messages::task::PlanningState*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "UniqueAutomationResponse"){
+           UniqueAutomationResponse* o = new UniqueAutomationResponse();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ResponseID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setResponseID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "OriginalResponse")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setOriginalResponse((afrl::cmasi::AutomationResponse*) oo );
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "SensorFootprintRequests"){
+           SensorFootprintRequests* o = new SensorFootprintRequests();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Footprints")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getFootprints().push_back( (uxas::messages::task::FootprintRequest*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "FootprintRequest"){
+           FootprintRequest* o = new FootprintRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "FootprintRequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setFootprintRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "EligibleWavelengths")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleWavelengths().push_back( afrl::cmasi::WavelengthBand::get_WavelengthBand(get_string( tmp->getChild(j))));
+                 }
+                 continue;
+              }
+              if(name == "GroundSampleDistances")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getGroundSampleDistances().push_back( get_real32( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "AglAltitudes")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getAglAltitudes().push_back( get_real32( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "ElevationAngles")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getElevationAngles().push_back( get_real32( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "SensorFootprint"){
+           SensorFootprint* o = new SensorFootprint();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "FootprintResponseID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setFootprintResponseID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "CameraID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCameraID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "GimbalID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGimbalID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "HorizontalFOV")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHorizontalFOV( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "AglAltitude")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAglAltitude( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "GimbalElevation")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGimbalElevation( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "AspectRatio")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAspectRatio( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "AchievedGSD")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAchievedGSD( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "CameraWavelength")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCameraWavelength( afrl::cmasi::WavelengthBand::get_WavelengthBand( get_string( tmp )));
+                 continue;
+              }
+              if(name == "HorizontalToLeadingEdge")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHorizontalToLeadingEdge( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "HorizontalToTrailingEdge")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHorizontalToTrailingEdge( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "HorizontalToCenter")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setHorizontalToCenter( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "WidthCenter")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setWidthCenter( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "SlantRangeToCenter")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setSlantRangeToCenter( get_real32( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "SensorFootprintResponse"){
+           SensorFootprintResponse* o = new SensorFootprintResponse();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ResponseID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setResponseID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Footprints")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getFootprints().push_back( (uxas::messages::task::SensorFootprint*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskImplementationRequest"){
+           TaskImplementationRequest* o = new TaskImplementationRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "StartingWaypointID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartingWaypointID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "StartPosition")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setStartPosition((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "StartHeading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartHeading( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "StartTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartTime( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "RegionID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRegionID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "OptionID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setOptionID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TimeThreshold")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeThreshold( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskImplementationResponse"){
+           TaskImplementationResponse* o = new TaskImplementationResponse();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ResponseID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setResponseID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "OptionID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setOptionID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TaskWaypoints")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getTaskWaypoints().push_back( (afrl::cmasi::Waypoint*) oo);
+                 }
+                 continue;
+              }
+              if(name == "FinalLocation")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setFinalLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "FinalHeading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setFinalHeading( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "FinalTime")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setFinalTime( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "AssignmentCostMatrix"){
+           AssignmentCostMatrix* o = new AssignmentCostMatrix();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "CorrespondingAutomationRequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCorrespondingAutomationRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TaskLevelRelationship")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskLevelRelationship( get_string( tmp ));
+                 continue;
+              }
+              if(name == "TaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getTaskList().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "OperatingRegion")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setOperatingRegion( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "CostMatrix")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getCostMatrix().push_back( (uxas::messages::task::TaskOptionCost*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskOptionCost"){
+           TaskOptionCost* o = new TaskOptionCost();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "IntialTaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setIntialTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "IntialTaskOption")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setIntialTaskOption( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "DestinationTaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDestinationTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "DestinationTaskOption")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setDestinationTaskOption( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TimeToGo")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeToGo( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskAssignment"){
+           TaskAssignment* o = new TaskAssignment();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "OptionID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setOptionID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "AssignedVehicle")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAssignedVehicle( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TimeThreshold")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeThreshold( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TimeTaskCompleted")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeTaskCompleted( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskAssignmentSummary"){
+           TaskAssignmentSummary* o = new TaskAssignmentSummary();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "CorrespondingAutomationRequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCorrespondingAutomationRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "OperatingRegion")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setOperatingRegion( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TaskList")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getTaskList().push_back( (uxas::messages::task::TaskAssignment*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskOption"){
+           TaskOption* o = new TaskOption();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "OptionID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setOptionID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "EligibleEntities")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEligibleEntities().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "Cost")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCost( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "StartLocation")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setStartLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "StartHeading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStartHeading( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "EndLocation")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setEndLocation((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "EndHeading")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEndHeading( get_real32( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskPlanOptions"){
+           TaskPlanOptions* o = new TaskPlanOptions();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "CorrespondingAutomationRequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setCorrespondingAutomationRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Composition")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setComposition( get_string( tmp ));
+                 continue;
+              }
+              if(name == "Options")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getOptions().push_back( (uxas::messages::task::TaskOption*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskPause"){
+           TaskPause* o = new TaskPause();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskResume"){
+           TaskResume* o = new TaskResume();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "RestartCompletely")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRestartCompletely( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "ReAssign")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setReAssign((uxas::messages::task::TaskAssignment*) oo );
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskProgress"){
+           TaskProgress* o = new TaskProgress();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ResponseID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setResponseID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "PercentComplete")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPercentComplete( get_real32( tmp ));
+                 continue;
+              }
+              if(name == "EntitiesEngaged")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEntitiesEngaged().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskProgressRequest"){
+           TaskProgressRequest* o = new TaskProgressRequest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "RequestID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRequestID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskInitialized"){
+           TaskInitialized* o = new TaskInitialized();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskActive"){
+           TaskActive* o = new TaskActive();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "EntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TimeTaskActivated")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeTaskActivated( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "TaskComplete"){
+           TaskComplete* o = new TaskComplete();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "TaskID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTaskID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "EntitiesInvolved")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getEntitiesInvolved().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "TimeTaskCompleted")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeTaskCompleted( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "CancelTask"){
+           CancelTask* o = new CancelTask();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Vehicles")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getVehicles().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+              if(name == "CanceledTasks")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getCanceledTasks().push_back( get_int64( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+
+
+         return NULL;
+        
+    }
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/UXTASKXMLReader.h b/src/LMCP/uxas/messages/task/UXTASKXMLReader.h
new file mode 100644
index 0000000..abbe931
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/UXTASKXMLReader.h
@@ -0,0 +1,47 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef UXTASK_SERIESXMLREADER_H_
+#define UXTASK_SERIESXMLREADER_H_
+
+#include "avtas/lmcp/Object.h"
+#include "avtas/lmcp/Node.h"
+#include "avtas/lmcp/NodeUtil.h"
+
+#include <iostream>
+
+
+using namespace avtas::lmcp;
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+class SeriesXMLReader {
+
+    /** reads an LMCP XML Storage file and returns a list of LMCPObjects */
+    public:
+
+        SeriesXMLReader(void) {}
+
+        virtual ~SeriesXMLReader(){}  
+
+        static avtas::lmcp::Object * visitType(avtas::lmcp::Node* el );
+
+};
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif 
diff --git a/src/LMCP/uxas/messages/task/UniqueAutomationRequest.h b/src/LMCP/uxas/messages/task/UniqueAutomationRequest.h
new file mode 100644
index 0000000..2af0a66
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/UniqueAutomationRequest.h
@@ -0,0 +1,128 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_UNIQUEAUTOMATIONREQUEST_H_
+#define _UXAS_MESSAGES_TASK_UNIQUEAUTOMATIONREQUEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AutomationRequest.h"
+#include "uxas/messages/task/PlanningState.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isUniqueAutomationRequest(avtas::lmcp::Object* obj);
+   bool isUniqueAutomationRequest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > UniqueAutomationRequestDescendants();
+   
+   class UniqueAutomationRequest : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      UniqueAutomationRequest(void);
+
+      // Copy Constructor
+      UniqueAutomationRequest(const UniqueAutomationRequest &that);
+
+      // Assignment Operator
+      UniqueAutomationRequest & operator=(const UniqueAutomationRequest &that);
+
+      // Destructor
+      virtual ~UniqueAutomationRequest(void);
+
+      // Equals overload
+      bool operator==(const UniqueAutomationRequest & that);
+      bool operator!=(const UniqueAutomationRequest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual UniqueAutomationRequest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 7; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Identifier for tracking requests and responses (Units: None)*/
+      int64_t getRequestID(void) const { return __RequestID; }
+      UniqueAutomationRequest& setRequestID(const int64_t val);
+
+      /** Original automation request without a unique identifier (Units: None)*/
+      afrl::cmasi::AutomationRequest* const getOriginalRequest(void) { return __OriginalRequest; }
+      UniqueAutomationRequest& setOriginalRequest(const afrl::cmasi::AutomationRequest* const val);
+
+      /** If this boolean is true, then the resulting plans based on this automation request will not be directly implemented, for example, tasks should not expect the waypoints generated for this request to be active (Units: None)*/
+      bool getSandBoxRequest(void) const { return __SandBoxRequest; }
+      UniqueAutomationRequest& setSandBoxRequest(const bool val);
+
+      /** The initial states of entities used in planning. Note: if an eligible entity does not have a PlanningState, then it's most recent EntityState is used for plannning. (Units: None)*/
+      std::vector<uxas::messages::task::PlanningState*> & getPlanningStates(void) { return __PlanningStates; }
+
+
+
+   protected:
+      /** Identifier for tracking requests and responses */
+      int64_t __RequestID;
+      /** Original automation request without a unique identifier */
+      afrl::cmasi::AutomationRequest* __OriginalRequest;
+      /** If this boolean is true, then the resulting plans based on this automation request will not be directly implemented, for example, tasks should not expect the waypoints generated for this request to be active */
+      bool __SandBoxRequest;
+      /** The initial states of entities used in planning. Note: if an eligible entity does not have a PlanningState, then it's most recent EntityState is used for plannning. */
+      std::vector< uxas::messages::task::PlanningState* > __PlanningStates;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_UNIQUEAUTOMATIONREQUEST_H_
diff --git a/src/LMCP/uxas/messages/task/UniqueAutomationRequestDescendants.h b/src/LMCP/uxas/messages/task/UniqueAutomationRequestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/UniqueAutomationRequestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/UniqueAutomationResponse.h b/src/LMCP/uxas/messages/task/UniqueAutomationResponse.h
new file mode 100644
index 0000000..2fec150
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/UniqueAutomationResponse.h
@@ -0,0 +1,115 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_TASK_UNIQUEAUTOMATIONRESPONSE_H_
+#define _UXAS_MESSAGES_TASK_UNIQUEAUTOMATIONRESPONSE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXTASKEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/AutomationResponse.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   bool isUniqueAutomationResponse(avtas::lmcp::Object* obj);
+   bool isUniqueAutomationResponse(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > UniqueAutomationResponseDescendants();
+   
+   class UniqueAutomationResponse : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      UniqueAutomationResponse(void);
+
+      // Copy Constructor
+      UniqueAutomationResponse(const UniqueAutomationResponse &that);
+
+      // Assignment Operator
+      UniqueAutomationResponse & operator=(const UniqueAutomationResponse &that);
+
+      // Destructor
+      virtual ~UniqueAutomationResponse(void);
+
+      // Equals overload
+      bool operator==(const UniqueAutomationResponse & that);
+      bool operator!=(const UniqueAutomationResponse & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual UniqueAutomationResponse* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 8; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXTASK"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149757930721443840LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 6; }
+
+      // Accessors and Modifiers
+      /** Identifier for tracking requests and responses. Must match RequestID from corresponding UniqueAutomationRequest (Units: None)*/
+      int64_t getResponseID(void) const { return __ResponseID; }
+      UniqueAutomationResponse& setResponseID(const int64_t val);
+
+      /** Original automation request without a unique identifier (Units: None)*/
+      afrl::cmasi::AutomationResponse* const getOriginalResponse(void) { return __OriginalResponse; }
+      UniqueAutomationResponse& setOriginalResponse(const afrl::cmasi::AutomationResponse* const val);
+
+
+
+   protected:
+      /** Identifier for tracking requests and responses. Must match RequestID from corresponding UniqueAutomationRequest */
+      int64_t __ResponseID;
+      /** Original automation request without a unique identifier */
+      afrl::cmasi::AutomationResponse* __OriginalResponse;
+
+   };
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_TASK_UNIQUEAUTOMATIONRESPONSE_H_
diff --git a/src/LMCP/uxas/messages/task/UniqueAutomationResponseDescendants.h b/src/LMCP/uxas/messages/task/UniqueAutomationResponseDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/UniqueAutomationResponseDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskAssignmentCoordination.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskAssignmentCoordination.cpp
new file mode 100644
index 0000000..c03df79
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskAssignmentCoordination.cpp
@@ -0,0 +1,209 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/AssignmentCoordination.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AssignmentCoordination::Subscription = "uxas.messages.task.AssignmentCoordination";
+   const std::string AssignmentCoordination::TypeName = "AssignmentCoordination";
+   
+   bool isAssignmentCoordination(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 3) return false;
+      return true;
+   }
+   
+   bool isAssignmentCoordination(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 3) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AssignmentCoordinationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   AssignmentCoordination::AssignmentCoordination(void) : avtas::lmcp::Object()
+   {
+      __CoordinatedAutomationRequestID = 0LL;
+      __PlanningState = new uxas::messages::task::PlanningState();
+
+   }
+     
+   AssignmentCoordination::AssignmentCoordination(const AssignmentCoordination &that) : avtas::lmcp::Object(that)
+   {
+        __CoordinatedAutomationRequestID = that.__CoordinatedAutomationRequestID;
+        __PlanningState = that.__PlanningState == nullptr ? nullptr : that.__PlanningState->clone();
+
+   }
+   
+   AssignmentCoordination & AssignmentCoordination::operator=(const AssignmentCoordination &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__PlanningState != nullptr) delete __PlanningState;
+
+         __CoordinatedAutomationRequestID = that.__CoordinatedAutomationRequestID;
+         __PlanningState = that.__PlanningState == nullptr ? nullptr : that.__PlanningState->clone();
+
+      }
+      return *this;
+   }
+
+   AssignmentCoordination* AssignmentCoordination::clone() const
+   {
+        return new AssignmentCoordination(*this);
+   }
+   
+   AssignmentCoordination::~AssignmentCoordination(void)
+   {
+      if (__PlanningState != nullptr) delete __PlanningState;
+
+   }
+  
+   void AssignmentCoordination::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__CoordinatedAutomationRequestID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __PlanningState, buf);
+
+   }
+   
+   void AssignmentCoordination::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __CoordinatedAutomationRequestID = buf.getLong();
+      {
+         if (__PlanningState != nullptr) delete __PlanningState;
+         __PlanningState = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __PlanningState = (uxas::messages::task::PlanningState*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__PlanningState != nullptr) __PlanningState->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t AssignmentCoordination::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__PlanningState != nullptr ? __PlanningState->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string AssignmentCoordination::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AssignmentCoordination ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "CoordinatedAutomationRequestID (int64_t) = " << __CoordinatedAutomationRequestID << "\n";
+      oss << indent << "PlanningState (PlanningState)";
+      if (__PlanningState == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AssignmentCoordination::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AssignmentCoordination Series=\"UXTASK\">\n";
+      str << ws << "   <CoordinatedAutomationRequestID>" << __CoordinatedAutomationRequestID << "</CoordinatedAutomationRequestID>\n";
+      if (__PlanningState != nullptr)
+      {
+         str << ws << "   <PlanningState>";
+         str << "\n" + __PlanningState->toXML(depth + 1) + ws + "   ";
+         str << "</PlanningState>\n";
+      }
+      str << ws << "</AssignmentCoordination>\n";
+
+      return str.str();
+   }
+
+   bool AssignmentCoordination::operator==(const AssignmentCoordination & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__CoordinatedAutomationRequestID != that.__CoordinatedAutomationRequestID) return false;
+      if(__PlanningState && that.__PlanningState)
+      {
+         if(__PlanningState->getSeriesNameAsLong() != that.__PlanningState->getSeriesNameAsLong()) return false;
+         if(__PlanningState->getSeriesVersion() != that.__PlanningState->getSeriesVersion()) return false;
+         if(__PlanningState->getLmcpType() != that.__PlanningState->getLmcpType()) return false;
+         if( *(__PlanningState) != *(that.__PlanningState) ) return false;
+      }
+      else if(__PlanningState != that.__PlanningState) return false;
+      return true;
+
+   }
+
+   bool AssignmentCoordination::operator!=(const AssignmentCoordination & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   AssignmentCoordination& AssignmentCoordination::setCoordinatedAutomationRequestID(const int64_t val)
+   {
+      __CoordinatedAutomationRequestID = val;
+      return *this;
+   }
+
+   AssignmentCoordination& AssignmentCoordination::setPlanningState(const uxas::messages::task::PlanningState* const val)
+   {
+      if (__PlanningState != nullptr) { delete __PlanningState; __PlanningState = nullptr; }
+      if (val != nullptr) { __PlanningState = const_cast< uxas::messages::task::PlanningState* > (val); }
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskAssignmentCoordinatorTask.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskAssignmentCoordinatorTask.cpp
new file mode 100644
index 0000000..5f57dff
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskAssignmentCoordinatorTask.cpp
@@ -0,0 +1,175 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/AssignmentCoordinatorTask.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AssignmentCoordinatorTask::Subscription = "uxas.messages.task.AssignmentCoordinatorTask";
+   const std::string AssignmentCoordinatorTask::TypeName = "AssignmentCoordinatorTask";
+   
+   bool isAssignmentCoordinatorTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 1) return false;
+      return true;
+   }
+   
+   bool isAssignmentCoordinatorTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 1) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AssignmentCoordinatorTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   AssignmentCoordinatorTask::AssignmentCoordinatorTask(void) : afrl::cmasi::Task()
+   {
+
+   }
+     
+   AssignmentCoordinatorTask::AssignmentCoordinatorTask(const AssignmentCoordinatorTask &that) : afrl::cmasi::Task(that)
+   {
+
+   }
+   
+   AssignmentCoordinatorTask & AssignmentCoordinatorTask::operator=(const AssignmentCoordinatorTask &that)
+   {
+      if (this != &that)
+      {
+         afrl::cmasi::Task::operator=(that);
+
+
+      }
+      return *this;
+   }
+
+   AssignmentCoordinatorTask* AssignmentCoordinatorTask::clone() const
+   {
+        return new AssignmentCoordinatorTask(*this);
+   }
+   
+   AssignmentCoordinatorTask::~AssignmentCoordinatorTask(void)
+   {
+
+   }
+  
+   void AssignmentCoordinatorTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      afrl::cmasi::Task::pack(buf);
+      // Copy the class into the buffer
+
+   }
+   
+   void AssignmentCoordinatorTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      afrl::cmasi::Task::unpack(buf);
+      // Copy the buffer into the class
+
+   }
+
+   uint32_t AssignmentCoordinatorTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += afrl::cmasi::Task::calculatePackedSize();
+
+      return size;
+   }
+
+   std::string AssignmentCoordinatorTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AssignmentCoordinatorTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "RevisitRate (float) = " << __RevisitRate << "\n";
+      oss << indent << "Parameters (KeyValuePair [ " << __Parameters.size() << ", var ])\n";
+      oss << indent << "Priority (uint8_t) = " << __Priority << "\n";
+      oss << indent << "Required (bool) = " << __Required << "\n";
+
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AssignmentCoordinatorTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AssignmentCoordinatorTask Series=\"UXTASK\">\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <RevisitRate>" << __RevisitRate << "</RevisitRate>\n";
+      str << ws << "   <Parameters>\n";
+      for (size_t i=0; i<__Parameters.size(); i++)
+      {
+         str << (__Parameters[i] == nullptr ? ( ws + "   <null/>\n") : (__Parameters[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Parameters>\n";
+      str << ws << "   <Priority>" << (int32_t) __Priority << "</Priority>\n";
+      str << ws << "   <Required>" << (__Required ? "true" : "false") << "</Required>\n";
+      str << ws << "</AssignmentCoordinatorTask>\n";
+
+      return str.str();
+   }
+
+   bool AssignmentCoordinatorTask::operator==(const AssignmentCoordinatorTask & that)
+   {
+      if( afrl::cmasi::Task::operator!=(that) )
+      {
+          return false;
+      }
+      return true;
+
+   }
+
+   bool AssignmentCoordinatorTask::operator!=(const AssignmentCoordinatorTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskAssignmentCostMatrix.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskAssignmentCostMatrix.cpp
new file mode 100644
index 0000000..9ea71f0
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskAssignmentCostMatrix.cpp
@@ -0,0 +1,301 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/AssignmentCostMatrix.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AssignmentCostMatrix::Subscription = "uxas.messages.task.AssignmentCostMatrix";
+   const std::string AssignmentCostMatrix::TypeName = "AssignmentCostMatrix";
+   
+   bool isAssignmentCostMatrix(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 15) return false;
+      return true;
+   }
+   
+   bool isAssignmentCostMatrix(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 15) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AssignmentCostMatrixDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   AssignmentCostMatrix::AssignmentCostMatrix(void) : avtas::lmcp::Object()
+   {
+      __CorrespondingAutomationRequestID = 0LL;
+      __TaskLevelRelationship = std::string("");
+      __OperatingRegion = 0LL;
+
+   }
+     
+   AssignmentCostMatrix::AssignmentCostMatrix(const AssignmentCostMatrix &that) : avtas::lmcp::Object(that)
+   {
+        __CorrespondingAutomationRequestID = that.__CorrespondingAutomationRequestID;
+        __TaskLevelRelationship = that.__TaskLevelRelationship;
+        __TaskList.clear();
+        for (size_t i=0; i< that.__TaskList.size(); i++)
+        {
+           __TaskList.push_back( that.__TaskList[i]);
+        }
+        __OperatingRegion = that.__OperatingRegion;
+        __CostMatrix.clear();
+        for (size_t i=0; i< that.__CostMatrix.size(); i++)
+        {
+           __CostMatrix.push_back( that.__CostMatrix[i] == nullptr ? nullptr : that.__CostMatrix[i]->clone());
+        }
+
+   }
+   
+   AssignmentCostMatrix & AssignmentCostMatrix::operator=(const AssignmentCostMatrix &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__CostMatrix.size(); i++)
+         {
+            if (__CostMatrix[i] != nullptr) delete __CostMatrix[i];
+         }
+
+         __CorrespondingAutomationRequestID = that.__CorrespondingAutomationRequestID;
+         __TaskLevelRelationship = that.__TaskLevelRelationship;
+         __TaskList.clear();
+         for (size_t i=0; i< that.__TaskList.size(); i++)
+         {
+            __TaskList.push_back( that.__TaskList[i]);
+         }
+         __OperatingRegion = that.__OperatingRegion;
+         __CostMatrix.clear();
+         for (size_t i=0; i< that.__CostMatrix.size(); i++)
+         {
+            __CostMatrix.push_back( that.__CostMatrix[i] == nullptr ? nullptr : that.__CostMatrix[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   AssignmentCostMatrix* AssignmentCostMatrix::clone() const
+   {
+        return new AssignmentCostMatrix(*this);
+   }
+   
+   AssignmentCostMatrix::~AssignmentCostMatrix(void)
+   {
+      for (size_t i=0; i<__CostMatrix.size(); i++)
+      {
+         if (__CostMatrix[i] != nullptr) delete __CostMatrix[i];
+      }
+
+   }
+  
+   void AssignmentCostMatrix::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__CorrespondingAutomationRequestID);
+      buf.putString(__TaskLevelRelationship);
+      buf.putUShort( static_cast<uint16_t>(__TaskList.size()));
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         buf.putLong(__TaskList[i]);
+      }
+      buf.putLong(__OperatingRegion);
+      buf.putUShort( static_cast<uint16_t>(__CostMatrix.size()));
+      for (size_t i=0; i<__CostMatrix.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __CostMatrix[i], buf);
+      }
+
+   }
+   
+   void AssignmentCostMatrix::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __CorrespondingAutomationRequestID = buf.getLong();
+      __TaskLevelRelationship = buf.getString();
+      __TaskList.clear();
+      uint16_t __TaskList_length = buf.getUShort();
+      for (uint32_t i=0; i< __TaskList_length; i++)
+      {
+         __TaskList.push_back(buf.getLong() );
+      }
+      __OperatingRegion = buf.getLong();
+      for (size_t i=0; i<__CostMatrix.size(); i++)
+      {
+         if (__CostMatrix[i] != nullptr)
+            delete __CostMatrix[i];
+      }
+      __CostMatrix.clear();
+      uint16_t __CostMatrix_length = buf.getUShort();
+      for (uint32_t i=0; i< __CostMatrix_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::task::TaskOptionCost* e = (uxas::messages::task::TaskOptionCost*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __CostMatrix.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t AssignmentCostMatrix::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2 + __TaskLevelRelationship.length();
+      size += 2 + sizeof(int64_t) * __TaskList.size();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__CostMatrix.size(); i++)
+      {
+         if (__CostMatrix[i] != nullptr)
+         {
+            size += __CostMatrix[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string AssignmentCostMatrix::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AssignmentCostMatrix ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "CorrespondingAutomationRequestID (int64_t) = " << __CorrespondingAutomationRequestID << "\n";
+      oss << indent << "TaskLevelRelationship (std::string) = " << __TaskLevelRelationship << "\n";
+      oss << indent << "TaskList (int64 [ " << __TaskList.size() << ", var ])\n";
+      oss << indent << "OperatingRegion (int64_t) = " << __OperatingRegion << "\n";
+      oss << indent << "CostMatrix (TaskOptionCost [ " << __CostMatrix.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AssignmentCostMatrix::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AssignmentCostMatrix Series=\"UXTASK\">\n";
+      str << ws << "   <CorrespondingAutomationRequestID>" << __CorrespondingAutomationRequestID << "</CorrespondingAutomationRequestID>\n";
+      str << ws << "   <TaskLevelRelationship>" << __TaskLevelRelationship << "</TaskLevelRelationship>\n";
+      str << ws << "   <TaskList>\n";
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         str << ws << "   <int64>" << __TaskList[i] << "</int64>\n";
+      }
+      str << ws << "   </TaskList>\n";
+      str << ws << "   <OperatingRegion>" << __OperatingRegion << "</OperatingRegion>\n";
+      str << ws << "   <CostMatrix>\n";
+      for (size_t i=0; i<__CostMatrix.size(); i++)
+      {
+         str << (__CostMatrix[i] == nullptr ? ( ws + "   <null/>\n") : (__CostMatrix[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </CostMatrix>\n";
+      str << ws << "</AssignmentCostMatrix>\n";
+
+      return str.str();
+   }
+
+   bool AssignmentCostMatrix::operator==(const AssignmentCostMatrix & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__CorrespondingAutomationRequestID != that.__CorrespondingAutomationRequestID) return false;
+      if(__TaskLevelRelationship != that.__TaskLevelRelationship) return false;
+      if(__TaskList.size() != that.__TaskList.size()) return false;
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         if(__TaskList[i] != that.__TaskList[i]) return false;
+      }
+      if(__OperatingRegion != that.__OperatingRegion) return false;
+      if(__CostMatrix.size() != that.__CostMatrix.size()) return false;
+      for (size_t i=0; i<__CostMatrix.size(); i++)
+      {
+         if(__CostMatrix[i] && that.__CostMatrix[i])
+         {
+            if(__CostMatrix[i]->getSeriesNameAsLong() != that.__CostMatrix[i]->getSeriesNameAsLong()) return false;
+            if(__CostMatrix[i]->getSeriesVersion() != that.__CostMatrix[i]->getSeriesVersion()) return false;
+            if(__CostMatrix[i]->getLmcpType() != that.__CostMatrix[i]->getLmcpType()) return false;
+            if( *(__CostMatrix[i]) != *(that.__CostMatrix[i]) ) return false;
+         }
+         else if(__CostMatrix[i] != that.__CostMatrix[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool AssignmentCostMatrix::operator!=(const AssignmentCostMatrix & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   AssignmentCostMatrix& AssignmentCostMatrix::setCorrespondingAutomationRequestID(const int64_t val)
+   {
+      __CorrespondingAutomationRequestID = val;
+      return *this;
+   }
+
+   AssignmentCostMatrix& AssignmentCostMatrix::setTaskLevelRelationship(const std::string val)
+   {
+      __TaskLevelRelationship = val;
+      return *this;
+   }
+
+
+   AssignmentCostMatrix& AssignmentCostMatrix::setOperatingRegion(const int64_t val)
+   {
+      __OperatingRegion = val;
+      return *this;
+   }
+
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskCancelTask.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskCancelTask.cpp
new file mode 100644
index 0000000..4e887f2
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskCancelTask.cpp
@@ -0,0 +1,220 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/CancelTask.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string CancelTask::Subscription = "uxas.messages.task.CancelTask";
+   const std::string CancelTask::TypeName = "CancelTask";
+   
+   bool isCancelTask(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 28) return false;
+      return true;
+   }
+   
+   bool isCancelTask(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 28) return false;
+      return true;
+   }
+   
+   std::vector< std::string > CancelTaskDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   CancelTask::CancelTask(void) : avtas::lmcp::Object()
+   {
+
+   }
+     
+   CancelTask::CancelTask(const CancelTask &that) : avtas::lmcp::Object(that)
+   {
+        __Vehicles.clear();
+        for (size_t i=0; i< that.__Vehicles.size(); i++)
+        {
+           __Vehicles.push_back( that.__Vehicles[i]);
+        }
+        __CanceledTasks.clear();
+        for (size_t i=0; i< that.__CanceledTasks.size(); i++)
+        {
+           __CanceledTasks.push_back( that.__CanceledTasks[i]);
+        }
+
+   }
+   
+   CancelTask & CancelTask::operator=(const CancelTask &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __Vehicles.clear();
+         for (size_t i=0; i< that.__Vehicles.size(); i++)
+         {
+            __Vehicles.push_back( that.__Vehicles[i]);
+         }
+         __CanceledTasks.clear();
+         for (size_t i=0; i< that.__CanceledTasks.size(); i++)
+         {
+            __CanceledTasks.push_back( that.__CanceledTasks[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   CancelTask* CancelTask::clone() const
+   {
+        return new CancelTask(*this);
+   }
+   
+   CancelTask::~CancelTask(void)
+   {
+
+   }
+  
+   void CancelTask::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__Vehicles.size()));
+      for (size_t i=0; i<__Vehicles.size(); i++)
+      {
+         buf.putLong(__Vehicles[i]);
+      }
+      buf.putUShort( static_cast<uint16_t>(__CanceledTasks.size()));
+      for (size_t i=0; i<__CanceledTasks.size(); i++)
+      {
+         buf.putLong(__CanceledTasks[i]);
+      }
+
+   }
+   
+   void CancelTask::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __Vehicles.clear();
+      uint16_t __Vehicles_length = buf.getUShort();
+      for (uint32_t i=0; i< __Vehicles_length; i++)
+      {
+         __Vehicles.push_back(buf.getLong() );
+      }
+      __CanceledTasks.clear();
+      uint16_t __CanceledTasks_length = buf.getUShort();
+      for (uint32_t i=0; i< __CanceledTasks_length; i++)
+      {
+         __CanceledTasks.push_back(buf.getLong() );
+      }
+
+   }
+
+   uint32_t CancelTask::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2 + sizeof(int64_t) * __Vehicles.size();
+      size += 2 + sizeof(int64_t) * __CanceledTasks.size();
+
+      return size;
+   }
+
+   std::string CancelTask::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( CancelTask ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "Vehicles (int64 [ " << __Vehicles.size() << ", var ])\n";
+      oss << indent << "CanceledTasks (int64 [ " << __CanceledTasks.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string CancelTask::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<CancelTask Series=\"UXTASK\">\n";
+      str << ws << "   <Vehicles>\n";
+      for (size_t i=0; i<__Vehicles.size(); i++)
+      {
+         str << ws << "   <int64>" << __Vehicles[i] << "</int64>\n";
+      }
+      str << ws << "   </Vehicles>\n";
+      str << ws << "   <CanceledTasks>\n";
+      for (size_t i=0; i<__CanceledTasks.size(); i++)
+      {
+         str << ws << "   <int64>" << __CanceledTasks[i] << "</int64>\n";
+      }
+      str << ws << "   </CanceledTasks>\n";
+      str << ws << "</CancelTask>\n";
+
+      return str.str();
+   }
+
+   bool CancelTask::operator==(const CancelTask & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Vehicles.size() != that.__Vehicles.size()) return false;
+      for (size_t i=0; i<__Vehicles.size(); i++)
+      {
+         if(__Vehicles[i] != that.__Vehicles[i]) return false;
+      }
+      if(__CanceledTasks.size() != that.__CanceledTasks.size()) return false;
+      for (size_t i=0; i<__CanceledTasks.size(); i++)
+      {
+         if(__CanceledTasks[i] != that.__CanceledTasks[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool CancelTask::operator!=(const CancelTask & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskCoordinatedAutomationRequest.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskCoordinatedAutomationRequest.cpp
new file mode 100644
index 0000000..db89c14
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskCoordinatedAutomationRequest.cpp
@@ -0,0 +1,295 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/CoordinatedAutomationRequest.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string CoordinatedAutomationRequest::Subscription = "uxas.messages.task.CoordinatedAutomationRequest";
+   const std::string CoordinatedAutomationRequest::TypeName = "CoordinatedAutomationRequest";
+   
+   bool isCoordinatedAutomationRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 4) return false;
+      return true;
+   }
+   
+   bool isCoordinatedAutomationRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 4) return false;
+      return true;
+   }
+   
+   std::vector< std::string > CoordinatedAutomationRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   CoordinatedAutomationRequest::CoordinatedAutomationRequest(void) : avtas::lmcp::Object()
+   {
+      __RequestID = 0LL;
+      __MaximumResponseTime = -1LL;
+      __OriginalRequest = new afrl::cmasi::AutomationRequest();
+
+   }
+     
+   CoordinatedAutomationRequest::CoordinatedAutomationRequest(const CoordinatedAutomationRequest &that) : avtas::lmcp::Object(that)
+   {
+        __RequestID = that.__RequestID;
+        __MaximumResponseTime = that.__MaximumResponseTime;
+        __OriginalRequest = that.__OriginalRequest == nullptr ? nullptr : that.__OriginalRequest->clone();
+        __PlanningStates.clear();
+        for (size_t i=0; i< that.__PlanningStates.size(); i++)
+        {
+           __PlanningStates.push_back( that.__PlanningStates[i] == nullptr ? nullptr : that.__PlanningStates[i]->clone());
+        }
+
+   }
+   
+   CoordinatedAutomationRequest & CoordinatedAutomationRequest::operator=(const CoordinatedAutomationRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__OriginalRequest != nullptr) delete __OriginalRequest;
+         for (size_t i=0; i<__PlanningStates.size(); i++)
+         {
+            if (__PlanningStates[i] != nullptr) delete __PlanningStates[i];
+         }
+
+         __RequestID = that.__RequestID;
+         __MaximumResponseTime = that.__MaximumResponseTime;
+         __OriginalRequest = that.__OriginalRequest == nullptr ? nullptr : that.__OriginalRequest->clone();
+         __PlanningStates.clear();
+         for (size_t i=0; i< that.__PlanningStates.size(); i++)
+         {
+            __PlanningStates.push_back( that.__PlanningStates[i] == nullptr ? nullptr : that.__PlanningStates[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   CoordinatedAutomationRequest* CoordinatedAutomationRequest::clone() const
+   {
+        return new CoordinatedAutomationRequest(*this);
+   }
+   
+   CoordinatedAutomationRequest::~CoordinatedAutomationRequest(void)
+   {
+      if (__OriginalRequest != nullptr) delete __OriginalRequest;
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         if (__PlanningStates[i] != nullptr) delete __PlanningStates[i];
+      }
+
+   }
+  
+   void CoordinatedAutomationRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RequestID);
+      buf.putLong(__MaximumResponseTime);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __OriginalRequest, buf);
+      buf.putUShort( static_cast<uint16_t>(__PlanningStates.size()));
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __PlanningStates[i], buf);
+      }
+
+   }
+   
+   void CoordinatedAutomationRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RequestID = buf.getLong();
+      __MaximumResponseTime = buf.getLong();
+      {
+         if (__OriginalRequest != nullptr) delete __OriginalRequest;
+         __OriginalRequest = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __OriginalRequest = (afrl::cmasi::AutomationRequest*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__OriginalRequest != nullptr) __OriginalRequest->unpack(buf);
+         }
+      }
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         if (__PlanningStates[i] != nullptr)
+            delete __PlanningStates[i];
+      }
+      __PlanningStates.clear();
+      uint16_t __PlanningStates_length = buf.getUShort();
+      for (uint32_t i=0; i< __PlanningStates_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::task::PlanningState* e = (uxas::messages::task::PlanningState*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __PlanningStates.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t CoordinatedAutomationRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += (__OriginalRequest != nullptr ? __OriginalRequest->calculatePackedSize() + 15 : 1);
+      size += 2;
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         if (__PlanningStates[i] != nullptr)
+         {
+            size += __PlanningStates[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string CoordinatedAutomationRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( CoordinatedAutomationRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RequestID (int64_t) = " << __RequestID << "\n";
+      oss << indent << "MaximumResponseTime (int64_t) = " << __MaximumResponseTime << "\n";
+      oss << indent << "OriginalRequest (AutomationRequest)";
+      if (__OriginalRequest == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "PlanningStates (PlanningState [ " << __PlanningStates.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string CoordinatedAutomationRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<CoordinatedAutomationRequest Series=\"UXTASK\">\n";
+      str << ws << "   <RequestID>" << __RequestID << "</RequestID>\n";
+      str << ws << "   <MaximumResponseTime>" << __MaximumResponseTime << "</MaximumResponseTime>\n";
+      if (__OriginalRequest != nullptr)
+      {
+         str << ws << "   <OriginalRequest>";
+         str << "\n" + __OriginalRequest->toXML(depth + 1) + ws + "   ";
+         str << "</OriginalRequest>\n";
+      }
+      str << ws << "   <PlanningStates>\n";
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         str << (__PlanningStates[i] == nullptr ? ( ws + "   <null/>\n") : (__PlanningStates[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PlanningStates>\n";
+      str << ws << "</CoordinatedAutomationRequest>\n";
+
+      return str.str();
+   }
+
+   bool CoordinatedAutomationRequest::operator==(const CoordinatedAutomationRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RequestID != that.__RequestID) return false;
+      if(__MaximumResponseTime != that.__MaximumResponseTime) return false;
+      if(__OriginalRequest && that.__OriginalRequest)
+      {
+         if(__OriginalRequest->getSeriesNameAsLong() != that.__OriginalRequest->getSeriesNameAsLong()) return false;
+         if(__OriginalRequest->getSeriesVersion() != that.__OriginalRequest->getSeriesVersion()) return false;
+         if(__OriginalRequest->getLmcpType() != that.__OriginalRequest->getLmcpType()) return false;
+         if( *(__OriginalRequest) != *(that.__OriginalRequest) ) return false;
+      }
+      else if(__OriginalRequest != that.__OriginalRequest) return false;
+      if(__PlanningStates.size() != that.__PlanningStates.size()) return false;
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         if(__PlanningStates[i] && that.__PlanningStates[i])
+         {
+            if(__PlanningStates[i]->getSeriesNameAsLong() != that.__PlanningStates[i]->getSeriesNameAsLong()) return false;
+            if(__PlanningStates[i]->getSeriesVersion() != that.__PlanningStates[i]->getSeriesVersion()) return false;
+            if(__PlanningStates[i]->getLmcpType() != that.__PlanningStates[i]->getLmcpType()) return false;
+            if( *(__PlanningStates[i]) != *(that.__PlanningStates[i]) ) return false;
+         }
+         else if(__PlanningStates[i] != that.__PlanningStates[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool CoordinatedAutomationRequest::operator!=(const CoordinatedAutomationRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   CoordinatedAutomationRequest& CoordinatedAutomationRequest::setRequestID(const int64_t val)
+   {
+      __RequestID = val;
+      return *this;
+   }
+
+   CoordinatedAutomationRequest& CoordinatedAutomationRequest::setMaximumResponseTime(const int64_t val)
+   {
+      __MaximumResponseTime = val;
+      return *this;
+   }
+
+   CoordinatedAutomationRequest& CoordinatedAutomationRequest::setOriginalRequest(const afrl::cmasi::AutomationRequest* const val)
+   {
+      if (__OriginalRequest != nullptr) { delete __OriginalRequest; __OriginalRequest = nullptr; }
+      if (val != nullptr) { __OriginalRequest = const_cast< afrl::cmasi::AutomationRequest* > (val); }
+      return *this;
+   }
+
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskFootprintRequest.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskFootprintRequest.cpp
new file mode 100644
index 0000000..6e6aaf2
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskFootprintRequest.cpp
@@ -0,0 +1,320 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/FootprintRequest.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string FootprintRequest::Subscription = "uxas.messages.task.FootprintRequest";
+   const std::string FootprintRequest::TypeName = "FootprintRequest";
+   
+   bool isFootprintRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 10) return false;
+      return true;
+   }
+   
+   bool isFootprintRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 10) return false;
+      return true;
+   }
+   
+   std::vector< std::string > FootprintRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   FootprintRequest::FootprintRequest(void) : avtas::lmcp::Object()
+   {
+      __FootprintRequestID = 0LL;
+      __VehicleID = 0LL;
+
+   }
+     
+   FootprintRequest::FootprintRequest(const FootprintRequest &that) : avtas::lmcp::Object(that)
+   {
+        __FootprintRequestID = that.__FootprintRequestID;
+        __VehicleID = that.__VehicleID;
+        __EligibleWavelengths.clear();
+        for (size_t i=0; i< that.__EligibleWavelengths.size(); i++)
+        {
+           __EligibleWavelengths.push_back( that.__EligibleWavelengths[i]);
+        }
+        __GroundSampleDistances.clear();
+        for (size_t i=0; i< that.__GroundSampleDistances.size(); i++)
+        {
+           __GroundSampleDistances.push_back( that.__GroundSampleDistances[i]);
+        }
+        __AglAltitudes.clear();
+        for (size_t i=0; i< that.__AglAltitudes.size(); i++)
+        {
+           __AglAltitudes.push_back( that.__AglAltitudes[i]);
+        }
+        __ElevationAngles.clear();
+        for (size_t i=0; i< that.__ElevationAngles.size(); i++)
+        {
+           __ElevationAngles.push_back( that.__ElevationAngles[i]);
+        }
+
+   }
+   
+   FootprintRequest & FootprintRequest::operator=(const FootprintRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __FootprintRequestID = that.__FootprintRequestID;
+         __VehicleID = that.__VehicleID;
+         __EligibleWavelengths.clear();
+         for (size_t i=0; i< that.__EligibleWavelengths.size(); i++)
+         {
+            __EligibleWavelengths.push_back( that.__EligibleWavelengths[i]);
+         }
+         __GroundSampleDistances.clear();
+         for (size_t i=0; i< that.__GroundSampleDistances.size(); i++)
+         {
+            __GroundSampleDistances.push_back( that.__GroundSampleDistances[i]);
+         }
+         __AglAltitudes.clear();
+         for (size_t i=0; i< that.__AglAltitudes.size(); i++)
+         {
+            __AglAltitudes.push_back( that.__AglAltitudes[i]);
+         }
+         __ElevationAngles.clear();
+         for (size_t i=0; i< that.__ElevationAngles.size(); i++)
+         {
+            __ElevationAngles.push_back( that.__ElevationAngles[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   FootprintRequest* FootprintRequest::clone() const
+   {
+        return new FootprintRequest(*this);
+   }
+   
+   FootprintRequest::~FootprintRequest(void)
+   {
+
+   }
+  
+   void FootprintRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__FootprintRequestID);
+      buf.putLong(__VehicleID);
+      buf.putUShort( static_cast<uint16_t>(__EligibleWavelengths.size()));
+      for (size_t i=0; i<__EligibleWavelengths.size(); i++)
+      {
+         buf.putInt( (int32_t) __EligibleWavelengths[i]);
+      }
+      buf.putUShort( static_cast<uint16_t>(__GroundSampleDistances.size()));
+      for (size_t i=0; i<__GroundSampleDistances.size(); i++)
+      {
+         buf.putFloat(__GroundSampleDistances[i]);
+      }
+      buf.putUShort( static_cast<uint16_t>(__AglAltitudes.size()));
+      for (size_t i=0; i<__AglAltitudes.size(); i++)
+      {
+         buf.putFloat(__AglAltitudes[i]);
+      }
+      buf.putUShort( static_cast<uint16_t>(__ElevationAngles.size()));
+      for (size_t i=0; i<__ElevationAngles.size(); i++)
+      {
+         buf.putFloat(__ElevationAngles[i]);
+      }
+
+   }
+   
+   void FootprintRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __FootprintRequestID = buf.getLong();
+      __VehicleID = buf.getLong();
+      __EligibleWavelengths.clear();
+      uint16_t __EligibleWavelengths_length = buf.getUShort();
+      for (uint32_t i=0; i< __EligibleWavelengths_length; i++)
+      {
+         __EligibleWavelengths.push_back( (afrl::cmasi::WavelengthBand::WavelengthBand) buf.getInt() );
+      }
+      __GroundSampleDistances.clear();
+      uint16_t __GroundSampleDistances_length = buf.getUShort();
+      for (uint32_t i=0; i< __GroundSampleDistances_length; i++)
+      {
+         __GroundSampleDistances.push_back(buf.getFloat() );
+      }
+      __AglAltitudes.clear();
+      uint16_t __AglAltitudes_length = buf.getUShort();
+      for (uint32_t i=0; i< __AglAltitudes_length; i++)
+      {
+         __AglAltitudes.push_back(buf.getFloat() );
+      }
+      __ElevationAngles.clear();
+      uint16_t __ElevationAngles_length = buf.getUShort();
+      for (uint32_t i=0; i< __ElevationAngles_length; i++)
+      {
+         __ElevationAngles.push_back(buf.getFloat() );
+      }
+
+   }
+
+   uint32_t FootprintRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += 2 + sizeof(afrl::cmasi::WavelengthBand::WavelengthBand) * __EligibleWavelengths.size();
+      size += 2 + sizeof(float) * __GroundSampleDistances.size();
+      size += 2 + sizeof(float) * __AglAltitudes.size();
+      size += 2 + sizeof(float) * __ElevationAngles.size();
+
+      return size;
+   }
+
+   std::string FootprintRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( FootprintRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "FootprintRequestID (int64_t) = " << __FootprintRequestID << "\n";
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "EligibleWavelengths (WavelengthBand [ " << __EligibleWavelengths.size() << ", var ])\n";
+      oss << indent << "GroundSampleDistances (real32 [ " << __GroundSampleDistances.size() << ", var ])\n";
+      oss << indent << "AglAltitudes (real32 [ " << __AglAltitudes.size() << ", var ])\n";
+      oss << indent << "ElevationAngles (real32 [ " << __ElevationAngles.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string FootprintRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<FootprintRequest Series=\"UXTASK\">\n";
+      str << ws << "   <FootprintRequestID>" << __FootprintRequestID << "</FootprintRequestID>\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <EligibleWavelengths>\n";
+      for (size_t i=0; i<__EligibleWavelengths.size(); i++)
+      {
+         str << ws << "   <WavelengthBand>" << afrl::cmasi::WavelengthBand::get_string(__EligibleWavelengths[i]) << "</WavelengthBand>\n";
+      }
+      str << ws << "   </EligibleWavelengths>\n";
+      str << ws << "   <GroundSampleDistances>\n";
+      for (size_t i=0; i<__GroundSampleDistances.size(); i++)
+      {
+         str << ws << "   <real32>" << __GroundSampleDistances[i] << "</real32>\n";
+      }
+      str << ws << "   </GroundSampleDistances>\n";
+      str << ws << "   <AglAltitudes>\n";
+      for (size_t i=0; i<__AglAltitudes.size(); i++)
+      {
+         str << ws << "   <real32>" << __AglAltitudes[i] << "</real32>\n";
+      }
+      str << ws << "   </AglAltitudes>\n";
+      str << ws << "   <ElevationAngles>\n";
+      for (size_t i=0; i<__ElevationAngles.size(); i++)
+      {
+         str << ws << "   <real32>" << __ElevationAngles[i] << "</real32>\n";
+      }
+      str << ws << "   </ElevationAngles>\n";
+      str << ws << "</FootprintRequest>\n";
+
+      return str.str();
+   }
+
+   bool FootprintRequest::operator==(const FootprintRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__FootprintRequestID != that.__FootprintRequestID) return false;
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__EligibleWavelengths.size() != that.__EligibleWavelengths.size()) return false;
+      for (size_t i=0; i<__EligibleWavelengths.size(); i++)
+      {
+         if(__EligibleWavelengths[i] != that.__EligibleWavelengths[i]) return false;
+      }
+      if(__GroundSampleDistances.size() != that.__GroundSampleDistances.size()) return false;
+      for (size_t i=0; i<__GroundSampleDistances.size(); i++)
+      {
+         if(__GroundSampleDistances[i] != that.__GroundSampleDistances[i]) return false;
+      }
+      if(__AglAltitudes.size() != that.__AglAltitudes.size()) return false;
+      for (size_t i=0; i<__AglAltitudes.size(); i++)
+      {
+         if(__AglAltitudes[i] != that.__AglAltitudes[i]) return false;
+      }
+      if(__ElevationAngles.size() != that.__ElevationAngles.size()) return false;
+      for (size_t i=0; i<__ElevationAngles.size(); i++)
+      {
+         if(__ElevationAngles[i] != that.__ElevationAngles[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool FootprintRequest::operator!=(const FootprintRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   FootprintRequest& FootprintRequest::setFootprintRequestID(const int64_t val)
+   {
+      __FootprintRequestID = val;
+      return *this;
+   }
+
+   FootprintRequest& FootprintRequest::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+
+
+
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskPlanningState.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskPlanningState.cpp
new file mode 100644
index 0000000..2c9cbc7
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskPlanningState.cpp
@@ -0,0 +1,226 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/PlanningState.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string PlanningState::Subscription = "uxas.messages.task.PlanningState";
+   const std::string PlanningState::TypeName = "PlanningState";
+   
+   bool isPlanningState(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 2) return false;
+      return true;
+   }
+   
+   bool isPlanningState(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 2) return false;
+      return true;
+   }
+   
+   std::vector< std::string > PlanningStateDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   PlanningState::PlanningState(void) : avtas::lmcp::Object()
+   {
+      __EntityID = 0LL;
+      __PlanningPosition = new afrl::cmasi::Location3D();
+      __PlanningHeading = 0.f;
+
+   }
+     
+   PlanningState::PlanningState(const PlanningState &that) : avtas::lmcp::Object(that)
+   {
+        __EntityID = that.__EntityID;
+        __PlanningPosition = that.__PlanningPosition == nullptr ? nullptr : that.__PlanningPosition->clone();
+        __PlanningHeading = that.__PlanningHeading;
+
+   }
+   
+   PlanningState & PlanningState::operator=(const PlanningState &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__PlanningPosition != nullptr) delete __PlanningPosition;
+
+         __EntityID = that.__EntityID;
+         __PlanningPosition = that.__PlanningPosition == nullptr ? nullptr : that.__PlanningPosition->clone();
+         __PlanningHeading = that.__PlanningHeading;
+
+      }
+      return *this;
+   }
+
+   PlanningState* PlanningState::clone() const
+   {
+        return new PlanningState(*this);
+   }
+   
+   PlanningState::~PlanningState(void)
+   {
+      if (__PlanningPosition != nullptr) delete __PlanningPosition;
+
+   }
+  
+   void PlanningState::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__EntityID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __PlanningPosition, buf);
+      buf.putFloat(__PlanningHeading);
+
+   }
+   
+   void PlanningState::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __EntityID = buf.getLong();
+      {
+         if (__PlanningPosition != nullptr) delete __PlanningPosition;
+         __PlanningPosition = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __PlanningPosition = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__PlanningPosition != nullptr) __PlanningPosition->unpack(buf);
+         }
+      }
+      __PlanningHeading = buf.getFloat();
+
+   }
+
+   uint32_t PlanningState::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__PlanningPosition != nullptr ? __PlanningPosition->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string PlanningState::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( PlanningState ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "EntityID (int64_t) = " << __EntityID << "\n";
+      oss << indent << "PlanningPosition (Location3D)";
+      if (__PlanningPosition == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "PlanningHeading (float) = " << __PlanningHeading << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string PlanningState::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<PlanningState Series=\"UXTASK\">\n";
+      str << ws << "   <EntityID>" << __EntityID << "</EntityID>\n";
+      if (__PlanningPosition != nullptr)
+      {
+         str << ws << "   <PlanningPosition>";
+         str << "\n" + __PlanningPosition->toXML(depth + 1) + ws + "   ";
+         str << "</PlanningPosition>\n";
+      }
+      str << ws << "   <PlanningHeading>" << __PlanningHeading << "</PlanningHeading>\n";
+      str << ws << "</PlanningState>\n";
+
+      return str.str();
+   }
+
+   bool PlanningState::operator==(const PlanningState & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__EntityID != that.__EntityID) return false;
+      if(__PlanningPosition && that.__PlanningPosition)
+      {
+         if(__PlanningPosition->getSeriesNameAsLong() != that.__PlanningPosition->getSeriesNameAsLong()) return false;
+         if(__PlanningPosition->getSeriesVersion() != that.__PlanningPosition->getSeriesVersion()) return false;
+         if(__PlanningPosition->getLmcpType() != that.__PlanningPosition->getLmcpType()) return false;
+         if( *(__PlanningPosition) != *(that.__PlanningPosition) ) return false;
+      }
+      else if(__PlanningPosition != that.__PlanningPosition) return false;
+      if(__PlanningHeading != that.__PlanningHeading) return false;
+      return true;
+
+   }
+
+   bool PlanningState::operator!=(const PlanningState & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   PlanningState& PlanningState::setEntityID(const int64_t val)
+   {
+      __EntityID = val;
+      return *this;
+   }
+
+   PlanningState& PlanningState::setPlanningPosition(const afrl::cmasi::Location3D* const val)
+   {
+      if (__PlanningPosition != nullptr) { delete __PlanningPosition; __PlanningPosition = nullptr; }
+      if (val != nullptr) { __PlanningPosition = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   PlanningState& PlanningState::setPlanningHeading(const float val)
+   {
+      __PlanningHeading = val;
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskSensorFootprint.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskSensorFootprint.cpp
new file mode 100644
index 0000000..acec63b
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskSensorFootprint.cpp
@@ -0,0 +1,375 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/SensorFootprint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string SensorFootprint::Subscription = "uxas.messages.task.SensorFootprint";
+   const std::string SensorFootprint::TypeName = "SensorFootprint";
+   
+   bool isSensorFootprint(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 11) return false;
+      return true;
+   }
+   
+   bool isSensorFootprint(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 11) return false;
+      return true;
+   }
+   
+   std::vector< std::string > SensorFootprintDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   SensorFootprint::SensorFootprint(void) : avtas::lmcp::Object()
+   {
+      __FootprintResponseID = 0LL;
+      __VehicleID = 0LL;
+      __CameraID = 0LL;
+      __GimbalID = 0LL;
+      __HorizontalFOV = 0.f;
+      __AglAltitude = 0.f;
+      __GimbalElevation = 0.f;
+      __AspectRatio = 0.f;
+      __AchievedGSD = 0.f;
+      __CameraWavelength = afrl::cmasi::WavelengthBand::AllAny;
+      __HorizontalToLeadingEdge = 0.f;
+      __HorizontalToTrailingEdge = 0.f;
+      __HorizontalToCenter = 0.f;
+      __WidthCenter = 0.f;
+      __SlantRangeToCenter = 0.f;
+
+   }
+     
+   SensorFootprint::SensorFootprint(const SensorFootprint &that) : avtas::lmcp::Object(that)
+   {
+        __FootprintResponseID = that.__FootprintResponseID;
+        __VehicleID = that.__VehicleID;
+        __CameraID = that.__CameraID;
+        __GimbalID = that.__GimbalID;
+        __HorizontalFOV = that.__HorizontalFOV;
+        __AglAltitude = that.__AglAltitude;
+        __GimbalElevation = that.__GimbalElevation;
+        __AspectRatio = that.__AspectRatio;
+        __AchievedGSD = that.__AchievedGSD;
+        __CameraWavelength = that.__CameraWavelength;
+        __HorizontalToLeadingEdge = that.__HorizontalToLeadingEdge;
+        __HorizontalToTrailingEdge = that.__HorizontalToTrailingEdge;
+        __HorizontalToCenter = that.__HorizontalToCenter;
+        __WidthCenter = that.__WidthCenter;
+        __SlantRangeToCenter = that.__SlantRangeToCenter;
+
+   }
+   
+   SensorFootprint & SensorFootprint::operator=(const SensorFootprint &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __FootprintResponseID = that.__FootprintResponseID;
+         __VehicleID = that.__VehicleID;
+         __CameraID = that.__CameraID;
+         __GimbalID = that.__GimbalID;
+         __HorizontalFOV = that.__HorizontalFOV;
+         __AglAltitude = that.__AglAltitude;
+         __GimbalElevation = that.__GimbalElevation;
+         __AspectRatio = that.__AspectRatio;
+         __AchievedGSD = that.__AchievedGSD;
+         __CameraWavelength = that.__CameraWavelength;
+         __HorizontalToLeadingEdge = that.__HorizontalToLeadingEdge;
+         __HorizontalToTrailingEdge = that.__HorizontalToTrailingEdge;
+         __HorizontalToCenter = that.__HorizontalToCenter;
+         __WidthCenter = that.__WidthCenter;
+         __SlantRangeToCenter = that.__SlantRangeToCenter;
+
+      }
+      return *this;
+   }
+
+   SensorFootprint* SensorFootprint::clone() const
+   {
+        return new SensorFootprint(*this);
+   }
+   
+   SensorFootprint::~SensorFootprint(void)
+   {
+
+   }
+  
+   void SensorFootprint::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__FootprintResponseID);
+      buf.putLong(__VehicleID);
+      buf.putLong(__CameraID);
+      buf.putLong(__GimbalID);
+      buf.putFloat(__HorizontalFOV);
+      buf.putFloat(__AglAltitude);
+      buf.putFloat(__GimbalElevation);
+      buf.putFloat(__AspectRatio);
+      buf.putFloat(__AchievedGSD);
+      buf.putInt( (int32_t) __CameraWavelength);
+      buf.putFloat(__HorizontalToLeadingEdge);
+      buf.putFloat(__HorizontalToTrailingEdge);
+      buf.putFloat(__HorizontalToCenter);
+      buf.putFloat(__WidthCenter);
+      buf.putFloat(__SlantRangeToCenter);
+
+   }
+   
+   void SensorFootprint::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __FootprintResponseID = buf.getLong();
+      __VehicleID = buf.getLong();
+      __CameraID = buf.getLong();
+      __GimbalID = buf.getLong();
+      __HorizontalFOV = buf.getFloat();
+      __AglAltitude = buf.getFloat();
+      __GimbalElevation = buf.getFloat();
+      __AspectRatio = buf.getFloat();
+      __AchievedGSD = buf.getFloat();
+      __CameraWavelength = (afrl::cmasi::WavelengthBand::WavelengthBand) buf.getInt();
+      __HorizontalToLeadingEdge = buf.getFloat();
+      __HorizontalToTrailingEdge = buf.getFloat();
+      __HorizontalToCenter = buf.getFloat();
+      __WidthCenter = buf.getFloat();
+      __SlantRangeToCenter = buf.getFloat();
+
+   }
+
+   uint32_t SensorFootprint::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(afrl::cmasi::WavelengthBand::WavelengthBand);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string SensorFootprint::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( SensorFootprint ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "FootprintResponseID (int64_t) = " << __FootprintResponseID << "\n";
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "CameraID (int64_t) = " << __CameraID << "\n";
+      oss << indent << "GimbalID (int64_t) = " << __GimbalID << "\n";
+      oss << indent << "HorizontalFOV (float) = " << __HorizontalFOV << "\n";
+      oss << indent << "AglAltitude (float) = " << __AglAltitude << "\n";
+      oss << indent << "GimbalElevation (float) = " << __GimbalElevation << "\n";
+      oss << indent << "AspectRatio (float) = " << __AspectRatio << "\n";
+      oss << indent << "AchievedGSD (float) = " << __AchievedGSD << "\n";
+      oss << indent << "CameraWavelength (WavelengthBand) = " << __CameraWavelength << "\n";
+      oss << indent << "HorizontalToLeadingEdge (float) = " << __HorizontalToLeadingEdge << "\n";
+      oss << indent << "HorizontalToTrailingEdge (float) = " << __HorizontalToTrailingEdge << "\n";
+      oss << indent << "HorizontalToCenter (float) = " << __HorizontalToCenter << "\n";
+      oss << indent << "WidthCenter (float) = " << __WidthCenter << "\n";
+      oss << indent << "SlantRangeToCenter (float) = " << __SlantRangeToCenter << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string SensorFootprint::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<SensorFootprint Series=\"UXTASK\">\n";
+      str << ws << "   <FootprintResponseID>" << __FootprintResponseID << "</FootprintResponseID>\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <CameraID>" << __CameraID << "</CameraID>\n";
+      str << ws << "   <GimbalID>" << __GimbalID << "</GimbalID>\n";
+      str << ws << "   <HorizontalFOV>" << __HorizontalFOV << "</HorizontalFOV>\n";
+      str << ws << "   <AglAltitude>" << __AglAltitude << "</AglAltitude>\n";
+      str << ws << "   <GimbalElevation>" << __GimbalElevation << "</GimbalElevation>\n";
+      str << ws << "   <AspectRatio>" << __AspectRatio << "</AspectRatio>\n";
+      str << ws << "   <AchievedGSD>" << __AchievedGSD << "</AchievedGSD>\n";
+      str << ws << "   <CameraWavelength>" << afrl::cmasi::WavelengthBand::get_string(__CameraWavelength) << "</CameraWavelength>\n";
+      str << ws << "   <HorizontalToLeadingEdge>" << __HorizontalToLeadingEdge << "</HorizontalToLeadingEdge>\n";
+      str << ws << "   <HorizontalToTrailingEdge>" << __HorizontalToTrailingEdge << "</HorizontalToTrailingEdge>\n";
+      str << ws << "   <HorizontalToCenter>" << __HorizontalToCenter << "</HorizontalToCenter>\n";
+      str << ws << "   <WidthCenter>" << __WidthCenter << "</WidthCenter>\n";
+      str << ws << "   <SlantRangeToCenter>" << __SlantRangeToCenter << "</SlantRangeToCenter>\n";
+      str << ws << "</SensorFootprint>\n";
+
+      return str.str();
+   }
+
+   bool SensorFootprint::operator==(const SensorFootprint & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__FootprintResponseID != that.__FootprintResponseID) return false;
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__CameraID != that.__CameraID) return false;
+      if(__GimbalID != that.__GimbalID) return false;
+      if(__HorizontalFOV != that.__HorizontalFOV) return false;
+      if(__AglAltitude != that.__AglAltitude) return false;
+      if(__GimbalElevation != that.__GimbalElevation) return false;
+      if(__AspectRatio != that.__AspectRatio) return false;
+      if(__AchievedGSD != that.__AchievedGSD) return false;
+      if(__CameraWavelength != that.__CameraWavelength) return false;
+      if(__HorizontalToLeadingEdge != that.__HorizontalToLeadingEdge) return false;
+      if(__HorizontalToTrailingEdge != that.__HorizontalToTrailingEdge) return false;
+      if(__HorizontalToCenter != that.__HorizontalToCenter) return false;
+      if(__WidthCenter != that.__WidthCenter) return false;
+      if(__SlantRangeToCenter != that.__SlantRangeToCenter) return false;
+      return true;
+
+   }
+
+   bool SensorFootprint::operator!=(const SensorFootprint & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   SensorFootprint& SensorFootprint::setFootprintResponseID(const int64_t val)
+   {
+      __FootprintResponseID = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setCameraID(const int64_t val)
+   {
+      __CameraID = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setGimbalID(const int64_t val)
+   {
+      __GimbalID = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setHorizontalFOV(const float val)
+   {
+      __HorizontalFOV = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setAglAltitude(const float val)
+   {
+      __AglAltitude = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setGimbalElevation(const float val)
+   {
+      __GimbalElevation = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setAspectRatio(const float val)
+   {
+      __AspectRatio = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setAchievedGSD(const float val)
+   {
+      __AchievedGSD = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setCameraWavelength(const afrl::cmasi::WavelengthBand::WavelengthBand val)
+   {
+      __CameraWavelength = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setHorizontalToLeadingEdge(const float val)
+   {
+      __HorizontalToLeadingEdge = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setHorizontalToTrailingEdge(const float val)
+   {
+      __HorizontalToTrailingEdge = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setHorizontalToCenter(const float val)
+   {
+      __HorizontalToCenter = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setWidthCenter(const float val)
+   {
+      __WidthCenter = val;
+      return *this;
+   }
+
+   SensorFootprint& SensorFootprint::setSlantRangeToCenter(const float val)
+   {
+      __SlantRangeToCenter = val;
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskSensorFootprintRequests.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskSensorFootprintRequests.cpp
new file mode 100644
index 0000000..97322eb
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskSensorFootprintRequests.cpp
@@ -0,0 +1,236 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/SensorFootprintRequests.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string SensorFootprintRequests::Subscription = "uxas.messages.task.SensorFootprintRequests";
+   const std::string SensorFootprintRequests::TypeName = "SensorFootprintRequests";
+   
+   bool isSensorFootprintRequests(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 9) return false;
+      return true;
+   }
+   
+   bool isSensorFootprintRequests(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 9) return false;
+      return true;
+   }
+   
+   std::vector< std::string > SensorFootprintRequestsDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   SensorFootprintRequests::SensorFootprintRequests(void) : avtas::lmcp::Object()
+   {
+      __RequestID = 0LL;
+
+   }
+     
+   SensorFootprintRequests::SensorFootprintRequests(const SensorFootprintRequests &that) : avtas::lmcp::Object(that)
+   {
+        __RequestID = that.__RequestID;
+        __Footprints.clear();
+        for (size_t i=0; i< that.__Footprints.size(); i++)
+        {
+           __Footprints.push_back( that.__Footprints[i] == nullptr ? nullptr : that.__Footprints[i]->clone());
+        }
+
+   }
+   
+   SensorFootprintRequests & SensorFootprintRequests::operator=(const SensorFootprintRequests &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Footprints.size(); i++)
+         {
+            if (__Footprints[i] != nullptr) delete __Footprints[i];
+         }
+
+         __RequestID = that.__RequestID;
+         __Footprints.clear();
+         for (size_t i=0; i< that.__Footprints.size(); i++)
+         {
+            __Footprints.push_back( that.__Footprints[i] == nullptr ? nullptr : that.__Footprints[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   SensorFootprintRequests* SensorFootprintRequests::clone() const
+   {
+        return new SensorFootprintRequests(*this);
+   }
+   
+   SensorFootprintRequests::~SensorFootprintRequests(void)
+   {
+      for (size_t i=0; i<__Footprints.size(); i++)
+      {
+         if (__Footprints[i] != nullptr) delete __Footprints[i];
+      }
+
+   }
+  
+   void SensorFootprintRequests::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RequestID);
+      buf.putUShort( static_cast<uint16_t>(__Footprints.size()));
+      for (size_t i=0; i<__Footprints.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Footprints[i], buf);
+      }
+
+   }
+   
+   void SensorFootprintRequests::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RequestID = buf.getLong();
+      for (size_t i=0; i<__Footprints.size(); i++)
+      {
+         if (__Footprints[i] != nullptr)
+            delete __Footprints[i];
+      }
+      __Footprints.clear();
+      uint16_t __Footprints_length = buf.getUShort();
+      for (uint32_t i=0; i< __Footprints_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::task::FootprintRequest* e = (uxas::messages::task::FootprintRequest*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Footprints.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t SensorFootprintRequests::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__Footprints.size(); i++)
+      {
+         if (__Footprints[i] != nullptr)
+         {
+            size += __Footprints[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string SensorFootprintRequests::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( SensorFootprintRequests ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RequestID (int64_t) = " << __RequestID << "\n";
+      oss << indent << "Footprints (FootprintRequest [ " << __Footprints.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string SensorFootprintRequests::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<SensorFootprintRequests Series=\"UXTASK\">\n";
+      str << ws << "   <RequestID>" << __RequestID << "</RequestID>\n";
+      str << ws << "   <Footprints>\n";
+      for (size_t i=0; i<__Footprints.size(); i++)
+      {
+         str << (__Footprints[i] == nullptr ? ( ws + "   <null/>\n") : (__Footprints[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Footprints>\n";
+      str << ws << "</SensorFootprintRequests>\n";
+
+      return str.str();
+   }
+
+   bool SensorFootprintRequests::operator==(const SensorFootprintRequests & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RequestID != that.__RequestID) return false;
+      if(__Footprints.size() != that.__Footprints.size()) return false;
+      for (size_t i=0; i<__Footprints.size(); i++)
+      {
+         if(__Footprints[i] && that.__Footprints[i])
+         {
+            if(__Footprints[i]->getSeriesNameAsLong() != that.__Footprints[i]->getSeriesNameAsLong()) return false;
+            if(__Footprints[i]->getSeriesVersion() != that.__Footprints[i]->getSeriesVersion()) return false;
+            if(__Footprints[i]->getLmcpType() != that.__Footprints[i]->getLmcpType()) return false;
+            if( *(__Footprints[i]) != *(that.__Footprints[i]) ) return false;
+         }
+         else if(__Footprints[i] != that.__Footprints[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool SensorFootprintRequests::operator!=(const SensorFootprintRequests & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   SensorFootprintRequests& SensorFootprintRequests::setRequestID(const int64_t val)
+   {
+      __RequestID = val;
+      return *this;
+   }
+
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskSensorFootprintResponse.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskSensorFootprintResponse.cpp
new file mode 100644
index 0000000..c83425f
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskSensorFootprintResponse.cpp
@@ -0,0 +1,236 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/SensorFootprintResponse.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string SensorFootprintResponse::Subscription = "uxas.messages.task.SensorFootprintResponse";
+   const std::string SensorFootprintResponse::TypeName = "SensorFootprintResponse";
+   
+   bool isSensorFootprintResponse(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 12) return false;
+      return true;
+   }
+   
+   bool isSensorFootprintResponse(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 12) return false;
+      return true;
+   }
+   
+   std::vector< std::string > SensorFootprintResponseDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   SensorFootprintResponse::SensorFootprintResponse(void) : avtas::lmcp::Object()
+   {
+      __ResponseID = 0LL;
+
+   }
+     
+   SensorFootprintResponse::SensorFootprintResponse(const SensorFootprintResponse &that) : avtas::lmcp::Object(that)
+   {
+        __ResponseID = that.__ResponseID;
+        __Footprints.clear();
+        for (size_t i=0; i< that.__Footprints.size(); i++)
+        {
+           __Footprints.push_back( that.__Footprints[i] == nullptr ? nullptr : that.__Footprints[i]->clone());
+        }
+
+   }
+   
+   SensorFootprintResponse & SensorFootprintResponse::operator=(const SensorFootprintResponse &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Footprints.size(); i++)
+         {
+            if (__Footprints[i] != nullptr) delete __Footprints[i];
+         }
+
+         __ResponseID = that.__ResponseID;
+         __Footprints.clear();
+         for (size_t i=0; i< that.__Footprints.size(); i++)
+         {
+            __Footprints.push_back( that.__Footprints[i] == nullptr ? nullptr : that.__Footprints[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   SensorFootprintResponse* SensorFootprintResponse::clone() const
+   {
+        return new SensorFootprintResponse(*this);
+   }
+   
+   SensorFootprintResponse::~SensorFootprintResponse(void)
+   {
+      for (size_t i=0; i<__Footprints.size(); i++)
+      {
+         if (__Footprints[i] != nullptr) delete __Footprints[i];
+      }
+
+   }
+  
+   void SensorFootprintResponse::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ResponseID);
+      buf.putUShort( static_cast<uint16_t>(__Footprints.size()));
+      for (size_t i=0; i<__Footprints.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Footprints[i], buf);
+      }
+
+   }
+   
+   void SensorFootprintResponse::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ResponseID = buf.getLong();
+      for (size_t i=0; i<__Footprints.size(); i++)
+      {
+         if (__Footprints[i] != nullptr)
+            delete __Footprints[i];
+      }
+      __Footprints.clear();
+      uint16_t __Footprints_length = buf.getUShort();
+      for (uint32_t i=0; i< __Footprints_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::task::SensorFootprint* e = (uxas::messages::task::SensorFootprint*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Footprints.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t SensorFootprintResponse::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__Footprints.size(); i++)
+      {
+         if (__Footprints[i] != nullptr)
+         {
+            size += __Footprints[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string SensorFootprintResponse::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( SensorFootprintResponse ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ResponseID (int64_t) = " << __ResponseID << "\n";
+      oss << indent << "Footprints (SensorFootprint [ " << __Footprints.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string SensorFootprintResponse::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<SensorFootprintResponse Series=\"UXTASK\">\n";
+      str << ws << "   <ResponseID>" << __ResponseID << "</ResponseID>\n";
+      str << ws << "   <Footprints>\n";
+      for (size_t i=0; i<__Footprints.size(); i++)
+      {
+         str << (__Footprints[i] == nullptr ? ( ws + "   <null/>\n") : (__Footprints[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Footprints>\n";
+      str << ws << "</SensorFootprintResponse>\n";
+
+      return str.str();
+   }
+
+   bool SensorFootprintResponse::operator==(const SensorFootprintResponse & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ResponseID != that.__ResponseID) return false;
+      if(__Footprints.size() != that.__Footprints.size()) return false;
+      for (size_t i=0; i<__Footprints.size(); i++)
+      {
+         if(__Footprints[i] && that.__Footprints[i])
+         {
+            if(__Footprints[i]->getSeriesNameAsLong() != that.__Footprints[i]->getSeriesNameAsLong()) return false;
+            if(__Footprints[i]->getSeriesVersion() != that.__Footprints[i]->getSeriesVersion()) return false;
+            if(__Footprints[i]->getLmcpType() != that.__Footprints[i]->getLmcpType()) return false;
+            if( *(__Footprints[i]) != *(that.__Footprints[i]) ) return false;
+         }
+         else if(__Footprints[i] != that.__Footprints[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool SensorFootprintResponse::operator!=(const SensorFootprintResponse & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   SensorFootprintResponse& SensorFootprintResponse::setResponseID(const int64_t val)
+   {
+      __ResponseID = val;
+      return *this;
+   }
+
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskActive.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskActive.cpp
new file mode 100644
index 0000000..3747185
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskActive.cpp
@@ -0,0 +1,195 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskActive.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskActive::Subscription = "uxas.messages.task.TaskActive";
+   const std::string TaskActive::TypeName = "TaskActive";
+   
+   bool isTaskActive(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 26) return false;
+      return true;
+   }
+   
+   bool isTaskActive(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 26) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskActiveDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskActive::TaskActive(void) : avtas::lmcp::Object()
+   {
+      __TaskID = 0LL;
+      __EntityID = 0LL;
+      __TimeTaskActivated = 0LL;
+
+   }
+     
+   TaskActive::TaskActive(const TaskActive &that) : avtas::lmcp::Object(that)
+   {
+        __TaskID = that.__TaskID;
+        __EntityID = that.__EntityID;
+        __TimeTaskActivated = that.__TimeTaskActivated;
+
+   }
+   
+   TaskActive & TaskActive::operator=(const TaskActive &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __TaskID = that.__TaskID;
+         __EntityID = that.__EntityID;
+         __TimeTaskActivated = that.__TimeTaskActivated;
+
+      }
+      return *this;
+   }
+
+   TaskActive* TaskActive::clone() const
+   {
+        return new TaskActive(*this);
+   }
+   
+   TaskActive::~TaskActive(void)
+   {
+
+   }
+  
+   void TaskActive::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__TaskID);
+      buf.putLong(__EntityID);
+      buf.putLong(__TimeTaskActivated);
+
+   }
+   
+   void TaskActive::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __TaskID = buf.getLong();
+      __EntityID = buf.getLong();
+      __TimeTaskActivated = buf.getLong();
+
+   }
+
+   uint32_t TaskActive::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string TaskActive::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskActive ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "EntityID (int64_t) = " << __EntityID << "\n";
+      oss << indent << "TimeTaskActivated (int64_t) = " << __TimeTaskActivated << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskActive::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskActive Series=\"UXTASK\">\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <EntityID>" << __EntityID << "</EntityID>\n";
+      str << ws << "   <TimeTaskActivated>" << __TimeTaskActivated << "</TimeTaskActivated>\n";
+      str << ws << "</TaskActive>\n";
+
+      return str.str();
+   }
+
+   bool TaskActive::operator==(const TaskActive & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__TaskID != that.__TaskID) return false;
+      if(__EntityID != that.__EntityID) return false;
+      if(__TimeTaskActivated != that.__TimeTaskActivated) return false;
+      return true;
+
+   }
+
+   bool TaskActive::operator!=(const TaskActive & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskActive& TaskActive::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+   TaskActive& TaskActive::setEntityID(const int64_t val)
+   {
+      __EntityID = val;
+      return *this;
+   }
+
+   TaskActive& TaskActive::setTimeTaskActivated(const int64_t val)
+   {
+      __TimeTaskActivated = val;
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskAssignment.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskAssignment.cpp
new file mode 100644
index 0000000..89ede12
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskAssignment.cpp
@@ -0,0 +1,225 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskAssignment.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskAssignment::Subscription = "uxas.messages.task.TaskAssignment";
+   const std::string TaskAssignment::TypeName = "TaskAssignment";
+   
+   bool isTaskAssignment(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 17) return false;
+      return true;
+   }
+   
+   bool isTaskAssignment(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 17) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskAssignmentDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskAssignment::TaskAssignment(void) : avtas::lmcp::Object()
+   {
+      __TaskID = 0LL;
+      __OptionID = 0LL;
+      __AssignedVehicle = 0LL;
+      __TimeThreshold = 0LL;
+      __TimeTaskCompleted = 0LL;
+
+   }
+     
+   TaskAssignment::TaskAssignment(const TaskAssignment &that) : avtas::lmcp::Object(that)
+   {
+        __TaskID = that.__TaskID;
+        __OptionID = that.__OptionID;
+        __AssignedVehicle = that.__AssignedVehicle;
+        __TimeThreshold = that.__TimeThreshold;
+        __TimeTaskCompleted = that.__TimeTaskCompleted;
+
+   }
+   
+   TaskAssignment & TaskAssignment::operator=(const TaskAssignment &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __TaskID = that.__TaskID;
+         __OptionID = that.__OptionID;
+         __AssignedVehicle = that.__AssignedVehicle;
+         __TimeThreshold = that.__TimeThreshold;
+         __TimeTaskCompleted = that.__TimeTaskCompleted;
+
+      }
+      return *this;
+   }
+
+   TaskAssignment* TaskAssignment::clone() const
+   {
+        return new TaskAssignment(*this);
+   }
+   
+   TaskAssignment::~TaskAssignment(void)
+   {
+
+   }
+  
+   void TaskAssignment::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__TaskID);
+      buf.putLong(__OptionID);
+      buf.putLong(__AssignedVehicle);
+      buf.putLong(__TimeThreshold);
+      buf.putLong(__TimeTaskCompleted);
+
+   }
+   
+   void TaskAssignment::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __TaskID = buf.getLong();
+      __OptionID = buf.getLong();
+      __AssignedVehicle = buf.getLong();
+      __TimeThreshold = buf.getLong();
+      __TimeTaskCompleted = buf.getLong();
+
+   }
+
+   uint32_t TaskAssignment::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string TaskAssignment::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskAssignment ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "OptionID (int64_t) = " << __OptionID << "\n";
+      oss << indent << "AssignedVehicle (int64_t) = " << __AssignedVehicle << "\n";
+      oss << indent << "TimeThreshold (int64_t) = " << __TimeThreshold << "\n";
+      oss << indent << "TimeTaskCompleted (int64_t) = " << __TimeTaskCompleted << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskAssignment::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskAssignment Series=\"UXTASK\">\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <OptionID>" << __OptionID << "</OptionID>\n";
+      str << ws << "   <AssignedVehicle>" << __AssignedVehicle << "</AssignedVehicle>\n";
+      str << ws << "   <TimeThreshold>" << __TimeThreshold << "</TimeThreshold>\n";
+      str << ws << "   <TimeTaskCompleted>" << __TimeTaskCompleted << "</TimeTaskCompleted>\n";
+      str << ws << "</TaskAssignment>\n";
+
+      return str.str();
+   }
+
+   bool TaskAssignment::operator==(const TaskAssignment & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__TaskID != that.__TaskID) return false;
+      if(__OptionID != that.__OptionID) return false;
+      if(__AssignedVehicle != that.__AssignedVehicle) return false;
+      if(__TimeThreshold != that.__TimeThreshold) return false;
+      if(__TimeTaskCompleted != that.__TimeTaskCompleted) return false;
+      return true;
+
+   }
+
+   bool TaskAssignment::operator!=(const TaskAssignment & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskAssignment& TaskAssignment::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+   TaskAssignment& TaskAssignment::setOptionID(const int64_t val)
+   {
+      __OptionID = val;
+      return *this;
+   }
+
+   TaskAssignment& TaskAssignment::setAssignedVehicle(const int64_t val)
+   {
+      __AssignedVehicle = val;
+      return *this;
+   }
+
+   TaskAssignment& TaskAssignment::setTimeThreshold(const int64_t val)
+   {
+      __TimeThreshold = val;
+      return *this;
+   }
+
+   TaskAssignment& TaskAssignment::setTimeTaskCompleted(const int64_t val)
+   {
+      __TimeTaskCompleted = val;
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskAssignmentSummary.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskAssignmentSummary.cpp
new file mode 100644
index 0000000..7ed82e8
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskAssignmentSummary.cpp
@@ -0,0 +1,251 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskAssignmentSummary.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskAssignmentSummary::Subscription = "uxas.messages.task.TaskAssignmentSummary";
+   const std::string TaskAssignmentSummary::TypeName = "TaskAssignmentSummary";
+   
+   bool isTaskAssignmentSummary(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 18) return false;
+      return true;
+   }
+   
+   bool isTaskAssignmentSummary(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 18) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskAssignmentSummaryDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskAssignmentSummary::TaskAssignmentSummary(void) : avtas::lmcp::Object()
+   {
+      __CorrespondingAutomationRequestID = 0LL;
+      __OperatingRegion = 0LL;
+
+   }
+     
+   TaskAssignmentSummary::TaskAssignmentSummary(const TaskAssignmentSummary &that) : avtas::lmcp::Object(that)
+   {
+        __CorrespondingAutomationRequestID = that.__CorrespondingAutomationRequestID;
+        __OperatingRegion = that.__OperatingRegion;
+        __TaskList.clear();
+        for (size_t i=0; i< that.__TaskList.size(); i++)
+        {
+           __TaskList.push_back( that.__TaskList[i] == nullptr ? nullptr : that.__TaskList[i]->clone());
+        }
+
+   }
+   
+   TaskAssignmentSummary & TaskAssignmentSummary::operator=(const TaskAssignmentSummary &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__TaskList.size(); i++)
+         {
+            if (__TaskList[i] != nullptr) delete __TaskList[i];
+         }
+
+         __CorrespondingAutomationRequestID = that.__CorrespondingAutomationRequestID;
+         __OperatingRegion = that.__OperatingRegion;
+         __TaskList.clear();
+         for (size_t i=0; i< that.__TaskList.size(); i++)
+         {
+            __TaskList.push_back( that.__TaskList[i] == nullptr ? nullptr : that.__TaskList[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   TaskAssignmentSummary* TaskAssignmentSummary::clone() const
+   {
+        return new TaskAssignmentSummary(*this);
+   }
+   
+   TaskAssignmentSummary::~TaskAssignmentSummary(void)
+   {
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         if (__TaskList[i] != nullptr) delete __TaskList[i];
+      }
+
+   }
+  
+   void TaskAssignmentSummary::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__CorrespondingAutomationRequestID);
+      buf.putLong(__OperatingRegion);
+      buf.putUShort( static_cast<uint16_t>(__TaskList.size()));
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __TaskList[i], buf);
+      }
+
+   }
+   
+   void TaskAssignmentSummary::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __CorrespondingAutomationRequestID = buf.getLong();
+      __OperatingRegion = buf.getLong();
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         if (__TaskList[i] != nullptr)
+            delete __TaskList[i];
+      }
+      __TaskList.clear();
+      uint16_t __TaskList_length = buf.getUShort();
+      for (uint32_t i=0; i< __TaskList_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::task::TaskAssignment* e = (uxas::messages::task::TaskAssignment*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __TaskList.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t TaskAssignmentSummary::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         if (__TaskList[i] != nullptr)
+         {
+            size += __TaskList[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string TaskAssignmentSummary::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskAssignmentSummary ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "CorrespondingAutomationRequestID (int64_t) = " << __CorrespondingAutomationRequestID << "\n";
+      oss << indent << "OperatingRegion (int64_t) = " << __OperatingRegion << "\n";
+      oss << indent << "TaskList (TaskAssignment [ " << __TaskList.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskAssignmentSummary::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskAssignmentSummary Series=\"UXTASK\">\n";
+      str << ws << "   <CorrespondingAutomationRequestID>" << __CorrespondingAutomationRequestID << "</CorrespondingAutomationRequestID>\n";
+      str << ws << "   <OperatingRegion>" << __OperatingRegion << "</OperatingRegion>\n";
+      str << ws << "   <TaskList>\n";
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         str << (__TaskList[i] == nullptr ? ( ws + "   <null/>\n") : (__TaskList[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </TaskList>\n";
+      str << ws << "</TaskAssignmentSummary>\n";
+
+      return str.str();
+   }
+
+   bool TaskAssignmentSummary::operator==(const TaskAssignmentSummary & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__CorrespondingAutomationRequestID != that.__CorrespondingAutomationRequestID) return false;
+      if(__OperatingRegion != that.__OperatingRegion) return false;
+      if(__TaskList.size() != that.__TaskList.size()) return false;
+      for (size_t i=0; i<__TaskList.size(); i++)
+      {
+         if(__TaskList[i] && that.__TaskList[i])
+         {
+            if(__TaskList[i]->getSeriesNameAsLong() != that.__TaskList[i]->getSeriesNameAsLong()) return false;
+            if(__TaskList[i]->getSeriesVersion() != that.__TaskList[i]->getSeriesVersion()) return false;
+            if(__TaskList[i]->getLmcpType() != that.__TaskList[i]->getLmcpType()) return false;
+            if( *(__TaskList[i]) != *(that.__TaskList[i]) ) return false;
+         }
+         else if(__TaskList[i] != that.__TaskList[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool TaskAssignmentSummary::operator!=(const TaskAssignmentSummary & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskAssignmentSummary& TaskAssignmentSummary::setCorrespondingAutomationRequestID(const int64_t val)
+   {
+      __CorrespondingAutomationRequestID = val;
+      return *this;
+   }
+
+   TaskAssignmentSummary& TaskAssignmentSummary::setOperatingRegion(const int64_t val)
+   {
+      __OperatingRegion = val;
+      return *this;
+   }
+
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskAutomationRequest.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskAutomationRequest.cpp
new file mode 100644
index 0000000..cfc4d5a
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskAutomationRequest.cpp
@@ -0,0 +1,295 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskAutomationRequest.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskAutomationRequest::Subscription = "uxas.messages.task.TaskAutomationRequest";
+   const std::string TaskAutomationRequest::TypeName = "TaskAutomationRequest";
+   
+   bool isTaskAutomationRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 5) return false;
+      return true;
+   }
+   
+   bool isTaskAutomationRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 5) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskAutomationRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskAutomationRequest::TaskAutomationRequest(void) : avtas::lmcp::Object()
+   {
+      __RequestID = 0LL;
+      __OriginalRequest = new afrl::cmasi::AutomationRequest();
+      __SandBoxRequest = false;
+
+   }
+     
+   TaskAutomationRequest::TaskAutomationRequest(const TaskAutomationRequest &that) : avtas::lmcp::Object(that)
+   {
+        __RequestID = that.__RequestID;
+        __OriginalRequest = that.__OriginalRequest == nullptr ? nullptr : that.__OriginalRequest->clone();
+        __SandBoxRequest = that.__SandBoxRequest;
+        __PlanningStates.clear();
+        for (size_t i=0; i< that.__PlanningStates.size(); i++)
+        {
+           __PlanningStates.push_back( that.__PlanningStates[i] == nullptr ? nullptr : that.__PlanningStates[i]->clone());
+        }
+
+   }
+   
+   TaskAutomationRequest & TaskAutomationRequest::operator=(const TaskAutomationRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__OriginalRequest != nullptr) delete __OriginalRequest;
+         for (size_t i=0; i<__PlanningStates.size(); i++)
+         {
+            if (__PlanningStates[i] != nullptr) delete __PlanningStates[i];
+         }
+
+         __RequestID = that.__RequestID;
+         __OriginalRequest = that.__OriginalRequest == nullptr ? nullptr : that.__OriginalRequest->clone();
+         __SandBoxRequest = that.__SandBoxRequest;
+         __PlanningStates.clear();
+         for (size_t i=0; i< that.__PlanningStates.size(); i++)
+         {
+            __PlanningStates.push_back( that.__PlanningStates[i] == nullptr ? nullptr : that.__PlanningStates[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   TaskAutomationRequest* TaskAutomationRequest::clone() const
+   {
+        return new TaskAutomationRequest(*this);
+   }
+   
+   TaskAutomationRequest::~TaskAutomationRequest(void)
+   {
+      if (__OriginalRequest != nullptr) delete __OriginalRequest;
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         if (__PlanningStates[i] != nullptr) delete __PlanningStates[i];
+      }
+
+   }
+  
+   void TaskAutomationRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RequestID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __OriginalRequest, buf);
+      buf.putBool(__SandBoxRequest);
+      buf.putUShort( static_cast<uint16_t>(__PlanningStates.size()));
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __PlanningStates[i], buf);
+      }
+
+   }
+   
+   void TaskAutomationRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RequestID = buf.getLong();
+      {
+         if (__OriginalRequest != nullptr) delete __OriginalRequest;
+         __OriginalRequest = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __OriginalRequest = (afrl::cmasi::AutomationRequest*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__OriginalRequest != nullptr) __OriginalRequest->unpack(buf);
+         }
+      }
+      __SandBoxRequest = buf.getBool();
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         if (__PlanningStates[i] != nullptr)
+            delete __PlanningStates[i];
+      }
+      __PlanningStates.clear();
+      uint16_t __PlanningStates_length = buf.getUShort();
+      for (uint32_t i=0; i< __PlanningStates_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::task::PlanningState* e = (uxas::messages::task::PlanningState*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __PlanningStates.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t TaskAutomationRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__OriginalRequest != nullptr ? __OriginalRequest->calculatePackedSize() + 15 : 1);
+      size += sizeof(bool);
+      size += 2;
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         if (__PlanningStates[i] != nullptr)
+         {
+            size += __PlanningStates[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string TaskAutomationRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskAutomationRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RequestID (int64_t) = " << __RequestID << "\n";
+      oss << indent << "OriginalRequest (AutomationRequest)";
+      if (__OriginalRequest == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "SandBoxRequest (bool) = " << __SandBoxRequest << "\n";
+      oss << indent << "PlanningStates (PlanningState [ " << __PlanningStates.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskAutomationRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskAutomationRequest Series=\"UXTASK\">\n";
+      str << ws << "   <RequestID>" << __RequestID << "</RequestID>\n";
+      if (__OriginalRequest != nullptr)
+      {
+         str << ws << "   <OriginalRequest>";
+         str << "\n" + __OriginalRequest->toXML(depth + 1) + ws + "   ";
+         str << "</OriginalRequest>\n";
+      }
+      str << ws << "   <SandBoxRequest>" << (__SandBoxRequest ? "true" : "false") << "</SandBoxRequest>\n";
+      str << ws << "   <PlanningStates>\n";
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         str << (__PlanningStates[i] == nullptr ? ( ws + "   <null/>\n") : (__PlanningStates[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PlanningStates>\n";
+      str << ws << "</TaskAutomationRequest>\n";
+
+      return str.str();
+   }
+
+   bool TaskAutomationRequest::operator==(const TaskAutomationRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RequestID != that.__RequestID) return false;
+      if(__OriginalRequest && that.__OriginalRequest)
+      {
+         if(__OriginalRequest->getSeriesNameAsLong() != that.__OriginalRequest->getSeriesNameAsLong()) return false;
+         if(__OriginalRequest->getSeriesVersion() != that.__OriginalRequest->getSeriesVersion()) return false;
+         if(__OriginalRequest->getLmcpType() != that.__OriginalRequest->getLmcpType()) return false;
+         if( *(__OriginalRequest) != *(that.__OriginalRequest) ) return false;
+      }
+      else if(__OriginalRequest != that.__OriginalRequest) return false;
+      if(__SandBoxRequest != that.__SandBoxRequest) return false;
+      if(__PlanningStates.size() != that.__PlanningStates.size()) return false;
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         if(__PlanningStates[i] && that.__PlanningStates[i])
+         {
+            if(__PlanningStates[i]->getSeriesNameAsLong() != that.__PlanningStates[i]->getSeriesNameAsLong()) return false;
+            if(__PlanningStates[i]->getSeriesVersion() != that.__PlanningStates[i]->getSeriesVersion()) return false;
+            if(__PlanningStates[i]->getLmcpType() != that.__PlanningStates[i]->getLmcpType()) return false;
+            if( *(__PlanningStates[i]) != *(that.__PlanningStates[i]) ) return false;
+         }
+         else if(__PlanningStates[i] != that.__PlanningStates[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool TaskAutomationRequest::operator!=(const TaskAutomationRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskAutomationRequest& TaskAutomationRequest::setRequestID(const int64_t val)
+   {
+      __RequestID = val;
+      return *this;
+   }
+
+   TaskAutomationRequest& TaskAutomationRequest::setOriginalRequest(const afrl::cmasi::AutomationRequest* const val)
+   {
+      if (__OriginalRequest != nullptr) { delete __OriginalRequest; __OriginalRequest = nullptr; }
+      if (val != nullptr) { __OriginalRequest = const_cast< afrl::cmasi::AutomationRequest* > (val); }
+      return *this;
+   }
+
+   TaskAutomationRequest& TaskAutomationRequest::setSandBoxRequest(const bool val)
+   {
+      __SandBoxRequest = val;
+      return *this;
+   }
+
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskAutomationResponse.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskAutomationResponse.cpp
new file mode 100644
index 0000000..16cae25
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskAutomationResponse.cpp
@@ -0,0 +1,209 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskAutomationResponse.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskAutomationResponse::Subscription = "uxas.messages.task.TaskAutomationResponse";
+   const std::string TaskAutomationResponse::TypeName = "TaskAutomationResponse";
+   
+   bool isTaskAutomationResponse(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 6) return false;
+      return true;
+   }
+   
+   bool isTaskAutomationResponse(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 6) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskAutomationResponseDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskAutomationResponse::TaskAutomationResponse(void) : avtas::lmcp::Object()
+   {
+      __ResponseID = 0LL;
+      __OriginalResponse = new afrl::cmasi::AutomationResponse();
+
+   }
+     
+   TaskAutomationResponse::TaskAutomationResponse(const TaskAutomationResponse &that) : avtas::lmcp::Object(that)
+   {
+        __ResponseID = that.__ResponseID;
+        __OriginalResponse = that.__OriginalResponse == nullptr ? nullptr : that.__OriginalResponse->clone();
+
+   }
+   
+   TaskAutomationResponse & TaskAutomationResponse::operator=(const TaskAutomationResponse &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__OriginalResponse != nullptr) delete __OriginalResponse;
+
+         __ResponseID = that.__ResponseID;
+         __OriginalResponse = that.__OriginalResponse == nullptr ? nullptr : that.__OriginalResponse->clone();
+
+      }
+      return *this;
+   }
+
+   TaskAutomationResponse* TaskAutomationResponse::clone() const
+   {
+        return new TaskAutomationResponse(*this);
+   }
+   
+   TaskAutomationResponse::~TaskAutomationResponse(void)
+   {
+      if (__OriginalResponse != nullptr) delete __OriginalResponse;
+
+   }
+  
+   void TaskAutomationResponse::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ResponseID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __OriginalResponse, buf);
+
+   }
+   
+   void TaskAutomationResponse::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ResponseID = buf.getLong();
+      {
+         if (__OriginalResponse != nullptr) delete __OriginalResponse;
+         __OriginalResponse = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __OriginalResponse = (afrl::cmasi::AutomationResponse*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__OriginalResponse != nullptr) __OriginalResponse->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t TaskAutomationResponse::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__OriginalResponse != nullptr ? __OriginalResponse->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string TaskAutomationResponse::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskAutomationResponse ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ResponseID (int64_t) = " << __ResponseID << "\n";
+      oss << indent << "OriginalResponse (AutomationResponse)";
+      if (__OriginalResponse == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskAutomationResponse::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskAutomationResponse Series=\"UXTASK\">\n";
+      str << ws << "   <ResponseID>" << __ResponseID << "</ResponseID>\n";
+      if (__OriginalResponse != nullptr)
+      {
+         str << ws << "   <OriginalResponse>";
+         str << "\n" + __OriginalResponse->toXML(depth + 1) + ws + "   ";
+         str << "</OriginalResponse>\n";
+      }
+      str << ws << "</TaskAutomationResponse>\n";
+
+      return str.str();
+   }
+
+   bool TaskAutomationResponse::operator==(const TaskAutomationResponse & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ResponseID != that.__ResponseID) return false;
+      if(__OriginalResponse && that.__OriginalResponse)
+      {
+         if(__OriginalResponse->getSeriesNameAsLong() != that.__OriginalResponse->getSeriesNameAsLong()) return false;
+         if(__OriginalResponse->getSeriesVersion() != that.__OriginalResponse->getSeriesVersion()) return false;
+         if(__OriginalResponse->getLmcpType() != that.__OriginalResponse->getLmcpType()) return false;
+         if( *(__OriginalResponse) != *(that.__OriginalResponse) ) return false;
+      }
+      else if(__OriginalResponse != that.__OriginalResponse) return false;
+      return true;
+
+   }
+
+   bool TaskAutomationResponse::operator!=(const TaskAutomationResponse & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskAutomationResponse& TaskAutomationResponse::setResponseID(const int64_t val)
+   {
+      __ResponseID = val;
+      return *this;
+   }
+
+   TaskAutomationResponse& TaskAutomationResponse::setOriginalResponse(const afrl::cmasi::AutomationResponse* const val)
+   {
+      if (__OriginalResponse != nullptr) { delete __OriginalResponse; __OriginalResponse = nullptr; }
+      if (val != nullptr) { __OriginalResponse = const_cast< afrl::cmasi::AutomationResponse* > (val); }
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskComplete.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskComplete.cpp
new file mode 100644
index 0000000..d8ffe3f
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskComplete.cpp
@@ -0,0 +1,215 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskComplete.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskComplete::Subscription = "uxas.messages.task.TaskComplete";
+   const std::string TaskComplete::TypeName = "TaskComplete";
+   
+   bool isTaskComplete(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 27) return false;
+      return true;
+   }
+   
+   bool isTaskComplete(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 27) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskCompleteDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskComplete::TaskComplete(void) : avtas::lmcp::Object()
+   {
+      __TaskID = 0LL;
+      __TimeTaskCompleted = 0LL;
+
+   }
+     
+   TaskComplete::TaskComplete(const TaskComplete &that) : avtas::lmcp::Object(that)
+   {
+        __TaskID = that.__TaskID;
+        __EntitiesInvolved.clear();
+        for (size_t i=0; i< that.__EntitiesInvolved.size(); i++)
+        {
+           __EntitiesInvolved.push_back( that.__EntitiesInvolved[i]);
+        }
+        __TimeTaskCompleted = that.__TimeTaskCompleted;
+
+   }
+   
+   TaskComplete & TaskComplete::operator=(const TaskComplete &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __TaskID = that.__TaskID;
+         __EntitiesInvolved.clear();
+         for (size_t i=0; i< that.__EntitiesInvolved.size(); i++)
+         {
+            __EntitiesInvolved.push_back( that.__EntitiesInvolved[i]);
+         }
+         __TimeTaskCompleted = that.__TimeTaskCompleted;
+
+      }
+      return *this;
+   }
+
+   TaskComplete* TaskComplete::clone() const
+   {
+        return new TaskComplete(*this);
+   }
+   
+   TaskComplete::~TaskComplete(void)
+   {
+
+   }
+  
+   void TaskComplete::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__TaskID);
+      buf.putUShort( static_cast<uint16_t>(__EntitiesInvolved.size()));
+      for (size_t i=0; i<__EntitiesInvolved.size(); i++)
+      {
+         buf.putLong(__EntitiesInvolved[i]);
+      }
+      buf.putLong(__TimeTaskCompleted);
+
+   }
+   
+   void TaskComplete::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __TaskID = buf.getLong();
+      __EntitiesInvolved.clear();
+      uint16_t __EntitiesInvolved_length = buf.getUShort();
+      for (uint32_t i=0; i< __EntitiesInvolved_length; i++)
+      {
+         __EntitiesInvolved.push_back(buf.getLong() );
+      }
+      __TimeTaskCompleted = buf.getLong();
+
+   }
+
+   uint32_t TaskComplete::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2 + sizeof(int64_t) * __EntitiesInvolved.size();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string TaskComplete::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskComplete ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "EntitiesInvolved (int64 [ " << __EntitiesInvolved.size() << ", var ])\n";
+      oss << indent << "TimeTaskCompleted (int64_t) = " << __TimeTaskCompleted << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskComplete::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskComplete Series=\"UXTASK\">\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <EntitiesInvolved>\n";
+      for (size_t i=0; i<__EntitiesInvolved.size(); i++)
+      {
+         str << ws << "   <int64>" << __EntitiesInvolved[i] << "</int64>\n";
+      }
+      str << ws << "   </EntitiesInvolved>\n";
+      str << ws << "   <TimeTaskCompleted>" << __TimeTaskCompleted << "</TimeTaskCompleted>\n";
+      str << ws << "</TaskComplete>\n";
+
+      return str.str();
+   }
+
+   bool TaskComplete::operator==(const TaskComplete & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__TaskID != that.__TaskID) return false;
+      if(__EntitiesInvolved.size() != that.__EntitiesInvolved.size()) return false;
+      for (size_t i=0; i<__EntitiesInvolved.size(); i++)
+      {
+         if(__EntitiesInvolved[i] != that.__EntitiesInvolved[i]) return false;
+      }
+      if(__TimeTaskCompleted != that.__TimeTaskCompleted) return false;
+      return true;
+
+   }
+
+   bool TaskComplete::operator!=(const TaskComplete & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskComplete& TaskComplete::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+
+   TaskComplete& TaskComplete::setTimeTaskCompleted(const int64_t val)
+   {
+      __TimeTaskCompleted = val;
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskImplementationRequest.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskImplementationRequest.cpp
new file mode 100644
index 0000000..5d74671
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskImplementationRequest.cpp
@@ -0,0 +1,331 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskImplementationRequest.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskImplementationRequest::Subscription = "uxas.messages.task.TaskImplementationRequest";
+   const std::string TaskImplementationRequest::TypeName = "TaskImplementationRequest";
+   
+   bool isTaskImplementationRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 13) return false;
+      return true;
+   }
+   
+   bool isTaskImplementationRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 13) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskImplementationRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskImplementationRequest::TaskImplementationRequest(void) : avtas::lmcp::Object()
+   {
+      __RequestID = 0LL;
+      __StartingWaypointID = 0LL;
+      __VehicleID = 0LL;
+      __StartPosition = new afrl::cmasi::Location3D();
+      __StartHeading = 0.f;
+      __StartTime = 0LL;
+      __RegionID = 0LL;
+      __TaskID = 0LL;
+      __OptionID = 0LL;
+      __TimeThreshold = 0LL;
+
+   }
+     
+   TaskImplementationRequest::TaskImplementationRequest(const TaskImplementationRequest &that) : avtas::lmcp::Object(that)
+   {
+        __RequestID = that.__RequestID;
+        __StartingWaypointID = that.__StartingWaypointID;
+        __VehicleID = that.__VehicleID;
+        __StartPosition = that.__StartPosition == nullptr ? nullptr : that.__StartPosition->clone();
+        __StartHeading = that.__StartHeading;
+        __StartTime = that.__StartTime;
+        __RegionID = that.__RegionID;
+        __TaskID = that.__TaskID;
+        __OptionID = that.__OptionID;
+        __TimeThreshold = that.__TimeThreshold;
+
+   }
+   
+   TaskImplementationRequest & TaskImplementationRequest::operator=(const TaskImplementationRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__StartPosition != nullptr) delete __StartPosition;
+
+         __RequestID = that.__RequestID;
+         __StartingWaypointID = that.__StartingWaypointID;
+         __VehicleID = that.__VehicleID;
+         __StartPosition = that.__StartPosition == nullptr ? nullptr : that.__StartPosition->clone();
+         __StartHeading = that.__StartHeading;
+         __StartTime = that.__StartTime;
+         __RegionID = that.__RegionID;
+         __TaskID = that.__TaskID;
+         __OptionID = that.__OptionID;
+         __TimeThreshold = that.__TimeThreshold;
+
+      }
+      return *this;
+   }
+
+   TaskImplementationRequest* TaskImplementationRequest::clone() const
+   {
+        return new TaskImplementationRequest(*this);
+   }
+   
+   TaskImplementationRequest::~TaskImplementationRequest(void)
+   {
+      if (__StartPosition != nullptr) delete __StartPosition;
+
+   }
+  
+   void TaskImplementationRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RequestID);
+      buf.putLong(__StartingWaypointID);
+      buf.putLong(__VehicleID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __StartPosition, buf);
+      buf.putFloat(__StartHeading);
+      buf.putLong(__StartTime);
+      buf.putLong(__RegionID);
+      buf.putLong(__TaskID);
+      buf.putLong(__OptionID);
+      buf.putLong(__TimeThreshold);
+
+   }
+   
+   void TaskImplementationRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RequestID = buf.getLong();
+      __StartingWaypointID = buf.getLong();
+      __VehicleID = buf.getLong();
+      {
+         if (__StartPosition != nullptr) delete __StartPosition;
+         __StartPosition = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __StartPosition = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__StartPosition != nullptr) __StartPosition->unpack(buf);
+         }
+      }
+      __StartHeading = buf.getFloat();
+      __StartTime = buf.getLong();
+      __RegionID = buf.getLong();
+      __TaskID = buf.getLong();
+      __OptionID = buf.getLong();
+      __TimeThreshold = buf.getLong();
+
+   }
+
+   uint32_t TaskImplementationRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += (__StartPosition != nullptr ? __StartPosition->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string TaskImplementationRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskImplementationRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RequestID (int64_t) = " << __RequestID << "\n";
+      oss << indent << "StartingWaypointID (int64_t) = " << __StartingWaypointID << "\n";
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "StartPosition (Location3D)";
+      if (__StartPosition == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "StartHeading (float) = " << __StartHeading << "\n";
+      oss << indent << "StartTime (int64_t) = " << __StartTime << "\n";
+      oss << indent << "RegionID (int64_t) = " << __RegionID << "\n";
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "OptionID (int64_t) = " << __OptionID << "\n";
+      oss << indent << "TimeThreshold (int64_t) = " << __TimeThreshold << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskImplementationRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskImplementationRequest Series=\"UXTASK\">\n";
+      str << ws << "   <RequestID>" << __RequestID << "</RequestID>\n";
+      str << ws << "   <StartingWaypointID>" << __StartingWaypointID << "</StartingWaypointID>\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      if (__StartPosition != nullptr)
+      {
+         str << ws << "   <StartPosition>";
+         str << "\n" + __StartPosition->toXML(depth + 1) + ws + "   ";
+         str << "</StartPosition>\n";
+      }
+      str << ws << "   <StartHeading>" << __StartHeading << "</StartHeading>\n";
+      str << ws << "   <StartTime>" << __StartTime << "</StartTime>\n";
+      str << ws << "   <RegionID>" << __RegionID << "</RegionID>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <OptionID>" << __OptionID << "</OptionID>\n";
+      str << ws << "   <TimeThreshold>" << __TimeThreshold << "</TimeThreshold>\n";
+      str << ws << "</TaskImplementationRequest>\n";
+
+      return str.str();
+   }
+
+   bool TaskImplementationRequest::operator==(const TaskImplementationRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RequestID != that.__RequestID) return false;
+      if(__StartingWaypointID != that.__StartingWaypointID) return false;
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__StartPosition && that.__StartPosition)
+      {
+         if(__StartPosition->getSeriesNameAsLong() != that.__StartPosition->getSeriesNameAsLong()) return false;
+         if(__StartPosition->getSeriesVersion() != that.__StartPosition->getSeriesVersion()) return false;
+         if(__StartPosition->getLmcpType() != that.__StartPosition->getLmcpType()) return false;
+         if( *(__StartPosition) != *(that.__StartPosition) ) return false;
+      }
+      else if(__StartPosition != that.__StartPosition) return false;
+      if(__StartHeading != that.__StartHeading) return false;
+      if(__StartTime != that.__StartTime) return false;
+      if(__RegionID != that.__RegionID) return false;
+      if(__TaskID != that.__TaskID) return false;
+      if(__OptionID != that.__OptionID) return false;
+      if(__TimeThreshold != that.__TimeThreshold) return false;
+      return true;
+
+   }
+
+   bool TaskImplementationRequest::operator!=(const TaskImplementationRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskImplementationRequest& TaskImplementationRequest::setRequestID(const int64_t val)
+   {
+      __RequestID = val;
+      return *this;
+   }
+
+   TaskImplementationRequest& TaskImplementationRequest::setStartingWaypointID(const int64_t val)
+   {
+      __StartingWaypointID = val;
+      return *this;
+   }
+
+   TaskImplementationRequest& TaskImplementationRequest::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+   TaskImplementationRequest& TaskImplementationRequest::setStartPosition(const afrl::cmasi::Location3D* const val)
+   {
+      if (__StartPosition != nullptr) { delete __StartPosition; __StartPosition = nullptr; }
+      if (val != nullptr) { __StartPosition = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   TaskImplementationRequest& TaskImplementationRequest::setStartHeading(const float val)
+   {
+      __StartHeading = val;
+      return *this;
+   }
+
+   TaskImplementationRequest& TaskImplementationRequest::setStartTime(const int64_t val)
+   {
+      __StartTime = val;
+      return *this;
+   }
+
+   TaskImplementationRequest& TaskImplementationRequest::setRegionID(const int64_t val)
+   {
+      __RegionID = val;
+      return *this;
+   }
+
+   TaskImplementationRequest& TaskImplementationRequest::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+   TaskImplementationRequest& TaskImplementationRequest::setOptionID(const int64_t val)
+   {
+      __OptionID = val;
+      return *this;
+   }
+
+   TaskImplementationRequest& TaskImplementationRequest::setTimeThreshold(const int64_t val)
+   {
+      __TimeThreshold = val;
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskImplementationResponse.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskImplementationResponse.cpp
new file mode 100644
index 0000000..3f6165e
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskImplementationResponse.cpp
@@ -0,0 +1,358 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskImplementationResponse.h"
+#include "afrl/cmasi/PathWaypoint.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskImplementationResponse::Subscription = "uxas.messages.task.TaskImplementationResponse";
+   const std::string TaskImplementationResponse::TypeName = "TaskImplementationResponse";
+   
+   bool isTaskImplementationResponse(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 14) return false;
+      return true;
+   }
+   
+   bool isTaskImplementationResponse(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 14) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskImplementationResponseDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskImplementationResponse::TaskImplementationResponse(void) : avtas::lmcp::Object()
+   {
+      __ResponseID = 0LL;
+      __TaskID = 0LL;
+      __OptionID = 0LL;
+      __VehicleID = 0LL;
+      __FinalLocation = new afrl::cmasi::Location3D();
+      __FinalHeading = 0.f;
+      __FinalTime = 0LL;
+
+   }
+     
+   TaskImplementationResponse::TaskImplementationResponse(const TaskImplementationResponse &that) : avtas::lmcp::Object(that)
+   {
+        __ResponseID = that.__ResponseID;
+        __TaskID = that.__TaskID;
+        __OptionID = that.__OptionID;
+        __VehicleID = that.__VehicleID;
+        __TaskWaypoints.clear();
+        for (size_t i=0; i< that.__TaskWaypoints.size(); i++)
+        {
+           __TaskWaypoints.push_back( that.__TaskWaypoints[i] == nullptr ? nullptr : that.__TaskWaypoints[i]->clone());
+        }
+        __FinalLocation = that.__FinalLocation == nullptr ? nullptr : that.__FinalLocation->clone();
+        __FinalHeading = that.__FinalHeading;
+        __FinalTime = that.__FinalTime;
+
+   }
+   
+   TaskImplementationResponse & TaskImplementationResponse::operator=(const TaskImplementationResponse &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__TaskWaypoints.size(); i++)
+         {
+            if (__TaskWaypoints[i] != nullptr) delete __TaskWaypoints[i];
+         }
+         if (__FinalLocation != nullptr) delete __FinalLocation;
+
+         __ResponseID = that.__ResponseID;
+         __TaskID = that.__TaskID;
+         __OptionID = that.__OptionID;
+         __VehicleID = that.__VehicleID;
+         __TaskWaypoints.clear();
+         for (size_t i=0; i< that.__TaskWaypoints.size(); i++)
+         {
+            __TaskWaypoints.push_back( that.__TaskWaypoints[i] == nullptr ? nullptr : that.__TaskWaypoints[i]->clone());
+         }
+         __FinalLocation = that.__FinalLocation == nullptr ? nullptr : that.__FinalLocation->clone();
+         __FinalHeading = that.__FinalHeading;
+         __FinalTime = that.__FinalTime;
+
+      }
+      return *this;
+   }
+
+   TaskImplementationResponse* TaskImplementationResponse::clone() const
+   {
+        return new TaskImplementationResponse(*this);
+   }
+   
+   TaskImplementationResponse::~TaskImplementationResponse(void)
+   {
+      for (size_t i=0; i<__TaskWaypoints.size(); i++)
+      {
+         if (__TaskWaypoints[i] != nullptr) delete __TaskWaypoints[i];
+      }
+      if (__FinalLocation != nullptr) delete __FinalLocation;
+
+   }
+  
+   void TaskImplementationResponse::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ResponseID);
+      buf.putLong(__TaskID);
+      buf.putLong(__OptionID);
+      buf.putLong(__VehicleID);
+      buf.putUShort( static_cast<uint16_t>(__TaskWaypoints.size()));
+      for (size_t i=0; i<__TaskWaypoints.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __TaskWaypoints[i], buf);
+      }
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __FinalLocation, buf);
+      buf.putFloat(__FinalHeading);
+      buf.putLong(__FinalTime);
+
+   }
+   
+   void TaskImplementationResponse::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ResponseID = buf.getLong();
+      __TaskID = buf.getLong();
+      __OptionID = buf.getLong();
+      __VehicleID = buf.getLong();
+      for (size_t i=0; i<__TaskWaypoints.size(); i++)
+      {
+         if (__TaskWaypoints[i] != nullptr)
+            delete __TaskWaypoints[i];
+      }
+      __TaskWaypoints.clear();
+      uint16_t __TaskWaypoints_length = buf.getUShort();
+      for (uint32_t i=0; i< __TaskWaypoints_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Waypoint* e = (afrl::cmasi::Waypoint*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __TaskWaypoints.push_back(e);
+         }
+      }
+      {
+         if (__FinalLocation != nullptr) delete __FinalLocation;
+         __FinalLocation = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __FinalLocation = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__FinalLocation != nullptr) __FinalLocation->unpack(buf);
+         }
+      }
+      __FinalHeading = buf.getFloat();
+      __FinalTime = buf.getLong();
+
+   }
+
+   uint32_t TaskImplementationResponse::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__TaskWaypoints.size(); i++)
+      {
+         if (__TaskWaypoints[i] != nullptr)
+         {
+            size += __TaskWaypoints[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += (__FinalLocation != nullptr ? __FinalLocation->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string TaskImplementationResponse::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskImplementationResponse ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ResponseID (int64_t) = " << __ResponseID << "\n";
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "OptionID (int64_t) = " << __OptionID << "\n";
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "TaskWaypoints (Waypoint [ " << __TaskWaypoints.size() << ", var ])\n";
+      oss << indent << "FinalLocation (Location3D)";
+      if (__FinalLocation == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "FinalHeading (float) = " << __FinalHeading << "\n";
+      oss << indent << "FinalTime (int64_t) = " << __FinalTime << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskImplementationResponse::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskImplementationResponse Series=\"UXTASK\">\n";
+      str << ws << "   <ResponseID>" << __ResponseID << "</ResponseID>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <OptionID>" << __OptionID << "</OptionID>\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <TaskWaypoints>\n";
+      for (size_t i=0; i<__TaskWaypoints.size(); i++)
+      {
+         str << (__TaskWaypoints[i] == nullptr ? ( ws + "   <null/>\n") : (__TaskWaypoints[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </TaskWaypoints>\n";
+      if (__FinalLocation != nullptr)
+      {
+         str << ws << "   <FinalLocation>";
+         str << "\n" + __FinalLocation->toXML(depth + 1) + ws + "   ";
+         str << "</FinalLocation>\n";
+      }
+      str << ws << "   <FinalHeading>" << __FinalHeading << "</FinalHeading>\n";
+      str << ws << "   <FinalTime>" << __FinalTime << "</FinalTime>\n";
+      str << ws << "</TaskImplementationResponse>\n";
+
+      return str.str();
+   }
+
+   bool TaskImplementationResponse::operator==(const TaskImplementationResponse & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ResponseID != that.__ResponseID) return false;
+      if(__TaskID != that.__TaskID) return false;
+      if(__OptionID != that.__OptionID) return false;
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__TaskWaypoints.size() != that.__TaskWaypoints.size()) return false;
+      for (size_t i=0; i<__TaskWaypoints.size(); i++)
+      {
+         if(__TaskWaypoints[i] && that.__TaskWaypoints[i])
+         {
+            if(__TaskWaypoints[i]->getSeriesNameAsLong() != that.__TaskWaypoints[i]->getSeriesNameAsLong()) return false;
+            if(__TaskWaypoints[i]->getSeriesVersion() != that.__TaskWaypoints[i]->getSeriesVersion()) return false;
+            if(__TaskWaypoints[i]->getLmcpType() != that.__TaskWaypoints[i]->getLmcpType()) return false;
+            if( *(__TaskWaypoints[i]) != *(that.__TaskWaypoints[i]) ) return false;
+         }
+         else if(__TaskWaypoints[i] != that.__TaskWaypoints[i]) return false;
+      }
+      if(__FinalLocation && that.__FinalLocation)
+      {
+         if(__FinalLocation->getSeriesNameAsLong() != that.__FinalLocation->getSeriesNameAsLong()) return false;
+         if(__FinalLocation->getSeriesVersion() != that.__FinalLocation->getSeriesVersion()) return false;
+         if(__FinalLocation->getLmcpType() != that.__FinalLocation->getLmcpType()) return false;
+         if( *(__FinalLocation) != *(that.__FinalLocation) ) return false;
+      }
+      else if(__FinalLocation != that.__FinalLocation) return false;
+      if(__FinalHeading != that.__FinalHeading) return false;
+      if(__FinalTime != that.__FinalTime) return false;
+      return true;
+
+   }
+
+   bool TaskImplementationResponse::operator!=(const TaskImplementationResponse & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskImplementationResponse& TaskImplementationResponse::setResponseID(const int64_t val)
+   {
+      __ResponseID = val;
+      return *this;
+   }
+
+   TaskImplementationResponse& TaskImplementationResponse::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+   TaskImplementationResponse& TaskImplementationResponse::setOptionID(const int64_t val)
+   {
+      __OptionID = val;
+      return *this;
+   }
+
+   TaskImplementationResponse& TaskImplementationResponse::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+
+   TaskImplementationResponse& TaskImplementationResponse::setFinalLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__FinalLocation != nullptr) { delete __FinalLocation; __FinalLocation = nullptr; }
+      if (val != nullptr) { __FinalLocation = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   TaskImplementationResponse& TaskImplementationResponse::setFinalHeading(const float val)
+   {
+      __FinalHeading = val;
+      return *this;
+   }
+
+   TaskImplementationResponse& TaskImplementationResponse::setFinalTime(const int64_t val)
+   {
+      __FinalTime = val;
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskInitialized.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskInitialized.cpp
new file mode 100644
index 0000000..2cdcbfc
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskInitialized.cpp
@@ -0,0 +1,165 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskInitialized.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskInitialized::Subscription = "uxas.messages.task.TaskInitialized";
+   const std::string TaskInitialized::TypeName = "TaskInitialized";
+   
+   bool isTaskInitialized(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 25) return false;
+      return true;
+   }
+   
+   bool isTaskInitialized(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 25) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskInitializedDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskInitialized::TaskInitialized(void) : avtas::lmcp::Object()
+   {
+      __TaskID = 0LL;
+
+   }
+     
+   TaskInitialized::TaskInitialized(const TaskInitialized &that) : avtas::lmcp::Object(that)
+   {
+        __TaskID = that.__TaskID;
+
+   }
+   
+   TaskInitialized & TaskInitialized::operator=(const TaskInitialized &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __TaskID = that.__TaskID;
+
+      }
+      return *this;
+   }
+
+   TaskInitialized* TaskInitialized::clone() const
+   {
+        return new TaskInitialized(*this);
+   }
+   
+   TaskInitialized::~TaskInitialized(void)
+   {
+
+   }
+  
+   void TaskInitialized::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__TaskID);
+
+   }
+   
+   void TaskInitialized::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __TaskID = buf.getLong();
+
+   }
+
+   uint32_t TaskInitialized::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string TaskInitialized::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskInitialized ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskInitialized::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskInitialized Series=\"UXTASK\">\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "</TaskInitialized>\n";
+
+      return str.str();
+   }
+
+   bool TaskInitialized::operator==(const TaskInitialized & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__TaskID != that.__TaskID) return false;
+      return true;
+
+   }
+
+   bool TaskInitialized::operator!=(const TaskInitialized & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskInitialized& TaskInitialized::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskOption.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskOption.cpp
new file mode 100644
index 0000000..3b0f2c8
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskOption.cpp
@@ -0,0 +1,352 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskOption.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskOption::Subscription = "uxas.messages.task.TaskOption";
+   const std::string TaskOption::TypeName = "TaskOption";
+   
+   bool isTaskOption(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 19) return false;
+      return true;
+   }
+   
+   bool isTaskOption(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 19) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskOptionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskOption::TaskOption(void) : avtas::lmcp::Object()
+   {
+      __TaskID = 0LL;
+      __OptionID = 0LL;
+      __Cost = 0LL;
+      __StartLocation = new afrl::cmasi::Location3D();
+      __StartHeading = 0.f;
+      __EndLocation = new afrl::cmasi::Location3D();
+      __EndHeading = 0.f;
+
+   }
+     
+   TaskOption::TaskOption(const TaskOption &that) : avtas::lmcp::Object(that)
+   {
+        __TaskID = that.__TaskID;
+        __OptionID = that.__OptionID;
+        __EligibleEntities.clear();
+        for (size_t i=0; i< that.__EligibleEntities.size(); i++)
+        {
+           __EligibleEntities.push_back( that.__EligibleEntities[i]);
+        }
+        __Cost = that.__Cost;
+        __StartLocation = that.__StartLocation == nullptr ? nullptr : that.__StartLocation->clone();
+        __StartHeading = that.__StartHeading;
+        __EndLocation = that.__EndLocation == nullptr ? nullptr : that.__EndLocation->clone();
+        __EndHeading = that.__EndHeading;
+
+   }
+   
+   TaskOption & TaskOption::operator=(const TaskOption &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__StartLocation != nullptr) delete __StartLocation;
+         if (__EndLocation != nullptr) delete __EndLocation;
+
+         __TaskID = that.__TaskID;
+         __OptionID = that.__OptionID;
+         __EligibleEntities.clear();
+         for (size_t i=0; i< that.__EligibleEntities.size(); i++)
+         {
+            __EligibleEntities.push_back( that.__EligibleEntities[i]);
+         }
+         __Cost = that.__Cost;
+         __StartLocation = that.__StartLocation == nullptr ? nullptr : that.__StartLocation->clone();
+         __StartHeading = that.__StartHeading;
+         __EndLocation = that.__EndLocation == nullptr ? nullptr : that.__EndLocation->clone();
+         __EndHeading = that.__EndHeading;
+
+      }
+      return *this;
+   }
+
+   TaskOption* TaskOption::clone() const
+   {
+        return new TaskOption(*this);
+   }
+   
+   TaskOption::~TaskOption(void)
+   {
+      if (__StartLocation != nullptr) delete __StartLocation;
+      if (__EndLocation != nullptr) delete __EndLocation;
+
+   }
+  
+   void TaskOption::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__TaskID);
+      buf.putLong(__OptionID);
+      buf.putUShort( static_cast<uint16_t>(__EligibleEntities.size()));
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         buf.putLong(__EligibleEntities[i]);
+      }
+      buf.putLong(__Cost);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __StartLocation, buf);
+      buf.putFloat(__StartHeading);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __EndLocation, buf);
+      buf.putFloat(__EndHeading);
+
+   }
+   
+   void TaskOption::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __TaskID = buf.getLong();
+      __OptionID = buf.getLong();
+      __EligibleEntities.clear();
+      uint16_t __EligibleEntities_length = buf.getUShort();
+      for (uint32_t i=0; i< __EligibleEntities_length; i++)
+      {
+         __EligibleEntities.push_back(buf.getLong() );
+      }
+      __Cost = buf.getLong();
+      {
+         if (__StartLocation != nullptr) delete __StartLocation;
+         __StartLocation = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __StartLocation = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__StartLocation != nullptr) __StartLocation->unpack(buf);
+         }
+      }
+      __StartHeading = buf.getFloat();
+      {
+         if (__EndLocation != nullptr) delete __EndLocation;
+         __EndLocation = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __EndLocation = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__EndLocation != nullptr) __EndLocation->unpack(buf);
+         }
+      }
+      __EndHeading = buf.getFloat();
+
+   }
+
+   uint32_t TaskOption::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += 2 + sizeof(int64_t) * __EligibleEntities.size();
+      size += sizeof(int64_t);
+      size += (__StartLocation != nullptr ? __StartLocation->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+      size += (__EndLocation != nullptr ? __EndLocation->calculatePackedSize() + 15 : 1);
+      size += sizeof(float);
+
+      return size;
+   }
+
+   std::string TaskOption::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskOption ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "OptionID (int64_t) = " << __OptionID << "\n";
+      oss << indent << "EligibleEntities (int64 [ " << __EligibleEntities.size() << ", var ])\n";
+      oss << indent << "Cost (int64_t) = " << __Cost << "\n";
+      oss << indent << "StartLocation (Location3D)";
+      if (__StartLocation == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "StartHeading (float) = " << __StartHeading << "\n";
+      oss << indent << "EndLocation (Location3D)";
+      if (__EndLocation == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "EndHeading (float) = " << __EndHeading << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskOption::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskOption Series=\"UXTASK\">\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <OptionID>" << __OptionID << "</OptionID>\n";
+      str << ws << "   <EligibleEntities>\n";
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         str << ws << "   <int64>" << __EligibleEntities[i] << "</int64>\n";
+      }
+      str << ws << "   </EligibleEntities>\n";
+      str << ws << "   <Cost>" << __Cost << "</Cost>\n";
+      if (__StartLocation != nullptr)
+      {
+         str << ws << "   <StartLocation>";
+         str << "\n" + __StartLocation->toXML(depth + 1) + ws + "   ";
+         str << "</StartLocation>\n";
+      }
+      str << ws << "   <StartHeading>" << __StartHeading << "</StartHeading>\n";
+      if (__EndLocation != nullptr)
+      {
+         str << ws << "   <EndLocation>";
+         str << "\n" + __EndLocation->toXML(depth + 1) + ws + "   ";
+         str << "</EndLocation>\n";
+      }
+      str << ws << "   <EndHeading>" << __EndHeading << "</EndHeading>\n";
+      str << ws << "</TaskOption>\n";
+
+      return str.str();
+   }
+
+   bool TaskOption::operator==(const TaskOption & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__TaskID != that.__TaskID) return false;
+      if(__OptionID != that.__OptionID) return false;
+      if(__EligibleEntities.size() != that.__EligibleEntities.size()) return false;
+      for (size_t i=0; i<__EligibleEntities.size(); i++)
+      {
+         if(__EligibleEntities[i] != that.__EligibleEntities[i]) return false;
+      }
+      if(__Cost != that.__Cost) return false;
+      if(__StartLocation && that.__StartLocation)
+      {
+         if(__StartLocation->getSeriesNameAsLong() != that.__StartLocation->getSeriesNameAsLong()) return false;
+         if(__StartLocation->getSeriesVersion() != that.__StartLocation->getSeriesVersion()) return false;
+         if(__StartLocation->getLmcpType() != that.__StartLocation->getLmcpType()) return false;
+         if( *(__StartLocation) != *(that.__StartLocation) ) return false;
+      }
+      else if(__StartLocation != that.__StartLocation) return false;
+      if(__StartHeading != that.__StartHeading) return false;
+      if(__EndLocation && that.__EndLocation)
+      {
+         if(__EndLocation->getSeriesNameAsLong() != that.__EndLocation->getSeriesNameAsLong()) return false;
+         if(__EndLocation->getSeriesVersion() != that.__EndLocation->getSeriesVersion()) return false;
+         if(__EndLocation->getLmcpType() != that.__EndLocation->getLmcpType()) return false;
+         if( *(__EndLocation) != *(that.__EndLocation) ) return false;
+      }
+      else if(__EndLocation != that.__EndLocation) return false;
+      if(__EndHeading != that.__EndHeading) return false;
+      return true;
+
+   }
+
+   bool TaskOption::operator!=(const TaskOption & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskOption& TaskOption::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+   TaskOption& TaskOption::setOptionID(const int64_t val)
+   {
+      __OptionID = val;
+      return *this;
+   }
+
+
+   TaskOption& TaskOption::setCost(const int64_t val)
+   {
+      __Cost = val;
+      return *this;
+   }
+
+   TaskOption& TaskOption::setStartLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__StartLocation != nullptr) { delete __StartLocation; __StartLocation = nullptr; }
+      if (val != nullptr) { __StartLocation = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   TaskOption& TaskOption::setStartHeading(const float val)
+   {
+      __StartHeading = val;
+      return *this;
+   }
+
+   TaskOption& TaskOption::setEndLocation(const afrl::cmasi::Location3D* const val)
+   {
+      if (__EndLocation != nullptr) { delete __EndLocation; __EndLocation = nullptr; }
+      if (val != nullptr) { __EndLocation = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   TaskOption& TaskOption::setEndHeading(const float val)
+   {
+      __EndHeading = val;
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskOptionCost.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskOptionCost.cpp
new file mode 100644
index 0000000..e2c46d7
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskOptionCost.cpp
@@ -0,0 +1,240 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskOptionCost.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskOptionCost::Subscription = "uxas.messages.task.TaskOptionCost";
+   const std::string TaskOptionCost::TypeName = "TaskOptionCost";
+   
+   bool isTaskOptionCost(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 16) return false;
+      return true;
+   }
+   
+   bool isTaskOptionCost(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 16) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskOptionCostDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskOptionCost::TaskOptionCost(void) : avtas::lmcp::Object()
+   {
+      __VehicleID = 0LL;
+      __IntialTaskID = 0LL;
+      __IntialTaskOption = 0LL;
+      __DestinationTaskID = 0LL;
+      __DestinationTaskOption = 0LL;
+      __TimeToGo = 0LL;
+
+   }
+     
+   TaskOptionCost::TaskOptionCost(const TaskOptionCost &that) : avtas::lmcp::Object(that)
+   {
+        __VehicleID = that.__VehicleID;
+        __IntialTaskID = that.__IntialTaskID;
+        __IntialTaskOption = that.__IntialTaskOption;
+        __DestinationTaskID = that.__DestinationTaskID;
+        __DestinationTaskOption = that.__DestinationTaskOption;
+        __TimeToGo = that.__TimeToGo;
+
+   }
+   
+   TaskOptionCost & TaskOptionCost::operator=(const TaskOptionCost &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __VehicleID = that.__VehicleID;
+         __IntialTaskID = that.__IntialTaskID;
+         __IntialTaskOption = that.__IntialTaskOption;
+         __DestinationTaskID = that.__DestinationTaskID;
+         __DestinationTaskOption = that.__DestinationTaskOption;
+         __TimeToGo = that.__TimeToGo;
+
+      }
+      return *this;
+   }
+
+   TaskOptionCost* TaskOptionCost::clone() const
+   {
+        return new TaskOptionCost(*this);
+   }
+   
+   TaskOptionCost::~TaskOptionCost(void)
+   {
+
+   }
+  
+   void TaskOptionCost::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__VehicleID);
+      buf.putLong(__IntialTaskID);
+      buf.putLong(__IntialTaskOption);
+      buf.putLong(__DestinationTaskID);
+      buf.putLong(__DestinationTaskOption);
+      buf.putLong(__TimeToGo);
+
+   }
+   
+   void TaskOptionCost::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __VehicleID = buf.getLong();
+      __IntialTaskID = buf.getLong();
+      __IntialTaskOption = buf.getLong();
+      __DestinationTaskID = buf.getLong();
+      __DestinationTaskOption = buf.getLong();
+      __TimeToGo = buf.getLong();
+
+   }
+
+   uint32_t TaskOptionCost::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string TaskOptionCost::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskOptionCost ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "IntialTaskID (int64_t) = " << __IntialTaskID << "\n";
+      oss << indent << "IntialTaskOption (int64_t) = " << __IntialTaskOption << "\n";
+      oss << indent << "DestinationTaskID (int64_t) = " << __DestinationTaskID << "\n";
+      oss << indent << "DestinationTaskOption (int64_t) = " << __DestinationTaskOption << "\n";
+      oss << indent << "TimeToGo (int64_t) = " << __TimeToGo << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskOptionCost::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskOptionCost Series=\"UXTASK\">\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <IntialTaskID>" << __IntialTaskID << "</IntialTaskID>\n";
+      str << ws << "   <IntialTaskOption>" << __IntialTaskOption << "</IntialTaskOption>\n";
+      str << ws << "   <DestinationTaskID>" << __DestinationTaskID << "</DestinationTaskID>\n";
+      str << ws << "   <DestinationTaskOption>" << __DestinationTaskOption << "</DestinationTaskOption>\n";
+      str << ws << "   <TimeToGo>" << __TimeToGo << "</TimeToGo>\n";
+      str << ws << "</TaskOptionCost>\n";
+
+      return str.str();
+   }
+
+   bool TaskOptionCost::operator==(const TaskOptionCost & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__IntialTaskID != that.__IntialTaskID) return false;
+      if(__IntialTaskOption != that.__IntialTaskOption) return false;
+      if(__DestinationTaskID != that.__DestinationTaskID) return false;
+      if(__DestinationTaskOption != that.__DestinationTaskOption) return false;
+      if(__TimeToGo != that.__TimeToGo) return false;
+      return true;
+
+   }
+
+   bool TaskOptionCost::operator!=(const TaskOptionCost & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskOptionCost& TaskOptionCost::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+   TaskOptionCost& TaskOptionCost::setIntialTaskID(const int64_t val)
+   {
+      __IntialTaskID = val;
+      return *this;
+   }
+
+   TaskOptionCost& TaskOptionCost::setIntialTaskOption(const int64_t val)
+   {
+      __IntialTaskOption = val;
+      return *this;
+   }
+
+   TaskOptionCost& TaskOptionCost::setDestinationTaskID(const int64_t val)
+   {
+      __DestinationTaskID = val;
+      return *this;
+   }
+
+   TaskOptionCost& TaskOptionCost::setDestinationTaskOption(const int64_t val)
+   {
+      __DestinationTaskOption = val;
+      return *this;
+   }
+
+   TaskOptionCost& TaskOptionCost::setTimeToGo(const int64_t val)
+   {
+      __TimeToGo = val;
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskPause.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskPause.cpp
new file mode 100644
index 0000000..fd9900e
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskPause.cpp
@@ -0,0 +1,165 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskPause.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskPause::Subscription = "uxas.messages.task.TaskPause";
+   const std::string TaskPause::TypeName = "TaskPause";
+   
+   bool isTaskPause(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 21) return false;
+      return true;
+   }
+   
+   bool isTaskPause(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 21) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskPauseDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskPause::TaskPause(void) : avtas::lmcp::Object()
+   {
+      __TaskID = 0LL;
+
+   }
+     
+   TaskPause::TaskPause(const TaskPause &that) : avtas::lmcp::Object(that)
+   {
+        __TaskID = that.__TaskID;
+
+   }
+   
+   TaskPause & TaskPause::operator=(const TaskPause &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __TaskID = that.__TaskID;
+
+      }
+      return *this;
+   }
+
+   TaskPause* TaskPause::clone() const
+   {
+        return new TaskPause(*this);
+   }
+   
+   TaskPause::~TaskPause(void)
+   {
+
+   }
+  
+   void TaskPause::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__TaskID);
+
+   }
+   
+   void TaskPause::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __TaskID = buf.getLong();
+
+   }
+
+   uint32_t TaskPause::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string TaskPause::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskPause ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskPause::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskPause Series=\"UXTASK\">\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "</TaskPause>\n";
+
+      return str.str();
+   }
+
+   bool TaskPause::operator==(const TaskPause & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__TaskID != that.__TaskID) return false;
+      return true;
+
+   }
+
+   bool TaskPause::operator!=(const TaskPause & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskPause& TaskPause::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskPlanOptions.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskPlanOptions.cpp
new file mode 100644
index 0000000..398ca78
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskPlanOptions.cpp
@@ -0,0 +1,266 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskPlanOptions.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskPlanOptions::Subscription = "uxas.messages.task.TaskPlanOptions";
+   const std::string TaskPlanOptions::TypeName = "TaskPlanOptions";
+   
+   bool isTaskPlanOptions(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 20) return false;
+      return true;
+   }
+   
+   bool isTaskPlanOptions(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 20) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskPlanOptionsDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskPlanOptions::TaskPlanOptions(void) : avtas::lmcp::Object()
+   {
+      __CorrespondingAutomationRequestID = 0LL;
+      __TaskID = 0LL;
+      __Composition = std::string("");
+
+   }
+     
+   TaskPlanOptions::TaskPlanOptions(const TaskPlanOptions &that) : avtas::lmcp::Object(that)
+   {
+        __CorrespondingAutomationRequestID = that.__CorrespondingAutomationRequestID;
+        __TaskID = that.__TaskID;
+        __Composition = that.__Composition;
+        __Options.clear();
+        for (size_t i=0; i< that.__Options.size(); i++)
+        {
+           __Options.push_back( that.__Options[i] == nullptr ? nullptr : that.__Options[i]->clone());
+        }
+
+   }
+   
+   TaskPlanOptions & TaskPlanOptions::operator=(const TaskPlanOptions &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__Options.size(); i++)
+         {
+            if (__Options[i] != nullptr) delete __Options[i];
+         }
+
+         __CorrespondingAutomationRequestID = that.__CorrespondingAutomationRequestID;
+         __TaskID = that.__TaskID;
+         __Composition = that.__Composition;
+         __Options.clear();
+         for (size_t i=0; i< that.__Options.size(); i++)
+         {
+            __Options.push_back( that.__Options[i] == nullptr ? nullptr : that.__Options[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   TaskPlanOptions* TaskPlanOptions::clone() const
+   {
+        return new TaskPlanOptions(*this);
+   }
+   
+   TaskPlanOptions::~TaskPlanOptions(void)
+   {
+      for (size_t i=0; i<__Options.size(); i++)
+      {
+         if (__Options[i] != nullptr) delete __Options[i];
+      }
+
+   }
+  
+   void TaskPlanOptions::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__CorrespondingAutomationRequestID);
+      buf.putLong(__TaskID);
+      buf.putString(__Composition);
+      buf.putUShort( static_cast<uint16_t>(__Options.size()));
+      for (size_t i=0; i<__Options.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Options[i], buf);
+      }
+
+   }
+   
+   void TaskPlanOptions::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __CorrespondingAutomationRequestID = buf.getLong();
+      __TaskID = buf.getLong();
+      __Composition = buf.getString();
+      for (size_t i=0; i<__Options.size(); i++)
+      {
+         if (__Options[i] != nullptr)
+            delete __Options[i];
+      }
+      __Options.clear();
+      uint16_t __Options_length = buf.getUShort();
+      for (uint32_t i=0; i< __Options_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::task::TaskOption* e = (uxas::messages::task::TaskOption*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Options.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t TaskPlanOptions::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += 2 + __Composition.length();
+      size += 2;
+      for (size_t i=0; i<__Options.size(); i++)
+      {
+         if (__Options[i] != nullptr)
+         {
+            size += __Options[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string TaskPlanOptions::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskPlanOptions ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "CorrespondingAutomationRequestID (int64_t) = " << __CorrespondingAutomationRequestID << "\n";
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "Composition (std::string) = " << __Composition << "\n";
+      oss << indent << "Options (TaskOption [ " << __Options.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskPlanOptions::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskPlanOptions Series=\"UXTASK\">\n";
+      str << ws << "   <CorrespondingAutomationRequestID>" << __CorrespondingAutomationRequestID << "</CorrespondingAutomationRequestID>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <Composition>" << __Composition << "</Composition>\n";
+      str << ws << "   <Options>\n";
+      for (size_t i=0; i<__Options.size(); i++)
+      {
+         str << (__Options[i] == nullptr ? ( ws + "   <null/>\n") : (__Options[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Options>\n";
+      str << ws << "</TaskPlanOptions>\n";
+
+      return str.str();
+   }
+
+   bool TaskPlanOptions::operator==(const TaskPlanOptions & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__CorrespondingAutomationRequestID != that.__CorrespondingAutomationRequestID) return false;
+      if(__TaskID != that.__TaskID) return false;
+      if(__Composition != that.__Composition) return false;
+      if(__Options.size() != that.__Options.size()) return false;
+      for (size_t i=0; i<__Options.size(); i++)
+      {
+         if(__Options[i] && that.__Options[i])
+         {
+            if(__Options[i]->getSeriesNameAsLong() != that.__Options[i]->getSeriesNameAsLong()) return false;
+            if(__Options[i]->getSeriesVersion() != that.__Options[i]->getSeriesVersion()) return false;
+            if(__Options[i]->getLmcpType() != that.__Options[i]->getLmcpType()) return false;
+            if( *(__Options[i]) != *(that.__Options[i]) ) return false;
+         }
+         else if(__Options[i] != that.__Options[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool TaskPlanOptions::operator!=(const TaskPlanOptions & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskPlanOptions& TaskPlanOptions::setCorrespondingAutomationRequestID(const int64_t val)
+   {
+      __CorrespondingAutomationRequestID = val;
+      return *this;
+   }
+
+   TaskPlanOptions& TaskPlanOptions::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+   TaskPlanOptions& TaskPlanOptions::setComposition(const std::string val)
+   {
+      __Composition = val;
+      return *this;
+   }
+
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskProgress.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskProgress.cpp
new file mode 100644
index 0000000..2a98dff
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskProgress.cpp
@@ -0,0 +1,230 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskProgress.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskProgress::Subscription = "uxas.messages.task.TaskProgress";
+   const std::string TaskProgress::TypeName = "TaskProgress";
+   
+   bool isTaskProgress(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 23) return false;
+      return true;
+   }
+   
+   bool isTaskProgress(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 23) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskProgressDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskProgress::TaskProgress(void) : avtas::lmcp::Object()
+   {
+      __ResponseID = 0LL;
+      __TaskID = 0LL;
+      __PercentComplete = 0.f;
+
+   }
+     
+   TaskProgress::TaskProgress(const TaskProgress &that) : avtas::lmcp::Object(that)
+   {
+        __ResponseID = that.__ResponseID;
+        __TaskID = that.__TaskID;
+        __PercentComplete = that.__PercentComplete;
+        __EntitiesEngaged.clear();
+        for (size_t i=0; i< that.__EntitiesEngaged.size(); i++)
+        {
+           __EntitiesEngaged.push_back( that.__EntitiesEngaged[i]);
+        }
+
+   }
+   
+   TaskProgress & TaskProgress::operator=(const TaskProgress &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __ResponseID = that.__ResponseID;
+         __TaskID = that.__TaskID;
+         __PercentComplete = that.__PercentComplete;
+         __EntitiesEngaged.clear();
+         for (size_t i=0; i< that.__EntitiesEngaged.size(); i++)
+         {
+            __EntitiesEngaged.push_back( that.__EntitiesEngaged[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   TaskProgress* TaskProgress::clone() const
+   {
+        return new TaskProgress(*this);
+   }
+   
+   TaskProgress::~TaskProgress(void)
+   {
+
+   }
+  
+   void TaskProgress::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ResponseID);
+      buf.putLong(__TaskID);
+      buf.putFloat(__PercentComplete);
+      buf.putUShort( static_cast<uint16_t>(__EntitiesEngaged.size()));
+      for (size_t i=0; i<__EntitiesEngaged.size(); i++)
+      {
+         buf.putLong(__EntitiesEngaged[i]);
+      }
+
+   }
+   
+   void TaskProgress::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ResponseID = buf.getLong();
+      __TaskID = buf.getLong();
+      __PercentComplete = buf.getFloat();
+      __EntitiesEngaged.clear();
+      uint16_t __EntitiesEngaged_length = buf.getUShort();
+      for (uint32_t i=0; i< __EntitiesEngaged_length; i++)
+      {
+         __EntitiesEngaged.push_back(buf.getLong() );
+      }
+
+   }
+
+   uint32_t TaskProgress::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+      size += sizeof(float);
+      size += 2 + sizeof(int64_t) * __EntitiesEngaged.size();
+
+      return size;
+   }
+
+   std::string TaskProgress::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskProgress ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ResponseID (int64_t) = " << __ResponseID << "\n";
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "PercentComplete (float) = " << __PercentComplete << "\n";
+      oss << indent << "EntitiesEngaged (int64 [ " << __EntitiesEngaged.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskProgress::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskProgress Series=\"UXTASK\">\n";
+      str << ws << "   <ResponseID>" << __ResponseID << "</ResponseID>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <PercentComplete>" << __PercentComplete << "</PercentComplete>\n";
+      str << ws << "   <EntitiesEngaged>\n";
+      for (size_t i=0; i<__EntitiesEngaged.size(); i++)
+      {
+         str << ws << "   <int64>" << __EntitiesEngaged[i] << "</int64>\n";
+      }
+      str << ws << "   </EntitiesEngaged>\n";
+      str << ws << "</TaskProgress>\n";
+
+      return str.str();
+   }
+
+   bool TaskProgress::operator==(const TaskProgress & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ResponseID != that.__ResponseID) return false;
+      if(__TaskID != that.__TaskID) return false;
+      if(__PercentComplete != that.__PercentComplete) return false;
+      if(__EntitiesEngaged.size() != that.__EntitiesEngaged.size()) return false;
+      for (size_t i=0; i<__EntitiesEngaged.size(); i++)
+      {
+         if(__EntitiesEngaged[i] != that.__EntitiesEngaged[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool TaskProgress::operator!=(const TaskProgress & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskProgress& TaskProgress::setResponseID(const int64_t val)
+   {
+      __ResponseID = val;
+      return *this;
+   }
+
+   TaskProgress& TaskProgress::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+   TaskProgress& TaskProgress::setPercentComplete(const float val)
+   {
+      __PercentComplete = val;
+      return *this;
+   }
+
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskProgressRequest.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskProgressRequest.cpp
new file mode 100644
index 0000000..3c52998
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskProgressRequest.cpp
@@ -0,0 +1,180 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskProgressRequest.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskProgressRequest::Subscription = "uxas.messages.task.TaskProgressRequest";
+   const std::string TaskProgressRequest::TypeName = "TaskProgressRequest";
+   
+   bool isTaskProgressRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 24) return false;
+      return true;
+   }
+   
+   bool isTaskProgressRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 24) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskProgressRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskProgressRequest::TaskProgressRequest(void) : avtas::lmcp::Object()
+   {
+      __RequestID = 0LL;
+      __TaskID = 0LL;
+
+   }
+     
+   TaskProgressRequest::TaskProgressRequest(const TaskProgressRequest &that) : avtas::lmcp::Object(that)
+   {
+        __RequestID = that.__RequestID;
+        __TaskID = that.__TaskID;
+
+   }
+   
+   TaskProgressRequest & TaskProgressRequest::operator=(const TaskProgressRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __RequestID = that.__RequestID;
+         __TaskID = that.__TaskID;
+
+      }
+      return *this;
+   }
+
+   TaskProgressRequest* TaskProgressRequest::clone() const
+   {
+        return new TaskProgressRequest(*this);
+   }
+   
+   TaskProgressRequest::~TaskProgressRequest(void)
+   {
+
+   }
+  
+   void TaskProgressRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RequestID);
+      buf.putLong(__TaskID);
+
+   }
+   
+   void TaskProgressRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RequestID = buf.getLong();
+      __TaskID = buf.getLong();
+
+   }
+
+   uint32_t TaskProgressRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string TaskProgressRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskProgressRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RequestID (int64_t) = " << __RequestID << "\n";
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskProgressRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskProgressRequest Series=\"UXTASK\">\n";
+      str << ws << "   <RequestID>" << __RequestID << "</RequestID>\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "</TaskProgressRequest>\n";
+
+      return str.str();
+   }
+
+   bool TaskProgressRequest::operator==(const TaskProgressRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RequestID != that.__RequestID) return false;
+      if(__TaskID != that.__TaskID) return false;
+      return true;
+
+   }
+
+   bool TaskProgressRequest::operator!=(const TaskProgressRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskProgressRequest& TaskProgressRequest::setRequestID(const int64_t val)
+   {
+      __RequestID = val;
+      return *this;
+   }
+
+   TaskProgressRequest& TaskProgressRequest::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskTaskResume.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskResume.cpp
new file mode 100644
index 0000000..9158fdf
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskTaskResume.cpp
@@ -0,0 +1,224 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/TaskResume.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string TaskResume::Subscription = "uxas.messages.task.TaskResume";
+   const std::string TaskResume::TypeName = "TaskResume";
+   
+   bool isTaskResume(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 22) return false;
+      return true;
+   }
+   
+   bool isTaskResume(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 22) return false;
+      return true;
+   }
+   
+   std::vector< std::string > TaskResumeDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   TaskResume::TaskResume(void) : avtas::lmcp::Object()
+   {
+      __TaskID = 0LL;
+      __RestartCompletely = false;
+      __ReAssign = nullptr;
+
+   }
+     
+   TaskResume::TaskResume(const TaskResume &that) : avtas::lmcp::Object(that)
+   {
+        __TaskID = that.__TaskID;
+        __RestartCompletely = that.__RestartCompletely;
+        __ReAssign = that.__ReAssign == nullptr ? nullptr : that.__ReAssign->clone();
+
+   }
+   
+   TaskResume & TaskResume::operator=(const TaskResume &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__ReAssign != nullptr) delete __ReAssign;
+
+         __TaskID = that.__TaskID;
+         __RestartCompletely = that.__RestartCompletely;
+         __ReAssign = that.__ReAssign == nullptr ? nullptr : that.__ReAssign->clone();
+
+      }
+      return *this;
+   }
+
+   TaskResume* TaskResume::clone() const
+   {
+        return new TaskResume(*this);
+   }
+   
+   TaskResume::~TaskResume(void)
+   {
+      if (__ReAssign != nullptr) delete __ReAssign;
+
+   }
+  
+   void TaskResume::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__TaskID);
+      buf.putBool(__RestartCompletely);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __ReAssign, buf);
+
+   }
+   
+   void TaskResume::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __TaskID = buf.getLong();
+      __RestartCompletely = buf.getBool();
+      {
+         if (__ReAssign != nullptr) delete __ReAssign;
+         __ReAssign = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __ReAssign = (uxas::messages::task::TaskAssignment*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__ReAssign != nullptr) __ReAssign->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t TaskResume::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(bool);
+      size += (__ReAssign != nullptr ? __ReAssign->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string TaskResume::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( TaskResume ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "TaskID (int64_t) = " << __TaskID << "\n";
+      oss << indent << "RestartCompletely (bool) = " << __RestartCompletely << "\n";
+      oss << indent << "ReAssign (TaskAssignment)";
+      if (__ReAssign == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string TaskResume::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<TaskResume Series=\"UXTASK\">\n";
+      str << ws << "   <TaskID>" << __TaskID << "</TaskID>\n";
+      str << ws << "   <RestartCompletely>" << (__RestartCompletely ? "true" : "false") << "</RestartCompletely>\n";
+      if (__ReAssign != nullptr)
+      {
+         str << ws << "   <ReAssign>";
+         str << "\n" + __ReAssign->toXML(depth + 1) + ws + "   ";
+         str << "</ReAssign>\n";
+      }
+      str << ws << "</TaskResume>\n";
+
+      return str.str();
+   }
+
+   bool TaskResume::operator==(const TaskResume & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__TaskID != that.__TaskID) return false;
+      if(__RestartCompletely != that.__RestartCompletely) return false;
+      if(__ReAssign && that.__ReAssign)
+      {
+         if(__ReAssign->getSeriesNameAsLong() != that.__ReAssign->getSeriesNameAsLong()) return false;
+         if(__ReAssign->getSeriesVersion() != that.__ReAssign->getSeriesVersion()) return false;
+         if(__ReAssign->getLmcpType() != that.__ReAssign->getLmcpType()) return false;
+         if( *(__ReAssign) != *(that.__ReAssign) ) return false;
+      }
+      else if(__ReAssign != that.__ReAssign) return false;
+      return true;
+
+   }
+
+   bool TaskResume::operator!=(const TaskResume & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   TaskResume& TaskResume::setTaskID(const int64_t val)
+   {
+      __TaskID = val;
+      return *this;
+   }
+
+   TaskResume& TaskResume::setRestartCompletely(const bool val)
+   {
+      __RestartCompletely = val;
+      return *this;
+   }
+
+   TaskResume& TaskResume::setReAssign(const uxas::messages::task::TaskAssignment* const val)
+   {
+      if (__ReAssign != nullptr) { delete __ReAssign; __ReAssign = nullptr; }
+      if (val != nullptr) { __ReAssign = const_cast< uxas::messages::task::TaskAssignment* > (val); }
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskUniqueAutomationRequest.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskUniqueAutomationRequest.cpp
new file mode 100644
index 0000000..6de117a
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskUniqueAutomationRequest.cpp
@@ -0,0 +1,295 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/UniqueAutomationRequest.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string UniqueAutomationRequest::Subscription = "uxas.messages.task.UniqueAutomationRequest";
+   const std::string UniqueAutomationRequest::TypeName = "UniqueAutomationRequest";
+   
+   bool isUniqueAutomationRequest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 7) return false;
+      return true;
+   }
+   
+   bool isUniqueAutomationRequest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 7) return false;
+      return true;
+   }
+   
+   std::vector< std::string > UniqueAutomationRequestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   UniqueAutomationRequest::UniqueAutomationRequest(void) : avtas::lmcp::Object()
+   {
+      __RequestID = 0LL;
+      __OriginalRequest = new afrl::cmasi::AutomationRequest();
+      __SandBoxRequest = false;
+
+   }
+     
+   UniqueAutomationRequest::UniqueAutomationRequest(const UniqueAutomationRequest &that) : avtas::lmcp::Object(that)
+   {
+        __RequestID = that.__RequestID;
+        __OriginalRequest = that.__OriginalRequest == nullptr ? nullptr : that.__OriginalRequest->clone();
+        __SandBoxRequest = that.__SandBoxRequest;
+        __PlanningStates.clear();
+        for (size_t i=0; i< that.__PlanningStates.size(); i++)
+        {
+           __PlanningStates.push_back( that.__PlanningStates[i] == nullptr ? nullptr : that.__PlanningStates[i]->clone());
+        }
+
+   }
+   
+   UniqueAutomationRequest & UniqueAutomationRequest::operator=(const UniqueAutomationRequest &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__OriginalRequest != nullptr) delete __OriginalRequest;
+         for (size_t i=0; i<__PlanningStates.size(); i++)
+         {
+            if (__PlanningStates[i] != nullptr) delete __PlanningStates[i];
+         }
+
+         __RequestID = that.__RequestID;
+         __OriginalRequest = that.__OriginalRequest == nullptr ? nullptr : that.__OriginalRequest->clone();
+         __SandBoxRequest = that.__SandBoxRequest;
+         __PlanningStates.clear();
+         for (size_t i=0; i< that.__PlanningStates.size(); i++)
+         {
+            __PlanningStates.push_back( that.__PlanningStates[i] == nullptr ? nullptr : that.__PlanningStates[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   UniqueAutomationRequest* UniqueAutomationRequest::clone() const
+   {
+        return new UniqueAutomationRequest(*this);
+   }
+   
+   UniqueAutomationRequest::~UniqueAutomationRequest(void)
+   {
+      if (__OriginalRequest != nullptr) delete __OriginalRequest;
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         if (__PlanningStates[i] != nullptr) delete __PlanningStates[i];
+      }
+
+   }
+  
+   void UniqueAutomationRequest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__RequestID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __OriginalRequest, buf);
+      buf.putBool(__SandBoxRequest);
+      buf.putUShort( static_cast<uint16_t>(__PlanningStates.size()));
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __PlanningStates[i], buf);
+      }
+
+   }
+   
+   void UniqueAutomationRequest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __RequestID = buf.getLong();
+      {
+         if (__OriginalRequest != nullptr) delete __OriginalRequest;
+         __OriginalRequest = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __OriginalRequest = (afrl::cmasi::AutomationRequest*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__OriginalRequest != nullptr) __OriginalRequest->unpack(buf);
+         }
+      }
+      __SandBoxRequest = buf.getBool();
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         if (__PlanningStates[i] != nullptr)
+            delete __PlanningStates[i];
+      }
+      __PlanningStates.clear();
+      uint16_t __PlanningStates_length = buf.getUShort();
+      for (uint32_t i=0; i< __PlanningStates_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            uxas::messages::task::PlanningState* e = (uxas::messages::task::PlanningState*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __PlanningStates.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t UniqueAutomationRequest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__OriginalRequest != nullptr ? __OriginalRequest->calculatePackedSize() + 15 : 1);
+      size += sizeof(bool);
+      size += 2;
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         if (__PlanningStates[i] != nullptr)
+         {
+            size += __PlanningStates[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string UniqueAutomationRequest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( UniqueAutomationRequest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "RequestID (int64_t) = " << __RequestID << "\n";
+      oss << indent << "OriginalRequest (AutomationRequest)";
+      if (__OriginalRequest == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "SandBoxRequest (bool) = " << __SandBoxRequest << "\n";
+      oss << indent << "PlanningStates (PlanningState [ " << __PlanningStates.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string UniqueAutomationRequest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<UniqueAutomationRequest Series=\"UXTASK\">\n";
+      str << ws << "   <RequestID>" << __RequestID << "</RequestID>\n";
+      if (__OriginalRequest != nullptr)
+      {
+         str << ws << "   <OriginalRequest>";
+         str << "\n" + __OriginalRequest->toXML(depth + 1) + ws + "   ";
+         str << "</OriginalRequest>\n";
+      }
+      str << ws << "   <SandBoxRequest>" << (__SandBoxRequest ? "true" : "false") << "</SandBoxRequest>\n";
+      str << ws << "   <PlanningStates>\n";
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         str << (__PlanningStates[i] == nullptr ? ( ws + "   <null/>\n") : (__PlanningStates[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </PlanningStates>\n";
+      str << ws << "</UniqueAutomationRequest>\n";
+
+      return str.str();
+   }
+
+   bool UniqueAutomationRequest::operator==(const UniqueAutomationRequest & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__RequestID != that.__RequestID) return false;
+      if(__OriginalRequest && that.__OriginalRequest)
+      {
+         if(__OriginalRequest->getSeriesNameAsLong() != that.__OriginalRequest->getSeriesNameAsLong()) return false;
+         if(__OriginalRequest->getSeriesVersion() != that.__OriginalRequest->getSeriesVersion()) return false;
+         if(__OriginalRequest->getLmcpType() != that.__OriginalRequest->getLmcpType()) return false;
+         if( *(__OriginalRequest) != *(that.__OriginalRequest) ) return false;
+      }
+      else if(__OriginalRequest != that.__OriginalRequest) return false;
+      if(__SandBoxRequest != that.__SandBoxRequest) return false;
+      if(__PlanningStates.size() != that.__PlanningStates.size()) return false;
+      for (size_t i=0; i<__PlanningStates.size(); i++)
+      {
+         if(__PlanningStates[i] && that.__PlanningStates[i])
+         {
+            if(__PlanningStates[i]->getSeriesNameAsLong() != that.__PlanningStates[i]->getSeriesNameAsLong()) return false;
+            if(__PlanningStates[i]->getSeriesVersion() != that.__PlanningStates[i]->getSeriesVersion()) return false;
+            if(__PlanningStates[i]->getLmcpType() != that.__PlanningStates[i]->getLmcpType()) return false;
+            if( *(__PlanningStates[i]) != *(that.__PlanningStates[i]) ) return false;
+         }
+         else if(__PlanningStates[i] != that.__PlanningStates[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool UniqueAutomationRequest::operator!=(const UniqueAutomationRequest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   UniqueAutomationRequest& UniqueAutomationRequest::setRequestID(const int64_t val)
+   {
+      __RequestID = val;
+      return *this;
+   }
+
+   UniqueAutomationRequest& UniqueAutomationRequest::setOriginalRequest(const afrl::cmasi::AutomationRequest* const val)
+   {
+      if (__OriginalRequest != nullptr) { delete __OriginalRequest; __OriginalRequest = nullptr; }
+      if (val != nullptr) { __OriginalRequest = const_cast< afrl::cmasi::AutomationRequest* > (val); }
+      return *this;
+   }
+
+   UniqueAutomationRequest& UniqueAutomationRequest::setSandBoxRequest(const bool val)
+   {
+      __SandBoxRequest = val;
+      return *this;
+   }
+
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/task/uxasmessagestaskUniqueAutomationResponse.cpp b/src/LMCP/uxas/messages/task/uxasmessagestaskUniqueAutomationResponse.cpp
new file mode 100644
index 0000000..ffe7965
--- /dev/null
+++ b/src/LMCP/uxas/messages/task/uxasmessagestaskUniqueAutomationResponse.cpp
@@ -0,0 +1,209 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/task/UniqueAutomationResponse.h"
+
+
+namespace uxas {
+namespace messages {
+namespace task {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string UniqueAutomationResponse::Subscription = "uxas.messages.task.UniqueAutomationResponse";
+   const std::string UniqueAutomationResponse::TypeName = "UniqueAutomationResponse";
+   
+   bool isUniqueAutomationResponse(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 8) return false;
+      return true;
+   }
+   
+   bool isUniqueAutomationResponse(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149757930721443840LL) return false;
+      if(obj->getSeriesVersion() != 6) return false;
+      if(obj->getLmcpType() != 8) return false;
+      return true;
+   }
+   
+   std::vector< std::string > UniqueAutomationResponseDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   UniqueAutomationResponse::UniqueAutomationResponse(void) : avtas::lmcp::Object()
+   {
+      __ResponseID = 0LL;
+      __OriginalResponse = new afrl::cmasi::AutomationResponse();
+
+   }
+     
+   UniqueAutomationResponse::UniqueAutomationResponse(const UniqueAutomationResponse &that) : avtas::lmcp::Object(that)
+   {
+        __ResponseID = that.__ResponseID;
+        __OriginalResponse = that.__OriginalResponse == nullptr ? nullptr : that.__OriginalResponse->clone();
+
+   }
+   
+   UniqueAutomationResponse & UniqueAutomationResponse::operator=(const UniqueAutomationResponse &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__OriginalResponse != nullptr) delete __OriginalResponse;
+
+         __ResponseID = that.__ResponseID;
+         __OriginalResponse = that.__OriginalResponse == nullptr ? nullptr : that.__OriginalResponse->clone();
+
+      }
+      return *this;
+   }
+
+   UniqueAutomationResponse* UniqueAutomationResponse::clone() const
+   {
+        return new UniqueAutomationResponse(*this);
+   }
+   
+   UniqueAutomationResponse::~UniqueAutomationResponse(void)
+   {
+      if (__OriginalResponse != nullptr) delete __OriginalResponse;
+
+   }
+  
+   void UniqueAutomationResponse::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ResponseID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __OriginalResponse, buf);
+
+   }
+   
+   void UniqueAutomationResponse::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ResponseID = buf.getLong();
+      {
+         if (__OriginalResponse != nullptr) delete __OriginalResponse;
+         __OriginalResponse = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __OriginalResponse = (afrl::cmasi::AutomationResponse*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__OriginalResponse != nullptr) __OriginalResponse->unpack(buf);
+         }
+      }
+
+   }
+
+   uint32_t UniqueAutomationResponse::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__OriginalResponse != nullptr ? __OriginalResponse->calculatePackedSize() + 15 : 1);
+
+      return size;
+   }
+
+   std::string UniqueAutomationResponse::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( UniqueAutomationResponse ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ResponseID (int64_t) = " << __ResponseID << "\n";
+      oss << indent << "OriginalResponse (AutomationResponse)";
+      if (__OriginalResponse == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string UniqueAutomationResponse::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<UniqueAutomationResponse Series=\"UXTASK\">\n";
+      str << ws << "   <ResponseID>" << __ResponseID << "</ResponseID>\n";
+      if (__OriginalResponse != nullptr)
+      {
+         str << ws << "   <OriginalResponse>";
+         str << "\n" + __OriginalResponse->toXML(depth + 1) + ws + "   ";
+         str << "</OriginalResponse>\n";
+      }
+      str << ws << "</UniqueAutomationResponse>\n";
+
+      return str.str();
+   }
+
+   bool UniqueAutomationResponse::operator==(const UniqueAutomationResponse & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ResponseID != that.__ResponseID) return false;
+      if(__OriginalResponse && that.__OriginalResponse)
+      {
+         if(__OriginalResponse->getSeriesNameAsLong() != that.__OriginalResponse->getSeriesNameAsLong()) return false;
+         if(__OriginalResponse->getSeriesVersion() != that.__OriginalResponse->getSeriesVersion()) return false;
+         if(__OriginalResponse->getLmcpType() != that.__OriginalResponse->getLmcpType()) return false;
+         if( *(__OriginalResponse) != *(that.__OriginalResponse) ) return false;
+      }
+      else if(__OriginalResponse != that.__OriginalResponse) return false;
+      return true;
+
+   }
+
+   bool UniqueAutomationResponse::operator!=(const UniqueAutomationResponse & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   UniqueAutomationResponse& UniqueAutomationResponse::setResponseID(const int64_t val)
+   {
+      __ResponseID = val;
+      return *this;
+   }
+
+   UniqueAutomationResponse& UniqueAutomationResponse::setOriginalResponse(const afrl::cmasi::AutomationResponse* const val)
+   {
+      if (__OriginalResponse != nullptr) { delete __OriginalResponse; __OriginalResponse = nullptr; }
+      if (val != nullptr) { __OriginalResponse = const_cast< afrl::cmasi::AutomationResponse* > (val); }
+      return *this;
+   }
+
+
+} // end namespace task
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/AutopilotKeepAlive.h b/src/LMCP/uxas/messages/uxnative/AutopilotKeepAlive.h
new file mode 100644
index 0000000..8f7bc67
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/AutopilotKeepAlive.h
@@ -0,0 +1,120 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_AUTOPILOTKEEPALIVE_H_
+#define _UXAS_MESSAGES_UXNATIVE_AUTOPILOTKEEPALIVE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isAutopilotKeepAlive(avtas::lmcp::Object* obj);
+   bool isAutopilotKeepAlive(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > AutopilotKeepAliveDescendants();
+   
+   class AutopilotKeepAlive : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      AutopilotKeepAlive(void);
+
+      // Copy Constructor
+      AutopilotKeepAlive(const AutopilotKeepAlive &that);
+
+      // Assignment Operator
+      AutopilotKeepAlive & operator=(const AutopilotKeepAlive &that);
+
+      // Destructor
+      virtual ~AutopilotKeepAlive(void);
+
+      // Equals overload
+      bool operator==(const AutopilotKeepAlive & that);
+      bool operator!=(const AutopilotKeepAlive & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual AutopilotKeepAlive* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 11; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** Enable communications between UxAS and the autopilot (Units: None)*/
+      bool getAutopilotEnabled(void) const { return __AutopilotEnabled; }
+      AutopilotKeepAlive& setAutopilotEnabled(const bool val);
+
+      /** Enable communications between UxAS and the Gimbal. Note: this does not effect the video stream. (Units: None)*/
+      bool getGimbalEnabled(void) const { return __GimbalEnabled; }
+      AutopilotKeepAlive& setGimbalEnabled(const bool val);
+
+      /** Time that this message was sent (Units: milliseconds since 1 Jan 1970)*/
+      int64_t getTimeSent(void) const { return __TimeSent; }
+      AutopilotKeepAlive& setTimeSent(const int64_t val);
+
+
+
+   protected:
+      /** Enable communications between UxAS and the autopilot */
+      bool __AutopilotEnabled;
+      /** Enable communications between UxAS and the Gimbal. Note: this does not effect the video stream. */
+      bool __GimbalEnabled;
+      /** Time that this message was sent */
+      int64_t __TimeSent;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_AUTOPILOTKEEPALIVE_H_
diff --git a/src/LMCP/uxas/messages/uxnative/AutopilotKeepAliveDescendants.h b/src/LMCP/uxas/messages/uxnative/AutopilotKeepAliveDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/AutopilotKeepAliveDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/BandwidthReceiveReport.h b/src/LMCP/uxas/messages/uxnative/BandwidthReceiveReport.h
new file mode 100644
index 0000000..47268b6
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/BandwidthReceiveReport.h
@@ -0,0 +1,122 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_BANDWIDTHRECEIVEREPORT_H_
+#define _UXAS_MESSAGES_UXNATIVE_BANDWIDTHRECEIVEREPORT_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "uxas/messages/uxnative/EntityLocation.h"
+#include "uxas/messages/uxnative/EntityLocation.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isBandwidthReceiveReport(avtas::lmcp::Object* obj);
+   bool isBandwidthReceiveReport(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > BandwidthReceiveReportDescendants();
+   
+   class BandwidthReceiveReport : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      BandwidthReceiveReport(void);
+
+      // Copy Constructor
+      BandwidthReceiveReport(const BandwidthReceiveReport &that);
+
+      // Assignment Operator
+      BandwidthReceiveReport & operator=(const BandwidthReceiveReport &that);
+
+      // Destructor
+      virtual ~BandwidthReceiveReport(void);
+
+      // Equals overload
+      bool operator==(const BandwidthReceiveReport & that);
+      bool operator!=(const BandwidthReceiveReport & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual BandwidthReceiveReport* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 8; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** Entity from which the message was sent (Units: None)*/
+      uxas::messages::uxnative::EntityLocation* const getEntitySender(void) { return __EntitySender; }
+      BandwidthReceiveReport& setEntitySender(const uxas::messages::uxnative::EntityLocation* const val);
+
+      /** Entity which received the message (Units: None)*/
+      uxas::messages::uxnative::EntityLocation* const getEntityReceiver(void) { return __EntityReceiver; }
+      BandwidthReceiveReport& setEntityReceiver(const uxas::messages::uxnative::EntityLocation* const val);
+
+      /** Size of the message that was received (Units: None)*/
+      uint32_t getTransferPayloadSize(void) const { return __TransferPayloadSize; }
+      BandwidthReceiveReport& setTransferPayloadSize(const uint32_t val);
+
+
+
+   protected:
+      /** Entity from which the message was sent */
+      uxas::messages::uxnative::EntityLocation* __EntitySender;
+      /** Entity which received the message */
+      uxas::messages::uxnative::EntityLocation* __EntityReceiver;
+      /** Size of the message that was received */
+      uint32_t __TransferPayloadSize;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_BANDWIDTHRECEIVEREPORT_H_
diff --git a/src/LMCP/uxas/messages/uxnative/BandwidthReceiveReportDescendants.h b/src/LMCP/uxas/messages/uxnative/BandwidthReceiveReportDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/BandwidthReceiveReportDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/BandwidthTest.h b/src/LMCP/uxas/messages/uxnative/BandwidthTest.h
new file mode 100644
index 0000000..1a373ae
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/BandwidthTest.h
@@ -0,0 +1,114 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_BANDWIDTHTEST_H_
+#define _UXAS_MESSAGES_UXNATIVE_BANDWIDTHTEST_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "uxas/messages/uxnative/EntityLocation.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isBandwidthTest(avtas::lmcp::Object* obj);
+   bool isBandwidthTest(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > BandwidthTestDescendants();
+   
+   class BandwidthTest : public uxas::messages::uxnative::EntityLocation {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      BandwidthTest(void);
+
+      // Copy Constructor
+      BandwidthTest(const BandwidthTest &that);
+
+      // Assignment Operator
+      BandwidthTest & operator=(const BandwidthTest &that);
+
+      // Destructor
+      virtual ~BandwidthTest(void);
+
+      // Equals overload
+      bool operator==(const BandwidthTest & that);
+      bool operator!=(const BandwidthTest & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual BandwidthTest* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 7; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** Message ID to track message loss (Units: None)*/
+      int64_t getMessageID(void) const { return __MessageID; }
+      BandwidthTest& setMessageID(const int64_t val);
+
+      /** Data payload for creating arbitrarily sized messages (Units: None)*/
+      std::string getPayload(void) const { return __Payload; }
+      BandwidthTest& setPayload(const std::string val);
+
+
+
+   protected:
+      /** Message ID to track message loss */
+      int64_t __MessageID;
+      /** Data payload for creating arbitrarily sized messages */
+      std::string __Payload;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_BANDWIDTHTEST_H_
diff --git a/src/LMCP/uxas/messages/uxnative/BandwidthTestDescendants.h b/src/LMCP/uxas/messages/uxnative/BandwidthTestDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/BandwidthTestDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/CreateNewService.h b/src/LMCP/uxas/messages/uxnative/CreateNewService.h
new file mode 100644
index 0000000..0b1c80e
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/CreateNewService.h
@@ -0,0 +1,114 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_CREATENEWSERVICE_H_
+#define _UXAS_MESSAGES_UXNATIVE_CREATENEWSERVICE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isCreateNewService(avtas::lmcp::Object* obj);
+   bool isCreateNewService(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > CreateNewServiceDescendants();
+   
+   class CreateNewService : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      CreateNewService(void);
+
+      // Copy Constructor
+      CreateNewService(const CreateNewService &that);
+
+      // Assignment Operator
+      CreateNewService & operator=(const CreateNewService &that);
+
+      // Destructor
+      virtual ~CreateNewService(void);
+
+      // Equals overload
+      bool operator==(const CreateNewService & that);
+      bool operator!=(const CreateNewService & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual CreateNewService* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 3; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** Globally unique ID for this service. Negative ServiceIDs are invalid. If ServiceID == 0, then a unique service ID will be generated. (Units: None)*/
+      int64_t getServiceID(void) const { return __ServiceID; }
+      CreateNewService& setServiceID(const int64_t val);
+
+      /** XML configuration for this service (Units: None)*/
+      std::vector<std::string> & getXmlConfiguration(void) { return __XmlConfiguration; }
+
+
+
+   protected:
+      /** Globally unique ID for this service. Negative ServiceIDs are invalid. If ServiceID == 0, then a unique service ID will be generated. */
+      int64_t __ServiceID;
+      /** XML configuration for this service */
+      std::vector< std::string > __XmlConfiguration;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_CREATENEWSERVICE_H_
diff --git a/src/LMCP/uxas/messages/uxnative/CreateNewServiceDescendants.h b/src/LMCP/uxas/messages/uxnative/CreateNewServiceDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/CreateNewServiceDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/EntityExit.h b/src/LMCP/uxas/messages/uxnative/EntityExit.h
new file mode 100644
index 0000000..e2c35d8
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/EntityExit.h
@@ -0,0 +1,114 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_ENTITYEXIT_H_
+#define _UXAS_MESSAGES_UXNATIVE_ENTITYEXIT_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isEntityExit(avtas::lmcp::Object* obj);
+   bool isEntityExit(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > EntityExitDescendants();
+   
+   class EntityExit : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      EntityExit(void);
+
+      // Copy Constructor
+      EntityExit(const EntityExit &that);
+
+      // Assignment Operator
+      EntityExit & operator=(const EntityExit &that);
+
+      // Destructor
+      virtual ~EntityExit(void);
+
+      // Equals overload
+      bool operator==(const EntityExit & that);
+      bool operator!=(const EntityExit & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual EntityExit* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 14; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** ID of entity exiting network (Units: None)*/
+      int64_t getEntityID(void) const { return __EntityID; }
+      EntityExit& setEntityID(const int64_t val);
+
+      /** Label of entity exiting network (Units: None)*/
+      std::string getLabel(void) const { return __Label; }
+      EntityExit& setLabel(const std::string val);
+
+
+
+   protected:
+      /** ID of entity exiting network */
+      int64_t __EntityID;
+      /** Label of entity exiting network */
+      std::string __Label;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_ENTITYEXIT_H_
diff --git a/src/LMCP/uxas/messages/uxnative/EntityExitDescendants.h b/src/LMCP/uxas/messages/uxnative/EntityExitDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/EntityExitDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/EntityJoin.h b/src/LMCP/uxas/messages/uxnative/EntityJoin.h
new file mode 100644
index 0000000..08d69d6
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/EntityJoin.h
@@ -0,0 +1,114 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_ENTITYJOIN_H_
+#define _UXAS_MESSAGES_UXNATIVE_ENTITYJOIN_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isEntityJoin(avtas::lmcp::Object* obj);
+   bool isEntityJoin(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > EntityJoinDescendants();
+   
+   class EntityJoin : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      EntityJoin(void);
+
+      // Copy Constructor
+      EntityJoin(const EntityJoin &that);
+
+      // Assignment Operator
+      EntityJoin & operator=(const EntityJoin &that);
+
+      // Destructor
+      virtual ~EntityJoin(void);
+
+      // Equals overload
+      bool operator==(const EntityJoin & that);
+      bool operator!=(const EntityJoin & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual EntityJoin* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 13; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** ID of entity joining network (Units: None)*/
+      int64_t getEntityID(void) const { return __EntityID; }
+      EntityJoin& setEntityID(const int64_t val);
+
+      /** Label of entity joining network (Units: None)*/
+      std::string getLabel(void) const { return __Label; }
+      EntityJoin& setLabel(const std::string val);
+
+
+
+   protected:
+      /** ID of entity joining network */
+      int64_t __EntityID;
+      /** Label of entity joining network */
+      std::string __Label;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_ENTITYJOIN_H_
diff --git a/src/LMCP/uxas/messages/uxnative/EntityJoinDescendants.h b/src/LMCP/uxas/messages/uxnative/EntityJoinDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/EntityJoinDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/EntityLocation.h b/src/LMCP/uxas/messages/uxnative/EntityLocation.h
new file mode 100644
index 0000000..7ce7619
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/EntityLocation.h
@@ -0,0 +1,121 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_ENTITYLOCATION_H_
+#define _UXAS_MESSAGES_UXNATIVE_ENTITYLOCATION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Location3D.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isEntityLocation(avtas::lmcp::Object* obj);
+   bool isEntityLocation(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > EntityLocationDescendants();
+   
+   class EntityLocation : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      EntityLocation(void);
+
+      // Copy Constructor
+      EntityLocation(const EntityLocation &that);
+
+      // Assignment Operator
+      EntityLocation & operator=(const EntityLocation &that);
+
+      // Destructor
+      virtual ~EntityLocation(void);
+
+      // Equals overload
+      bool operator==(const EntityLocation & that);
+      bool operator!=(const EntityLocation & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual EntityLocation* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 6; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** Entity ID (Units: None)*/
+      int64_t getEntityID(void) const { return __EntityID; }
+      EntityLocation& setEntityID(const int64_t val);
+
+      /** Current location of entity (Units: None)*/
+      afrl::cmasi::Location3D* const getPosition(void) { return __Position; }
+      EntityLocation& setPosition(const afrl::cmasi::Location3D* const val);
+
+      /** Corresponding time in milli-seconds since 1 Jan 1970 (Units: milliseconds)*/
+      int64_t getTime(void) const { return __Time; }
+      EntityLocation& setTime(const int64_t val);
+
+
+
+   protected:
+      /** Entity ID */
+      int64_t __EntityID;
+      /** Current location of entity */
+      afrl::cmasi::Location3D* __Position;
+      /** Corresponding time in milli-seconds since 1 Jan 1970 */
+      int64_t __Time;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_ENTITYLOCATION_H_
diff --git a/src/LMCP/uxas/messages/uxnative/EntityLocationDescendants.h b/src/LMCP/uxas/messages/uxnative/EntityLocationDescendants.h
new file mode 100644
index 0000000..a8f7cdf
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/EntityLocationDescendants.h
@@ -0,0 +1,13 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "uxas/messages/uxnative/BandwidthTest.h"
+
diff --git a/src/LMCP/uxas/messages/uxnative/IncrementWaypoint.h b/src/LMCP/uxas/messages/uxnative/IncrementWaypoint.h
new file mode 100644
index 0000000..5ae90a2
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/IncrementWaypoint.h
@@ -0,0 +1,108 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_INCREMENTWAYPOINT_H_
+#define _UXAS_MESSAGES_UXNATIVE_INCREMENTWAYPOINT_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isIncrementWaypoint(avtas::lmcp::Object* obj);
+   bool isIncrementWaypoint(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > IncrementWaypointDescendants();
+   
+   class IncrementWaypoint : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      IncrementWaypoint(void);
+
+      // Copy Constructor
+      IncrementWaypoint(const IncrementWaypoint &that);
+
+      // Assignment Operator
+      IncrementWaypoint & operator=(const IncrementWaypoint &that);
+
+      // Destructor
+      virtual ~IncrementWaypoint(void);
+
+      // Equals overload
+      bool operator==(const IncrementWaypoint & that);
+      bool operator!=(const IncrementWaypoint & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual IncrementWaypoint* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 5; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** ID of vehicle which should move to the next waypoint in its list (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      IncrementWaypoint& setVehicleID(const int64_t val);
+
+
+
+   protected:
+      /** ID of vehicle which should move to the next waypoint in its list */
+      int64_t __VehicleID;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_INCREMENTWAYPOINT_H_
diff --git a/src/LMCP/uxas/messages/uxnative/IncrementWaypointDescendants.h b/src/LMCP/uxas/messages/uxnative/IncrementWaypointDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/IncrementWaypointDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/KillService.h b/src/LMCP/uxas/messages/uxnative/KillService.h
new file mode 100644
index 0000000..911eb95
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/KillService.h
@@ -0,0 +1,108 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_KILLSERVICE_H_
+#define _UXAS_MESSAGES_UXNATIVE_KILLSERVICE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isKillService(avtas::lmcp::Object* obj);
+   bool isKillService(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > KillServiceDescendants();
+   
+   class KillService : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      KillService(void);
+
+      // Copy Constructor
+      KillService(const KillService &that);
+
+      // Assignment Operator
+      KillService & operator=(const KillService &that);
+
+      // Destructor
+      virtual ~KillService(void);
+
+      // Equals overload
+      bool operator==(const KillService & that);
+      bool operator!=(const KillService & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual KillService* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 4; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** Globally unique ID for the service to be removed. If ServiceID == 0, then no service will be killed. ServiceID == -1 causes all services to be killed and UxAS to be shutdown. (Units: None)*/
+      int64_t getServiceID(void) const { return __ServiceID; }
+      KillService& setServiceID(const int64_t val);
+
+
+
+   protected:
+      /** Globally unique ID for the service to be removed. If ServiceID == 0, then no service will be killed. ServiceID == -1 causes all services to be killed and UxAS to be shutdown. */
+      int64_t __ServiceID;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_KILLSERVICE_H_
diff --git a/src/LMCP/uxas/messages/uxnative/KillServiceDescendants.h b/src/LMCP/uxas/messages/uxnative/KillServiceDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/KillServiceDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/OnboardProcessorIsAlive.h b/src/LMCP/uxas/messages/uxnative/OnboardProcessorIsAlive.h
new file mode 100644
index 0000000..7d1cb84
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/OnboardProcessorIsAlive.h
@@ -0,0 +1,114 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_ONBOARDPROCESSORISALIVE_H_
+#define _UXAS_MESSAGES_UXNATIVE_ONBOARDPROCESSORISALIVE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isOnboardProcessorIsAlive(avtas::lmcp::Object* obj);
+   bool isOnboardProcessorIsAlive(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > OnboardProcessorIsAliveDescendants();
+   
+   class OnboardProcessorIsAlive : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      OnboardProcessorIsAlive(void);
+
+      // Copy Constructor
+      OnboardProcessorIsAlive(const OnboardProcessorIsAlive &that);
+
+      // Assignment Operator
+      OnboardProcessorIsAlive & operator=(const OnboardProcessorIsAlive &that);
+
+      // Destructor
+      virtual ~OnboardProcessorIsAlive(void);
+
+      // Equals overload
+      bool operator==(const OnboardProcessorIsAlive & that);
+      bool operator!=(const OnboardProcessorIsAlive & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual OnboardProcessorIsAlive* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 12; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** ID of vehicle with onboard processor (Units: None)*/
+      int64_t getVehicleID(void) const { return __VehicleID; }
+      OnboardProcessorIsAlive& setVehicleID(const int64_t val);
+
+      /** Time that this message was sent (Units: milliseconds since 1 Jan 1970)*/
+      int64_t getTimeSent(void) const { return __TimeSent; }
+      OnboardProcessorIsAlive& setTimeSent(const int64_t val);
+
+
+
+   protected:
+      /** ID of vehicle with onboard processor */
+      int64_t __VehicleID;
+      /** Time that this message was sent */
+      int64_t __TimeSent;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_ONBOARDPROCESSORISALIVE_H_
diff --git a/src/LMCP/uxas/messages/uxnative/OnboardProcessorIsAliveDescendants.h b/src/LMCP/uxas/messages/uxnative/OnboardProcessorIsAliveDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/OnboardProcessorIsAliveDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/StartupComplete.h b/src/LMCP/uxas/messages/uxnative/StartupComplete.h
new file mode 100644
index 0000000..af1e8a2
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/StartupComplete.h
@@ -0,0 +1,102 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_STARTUPCOMPLETE_H_
+#define _UXAS_MESSAGES_UXNATIVE_STARTUPCOMPLETE_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isStartupComplete(avtas::lmcp::Object* obj);
+   bool isStartupComplete(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > StartupCompleteDescendants();
+   
+   class StartupComplete : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      StartupComplete(void);
+
+      // Copy Constructor
+      StartupComplete(const StartupComplete &that);
+
+      // Assignment Operator
+      StartupComplete & operator=(const StartupComplete &that);
+
+      // Destructor
+      virtual ~StartupComplete(void);
+
+      // Equals overload
+      bool operator==(const StartupComplete & that);
+      bool operator!=(const StartupComplete & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual StartupComplete* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 2; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+
+
+   protected:
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_STARTUPCOMPLETE_H_
diff --git a/src/LMCP/uxas/messages/uxnative/StartupCompleteDescendants.h b/src/LMCP/uxas/messages/uxnative/StartupCompleteDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/StartupCompleteDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/SubTaskAssignment.h b/src/LMCP/uxas/messages/uxnative/SubTaskAssignment.h
new file mode 100644
index 0000000..3329d0b
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/SubTaskAssignment.h
@@ -0,0 +1,115 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_SUBTASKASSIGNMENT_H_
+#define _UXAS_MESSAGES_UXNATIVE_SUBTASKASSIGNMENT_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Task.h"
+#include "afrl/cmasi/EntityState.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isSubTaskAssignment(avtas::lmcp::Object* obj);
+   bool isSubTaskAssignment(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > SubTaskAssignmentDescendants();
+   
+   class SubTaskAssignment : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      SubTaskAssignment(void);
+
+      // Copy Constructor
+      SubTaskAssignment(const SubTaskAssignment &that);
+
+      // Assignment Operator
+      SubTaskAssignment & operator=(const SubTaskAssignment &that);
+
+      // Destructor
+      virtual ~SubTaskAssignment(void);
+
+      // Equals overload
+      bool operator==(const SubTaskAssignment & that);
+      bool operator!=(const SubTaskAssignment & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual SubTaskAssignment* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 10; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** List of tasks that current team should complete (Units: None)*/
+      std::vector<afrl::cmasi::Task*> & getSubTasks(void) { return __SubTasks; }
+
+      /** Neighboring entities to consider (Units: None)*/
+      std::vector<afrl::cmasi::EntityState*> & getNeighbors(void) { return __Neighbors; }
+
+
+
+   protected:
+      /** List of tasks that current team should complete */
+      std::vector< afrl::cmasi::Task* > __SubTasks;
+      /** Neighboring entities to consider */
+      std::vector< afrl::cmasi::EntityState* > __Neighbors;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_SUBTASKASSIGNMENT_H_
diff --git a/src/LMCP/uxas/messages/uxnative/SubTaskAssignmentDescendants.h b/src/LMCP/uxas/messages/uxnative/SubTaskAssignmentDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/SubTaskAssignmentDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/SubTaskExecution.h b/src/LMCP/uxas/messages/uxnative/SubTaskExecution.h
new file mode 100644
index 0000000..e00dff0
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/SubTaskExecution.h
@@ -0,0 +1,115 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_SUBTASKEXECUTION_H_
+#define _UXAS_MESSAGES_UXNATIVE_SUBTASKEXECUTION_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+#include "afrl/cmasi/Task.h"
+
+#include <vector>
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isSubTaskExecution(avtas::lmcp::Object* obj);
+   bool isSubTaskExecution(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > SubTaskExecutionDescendants();
+   
+   class SubTaskExecution : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      SubTaskExecution(void);
+
+      // Copy Constructor
+      SubTaskExecution(const SubTaskExecution &that);
+
+      // Assignment Operator
+      SubTaskExecution & operator=(const SubTaskExecution &that);
+
+      // Destructor
+      virtual ~SubTaskExecution(void);
+
+      // Equals overload
+      bool operator==(const SubTaskExecution & that);
+      bool operator!=(const SubTaskExecution & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual SubTaskExecution* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 9; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** List of tasks that current entity should complete (Units: None)*/
+      std::vector<afrl::cmasi::Task*> & getSubTasks(void) { return __SubTasks; }
+
+      /** Enable strict ordering (Units: None)*/
+      bool getStrictOrder(void) const { return __StrictOrder; }
+      SubTaskExecution& setStrictOrder(const bool val);
+
+
+
+   protected:
+      /** List of tasks that current entity should complete */
+      std::vector< afrl::cmasi::Task* > __SubTasks;
+      /** Enable strict ordering */
+      bool __StrictOrder;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_SUBTASKEXECUTION_H_
diff --git a/src/LMCP/uxas/messages/uxnative/SubTaskExecutionDescendants.h b/src/LMCP/uxas/messages/uxnative/SubTaskExecutionDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/SubTaskExecutionDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/UXNATIVE.h b/src/LMCP/uxas/messages/uxnative/UXNATIVE.h
new file mode 100644
index 0000000..0486194
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/UXNATIVE.h
@@ -0,0 +1,32 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_ENTIRESERIESHEADER_H_
+#define _UXAS_MESSAGES_UXNATIVE_ENTIRESERIESHEADER_H_
+
+#include "uxas/messages/uxnative/VideoRecord.h"
+#include "uxas/messages/uxnative/StartupComplete.h"
+#include "uxas/messages/uxnative/CreateNewService.h"
+#include "uxas/messages/uxnative/KillService.h"
+#include "uxas/messages/uxnative/IncrementWaypoint.h"
+#include "uxas/messages/uxnative/EntityLocation.h"
+#include "uxas/messages/uxnative/BandwidthTest.h"
+#include "uxas/messages/uxnative/BandwidthReceiveReport.h"
+#include "uxas/messages/uxnative/SubTaskExecution.h"
+#include "uxas/messages/uxnative/SubTaskAssignment.h"
+#include "uxas/messages/uxnative/AutopilotKeepAlive.h"
+#include "uxas/messages/uxnative/OnboardProcessorIsAlive.h"
+#include "uxas/messages/uxnative/EntityJoin.h"
+#include "uxas/messages/uxnative/EntityExit.h"
+#include "uxas/messages/uxnative/UXNATIVEEnum.h"
+
+
+#endif //_UXAS_MESSAGES_UXNATIVE_ENTIRESERIESHEADER_H_
diff --git a/src/LMCP/uxas/messages/uxnative/UXNATIVEEnum.h b/src/LMCP/uxas/messages/uxnative/UXNATIVEEnum.h
new file mode 100644
index 0000000..3b193ae
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/UXNATIVEEnum.h
@@ -0,0 +1,47 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_UXNATIVEENUM_H_
+#define _UXAS_MESSAGES_UXNATIVE_UXNATIVEENUM_H_
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   namespace UXNATIVEEnum {
+
+      enum LmcpType {
+         VIDEORECORD = 1,
+         STARTUPCOMPLETE = 2,
+         CREATENEWSERVICE = 3,
+         KILLSERVICE = 4,
+         INCREMENTWAYPOINT = 5,
+         ENTITYLOCATION = 6,
+         BANDWIDTHTEST = 7,
+         BANDWIDTHRECEIVEREPORT = 8,
+         SUBTASKEXECUTION = 9,
+         SUBTASKASSIGNMENT = 10,
+         AUTOPILOTKEEPALIVE = 11,
+         ONBOARDPROCESSORISALIVE = 12,
+         ENTITYJOIN = 13,
+         ENTITYEXIT = 14
+      };
+
+   }
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif //_UXAS_MESSAGES_UXNATIVE_UXNATIVEENUM_H_
diff --git a/src/LMCP/uxas/messages/uxnative/UXNATIVEXMLReader.cpp b/src/LMCP/uxas/messages/uxnative/UXNATIVEXMLReader.cpp
new file mode 100644
index 0000000..9439d76
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/UXNATIVEXMLReader.cpp
@@ -0,0 +1,364 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include "uxas/messages/uxnative/UXNATIVEXMLReader.h"
+#include "avtas/lmcp/XMLParser.h"
+#include <vector>
+#include <string>
+#include "avtas/lmcp/LmcpXMLReader.h"
+
+#include "uxas/messages/uxnative/VideoRecord.h"
+#include "uxas/messages/uxnative/StartupComplete.h"
+#include "uxas/messages/uxnative/CreateNewService.h"
+#include "uxas/messages/uxnative/KillService.h"
+#include "uxas/messages/uxnative/IncrementWaypoint.h"
+#include "uxas/messages/uxnative/EntityLocation.h"
+#include "uxas/messages/uxnative/BandwidthTest.h"
+#include "uxas/messages/uxnative/BandwidthReceiveReport.h"
+#include "uxas/messages/uxnative/SubTaskExecution.h"
+#include "uxas/messages/uxnative/SubTaskAssignment.h"
+#include "uxas/messages/uxnative/AutopilotKeepAlive.h"
+#include "uxas/messages/uxnative/OnboardProcessorIsAlive.h"
+#include "uxas/messages/uxnative/EntityJoin.h"
+#include "uxas/messages/uxnative/EntityExit.h"
+#include "uxas/messages/uxnative/UXNATIVEEnum.h"
+
+
+using namespace avtas::lmcp;
+using namespace avtas::lmcp::xml;
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+    avtas::lmcp::Object* SeriesXMLReader :: visitType(avtas::lmcp::Node* el){
+
+        if (el == NULL) return NULL;
+        
+        std::string type = el->getTagName();
+            
+        if (type == "VideoRecord"){
+           VideoRecord* o = new VideoRecord();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "Record")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setRecord( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "StartupComplete"){
+           StartupComplete* o = new StartupComplete();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+           }
+           return o;
+        }
+        if (type == "CreateNewService"){
+           CreateNewService* o = new CreateNewService();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ServiceID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setServiceID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "XmlConfiguration")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    o->getXmlConfiguration().push_back( get_string( tmp->getChild(j)));
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "KillService"){
+           KillService* o = new KillService();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "ServiceID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setServiceID( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "IncrementWaypoint"){
+           IncrementWaypoint* o = new IncrementWaypoint();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "EntityLocation"){
+           EntityLocation* o = new EntityLocation();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "EntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Position")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setPosition((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "Time")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTime( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "BandwidthTest"){
+           BandwidthTest* o = new BandwidthTest();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "MessageID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setMessageID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Payload")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setPayload( get_string( tmp ));
+                 continue;
+              }
+              if(name == "EntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Position")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setPosition((afrl::cmasi::Location3D*) oo );
+                 continue;
+              }
+              if(name == "Time")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTime( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "BandwidthReceiveReport"){
+           BandwidthReceiveReport* o = new BandwidthReceiveReport();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "EntitySender")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setEntitySender((uxas::messages::uxnative::EntityLocation*) oo );
+                 continue;
+              }
+              if(name == "EntityReceiver")
+              {
+                 Node* tmp = el->getChild(i);
+                 Object* oo = readXML( tmp->getChild(0) );
+                 o->setEntityReceiver((uxas::messages::uxnative::EntityLocation*) oo );
+                 continue;
+              }
+              if(name == "TransferPayloadSize")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTransferPayloadSize( get_uint32( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "SubTaskExecution"){
+           SubTaskExecution* o = new SubTaskExecution();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "SubTasks")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getSubTasks().push_back( (afrl::cmasi::Task*) oo);
+                 }
+                 continue;
+              }
+              if(name == "StrictOrder")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setStrictOrder( get_bool( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "SubTaskAssignment"){
+           SubTaskAssignment* o = new SubTaskAssignment();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "SubTasks")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getSubTasks().push_back( (afrl::cmasi::Task*) oo);
+                 }
+                 continue;
+              }
+              if(name == "Neighbors")
+              {
+                 Node* tmp = el->getChild(i);
+                 for (uint32_t j=0; j<tmp->getChildCount(); j++)
+                 {
+                    Object* oo = readXML( tmp->getChild(j));
+                    o->getNeighbors().push_back( (afrl::cmasi::EntityState*) oo);
+                 }
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "AutopilotKeepAlive"){
+           AutopilotKeepAlive* o = new AutopilotKeepAlive();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "AutopilotEnabled")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setAutopilotEnabled( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "GimbalEnabled")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setGimbalEnabled( get_bool( tmp ));
+                 continue;
+              }
+              if(name == "TimeSent")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeSent( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "OnboardProcessorIsAlive"){
+           OnboardProcessorIsAlive* o = new OnboardProcessorIsAlive();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "VehicleID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setVehicleID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "TimeSent")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setTimeSent( get_int64( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "EntityJoin"){
+           EntityJoin* o = new EntityJoin();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "EntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+        if (type == "EntityExit"){
+           EntityExit* o = new EntityExit();
+           for (uint32_t i=0; i<el->getChildCount(); i++)
+           {
+              std::string name = el->getChild(i)->getTagName();
+              if(name == "EntityID")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setEntityID( get_int64( tmp ));
+                 continue;
+              }
+              if(name == "Label")
+              {
+                 Node* tmp = el->getChild(i);
+                 o->setLabel( get_string( tmp ));
+                 continue;
+              }
+           }
+           return o;
+        }
+
+
+         return NULL;
+        
+    }
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/UXNATIVEXMLReader.h b/src/LMCP/uxas/messages/uxnative/UXNATIVEXMLReader.h
new file mode 100644
index 0000000..c7b6317
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/UXNATIVEXMLReader.h
@@ -0,0 +1,47 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef UXNATIVE_SERIESXMLREADER_H_
+#define UXNATIVE_SERIESXMLREADER_H_
+
+#include "avtas/lmcp/Object.h"
+#include "avtas/lmcp/Node.h"
+#include "avtas/lmcp/NodeUtil.h"
+
+#include <iostream>
+
+
+using namespace avtas::lmcp;
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+class SeriesXMLReader {
+
+    /** reads an LMCP XML Storage file and returns a list of LMCPObjects */
+    public:
+
+        SeriesXMLReader(void) {}
+
+        virtual ~SeriesXMLReader(){}  
+
+        static avtas::lmcp::Object * visitType(avtas::lmcp::Node* el );
+
+};
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif 
diff --git a/src/LMCP/uxas/messages/uxnative/VideoRecord.h b/src/LMCP/uxas/messages/uxnative/VideoRecord.h
new file mode 100644
index 0000000..49bd4fa
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/VideoRecord.h
@@ -0,0 +1,108 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#ifndef _UXAS_MESSAGES_UXNATIVE_VIDEORECORD_H_
+#define _UXAS_MESSAGES_UXNATIVE_VIDEORECORD_H_
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+#include "avtas/lmcp/Factory.h"
+#include "UXNATIVEEnum.h"
+#include "avtas/lmcp/Object.h"
+
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   bool isVideoRecord(avtas::lmcp::Object* obj);
+   bool isVideoRecord(std::shared_ptr<avtas::lmcp::Object>& obj);
+   std::vector< std::string > VideoRecordDescendants();
+   
+   class VideoRecord : public avtas::lmcp::Object {
+   public:
+      static const std::string Subscription;
+      static const std::string TypeName;
+      
+      // Constructor
+      VideoRecord(void);
+
+      // Copy Constructor
+      VideoRecord(const VideoRecord &that);
+
+      // Assignment Operator
+      VideoRecord & operator=(const VideoRecord &that);
+
+      // Destructor
+      virtual ~VideoRecord(void);
+
+      // Equals overload
+      bool operator==(const VideoRecord & that);
+      bool operator!=(const VideoRecord & that);
+
+      // Serializes calling object into a ByteBuffer.
+      virtual void pack(avtas::lmcp::ByteBuffer & buf) const;
+
+      // Deserializes ByteBuffer into calling object.
+      virtual void unpack(avtas::lmcp::ByteBuffer & buf);
+
+      // Calculates current object size in bytes
+      virtual uint32_t calculatePackedSize(void) const;
+
+      // Creates a copy of this object and returns a pointer to it.
+      virtual VideoRecord* clone() const;
+
+      // Returns string representation of object
+      virtual std::string toString(int32_t depth=0) const;
+
+      // Returns an XML string representation of the object.
+      virtual std::string toXML(int32_t depth=0);
+
+      // Returns object type id
+      virtual uint32_t getLmcpType(void) const { return 1; }
+	  
+      // Returns object type name string
+      virtual std::string getLmcpTypeName(void) const { return TypeName; }
+	  
+      // Returns object type name string with full namespace prepended, same as subscription name
+      virtual std::string getFullLmcpTypeName(void) const { return Subscription; }
+
+      // Returns series name string
+      virtual std::string getSeriesName(void) const { static std::string s_string("UXNATIVE"); return s_string; }
+
+      // gets the series name as a long value
+      virtual int64_t getSeriesNameAsLong(void) const { return 6149751333668345413LL; }
+
+      //gets the version number of the series
+      virtual uint16_t getSeriesVersion(void) const { return 2; }
+
+      // Accessors and Modifiers
+      /** Start [true] or stop [false] video recording (Units: None)*/
+      bool getRecord(void) const { return __Record; }
+      VideoRecord& setRecord(const bool val);
+
+
+
+   protected:
+      /** Start [true] or stop [false] video recording */
+      bool __Record;
+
+   };
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
+
+#endif // _UXAS_MESSAGES_UXNATIVE_VIDEORECORD_H_
diff --git a/src/LMCP/uxas/messages/uxnative/VideoRecordDescendants.h b/src/LMCP/uxas/messages/uxnative/VideoRecordDescendants.h
new file mode 100644
index 0000000..f88b151
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/VideoRecordDescendants.h
@@ -0,0 +1,12 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeAutopilotKeepAlive.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeAutopilotKeepAlive.cpp
new file mode 100644
index 0000000..fd0548a
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeAutopilotKeepAlive.cpp
@@ -0,0 +1,195 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/AutopilotKeepAlive.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string AutopilotKeepAlive::Subscription = "uxas.messages.uxnative.AutopilotKeepAlive";
+   const std::string AutopilotKeepAlive::TypeName = "AutopilotKeepAlive";
+   
+   bool isAutopilotKeepAlive(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 11) return false;
+      return true;
+   }
+   
+   bool isAutopilotKeepAlive(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 11) return false;
+      return true;
+   }
+   
+   std::vector< std::string > AutopilotKeepAliveDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   AutopilotKeepAlive::AutopilotKeepAlive(void) : avtas::lmcp::Object()
+   {
+      __AutopilotEnabled = true;
+      __GimbalEnabled = true;
+      __TimeSent = 0LL;
+
+   }
+     
+   AutopilotKeepAlive::AutopilotKeepAlive(const AutopilotKeepAlive &that) : avtas::lmcp::Object(that)
+   {
+        __AutopilotEnabled = that.__AutopilotEnabled;
+        __GimbalEnabled = that.__GimbalEnabled;
+        __TimeSent = that.__TimeSent;
+
+   }
+   
+   AutopilotKeepAlive & AutopilotKeepAlive::operator=(const AutopilotKeepAlive &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __AutopilotEnabled = that.__AutopilotEnabled;
+         __GimbalEnabled = that.__GimbalEnabled;
+         __TimeSent = that.__TimeSent;
+
+      }
+      return *this;
+   }
+
+   AutopilotKeepAlive* AutopilotKeepAlive::clone() const
+   {
+        return new AutopilotKeepAlive(*this);
+   }
+   
+   AutopilotKeepAlive::~AutopilotKeepAlive(void)
+   {
+
+   }
+  
+   void AutopilotKeepAlive::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putBool(__AutopilotEnabled);
+      buf.putBool(__GimbalEnabled);
+      buf.putLong(__TimeSent);
+
+   }
+   
+   void AutopilotKeepAlive::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __AutopilotEnabled = buf.getBool();
+      __GimbalEnabled = buf.getBool();
+      __TimeSent = buf.getLong();
+
+   }
+
+   uint32_t AutopilotKeepAlive::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(bool);
+      size += sizeof(bool);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string AutopilotKeepAlive::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( AutopilotKeepAlive ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "AutopilotEnabled (bool) = " << __AutopilotEnabled << "\n";
+      oss << indent << "GimbalEnabled (bool) = " << __GimbalEnabled << "\n";
+      oss << indent << "TimeSent (int64_t) = " << __TimeSent << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string AutopilotKeepAlive::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<AutopilotKeepAlive Series=\"UXNATIVE\">\n";
+      str << ws << "   <AutopilotEnabled>" << (__AutopilotEnabled ? "true" : "false") << "</AutopilotEnabled>\n";
+      str << ws << "   <GimbalEnabled>" << (__GimbalEnabled ? "true" : "false") << "</GimbalEnabled>\n";
+      str << ws << "   <TimeSent>" << __TimeSent << "</TimeSent>\n";
+      str << ws << "</AutopilotKeepAlive>\n";
+
+      return str.str();
+   }
+
+   bool AutopilotKeepAlive::operator==(const AutopilotKeepAlive & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__AutopilotEnabled != that.__AutopilotEnabled) return false;
+      if(__GimbalEnabled != that.__GimbalEnabled) return false;
+      if(__TimeSent != that.__TimeSent) return false;
+      return true;
+
+   }
+
+   bool AutopilotKeepAlive::operator!=(const AutopilotKeepAlive & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   AutopilotKeepAlive& AutopilotKeepAlive::setAutopilotEnabled(const bool val)
+   {
+      __AutopilotEnabled = val;
+      return *this;
+   }
+
+   AutopilotKeepAlive& AutopilotKeepAlive::setGimbalEnabled(const bool val)
+   {
+      __GimbalEnabled = val;
+      return *this;
+   }
+
+   AutopilotKeepAlive& AutopilotKeepAlive::setTimeSent(const int64_t val)
+   {
+      __TimeSent = val;
+      return *this;
+   }
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeBandwidthReceiveReport.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeBandwidthReceiveReport.cpp
new file mode 100644
index 0000000..2999341
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeBandwidthReceiveReport.cpp
@@ -0,0 +1,255 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/BandwidthReceiveReport.h"
+#include "uxas/messages/uxnative/BandwidthTest.h"
+#include "uxas/messages/uxnative/BandwidthTest.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string BandwidthReceiveReport::Subscription = "uxas.messages.uxnative.BandwidthReceiveReport";
+   const std::string BandwidthReceiveReport::TypeName = "BandwidthReceiveReport";
+   
+   bool isBandwidthReceiveReport(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 8) return false;
+      return true;
+   }
+   
+   bool isBandwidthReceiveReport(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 8) return false;
+      return true;
+   }
+   
+   std::vector< std::string > BandwidthReceiveReportDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   BandwidthReceiveReport::BandwidthReceiveReport(void) : avtas::lmcp::Object()
+   {
+      __EntitySender = new uxas::messages::uxnative::EntityLocation();
+      __EntityReceiver = new uxas::messages::uxnative::EntityLocation();
+      __TransferPayloadSize = 0;
+
+   }
+     
+   BandwidthReceiveReport::BandwidthReceiveReport(const BandwidthReceiveReport &that) : avtas::lmcp::Object(that)
+   {
+        __EntitySender = that.__EntitySender == nullptr ? nullptr : that.__EntitySender->clone();
+        __EntityReceiver = that.__EntityReceiver == nullptr ? nullptr : that.__EntityReceiver->clone();
+        __TransferPayloadSize = that.__TransferPayloadSize;
+
+   }
+   
+   BandwidthReceiveReport & BandwidthReceiveReport::operator=(const BandwidthReceiveReport &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__EntitySender != nullptr) delete __EntitySender;
+         if (__EntityReceiver != nullptr) delete __EntityReceiver;
+
+         __EntitySender = that.__EntitySender == nullptr ? nullptr : that.__EntitySender->clone();
+         __EntityReceiver = that.__EntityReceiver == nullptr ? nullptr : that.__EntityReceiver->clone();
+         __TransferPayloadSize = that.__TransferPayloadSize;
+
+      }
+      return *this;
+   }
+
+   BandwidthReceiveReport* BandwidthReceiveReport::clone() const
+   {
+        return new BandwidthReceiveReport(*this);
+   }
+   
+   BandwidthReceiveReport::~BandwidthReceiveReport(void)
+   {
+      if (__EntitySender != nullptr) delete __EntitySender;
+      if (__EntityReceiver != nullptr) delete __EntityReceiver;
+
+   }
+  
+   void BandwidthReceiveReport::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __EntitySender, buf);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __EntityReceiver, buf);
+      buf.putUInt(__TransferPayloadSize);
+
+   }
+   
+   void BandwidthReceiveReport::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      {
+         if (__EntitySender != nullptr) delete __EntitySender;
+         __EntitySender = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __EntitySender = (uxas::messages::uxnative::EntityLocation*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__EntitySender != nullptr) __EntitySender->unpack(buf);
+         }
+      }
+      {
+         if (__EntityReceiver != nullptr) delete __EntityReceiver;
+         __EntityReceiver = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __EntityReceiver = (uxas::messages::uxnative::EntityLocation*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__EntityReceiver != nullptr) __EntityReceiver->unpack(buf);
+         }
+      }
+      __TransferPayloadSize = buf.getUInt();
+
+   }
+
+   uint32_t BandwidthReceiveReport::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += (__EntitySender != nullptr ? __EntitySender->calculatePackedSize() + 15 : 1);
+      size += (__EntityReceiver != nullptr ? __EntityReceiver->calculatePackedSize() + 15 : 1);
+      size += sizeof(uint32_t);
+
+      return size;
+   }
+
+   std::string BandwidthReceiveReport::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( BandwidthReceiveReport ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "EntitySender (EntityLocation)";
+      if (__EntitySender == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "EntityReceiver (EntityLocation)";
+      if (__EntityReceiver == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "TransferPayloadSize (uint32_t) = " << __TransferPayloadSize << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string BandwidthReceiveReport::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<BandwidthReceiveReport Series=\"UXNATIVE\">\n";
+      if (__EntitySender != nullptr)
+      {
+         str << ws << "   <EntitySender>";
+         str << "\n" + __EntitySender->toXML(depth + 1) + ws + "   ";
+         str << "</EntitySender>\n";
+      }
+      if (__EntityReceiver != nullptr)
+      {
+         str << ws << "   <EntityReceiver>";
+         str << "\n" + __EntityReceiver->toXML(depth + 1) + ws + "   ";
+         str << "</EntityReceiver>\n";
+      }
+      str << ws << "   <TransferPayloadSize>" << __TransferPayloadSize << "</TransferPayloadSize>\n";
+      str << ws << "</BandwidthReceiveReport>\n";
+
+      return str.str();
+   }
+
+   bool BandwidthReceiveReport::operator==(const BandwidthReceiveReport & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__EntitySender && that.__EntitySender)
+      {
+         if(__EntitySender->getSeriesNameAsLong() != that.__EntitySender->getSeriesNameAsLong()) return false;
+         if(__EntitySender->getSeriesVersion() != that.__EntitySender->getSeriesVersion()) return false;
+         if(__EntitySender->getLmcpType() != that.__EntitySender->getLmcpType()) return false;
+         if( *(__EntitySender) != *(that.__EntitySender) ) return false;
+      }
+      else if(__EntitySender != that.__EntitySender) return false;
+      if(__EntityReceiver && that.__EntityReceiver)
+      {
+         if(__EntityReceiver->getSeriesNameAsLong() != that.__EntityReceiver->getSeriesNameAsLong()) return false;
+         if(__EntityReceiver->getSeriesVersion() != that.__EntityReceiver->getSeriesVersion()) return false;
+         if(__EntityReceiver->getLmcpType() != that.__EntityReceiver->getLmcpType()) return false;
+         if( *(__EntityReceiver) != *(that.__EntityReceiver) ) return false;
+      }
+      else if(__EntityReceiver != that.__EntityReceiver) return false;
+      if(__TransferPayloadSize != that.__TransferPayloadSize) return false;
+      return true;
+
+   }
+
+   bool BandwidthReceiveReport::operator!=(const BandwidthReceiveReport & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   BandwidthReceiveReport& BandwidthReceiveReport::setEntitySender(const uxas::messages::uxnative::EntityLocation* const val)
+   {
+      if (__EntitySender != nullptr) { delete __EntitySender; __EntitySender = nullptr; }
+      if (val != nullptr) { __EntitySender = const_cast< uxas::messages::uxnative::EntityLocation* > (val); }
+      return *this;
+   }
+
+   BandwidthReceiveReport& BandwidthReceiveReport::setEntityReceiver(const uxas::messages::uxnative::EntityLocation* const val)
+   {
+      if (__EntityReceiver != nullptr) { delete __EntityReceiver; __EntityReceiver = nullptr; }
+      if (val != nullptr) { __EntityReceiver = const_cast< uxas::messages::uxnative::EntityLocation* > (val); }
+      return *this;
+   }
+
+   BandwidthReceiveReport& BandwidthReceiveReport::setTransferPayloadSize(const uint32_t val)
+   {
+      __TransferPayloadSize = val;
+      return *this;
+   }
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeBandwidthTest.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeBandwidthTest.cpp
new file mode 100644
index 0000000..882ec29
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeBandwidthTest.cpp
@@ -0,0 +1,195 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/BandwidthTest.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string BandwidthTest::Subscription = "uxas.messages.uxnative.BandwidthTest";
+   const std::string BandwidthTest::TypeName = "BandwidthTest";
+   
+   bool isBandwidthTest(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 7) return false;
+      return true;
+   }
+   
+   bool isBandwidthTest(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 7) return false;
+      return true;
+   }
+   
+   std::vector< std::string > BandwidthTestDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   BandwidthTest::BandwidthTest(void) : uxas::messages::uxnative::EntityLocation()
+   {
+      __MessageID = 0LL;
+      __Payload = std::string("");
+
+   }
+     
+   BandwidthTest::BandwidthTest(const BandwidthTest &that) : uxas::messages::uxnative::EntityLocation(that)
+   {
+        __MessageID = that.__MessageID;
+        __Payload = that.__Payload;
+
+   }
+   
+   BandwidthTest & BandwidthTest::operator=(const BandwidthTest &that)
+   {
+      if (this != &that)
+      {
+         uxas::messages::uxnative::EntityLocation::operator=(that);
+
+         __MessageID = that.__MessageID;
+         __Payload = that.__Payload;
+
+      }
+      return *this;
+   }
+
+   BandwidthTest* BandwidthTest::clone() const
+   {
+        return new BandwidthTest(*this);
+   }
+   
+   BandwidthTest::~BandwidthTest(void)
+   {
+
+   }
+  
+   void BandwidthTest::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      uxas::messages::uxnative::EntityLocation::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__MessageID);
+      buf.putString(__Payload);
+
+   }
+   
+   void BandwidthTest::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      uxas::messages::uxnative::EntityLocation::unpack(buf);
+      // Copy the buffer into the class
+      __MessageID = buf.getLong();
+      __Payload = buf.getString();
+
+   }
+
+   uint32_t BandwidthTest::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += uxas::messages::uxnative::EntityLocation::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2 + __Payload.length();
+
+      return size;
+   }
+
+   std::string BandwidthTest::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( BandwidthTest ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "EntityID (int64_t) = " << __EntityID << "\n";
+      oss << indent << "Position (Location3D)";
+      if (__Position == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "Time (int64_t) = " << __Time << "\n";
+
+      oss << indent << "MessageID (int64_t) = " << __MessageID << "\n";
+      oss << indent << "Payload (std::string) = " << __Payload << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string BandwidthTest::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<BandwidthTest Series=\"UXNATIVE\">\n";
+      str << ws << "   <MessageID>" << __MessageID << "</MessageID>\n";
+      str << ws << "   <Payload>" << __Payload << "</Payload>\n";
+      str << ws << "   <EntityID>" << __EntityID << "</EntityID>\n";
+      if (__Position != nullptr)
+      {
+         str << ws << "   <Position>";
+         str << "\n" + __Position->toXML(depth + 1) + ws + "   ";
+         str << "</Position>\n";
+      }
+      str << ws << "   <Time>" << __Time << "</Time>\n";
+      str << ws << "</BandwidthTest>\n";
+
+      return str.str();
+   }
+
+   bool BandwidthTest::operator==(const BandwidthTest & that)
+   {
+      if( uxas::messages::uxnative::EntityLocation::operator!=(that) )
+      {
+          return false;
+      }
+      if(__MessageID != that.__MessageID) return false;
+      if(__Payload != that.__Payload) return false;
+      return true;
+
+   }
+
+   bool BandwidthTest::operator!=(const BandwidthTest & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   BandwidthTest& BandwidthTest::setMessageID(const int64_t val)
+   {
+      __MessageID = val;
+      return *this;
+   }
+
+   BandwidthTest& BandwidthTest::setPayload(const std::string val)
+   {
+      __Payload = val;
+      return *this;
+   }
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeCreateNewService.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeCreateNewService.cpp
new file mode 100644
index 0000000..ea81c88
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeCreateNewService.cpp
@@ -0,0 +1,204 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/CreateNewService.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string CreateNewService::Subscription = "uxas.messages.uxnative.CreateNewService";
+   const std::string CreateNewService::TypeName = "CreateNewService";
+   
+   bool isCreateNewService(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 3) return false;
+      return true;
+   }
+   
+   bool isCreateNewService(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 3) return false;
+      return true;
+   }
+   
+   std::vector< std::string > CreateNewServiceDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   CreateNewService::CreateNewService(void) : avtas::lmcp::Object()
+   {
+      __ServiceID = 0LL;
+
+   }
+     
+   CreateNewService::CreateNewService(const CreateNewService &that) : avtas::lmcp::Object(that)
+   {
+        __ServiceID = that.__ServiceID;
+        __XmlConfiguration.clear();
+        for (size_t i=0; i< that.__XmlConfiguration.size(); i++)
+        {
+           __XmlConfiguration.push_back( that.__XmlConfiguration[i]);
+        }
+
+   }
+   
+   CreateNewService & CreateNewService::operator=(const CreateNewService &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __ServiceID = that.__ServiceID;
+         __XmlConfiguration.clear();
+         for (size_t i=0; i< that.__XmlConfiguration.size(); i++)
+         {
+            __XmlConfiguration.push_back( that.__XmlConfiguration[i]);
+         }
+
+      }
+      return *this;
+   }
+
+   CreateNewService* CreateNewService::clone() const
+   {
+        return new CreateNewService(*this);
+   }
+   
+   CreateNewService::~CreateNewService(void)
+   {
+
+   }
+  
+   void CreateNewService::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ServiceID);
+      buf.putUShort( static_cast<uint16_t>(__XmlConfiguration.size()));
+      for (size_t i=0; i<__XmlConfiguration.size(); i++)
+      {
+         buf.putString(__XmlConfiguration[i]);
+      }
+
+   }
+   
+   void CreateNewService::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ServiceID = buf.getLong();
+      __XmlConfiguration.clear();
+      uint16_t __XmlConfiguration_length = buf.getUShort();
+      for (uint32_t i=0; i< __XmlConfiguration_length; i++)
+      {
+         __XmlConfiguration.push_back(buf.getString() );
+      }
+
+   }
+
+   uint32_t CreateNewService::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2;
+      for (size_t i=0; i<__XmlConfiguration.size(); i++)
+      {
+         size += __XmlConfiguration[i].length() + 2;
+      }
+
+      return size;
+   }
+
+   std::string CreateNewService::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( CreateNewService ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ServiceID (int64_t) = " << __ServiceID << "\n";
+      oss << indent << "XmlConfiguration (string [ " << __XmlConfiguration.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string CreateNewService::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<CreateNewService Series=\"UXNATIVE\">\n";
+      str << ws << "   <ServiceID>" << __ServiceID << "</ServiceID>\n";
+      str << ws << "   <XmlConfiguration>\n";
+      for (size_t i=0; i<__XmlConfiguration.size(); i++)
+      {
+         str << ws << "   <string>" << __XmlConfiguration[i] << "</string>\n";
+      }
+      str << ws << "   </XmlConfiguration>\n";
+      str << ws << "</CreateNewService>\n";
+
+      return str.str();
+   }
+
+   bool CreateNewService::operator==(const CreateNewService & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ServiceID != that.__ServiceID) return false;
+      if(__XmlConfiguration.size() != that.__XmlConfiguration.size()) return false;
+      for (size_t i=0; i<__XmlConfiguration.size(); i++)
+      {
+         if(__XmlConfiguration[i] != that.__XmlConfiguration[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool CreateNewService::operator!=(const CreateNewService & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   CreateNewService& CreateNewService::setServiceID(const int64_t val)
+   {
+      __ServiceID = val;
+      return *this;
+   }
+
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeEntityExit.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeEntityExit.cpp
new file mode 100644
index 0000000..70e6d0a
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeEntityExit.cpp
@@ -0,0 +1,180 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/EntityExit.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string EntityExit::Subscription = "uxas.messages.uxnative.EntityExit";
+   const std::string EntityExit::TypeName = "EntityExit";
+   
+   bool isEntityExit(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 14) return false;
+      return true;
+   }
+   
+   bool isEntityExit(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 14) return false;
+      return true;
+   }
+   
+   std::vector< std::string > EntityExitDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   EntityExit::EntityExit(void) : avtas::lmcp::Object()
+   {
+      __EntityID = 0LL;
+      __Label = std::string("");
+
+   }
+     
+   EntityExit::EntityExit(const EntityExit &that) : avtas::lmcp::Object(that)
+   {
+        __EntityID = that.__EntityID;
+        __Label = that.__Label;
+
+   }
+   
+   EntityExit & EntityExit::operator=(const EntityExit &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __EntityID = that.__EntityID;
+         __Label = that.__Label;
+
+      }
+      return *this;
+   }
+
+   EntityExit* EntityExit::clone() const
+   {
+        return new EntityExit(*this);
+   }
+   
+   EntityExit::~EntityExit(void)
+   {
+
+   }
+  
+   void EntityExit::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__EntityID);
+      buf.putString(__Label);
+
+   }
+   
+   void EntityExit::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __EntityID = buf.getLong();
+      __Label = buf.getString();
+
+   }
+
+   uint32_t EntityExit::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2 + __Label.length();
+
+      return size;
+   }
+
+   std::string EntityExit::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( EntityExit ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "EntityID (int64_t) = " << __EntityID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string EntityExit::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<EntityExit Series=\"UXNATIVE\">\n";
+      str << ws << "   <EntityID>" << __EntityID << "</EntityID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "</EntityExit>\n";
+
+      return str.str();
+   }
+
+   bool EntityExit::operator==(const EntityExit & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__EntityID != that.__EntityID) return false;
+      if(__Label != that.__Label) return false;
+      return true;
+
+   }
+
+   bool EntityExit::operator!=(const EntityExit & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   EntityExit& EntityExit::setEntityID(const int64_t val)
+   {
+      __EntityID = val;
+      return *this;
+   }
+
+   EntityExit& EntityExit::setLabel(const std::string val)
+   {
+      __Label = val;
+      return *this;
+   }
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeEntityJoin.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeEntityJoin.cpp
new file mode 100644
index 0000000..d4ff3ea
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeEntityJoin.cpp
@@ -0,0 +1,180 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/EntityJoin.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string EntityJoin::Subscription = "uxas.messages.uxnative.EntityJoin";
+   const std::string EntityJoin::TypeName = "EntityJoin";
+   
+   bool isEntityJoin(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 13) return false;
+      return true;
+   }
+   
+   bool isEntityJoin(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 13) return false;
+      return true;
+   }
+   
+   std::vector< std::string > EntityJoinDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   EntityJoin::EntityJoin(void) : avtas::lmcp::Object()
+   {
+      __EntityID = 0LL;
+      __Label = std::string("");
+
+   }
+     
+   EntityJoin::EntityJoin(const EntityJoin &that) : avtas::lmcp::Object(that)
+   {
+        __EntityID = that.__EntityID;
+        __Label = that.__Label;
+
+   }
+   
+   EntityJoin & EntityJoin::operator=(const EntityJoin &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __EntityID = that.__EntityID;
+         __Label = that.__Label;
+
+      }
+      return *this;
+   }
+
+   EntityJoin* EntityJoin::clone() const
+   {
+        return new EntityJoin(*this);
+   }
+   
+   EntityJoin::~EntityJoin(void)
+   {
+
+   }
+  
+   void EntityJoin::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__EntityID);
+      buf.putString(__Label);
+
+   }
+   
+   void EntityJoin::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __EntityID = buf.getLong();
+      __Label = buf.getString();
+
+   }
+
+   uint32_t EntityJoin::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += 2 + __Label.length();
+
+      return size;
+   }
+
+   std::string EntityJoin::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( EntityJoin ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "EntityID (int64_t) = " << __EntityID << "\n";
+      oss << indent << "Label (std::string) = " << __Label << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string EntityJoin::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<EntityJoin Series=\"UXNATIVE\">\n";
+      str << ws << "   <EntityID>" << __EntityID << "</EntityID>\n";
+      str << ws << "   <Label>" << __Label << "</Label>\n";
+      str << ws << "</EntityJoin>\n";
+
+      return str.str();
+   }
+
+   bool EntityJoin::operator==(const EntityJoin & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__EntityID != that.__EntityID) return false;
+      if(__Label != that.__Label) return false;
+      return true;
+
+   }
+
+   bool EntityJoin::operator!=(const EntityJoin & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   EntityJoin& EntityJoin::setEntityID(const int64_t val)
+   {
+      __EntityID = val;
+      return *this;
+   }
+
+   EntityJoin& EntityJoin::setLabel(const std::string val)
+   {
+      __Label = val;
+      return *this;
+   }
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeEntityLocation.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeEntityLocation.cpp
new file mode 100644
index 0000000..33d0acf
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeEntityLocation.cpp
@@ -0,0 +1,227 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/EntityLocation.h"
+#include "afrl/cmasi/Waypoint.h"
+#include "afrl/cmasi/PathWaypoint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string EntityLocation::Subscription = "uxas.messages.uxnative.EntityLocation";
+   const std::string EntityLocation::TypeName = "EntityLocation";
+   
+   bool isEntityLocation(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 6) return false;
+      return true;
+   }
+   
+   bool isEntityLocation(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 6) return false;
+      return true;
+   }
+   
+   std::vector< std::string > EntityLocationDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+       descendants.push_back("uxas.messages.uxnative.BandwidthTest");
+
+       return descendants;
+   }
+   
+   EntityLocation::EntityLocation(void) : avtas::lmcp::Object()
+   {
+      __EntityID = 0LL;
+      __Position = new afrl::cmasi::Location3D();
+      __Time = 0LL;
+
+   }
+     
+   EntityLocation::EntityLocation(const EntityLocation &that) : avtas::lmcp::Object(that)
+   {
+        __EntityID = that.__EntityID;
+        __Position = that.__Position == nullptr ? nullptr : that.__Position->clone();
+        __Time = that.__Time;
+
+   }
+   
+   EntityLocation & EntityLocation::operator=(const EntityLocation &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         if (__Position != nullptr) delete __Position;
+
+         __EntityID = that.__EntityID;
+         __Position = that.__Position == nullptr ? nullptr : that.__Position->clone();
+         __Time = that.__Time;
+
+      }
+      return *this;
+   }
+
+   EntityLocation* EntityLocation::clone() const
+   {
+        return new EntityLocation(*this);
+   }
+   
+   EntityLocation::~EntityLocation(void)
+   {
+      if (__Position != nullptr) delete __Position;
+
+   }
+  
+   void EntityLocation::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__EntityID);
+      avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Position, buf);
+      buf.putLong(__Time);
+
+   }
+   
+   void EntityLocation::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __EntityID = buf.getLong();
+      {
+         if (__Position != nullptr) delete __Position;
+         __Position = nullptr;
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            __Position = (afrl::cmasi::Location3D*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if (__Position != nullptr) __Position->unpack(buf);
+         }
+      }
+      __Time = buf.getLong();
+
+   }
+
+   uint32_t EntityLocation::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += (__Position != nullptr ? __Position->calculatePackedSize() + 15 : 1);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string EntityLocation::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( EntityLocation ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "EntityID (int64_t) = " << __EntityID << "\n";
+      oss << indent << "Position (Location3D)";
+      if (__Position == nullptr)
+         oss << " = nullptr";
+      oss << "\n";
+      oss << indent << "Time (int64_t) = " << __Time << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string EntityLocation::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<EntityLocation Series=\"UXNATIVE\">\n";
+      str << ws << "   <EntityID>" << __EntityID << "</EntityID>\n";
+      if (__Position != nullptr)
+      {
+         str << ws << "   <Position>";
+         str << "\n" + __Position->toXML(depth + 1) + ws + "   ";
+         str << "</Position>\n";
+      }
+      str << ws << "   <Time>" << __Time << "</Time>\n";
+      str << ws << "</EntityLocation>\n";
+
+      return str.str();
+   }
+
+   bool EntityLocation::operator==(const EntityLocation & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__EntityID != that.__EntityID) return false;
+      if(__Position && that.__Position)
+      {
+         if(__Position->getSeriesNameAsLong() != that.__Position->getSeriesNameAsLong()) return false;
+         if(__Position->getSeriesVersion() != that.__Position->getSeriesVersion()) return false;
+         if(__Position->getLmcpType() != that.__Position->getLmcpType()) return false;
+         if( *(__Position) != *(that.__Position) ) return false;
+      }
+      else if(__Position != that.__Position) return false;
+      if(__Time != that.__Time) return false;
+      return true;
+
+   }
+
+   bool EntityLocation::operator!=(const EntityLocation & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   EntityLocation& EntityLocation::setEntityID(const int64_t val)
+   {
+      __EntityID = val;
+      return *this;
+   }
+
+   EntityLocation& EntityLocation::setPosition(const afrl::cmasi::Location3D* const val)
+   {
+      if (__Position != nullptr) { delete __Position; __Position = nullptr; }
+      if (val != nullptr) { __Position = const_cast< afrl::cmasi::Location3D* > (val); }
+      return *this;
+   }
+
+   EntityLocation& EntityLocation::setTime(const int64_t val)
+   {
+      __Time = val;
+      return *this;
+   }
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeIncrementWaypoint.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeIncrementWaypoint.cpp
new file mode 100644
index 0000000..585ed97
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeIncrementWaypoint.cpp
@@ -0,0 +1,165 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/IncrementWaypoint.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string IncrementWaypoint::Subscription = "uxas.messages.uxnative.IncrementWaypoint";
+   const std::string IncrementWaypoint::TypeName = "IncrementWaypoint";
+   
+   bool isIncrementWaypoint(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 5) return false;
+      return true;
+   }
+   
+   bool isIncrementWaypoint(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 5) return false;
+      return true;
+   }
+   
+   std::vector< std::string > IncrementWaypointDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   IncrementWaypoint::IncrementWaypoint(void) : avtas::lmcp::Object()
+   {
+      __VehicleID = 0LL;
+
+   }
+     
+   IncrementWaypoint::IncrementWaypoint(const IncrementWaypoint &that) : avtas::lmcp::Object(that)
+   {
+        __VehicleID = that.__VehicleID;
+
+   }
+   
+   IncrementWaypoint & IncrementWaypoint::operator=(const IncrementWaypoint &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __VehicleID = that.__VehicleID;
+
+      }
+      return *this;
+   }
+
+   IncrementWaypoint* IncrementWaypoint::clone() const
+   {
+        return new IncrementWaypoint(*this);
+   }
+   
+   IncrementWaypoint::~IncrementWaypoint(void)
+   {
+
+   }
+  
+   void IncrementWaypoint::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__VehicleID);
+
+   }
+   
+   void IncrementWaypoint::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __VehicleID = buf.getLong();
+
+   }
+
+   uint32_t IncrementWaypoint::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string IncrementWaypoint::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( IncrementWaypoint ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string IncrementWaypoint::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<IncrementWaypoint Series=\"UXNATIVE\">\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "</IncrementWaypoint>\n";
+
+      return str.str();
+   }
+
+   bool IncrementWaypoint::operator==(const IncrementWaypoint & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__VehicleID != that.__VehicleID) return false;
+      return true;
+
+   }
+
+   bool IncrementWaypoint::operator!=(const IncrementWaypoint & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   IncrementWaypoint& IncrementWaypoint::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeKillService.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeKillService.cpp
new file mode 100644
index 0000000..5a5024f
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeKillService.cpp
@@ -0,0 +1,165 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/KillService.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string KillService::Subscription = "uxas.messages.uxnative.KillService";
+   const std::string KillService::TypeName = "KillService";
+   
+   bool isKillService(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 4) return false;
+      return true;
+   }
+   
+   bool isKillService(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 4) return false;
+      return true;
+   }
+   
+   std::vector< std::string > KillServiceDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   KillService::KillService(void) : avtas::lmcp::Object()
+   {
+      __ServiceID = 0LL;
+
+   }
+     
+   KillService::KillService(const KillService &that) : avtas::lmcp::Object(that)
+   {
+        __ServiceID = that.__ServiceID;
+
+   }
+   
+   KillService & KillService::operator=(const KillService &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __ServiceID = that.__ServiceID;
+
+      }
+      return *this;
+   }
+
+   KillService* KillService::clone() const
+   {
+        return new KillService(*this);
+   }
+   
+   KillService::~KillService(void)
+   {
+
+   }
+  
+   void KillService::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__ServiceID);
+
+   }
+   
+   void KillService::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __ServiceID = buf.getLong();
+
+   }
+
+   uint32_t KillService::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string KillService::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( KillService ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "ServiceID (int64_t) = " << __ServiceID << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string KillService::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<KillService Series=\"UXNATIVE\">\n";
+      str << ws << "   <ServiceID>" << __ServiceID << "</ServiceID>\n";
+      str << ws << "</KillService>\n";
+
+      return str.str();
+   }
+
+   bool KillService::operator==(const KillService & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__ServiceID != that.__ServiceID) return false;
+      return true;
+
+   }
+
+   bool KillService::operator!=(const KillService & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   KillService& KillService::setServiceID(const int64_t val)
+   {
+      __ServiceID = val;
+      return *this;
+   }
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeOnboardProcessorIsAlive.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeOnboardProcessorIsAlive.cpp
new file mode 100644
index 0000000..720b3f1
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeOnboardProcessorIsAlive.cpp
@@ -0,0 +1,180 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/OnboardProcessorIsAlive.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string OnboardProcessorIsAlive::Subscription = "uxas.messages.uxnative.OnboardProcessorIsAlive";
+   const std::string OnboardProcessorIsAlive::TypeName = "OnboardProcessorIsAlive";
+   
+   bool isOnboardProcessorIsAlive(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 12) return false;
+      return true;
+   }
+   
+   bool isOnboardProcessorIsAlive(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 12) return false;
+      return true;
+   }
+   
+   std::vector< std::string > OnboardProcessorIsAliveDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   OnboardProcessorIsAlive::OnboardProcessorIsAlive(void) : avtas::lmcp::Object()
+   {
+      __VehicleID = 0LL;
+      __TimeSent = 0LL;
+
+   }
+     
+   OnboardProcessorIsAlive::OnboardProcessorIsAlive(const OnboardProcessorIsAlive &that) : avtas::lmcp::Object(that)
+   {
+        __VehicleID = that.__VehicleID;
+        __TimeSent = that.__TimeSent;
+
+   }
+   
+   OnboardProcessorIsAlive & OnboardProcessorIsAlive::operator=(const OnboardProcessorIsAlive &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __VehicleID = that.__VehicleID;
+         __TimeSent = that.__TimeSent;
+
+      }
+      return *this;
+   }
+
+   OnboardProcessorIsAlive* OnboardProcessorIsAlive::clone() const
+   {
+        return new OnboardProcessorIsAlive(*this);
+   }
+   
+   OnboardProcessorIsAlive::~OnboardProcessorIsAlive(void)
+   {
+
+   }
+  
+   void OnboardProcessorIsAlive::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putLong(__VehicleID);
+      buf.putLong(__TimeSent);
+
+   }
+   
+   void OnboardProcessorIsAlive::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __VehicleID = buf.getLong();
+      __TimeSent = buf.getLong();
+
+   }
+
+   uint32_t OnboardProcessorIsAlive::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(int64_t);
+      size += sizeof(int64_t);
+
+      return size;
+   }
+
+   std::string OnboardProcessorIsAlive::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( OnboardProcessorIsAlive ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "VehicleID (int64_t) = " << __VehicleID << "\n";
+      oss << indent << "TimeSent (int64_t) = " << __TimeSent << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string OnboardProcessorIsAlive::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<OnboardProcessorIsAlive Series=\"UXNATIVE\">\n";
+      str << ws << "   <VehicleID>" << __VehicleID << "</VehicleID>\n";
+      str << ws << "   <TimeSent>" << __TimeSent << "</TimeSent>\n";
+      str << ws << "</OnboardProcessorIsAlive>\n";
+
+      return str.str();
+   }
+
+   bool OnboardProcessorIsAlive::operator==(const OnboardProcessorIsAlive & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__VehicleID != that.__VehicleID) return false;
+      if(__TimeSent != that.__TimeSent) return false;
+      return true;
+
+   }
+
+   bool OnboardProcessorIsAlive::operator!=(const OnboardProcessorIsAlive & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   OnboardProcessorIsAlive& OnboardProcessorIsAlive::setVehicleID(const int64_t val)
+   {
+      __VehicleID = val;
+      return *this;
+   }
+
+   OnboardProcessorIsAlive& OnboardProcessorIsAlive::setTimeSent(const int64_t val)
+   {
+      __TimeSent = val;
+      return *this;
+   }
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeStartupComplete.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeStartupComplete.cpp
new file mode 100644
index 0000000..0dfc5cc
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeStartupComplete.cpp
@@ -0,0 +1,150 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/StartupComplete.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string StartupComplete::Subscription = "uxas.messages.uxnative.StartupComplete";
+   const std::string StartupComplete::TypeName = "StartupComplete";
+   
+   bool isStartupComplete(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 2) return false;
+      return true;
+   }
+   
+   bool isStartupComplete(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 2) return false;
+      return true;
+   }
+   
+   std::vector< std::string > StartupCompleteDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   StartupComplete::StartupComplete(void) : avtas::lmcp::Object()
+   {
+
+   }
+     
+   StartupComplete::StartupComplete(const StartupComplete &that) : avtas::lmcp::Object(that)
+   {
+
+   }
+   
+   StartupComplete & StartupComplete::operator=(const StartupComplete &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+
+      }
+      return *this;
+   }
+
+   StartupComplete* StartupComplete::clone() const
+   {
+        return new StartupComplete(*this);
+   }
+   
+   StartupComplete::~StartupComplete(void)
+   {
+
+   }
+  
+   void StartupComplete::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+
+   }
+   
+   void StartupComplete::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+
+   }
+
+   uint32_t StartupComplete::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+
+      return size;
+   }
+
+   std::string StartupComplete::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( StartupComplete ) {\n";
+      indent = std::string((++depth)*3, ' ');
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string StartupComplete::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<StartupComplete Series=\"UXNATIVE\">\n";
+      str << ws << "</StartupComplete>\n";
+
+      return str.str();
+   }
+
+   bool StartupComplete::operator==(const StartupComplete & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      return true;
+
+   }
+
+   bool StartupComplete::operator!=(const StartupComplete & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeSubTaskAssignment.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeSubTaskAssignment.cpp
new file mode 100644
index 0000000..14f7530
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeSubTaskAssignment.cpp
@@ -0,0 +1,299 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/SubTaskAssignment.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/AreaSearchTask.h"
+#include "afrl/cmasi/LineSearchTask.h"
+#include "afrl/cmasi/PointSearchTask.h"
+#include "afrl/cmasi/LoiterTask.h"
+#include "afrl/cmasi/MustFlyTask.h"
+#include "afrl/cmasi/AirVehicleState.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string SubTaskAssignment::Subscription = "uxas.messages.uxnative.SubTaskAssignment";
+   const std::string SubTaskAssignment::TypeName = "SubTaskAssignment";
+   
+   bool isSubTaskAssignment(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 10) return false;
+      return true;
+   }
+   
+   bool isSubTaskAssignment(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 10) return false;
+      return true;
+   }
+   
+   std::vector< std::string > SubTaskAssignmentDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   SubTaskAssignment::SubTaskAssignment(void) : avtas::lmcp::Object()
+   {
+
+   }
+     
+   SubTaskAssignment::SubTaskAssignment(const SubTaskAssignment &that) : avtas::lmcp::Object(that)
+   {
+        __SubTasks.clear();
+        for (size_t i=0; i< that.__SubTasks.size(); i++)
+        {
+           __SubTasks.push_back( that.__SubTasks[i] == nullptr ? nullptr : that.__SubTasks[i]->clone());
+        }
+        __Neighbors.clear();
+        for (size_t i=0; i< that.__Neighbors.size(); i++)
+        {
+           __Neighbors.push_back( that.__Neighbors[i] == nullptr ? nullptr : that.__Neighbors[i]->clone());
+        }
+
+   }
+   
+   SubTaskAssignment & SubTaskAssignment::operator=(const SubTaskAssignment &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__SubTasks.size(); i++)
+         {
+            if (__SubTasks[i] != nullptr) delete __SubTasks[i];
+         }
+         for (size_t i=0; i<__Neighbors.size(); i++)
+         {
+            if (__Neighbors[i] != nullptr) delete __Neighbors[i];
+         }
+
+         __SubTasks.clear();
+         for (size_t i=0; i< that.__SubTasks.size(); i++)
+         {
+            __SubTasks.push_back( that.__SubTasks[i] == nullptr ? nullptr : that.__SubTasks[i]->clone());
+         }
+         __Neighbors.clear();
+         for (size_t i=0; i< that.__Neighbors.size(); i++)
+         {
+            __Neighbors.push_back( that.__Neighbors[i] == nullptr ? nullptr : that.__Neighbors[i]->clone());
+         }
+
+      }
+      return *this;
+   }
+
+   SubTaskAssignment* SubTaskAssignment::clone() const
+   {
+        return new SubTaskAssignment(*this);
+   }
+   
+   SubTaskAssignment::~SubTaskAssignment(void)
+   {
+      for (size_t i=0; i<__SubTasks.size(); i++)
+      {
+         if (__SubTasks[i] != nullptr) delete __SubTasks[i];
+      }
+      for (size_t i=0; i<__Neighbors.size(); i++)
+      {
+         if (__Neighbors[i] != nullptr) delete __Neighbors[i];
+      }
+
+   }
+  
+   void SubTaskAssignment::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__SubTasks.size()));
+      for (size_t i=0; i<__SubTasks.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __SubTasks[i], buf);
+      }
+      buf.putUShort( static_cast<uint16_t>(__Neighbors.size()));
+      for (size_t i=0; i<__Neighbors.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __Neighbors[i], buf);
+      }
+
+   }
+   
+   void SubTaskAssignment::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      for (size_t i=0; i<__SubTasks.size(); i++)
+      {
+         if (__SubTasks[i] != nullptr)
+            delete __SubTasks[i];
+      }
+      __SubTasks.clear();
+      uint16_t __SubTasks_length = buf.getUShort();
+      for (uint32_t i=0; i< __SubTasks_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Task* e = (afrl::cmasi::Task*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __SubTasks.push_back(e);
+         }
+      }
+      for (size_t i=0; i<__Neighbors.size(); i++)
+      {
+         if (__Neighbors[i] != nullptr)
+            delete __Neighbors[i];
+      }
+      __Neighbors.clear();
+      uint16_t __Neighbors_length = buf.getUShort();
+      for (uint32_t i=0; i< __Neighbors_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::EntityState* e = (afrl::cmasi::EntityState*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __Neighbors.push_back(e);
+         }
+      }
+
+   }
+
+   uint32_t SubTaskAssignment::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2;
+      for (size_t i=0; i<__SubTasks.size(); i++)
+      {
+         if (__SubTasks[i] != nullptr)
+         {
+            size += __SubTasks[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += 2;
+      for (size_t i=0; i<__Neighbors.size(); i++)
+      {
+         if (__Neighbors[i] != nullptr)
+         {
+            size += __Neighbors[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+
+      return size;
+   }
+
+   std::string SubTaskAssignment::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( SubTaskAssignment ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "SubTasks (Task [ " << __SubTasks.size() << ", var ])\n";
+      oss << indent << "Neighbors (EntityState [ " << __Neighbors.size() << ", var ])\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string SubTaskAssignment::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<SubTaskAssignment Series=\"UXNATIVE\">\n";
+      str << ws << "   <SubTasks>\n";
+      for (size_t i=0; i<__SubTasks.size(); i++)
+      {
+         str << (__SubTasks[i] == nullptr ? ( ws + "   <null/>\n") : (__SubTasks[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </SubTasks>\n";
+      str << ws << "   <Neighbors>\n";
+      for (size_t i=0; i<__Neighbors.size(); i++)
+      {
+         str << (__Neighbors[i] == nullptr ? ( ws + "   <null/>\n") : (__Neighbors[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </Neighbors>\n";
+      str << ws << "</SubTaskAssignment>\n";
+
+      return str.str();
+   }
+
+   bool SubTaskAssignment::operator==(const SubTaskAssignment & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__SubTasks.size() != that.__SubTasks.size()) return false;
+      for (size_t i=0; i<__SubTasks.size(); i++)
+      {
+         if(__SubTasks[i] && that.__SubTasks[i])
+         {
+            if(__SubTasks[i]->getSeriesNameAsLong() != that.__SubTasks[i]->getSeriesNameAsLong()) return false;
+            if(__SubTasks[i]->getSeriesVersion() != that.__SubTasks[i]->getSeriesVersion()) return false;
+            if(__SubTasks[i]->getLmcpType() != that.__SubTasks[i]->getLmcpType()) return false;
+            if( *(__SubTasks[i]) != *(that.__SubTasks[i]) ) return false;
+         }
+         else if(__SubTasks[i] != that.__SubTasks[i]) return false;
+      }
+      if(__Neighbors.size() != that.__Neighbors.size()) return false;
+      for (size_t i=0; i<__Neighbors.size(); i++)
+      {
+         if(__Neighbors[i] && that.__Neighbors[i])
+         {
+            if(__Neighbors[i]->getSeriesNameAsLong() != that.__Neighbors[i]->getSeriesNameAsLong()) return false;
+            if(__Neighbors[i]->getSeriesVersion() != that.__Neighbors[i]->getSeriesVersion()) return false;
+            if(__Neighbors[i]->getLmcpType() != that.__Neighbors[i]->getLmcpType()) return false;
+            if( *(__Neighbors[i]) != *(that.__Neighbors[i]) ) return false;
+         }
+         else if(__Neighbors[i] != that.__Neighbors[i]) return false;
+      }
+      return true;
+
+   }
+
+   bool SubTaskAssignment::operator!=(const SubTaskAssignment & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeSubTaskExecution.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeSubTaskExecution.cpp
new file mode 100644
index 0000000..b5461c3
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeSubTaskExecution.cpp
@@ -0,0 +1,242 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/SubTaskExecution.h"
+#include "afrl/cmasi/SearchTask.h"
+#include "afrl/cmasi/AreaSearchTask.h"
+#include "afrl/cmasi/LineSearchTask.h"
+#include "afrl/cmasi/PointSearchTask.h"
+#include "afrl/cmasi/LoiterTask.h"
+#include "afrl/cmasi/MustFlyTask.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string SubTaskExecution::Subscription = "uxas.messages.uxnative.SubTaskExecution";
+   const std::string SubTaskExecution::TypeName = "SubTaskExecution";
+   
+   bool isSubTaskExecution(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 9) return false;
+      return true;
+   }
+   
+   bool isSubTaskExecution(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 9) return false;
+      return true;
+   }
+   
+   std::vector< std::string > SubTaskExecutionDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   SubTaskExecution::SubTaskExecution(void) : avtas::lmcp::Object()
+   {
+      __StrictOrder = false;
+
+   }
+     
+   SubTaskExecution::SubTaskExecution(const SubTaskExecution &that) : avtas::lmcp::Object(that)
+   {
+        __SubTasks.clear();
+        for (size_t i=0; i< that.__SubTasks.size(); i++)
+        {
+           __SubTasks.push_back( that.__SubTasks[i] == nullptr ? nullptr : that.__SubTasks[i]->clone());
+        }
+        __StrictOrder = that.__StrictOrder;
+
+   }
+   
+   SubTaskExecution & SubTaskExecution::operator=(const SubTaskExecution &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+         for (size_t i=0; i<__SubTasks.size(); i++)
+         {
+            if (__SubTasks[i] != nullptr) delete __SubTasks[i];
+         }
+
+         __SubTasks.clear();
+         for (size_t i=0; i< that.__SubTasks.size(); i++)
+         {
+            __SubTasks.push_back( that.__SubTasks[i] == nullptr ? nullptr : that.__SubTasks[i]->clone());
+         }
+         __StrictOrder = that.__StrictOrder;
+
+      }
+      return *this;
+   }
+
+   SubTaskExecution* SubTaskExecution::clone() const
+   {
+        return new SubTaskExecution(*this);
+   }
+   
+   SubTaskExecution::~SubTaskExecution(void)
+   {
+      for (size_t i=0; i<__SubTasks.size(); i++)
+      {
+         if (__SubTasks[i] != nullptr) delete __SubTasks[i];
+      }
+
+   }
+  
+   void SubTaskExecution::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putUShort( static_cast<uint16_t>(__SubTasks.size()));
+      for (size_t i=0; i<__SubTasks.size(); i++)
+      {
+         avtas::lmcp::Factory::putObject( (avtas::lmcp::Object*) __SubTasks[i], buf);
+      }
+      buf.putBool(__StrictOrder);
+
+   }
+   
+   void SubTaskExecution::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      for (size_t i=0; i<__SubTasks.size(); i++)
+      {
+         if (__SubTasks[i] != nullptr)
+            delete __SubTasks[i];
+      }
+      __SubTasks.clear();
+      uint16_t __SubTasks_length = buf.getUShort();
+      for (uint32_t i=0; i< __SubTasks_length; i++)
+      {
+         if (buf.getBool())
+         {
+            int64_t series_id = buf.getLong();
+            uint32_t msgtype = buf.getUInt();
+            uint16_t version = buf.getUShort();
+            afrl::cmasi::Task* e = (afrl::cmasi::Task*) avtas::lmcp::Factory::createObject( series_id, msgtype, version );
+            if ( e != nullptr) e->unpack(buf); 
+            __SubTasks.push_back(e);
+         }
+      }
+      __StrictOrder = buf.getBool();
+
+   }
+
+   uint32_t SubTaskExecution::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += 2;
+      for (size_t i=0; i<__SubTasks.size(); i++)
+      {
+         if (__SubTasks[i] != nullptr)
+         {
+            size += __SubTasks[i]->calculatePackedSize() + 15;
+         }
+         else { size += 1; }
+      }
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string SubTaskExecution::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( SubTaskExecution ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "SubTasks (Task [ " << __SubTasks.size() << ", var ])\n";
+      oss << indent << "StrictOrder (bool) = " << __StrictOrder << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string SubTaskExecution::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<SubTaskExecution Series=\"UXNATIVE\">\n";
+      str << ws << "   <SubTasks>\n";
+      for (size_t i=0; i<__SubTasks.size(); i++)
+      {
+         str << (__SubTasks[i] == nullptr ? ( ws + "   <null/>\n") : (__SubTasks[i]->toXML(depth + 1))) ;
+      }
+      str << ws << "   </SubTasks>\n";
+      str << ws << "   <StrictOrder>" << (__StrictOrder ? "true" : "false") << "</StrictOrder>\n";
+      str << ws << "</SubTaskExecution>\n";
+
+      return str.str();
+   }
+
+   bool SubTaskExecution::operator==(const SubTaskExecution & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__SubTasks.size() != that.__SubTasks.size()) return false;
+      for (size_t i=0; i<__SubTasks.size(); i++)
+      {
+         if(__SubTasks[i] && that.__SubTasks[i])
+         {
+            if(__SubTasks[i]->getSeriesNameAsLong() != that.__SubTasks[i]->getSeriesNameAsLong()) return false;
+            if(__SubTasks[i]->getSeriesVersion() != that.__SubTasks[i]->getSeriesVersion()) return false;
+            if(__SubTasks[i]->getLmcpType() != that.__SubTasks[i]->getLmcpType()) return false;
+            if( *(__SubTasks[i]) != *(that.__SubTasks[i]) ) return false;
+         }
+         else if(__SubTasks[i] != that.__SubTasks[i]) return false;
+      }
+      if(__StrictOrder != that.__StrictOrder) return false;
+      return true;
+
+   }
+
+   bool SubTaskExecution::operator!=(const SubTaskExecution & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+
+   SubTaskExecution& SubTaskExecution::setStrictOrder(const bool val)
+   {
+      __StrictOrder = val;
+      return *this;
+   }
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
diff --git a/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeVideoRecord.cpp b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeVideoRecord.cpp
new file mode 100644
index 0000000..0faa5fd
--- /dev/null
+++ b/src/LMCP/uxas/messages/uxnative/uxasmessagesuxnativeVideoRecord.cpp
@@ -0,0 +1,165 @@
+// ===============================================================================
+// Authors: AFRL/RQQA
+// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
+// 
+// Copyright (c) 2017 Government of the United State of America, as represented by
+// the Secretary of the Air Force.  No copyright is claimed in the United States under
+// Title 17, U.S. Code.  All Other Rights Reserved.
+// ===============================================================================
+
+// This file was auto-created by LmcpGen. Modifications will be overwritten.
+
+#include <sstream>
+#include <iomanip>
+#include "uxas/messages/uxnative/VideoRecord.h"
+
+
+namespace uxas {
+namespace messages {
+namespace uxnative {
+
+
+   // Subscription string is namespace separated by '.' followed by type name
+   const std::string VideoRecord::Subscription = "uxas.messages.uxnative.VideoRecord";
+   const std::string VideoRecord::TypeName = "VideoRecord";
+   
+   bool isVideoRecord(avtas::lmcp::Object* obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 1) return false;
+      return true;
+   }
+   
+   bool isVideoRecord(std::shared_ptr<avtas::lmcp::Object>& obj)
+   {
+      if(!obj) return false;
+      if(obj->getSeriesNameAsLong() != 6149751333668345413LL) return false;
+      if(obj->getSeriesVersion() != 2) return false;
+      if(obj->getLmcpType() != 1) return false;
+      return true;
+   }
+   
+   std::vector< std::string > VideoRecordDescendants()
+   {
+       std::vector< std::string > descendants;
+       
+
+       return descendants;
+   }
+   
+   VideoRecord::VideoRecord(void) : avtas::lmcp::Object()
+   {
+      __Record = false;
+
+   }
+     
+   VideoRecord::VideoRecord(const VideoRecord &that) : avtas::lmcp::Object(that)
+   {
+        __Record = that.__Record;
+
+   }
+   
+   VideoRecord & VideoRecord::operator=(const VideoRecord &that)
+   {
+      if (this != &that)
+      {
+         avtas::lmcp::Object::operator=(that);
+
+         __Record = that.__Record;
+
+      }
+      return *this;
+   }
+
+   VideoRecord* VideoRecord::clone() const
+   {
+        return new VideoRecord(*this);
+   }
+   
+   VideoRecord::~VideoRecord(void)
+   {
+
+   }
+  
+   void VideoRecord::pack(avtas::lmcp::ByteBuffer & buf) const
+   {
+      // Call parent's pack method
+      avtas::lmcp::Object::pack(buf);
+      // Copy the class into the buffer
+      buf.putBool(__Record);
+
+   }
+   
+   void VideoRecord::unpack(avtas::lmcp::ByteBuffer & buf)
+   {
+      // Call parent's unpack method
+      avtas::lmcp::Object::unpack(buf);
+      // Copy the buffer into the class
+      __Record = buf.getBool();
+
+   }
+
+   uint32_t VideoRecord::calculatePackedSize(void) const
+   {
+      uint32_t size = 0;
+      size += avtas::lmcp::Object::calculatePackedSize();
+      size += sizeof(bool);
+
+      return size;
+   }
+
+   std::string VideoRecord::toString(int32_t depth) const
+   {
+      std::string indent(depth*3, ' ');
+      std::ostringstream oss;
+      oss << std::setprecision(15);
+      oss << indent << "Object ( VideoRecord ) {\n";
+      indent = std::string((++depth)*3, ' ');
+      oss << indent << "Record (bool) = " << __Record << "\n";
+
+      indent = std::string((--depth)*3, ' ');
+      oss << indent << "}\n";
+      return oss.str();
+   }
+
+   std::string VideoRecord::toXML(int32_t depth)
+   {
+      std::string ws(depth*3, ' ');
+      std::ostringstream str;
+      str << std::setprecision(15);
+      str << ws << "<VideoRecord Series=\"UXNATIVE\">\n";
+      str << ws << "   <Record>" << (__Record ? "true" : "false") << "</Record>\n";
+      str << ws << "</VideoRecord>\n";
+
+      return str.str();
+   }
+
+   bool VideoRecord::operator==(const VideoRecord & that)
+   {
+      if( avtas::lmcp::Object::operator!=(that) )
+      {
+          return false;
+      }
+      if(__Record != that.__Record) return false;
+      return true;
+
+   }
+
+   bool VideoRecord::operator!=(const VideoRecord & that)
+   {
+      return( !(operator==(that)) );
+   }
+
+   VideoRecord& VideoRecord::setRecord(const bool val)
+   {
+      __Record = val;
+      return *this;
+   }
+
+
+} // end namespace uxnative
+} // end namespace messages
+} // end namespace uxas
+
-- 
2.9.4

